import os
import gc
import bpy
import sys
import uuid
import time
import math
from math import radians, degrees, asin, cos
import struct
import tempfile
import traceback
import mathutils

import xml.etree.ElementTree as ET

from .mod_settings import *

from . import meshutils

if 1 == 1:

    props = {}

    
    
    
    
    
    
    props['constraint_group_base'] = "Sim"
    props['constraint_theme_base'] = "THEME08"




def get_bento_buddy_version():
    for mod_name in bpy.context.preferences.addons.keys():
        mod = sys.modules[mod_name]
        name = mod.bl_info.get('name')
        if name == "Bento Buddy":
            version = mod.bl_info.get('version', (-1, -1, -1))
            return version
    print("utils::get_bento_buddy_version reports: Something went wrong when trying to get the bentobuddy version")
    return False






def get_safe_name(names=None, max=100, report=False):
    fail = 0
    for i in range(max):
        name = get_temp_name()
        if name not in names:
            return name
        if report == True:
            print("utils::get_safe_name reports : collision ", name, " (", fail, ")", sep="")
    print("utils::get_safe_name reports : fall through, apparently there were", max, "collisions")
    return False



def get_unique_name():
    
    idn = str(uuid.uuid4())
    name = idn.replace("-", "")
    idt = str(time.time())
    time_now = idt.replace(".", "_")
    unique_name = name + "_" + time_now
    return unique_name



def get_unique_name_short():
    
    found = "yes" 
    break_point = 0 
    while found == "yes":
        unique_name = str(uuid.uuid4())
        break_point += 1
        if unique_name not in bpy.data.objects:
            name_search = "not found"
            break
        if break_point == 100:
            print("get_unique_name_short reports: 100 names were searched and found, this probably can't happen")
            popup("Houston we have a problem!  Name collision, check console", "Name Collision 100", "ERROR")
            break
    
    
    return unique_name.split('-', 1)[0]









def get_temp_name():
    unique_name = str(uuid.uuid4())
    return unique_name.split('-', 1)[0]



def popup(message = "", title = "Message Box", icon =  'INFO'):
    
    lines = message.splitlines()
    def draw(self, context):
        for l in lines:
            self.layout.label(text=l)
    bpy.context.window_manager.popup_menu(draw, title = title, icon = icon)
    return






def format_ctm(container=None):
    if container == None:
        print("format_ctm reports: nothing to do")
        return False

    formatted_text = "# Character Template Map auto-generated by Bento Buddy\n"
    formatted_text += "template_map = {\n"
    for sbone in container:
        (tarm, tbone), = container[sbone].items()
        formatted_text += "    " + '"' + sbone + '": ' + '{' + "\n"
        formatted_text += "        " + '"' + tarm +'": ' + '"' + tbone + '",' + "\n" + "        },\n"
    formatted_text += "    }\n"
    return formatted_text



def format_ccm(container=None):
    
    
    

    if container == None:
        print("format_ccm reports: nothing to do")

    obj = bpy.data.objects

    rename = container.get('rename')
    reskin = container.get('reskin')
    pose = container.get('pose')
    if rename == None or reskin == None:
        print("format_ccm reports: container is defective")
        return False

    
    
    

    formatted_text = "# Character Converter Map auto-generated by Bento Buddy\n"
    formatted_text = "rename = {\n"
    for tbone in rename:
        formatted_text += "    " + '"' + tbone + '": ' + '"' + rename[tbone] + '"' + ",\n"
    formatted_text += "    }\n"
    formatted_text += "reskin = {\n"
    for tbone in reskin:
        formatted_text += "    " + '"' + tbone + '": [' + "\n"
        for ghost_bone in reskin[tbone]:
            formatted_text += "        " + '"' + ghost_bone + '"' + ",\n"
        formatted_text += "        ],\n"
    formatted_text += "    }\n"
    if pose != None:
        
        
        formatted_text += "pose = {\n"
        for tbone in pose:
            formatted_text += "    " + '"' + tbone + '": [\n'
            for matrix in pose[tbone]:
                formatted_text += "        " + str(matrix) + ",\n"
            formatted_text += "        ],\n"
        formatted_text += "    }\n"

    return formatted_text



def flag_reloader():




    script_dir = os.path.dirname(os.path.abspath(__file__))

    print("-reload was triggered-")
    temp_path = tempfile.gettempdir()
    print(".path to temporary directory:", temp_path)
    source_file = "__init__.py"
    print(".storing backup of", source_file)
    source_path = script_dir + "/" + source_file
    target_path = temp_path + "/bentobuddy_reloader" + ".py"

    try:
        src = open(source_path, "r", encoding='UTF8')
    except Exception as e:
        txt = traceback.format_exc()
        print(txt)
        print("There was an error opening the source file for reading:", source_path)
        popup("Error opening source", "Error", "ERROR")
        return {'FINISHED'}

    src_buf = src.read()
    src.close()

    try:
        dst = open(target_path, "w", encoding='UTF8')
        dst.write(src_buf)
        dst.close()
    except Exception as e:
        txt = traceback.format_exc()
        print(txt)
        print("There was an error opening the target file for writing:", target_path)
        popup("Error writing target", "Error", "ERROR")
        return {'FINISHED'}

    
    
    

    try:
        dst = open(target_path, "r", encoding='UTF8')
        dst_buf = dst.read()
        dst.close()
    except Exception as e:
        txt = traceback.format_exc()
        print(txt)
        print("There was an error opening the target file in read mode for comparing:", target_path)
        popup("Error reading target for comparison", "Error", "ERROR")
        return {'FINISHED'}


    if dst_buf != src_buf:
        print("The destination and source do not match after a comparison, their file/paths are below")
        print("source:", source_path)
        print("target:", target_path)
        return {'FINISHED'}

    
    print("write back is processing...")
    try:
        src = open(source_path, "w", encoding='UTF8')
        src.write(src_buf)
        src.close()
    except Exception as e:
        txt = traceback.format_exc()
        print(txt)
        print("There was an error with the write-back process:", source_path)
        popup("Fatal Error, check backup data", "Error", "ERROR")
        return {'FINISHED'}

    
    print("-reload ends successfully-")

    return True








def run_script(script=None):
    
    
    
    
    
    
    

    script_dir = os.path.dirname(os.path.abspath(__file__))
    path = script_dir + presets_path

    print("would have run blender from:", blender, "using script:", script)
    return True




def add_constraint(
    source="", sbone="", target="", tbone="",
    type="COPY_TRANSFORMS", influence=1,
    target_space="WORLD", owner_space="WORLD",
    invert=True,
    owner="BONE"
    ):

    
    if bpy.data.objects[source].type == 'ARMATURE':
        bc = bpy.data.objects[source].pose.bones[sbone].constraints
    else:
        bpy.ops.object.mode_set(mode='OBJECT')
        bc = bpy.data.objects[source].constraints

    if type == 'CHILD_OF':
        bc.new('CHILD_OF')
        bc['Child Of'].target =  bpy.data.objects[target]
        bc['Child Of'].subtarget = tbone
        bc['Child Of'].influence = influence
        bc['Child Of'].name = "BB Child Of"
        if invert == True:
            context_py = bpy.context.copy()
            context_py["constraint"] = bc.active
            set_inverse(context_py, "BB Child Of")
            
        return
    elif type == 'COPY_LOCATION':
        bc.new('COPY_LOCATION')
        bc['Copy Location'].target = bpy.data.objects[target]
        bc['Copy Location'].subtarget = tbone
        bc['Copy Location'].target_space = target_space
        bc['Copy Location'].owner_space = owner_space
        bc['Copy Location'].influence = influence
        bc['Copy Location'].name = "BB Copy Loc"
        return
    elif type == 'COPY_ROTATION':
        bc.new('COPY_ROTATION')
        bc['Copy Rotation'].target = bpy.data.objects[target]
        bc['Copy Rotation'].subtarget = tbone
        bc['Copy Rotation'].target_space = target_space
        bc['Copy Rotation'].owner_space = owner_space
        bc['Copy Rotation'].influence = influence
        bc['Copy Rotation'].name = "BB Copy Rot"
        return
    elif type == 'COPY_SCALE':
        bc.new('COPY_SCALE')
        bc['Copy Scale'].target = bpy.data.objects[target]
        bc['Copy Scale'].subtarget = tbone
        bc['Copy Scale'].target_space = target_space
        bc['Copy Scale'].owner_space = owner_space
        bc['Copy Scale'].influence = influence
        bc['Copy Scale'].name = "BB Copy Scale"
        return
    elif type == 'COPY_TRANSFORMS':
        bc.new('COPY_TRANSFORMS')
        bc['Copy Transforms'].target = bpy.data.objects[target]
        bc['Copy Transforms'].subtarget = tbone
        bc['Copy Transforms'].target_space = target_space
        bc['Copy Transforms'].owner_space = owner_space
        bc['Copy Transforms'].influence = influence
        bc['Copy Transforms'].name = "BB Copy TRS"
        return
    else:
        print("add_constraint called with unknown type", type)
    return






def sl_orientation(objects=[]):
    obj = bpy.data.objects
    rotated = {}

    

    
    if 1 == 0:
        try:
            print("moo")
        except Exception as e:
            txt = traceback.format_exc()
            print(txt)

    
    for o in bpy.context.selected_objects:
        o.select_set(False)

    layer_settings = {}
    
    for name in objects:
        layer_settings[name] = {}
        layer_settings[name]['hide_set'] = obj[name].hide_get()
        layer_settings[name]['hide_select'] = obj[name].hide_select
        layer_settings[name]['hide_viewport'] = obj[name].hide_select

        obj[name].hide_set(False)
        obj[name].hide_select = False
        obj[name].hide_viewport = False
        obj[name].select_set(True)

    
    
    
    
    bpy.context.view_layer.objects.active = obj[ objects[0] ]
    bpy.ops.object.duplicate()
    mrig = bpy.context.active_object.name

    
    for name in objects:
        hide_set = layer_settings[name]['hide_set']
        obj[name].hide_set(hide_set)
        obj[name].hide_select = layer_settings[name]['hide_select']
        obj[name].hide_viewport = layer_settings[name]['hide_viewport']

    
    rotated['mbones'] = []
    rotated['mbones'].append(mrig)
    for o in bpy.context.selected_objects:
        if o.name == mrig:
            continue
        rotated['mbones'].append(o.name)
    
    bpy.ops.object.duplicate()

    vrig = bpy.context.active_object.name

    
    rotated['vbones'] = []
    rotated['vbones'].append(vrig)
    for o in bpy.context.selected_objects:
        if o.name == vrig:
            continue
        rotated['vbones'].append(o.name)

    for o in bpy.context.selected_objects:
        o.select_set(False)

    
    
    
    for name in rotated['mbones']:
        
        
        
        obj[name].select_set(True)
        bpy.context.view_layer.objects.active = obj[name]
        bpy.ops.object.transform_apply( rotation=True, location=False, scale=False )

        loc, rot, scale = obj[name].matrix_world.decompose()
        smat = mathutils.Matrix()
        for i in range(3):
            smat[i][i] = scale[i]
        eu = mathutils.Euler(map(radians, (-90, 0, 0)), 'XYZ')
        mat = mathutils.Matrix.Translation(loc) @ eu.to_matrix().to_4x4() @ smat
        obj[name].matrix_world = mat
        bpy.ops.object.transform_apply( rotation=True, location=False, scale=False )
        obj[name].select_set(False)

    
    
    for name in rotated['vbones']:
        obj[name].select_set(True)
        bpy.context.view_layer.objects.active = obj[name]
        bpy.ops.object.transform_apply( rotation=True, location=False, scale=False )
        loc, rot, scale = obj[name].matrix_world.decompose()
        smat = mathutils.Matrix()
        for i in range(3):
            smat[i][i] = scale[i]
        eu = mathutils.Euler(map(radians, (0, 0, 90)), 'XYZ')
        mat = mathutils.Matrix.Translation(loc) @ eu.to_matrix().to_4x4() @ smat
        obj[name].matrix_world = mat
        bpy.ops.object.transform_apply( rotation=True, location=False, scale=False )
        obj[name].select_set(False)

    for o in bpy.context.selected_objects:
        o.select_set(False)

    
    
    
    
    if 1 == 1:
        obj[mrig].select_set(True)
        bpy.context.view_layer.objects.active = obj[mrig]
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')
        obj[mrig].select_set(False)
        obj[vrig].select_set(True)
        bpy.context.view_layer.objects.active = obj[vrig]
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')
        obj[vrig].select_set(False)

    
    return rotated






def anim_reader(file=""):

    f = open(file, "rb")
    content = f.read()
    f.close()

    
    
                
                
                
                
                
                
                


    
    
    
    
    
    
    

    header = {}
        
        
        
        
        
        
        
        
        
        
        
        
        

    header['version'] = int.from_bytes(content[:2], byteorder='little', signed=False)
    header['sub_version'] = int.from_bytes(content[2:4], byteorder='little', signed=False)
    header['base_priority'] = int.from_bytes(content[4:8], byteorder='little', signed=True)
    header['duration'] = struct.unpack('f', content[8:12])[0]

    
    
    start = 12
    stride = 0
    
    
    for c in content[start:-1]:
        stride += 1
        if c == 0:
            break
    
    
    
    emote_bytes = content[start:start+stride-1]
    header['emote_name'] = emote_bytes.decode('utf-8')

    
    start += stride

    header['loop'] = int.from_bytes(content[start:start+4], byteorder='little', signed=True)
    start +=4

    header['ease_in_duration'] = struct.unpack('f', content[start:start+4])[0]
    header['ease_out_duration'] = struct.unpack('f', content[start+4:start+8])[0]
    start += 8

    header['loop_in_point'] = struct.unpack('f', content[start:start+4])[0]
    header['loop_out_point'] = struct.unpack('f', content[start+4:start+8])[0]
    start += 8

    header['hand_pose'] = int.from_bytes(content[start:start+4], byteorder='little', signed=False)
    start += 4

    header['num_joints'] = int.from_bytes(content[start:start+4], byteorder='little', signed=False)
    start += 4

    
    joints = {}
    joint_count = 0
    stride = 0
    while joint_count < header['num_joints']:
        joint_count += 1
        
        character_count = 0
        for c in content[start:-1]:
            character_count += 1 
            if c == 0:
                break

        joint_bytes = content[start:start+character_count-1] 
        start += character_count

        joint_name = joint_bytes.decode('utf-8')
        joints[joint_name] = {}

        joints[joint_name]['joint_priority'] = int.from_bytes(content[start:start+4], byteorder='little', signed=True)
        start += 4

        
        joints[joint_name]['num_rot_keys'] = int.from_bytes(content[start:start+4], byteorder='little', signed=True)
        start += 4
        rot_count = 0
        joints[joint_name]['rot'] = {}
        while rot_count < joints[joint_name]['num_rot_keys']:
            rot_count += 1
            
            joints[joint_name]['rot'][rot_count] = list()
            
            joints[joint_name]['rot'][rot_count].append( int.from_bytes(content[start:start+2], byteorder='little', signed=False) )
            start += 2
            joints[joint_name]['rot'][rot_count].append( int.from_bytes(content[start:start+2], byteorder='little', signed=False) )
            start += 2
            joints[joint_name]['rot'][rot_count].append( int.from_bytes(content[start:start+2], byteorder='little', signed=False) )
            start += 2
            joints[joint_name]['rot'][rot_count].append( int.from_bytes(content[start:start+2], byteorder='little', signed=False) )
            start += 2

        
        joints[joint_name]['num_pos_keys'] = int.from_bytes(content[start:start+4], byteorder='little', signed=True)
        start += 4
        loc_count = 0
        joints[joint_name]['loc'] = {}
        while loc_count < joints[joint_name]['num_pos_keys']:
            loc_count += 1
            joints[joint_name]['loc'][loc_count] = list()
            joints[joint_name]['loc'][loc_count].append( int.from_bytes(content[start:start+2], byteorder='little', signed=False) )
            start += 2
            joints[joint_name]['loc'][loc_count].append( int.from_bytes(content[start:start+2], byteorder='little', signed=False) )
            start += 2
            joints[joint_name]['loc'][loc_count].append( int.from_bytes(content[start:start+2], byteorder='little', signed=False) )
            start += 2
            joints[joint_name]['loc'][loc_count].append( int.from_bytes(content[start:start+2], byteorder='little', signed=False) )
            start += 2

    
    
    
    
    print("constraint read disabled")
    if 1 == 0:
        
        constraints['num_constraints'] = int.from_bytes(content[start:start+4], byteorder='little', signed=True)
        start += 4
        constraints['con'] = {}
        con_count = 0
        while con_count < joints[joint_name]['num_constraints']:
            con_count += 1
            constraints['con'][con_count] = {}
            constraints['con'][con_count]['chain_length'] = int.from_bytes(content[start:start+1], byteorder='little', signed=False)
            constraints['con'][con_count]['constraint_type'] = int.from_bytes(content[start:start+1], byteorder='little', signed=False)
            constraints['con'][con_count]['source_volume'] = content[start:start+2] 
            
            constraints['con'][con_count]['source_offset'] = "" 
            constraints['con'][con_count]['target_volume'] = "" 
            constraints['con'][con_count]['target_offset'] = "" 
            constraints['con'][con_count]['target_dir'] = "" 
            constraints['con'][con_count]['ease_in_start'] = 0 
            constraints['con'][con_count]['ease_in_stop'] = 0 
            constraints['con'][con_count]['ease_out_start'] = 0 
            constraints['con'][con_count]['ease_out_stop'] = 0 

    
    if 1 == 0:
        print("version:", header['version'])
        print("sub version:", header['sub_version'])
        print("base priority:", header['base_priority'])
        print("duration:",  '{:f}'.format(header['duration']) )
        print("emote name:", header['emote_name'])
        print("loop in point:",  '{:f}'.format(header['loop_in_point']) )
        print("loop out point:",  '{:f}'.format(header['loop_out_point']) )
        print("hand pose:", header['hand_pose'])
        print("num joints:", header['num_joints'])

        for j in joints:
            print("joint name:", j)
            print("joint priority:", joints[j]['joint_priority'])
            for rkey in joints[j]['rot']:
                print("     ", joints[j]['rot'][rkey])
            for lkey in joints[j]['loc']:
                print("     ", joints[j]['loc'][lkey])

    anim = {
        "header": header,
        "joints": joints,
        }

    return anim





def fix_quat(r):
    v = mathutils.Vector((r))
    half_angle = asin(v.magnitude)
    w = cos(half_angle)
    v = mathutils.Quaternion((w, r[0], r[1], r[2]))
    return v














def remove_empty_groups(mesh):
    
    def survey(meshObj):
        maxWeight = {}
        for i in meshObj.vertex_groups:
            maxWeight[i.index] = 0

        for v in meshObj.data.vertices:
            for g in v.groups:
                gn = g.group
                
                try:
                    w = meshObj.vertex_groups[g.group].weight(v.index)
                except:
                    pass
                if (maxWeight.get(gn) is None or w>maxWeight[gn]):
                    maxWeight[gn] = w
        return maxWeight

    meshObj = bpy.data.objects[mesh]
    
    armObj = meshutils.get_armature(meshObj)
    if armObj == False:
        print("There's no functional armature associated with the mesh", meshOb.name, "so there's no way to prune the weight groups properly.")
        return False

    maxWeight = survey(meshObj)
    
    ka = []
    ka.extend(maxWeight.keys())
    ka.sort(key=lambda gn: -gn)
    
    for gn in ka:
        if maxWeight[gn]<=0:
            
            
            name = meshObj.vertex_groups[gn].name
            
            if name not in armObj.data.bones:
                print("Skipping utility group:", name)
                continue
            meshObj.vertex_groups.remove(meshObj.vertex_groups[gn])





if 1 == 0:
    import re
    ob = bpy.context.active_object
    ob.update_from_editmode()
    vgroup_used = {i: False for i, k in enumerate(ob.vertex_groups)}
    vgroup_names = {i: k.name for i, k in enumerate(ob.vertex_groups)}
    for v in ob.data.vertices:
        for g in v.groups:
            if g.weight > 0.0:
                vgroup_used[g.group] = True
                vgroup_name = vgroup_names[g.group]
                armatch = re.search('((.R|.L)(.(\d){1,}){0,1})(?!.)', vgroup_name)
                if armatch != None:
                    tag = armatch.group()
                    mirror_tag =  tag.replace(".R", ".L") if armatch.group(2) == ".R" else tag.replace(".L", ".R") 
                    mirror_vgname = vgroup_name.replace(tag, mirror_tag)
                    for i, name in sorted(vgroup_names.items(), reverse=True):
                        if mirror_vgname == name:
                            vgroup_used[i] = True
                            break
    for i, used in sorted(vgroup_used.items(), reverse=True):
        if not used:
            ob.vertex_groups.remove(ob.vertex_groups[i])




def matrix_to_list(m):
    l = list(m)
    lt = list()
    for v in l:
        
        t = tuple([a for a in v])
        lt.append(t)
    return lt






def bind_to_matrix(l):
    M = mathutils.Matrix()
    for i in range(4):
        for j in range(4):
            M[i][j] = l[4*j + i]
    return M




def vector_to_list(v):
    l = [a for a in v]
    return l













def record_rig():
    import bpy
    import os
    import sys
    from . presets import avatar_skeleton as skel

    
    rig_file = "basic_rig.py"
    rig_path = "L:/compile/bentobuddy/test_material/" + rig_file

    if len(bpy.context.selected_objects) != 1:
        print("select a rig")
    if bpy.context.selected_objects[0].type != 'ARMATURE':
        print("this is not an armature")

    armObj = bpy.context.selected_objects[0]

    current_frame = bpy.context.scene.frame_current

    
    
    
    bpy.context.scene.frame_set(1)

    if armObj.data.animation_data != None:
        frame_start, frame_end = armObj.animation_data.action.frame_range
        bpy.context.scene.frame_set(start)

    
    

    
    

    def matrix_to_list(m):
        l = list(m)
        lt = list()
        for v in l:
            
            t = tuple([a for a in v])
            lt.append(t)
        print(lt)
        return lt
    def vector_to_list(v):
        l = [a for a in v]
        return l

    bpy.ops.object.mode_set(mode='EDIT')
    rig_data = {}
    for boneObj in armObj.data.edit_bones:
        bone = boneObj.name
        if bone not in skel.avatar_skeleton:
            continue
        rig_data[bone] = {}
        rig_data[bone]['type'] = skel.avatar_skeleton[bone]['type']
        rig_data[bone]['matrix_edit'] = matrix_to_list(boneObj.matrix.copy())
        rig_data[bone]['head_edit'] = vector_to_list(boneObj.head.copy())
        rig_data[bone]['tail_edit'] = vector_to_list(boneObj.tail.copy())
        rig_data[bone]['roll_edit'] = boneObj.roll
        rig_data[bone]['connected'] = skel.avatar_skeleton[bone]['connected']

    bpy.ops.object.mode_set(mode='OBJECT')

    for boneObj in armObj.pose.bones:
        bone = boneObj.name
        if bone not in skel.avatar_skeleton:
            continue
        rig_data[bone]['matrix_pose'] = matrix_to_list(boneObj.matrix.copy())
        
        if boneObj.parent:
            parent = boneObj.parent.name
        else:
            parent = ""
        rig_data[bone]['parent'] = parent

    if 1 == 0:
        txt = "# Do not incorporate this until you change the dictionary name to\n"
        txt += "# male_default or male_neutral, whichever rig you chose.\n"
        txt += "\n";
        txt += "rig = {\n"
        for bone in rig_data:
            txt += '    "' + bone + '": {' + "\n" 
            txt += '        "type": "' + rig_data[bone]['type'] + '",' + "\n"
            txt += '        "matrix_edit": "' + str(rig_data[bone]['matrix_edit']) + '",' + "\n"
            txt += '        "head_edit": "' + str(rig_data[bone]['head_edit']) + '",' + "\n"
            txt += '        "tail_edit": "' + str(rig_data[bone]['tail_edit']) + '",' + "\n"
            txt += '        "roll_edit": "' + str(rig_data[bone]['roll_edit']) + '",' + "\n"
            txt += '        "parent": "' + rig_data[bone]['parent'] + '",' + "\n"
            txt += '        "connected": "' + str(rig_data[bone]['connected']) + '",' + "\n"
            txt += "        }\n"

        txt += "    }\n"

    txt = "rig_data = "
    txt += str(rig_data)

    f = open(rig_path, "w", encoding='UTF8')
    f.write(txt)
    f.close()
    return






def can_select(object=None):
    if object == None:
        print("can_select: Nothing to do")
        return False

    old_mode = bpy.context.mode
    if old_mode != 'OBJECT':
        bpy.ops.object.mode_set(mode='OBJECT')
    else:
        old_mode = None

    obj = bpy.data.objects
    if object not in obj:
        print("can_select: object not available", object)
        return False

    selected = [o for o in bpy.context.selected_objects]
    active = bpy.context.active_object

    for o in selected:
        o.select_set(False)

    
    try:
        obj[object].select_set(True)
    except:
        pass

    
    if len(bpy.context.selected_objects) == 0:
        print("The object", object, "is not accessible in the scene, not selectable or not in view.")
        return False

    if old_mode != None:
        for o in selected:
            o.select_set(True)
            bpy.ops.object.mode_set(mode=old_mode)
    
    
    try:
        bpy.context.view_layer.objects.active = active
    except:
        pass

    return True






def get_obj_size(obj):
    marked = {id(obj)}
    obj_q = [obj]
    sz = 0

    while obj_q:
        sz += sum(map(sys.getsizeof, obj_q))

        
        
        all_refr = ((id(o), o) for o in gc.get_referents(*obj_q))

        
        
        new_refr = {o_id: o for o_id, o in all_refr if o_id not in marked and not isinstance(o, type)}

        
        
        
        obj_q = new_refr.values()
        marked.update(new_refr.keys())

    return sz




def get_average(object):
    
    
    el = len(object[0])
    
    for i in range(1, len(object)):
        if len(object[i]) != el:
            print("utils::get_average reports: Object sizes differ so cannot be averaged")
    
    result = list()
    v = mathutils.Vector((0,0,0))
    ol = len(object)
    for o in object:
        v += mathutils.Vector(o)
    result = v / ol
    return result




def percentage(percent, whole):
    return (percent * whole) / 100.0







def cleanup():
    print("running cleanup 1")
    try:
        bpy.context.scene.bb_anim.property_unset("export_sl_anim_label")
        bpy.context.scene.bb_anim.export_sl_anim_alert = False
        bpy.context.scene.bb_anim_props.property_unset("export_sl_bvh_label")
        bpy.context.scene.bb_anim_props.export_sl_bvh_alert = False

    except:
        print("utils::cleanup reports: Some things didn't clean but that's probably ok")
    return True







def update_context():
    dg = bpy.context.evaluated_depsgraph_get()
    dg.update()











def match_all(thing):
    return all(x==thing[0] for x in thing)










def get_state(report=True):

    arms = []
    mesh = []
    bones = []
    other = []

    selected = [o for o in bpy.context.selected_objects]
    active = bpy.context.active_object

    
    if active == None:
        if len(selected) > 0:
            activate(selected[0])
            print("No active object in the set, fixed!")

    
    old_mode = bpy.context.mode
    if old_mode == 'POSE':
        bones = [b for b in bpy.context.selected_pose_bones]

    
    
    if old_mode == 'EDIT_ARMATURE':
        old_mode = "EDIT"
        bpy.ops.object.mode_set(mode='POSE')
        bones = [b for b in bpy.context.selected_pose_bones]
        bpy.ops.object.mode_set(mode='OBJECT')

    
    if old_mode == 'EDIT_MESH':
        old_mode = "EDIT"

    if old_mode != 'OBJECT':
        bpy.ops.object.mode_set(mode='OBJECT')



    
    
    
    
    
    
    
    

    if selected:
        bpy.ops.object.mode_set(mode='OBJECT')
        for o in selected:
            o.select_set(False)
        for o in selected:
            o.select_set(True)
            bpy.context.view_layer.objects.active = o
            bpy.ops.object.mode_set(mode='OBJECT')
            o.select_set(False)
    else:
        if report==True:
            print("utils::get_state : reports - nothing selected, will process anyway")

    
    for o in selected:
        o.select_set(True)
    bpy.context.view_layer.objects.active = active
    





    
    
    
    


    
    

    for o in selected:
        if o.type == 'ARMATURE':
            arms.append(o)
        elif o.type == 'MESH':
            mesh.append(o)
        else:
            other.append(o)

    for o in bpy.context.selected_objects:
        o.select_set(False)

    state = {}
    state['mode'] = old_mode
    state['selected'] = selected
    state['active'] = active
    state['armatures'] = arms
    state['mesh'] = mesh
    state['other'] = other
    state['bones'] = bones

    
    
    
    
    all_objects = [o for o in selected]
    if active != None:
        all_objects.append(active)
    for o in all_objects:
        o.select_set(True)
        bpy.context.view_layer.objects.active = o
        bpy.ops.object.mode_set(mode='OBJECT')
        o.select_set(False)
    bpy.context.view_layer.objects.active = active

    return state





def set_state(state):

    old_mode = bpy.context.mode
    if old_mode != 'OBJECT':
        bpy.ops.object.mode_set(mode='OBJECT')

    for o in bpy.context.selected_objects:
        o.select_set(False)
    for o in state['selected']:
        o.select_set(True)

    active = state['active']
    bpy.context.view_layer.objects.active = active

    mode = state['mode']
    if mode == 'POSE':
        bpy.ops.object.mode_set(mode='POSE')
        for armObj in state['armatures']:
            for boneObj in armObj.data.bones:
                boneObj.select = False
        for boneObj in state['bones']:
            dBone = boneObj.bone
            dBone.select = True
    elif mode == 'EDIT':
        bpy.ops.object.mode_set(mode='EDIT')
        
        if len(state['armatures']) > 0:
            for armObj in state['armatures']:
                for boneObj in armObj.data.bones:
                    boneObj.select = False
            for boneObj in state['bones']:
                dBone = boneObj.bone
                dBone.select = True
    elif mode == 'PAINT_WEIGHT':
        
        bpy.ops.object.mode_set(mode='WEIGHT_PAINT')
        
        if len(state['armatures']) > 0:
            for armObj in state['armatures']:
                for boneObj in armObj.data.bones:
                    boneObj.select = False
            for boneObj in state['bones']:
                dBone = boneObj.bone
                dBone.select = True

    return True






def move_to_top(object=None, modifier=None):
    if object == None or modifier == None:
        return False
    obj = bpy.data.objects
    active = bpy.context.active_object
    bpy.context.view_layer.objects.active = obj[object]
    while obj[object].modifiers[0].name != modifier:
        bpy.ops.object.modifier_move_up(modifier=modifier)
    bpy.context.view_layer.objects.active = active
    return True




def cleanup():
    print("running cleanup 2")
    for block in bpy.data.meshes:
        if block.users == 0:
            bpy.data.meshes.remove(block)

    for block in bpy.data.materials:
        if block.users == 0:
            bpy.data.materials.remove(block)

    for block in bpy.data.textures:
        if block.users == 0:
            bpy.data.textures.remove(block)

    for block in bpy.data.images:
        if block.users == 0:
            bpy.data.images.remove(block)
    print("cleanup ran")
    return True








def delete():
    selected = bpy.context.selected_objects
    
    if len(selected) > 0:
        bpy.context.view_layer.objects.active = selected[0]
    if 1 == 1:
        bpy.ops.object.delete()
    else:
        for o in selected:
            if o.type == 'MESH':
                bpy.data.meshes.remove(bpy.data.meshes[o.name], do_unlink=True)
            elif o.type == 'ARMATURE':
                bpy.data.armatures.remove(bpy.data.armatures[o.name], do_unlink=True)
            
            else:
                try:
                    bpy.data.objects.remove(o)
                except:
                    print("Object", o.name, "of type", o.type, "could not be removed with (object) method")

    
    purge_orphans()
    return True





def purge_orphans():
    try:
        old_type = bpy.context.area.type
        bpy.context.area.type = 'OUTLINER'
        bpy.context.space_data.display_mode = 'ORPHAN_DATA'
        bpy.ops.outliner.orphans_purge()
        bpy.context.area.type = old_type
    except Exception as e:
        print(traceback.format_exc())
        print("Something in the purge_orphans process failed, see above for details")
        return False
    return True






def activate(object, safe=False):
    if isinstance(object, str):
        obj = bpy.data.objects
        OBJ = obj[object]
    else:
        OBJ = object
    if safe == True:
        state = get_state()
        OBJ.select_set(True)
        bpy.context.view_layer.objects.active = OBJ
        return state
    bpy.context.view_layer.objects.active = OBJ
    return True











def view_mesh(armature=None, view=False, all=True):
    obj = bpy.data.objects
    armObj = obj[armature]
    children = []
    if len(armObj.children) > 0:
        children = [c for c in armObj.children] 

    
    
    directors = armObj.get('bb_sim_directors')
    
    d = armObj.get('bb_sim_director')
    if d != None:
        if directors != None:
            directors.append(d)
        else:
            directors = [d] 

    if directors != None:
        for d in directors:
            if is_valid(d):
                children.append(d)
    for c in children:
        if all == True:
            c.hide_set(view)
        else:
            if c.type == 'MESH':
                c.hide_set(view)
    return True








def view_associated_mesh(armature=None, view=False, children=True, skinned=True):
    obj = bpy.data.objects
    armObj = armature
    if isinstance(armObj, str):
        armObj = obj[armature]

    targets = []
    
    if children == True:
        if len(armObj.children) > 0:
            targets = [c for c in armObj.children]

    
    if skinned == True:
        for o in obj:
            if o.type == 'MESH':
                for m in o.modifiers:
                    if m.type == 'ARMATURE':
                        if m.object == armObj:
                            targets.append(o)

    for o in targets:
        try:
            o.hide_set(view)
        except:
            print(o.name, "is inaccessible, skipping...")
    return True









def nuke_controllers():
    for o in bpy.data.objects:
        if o.type == 'ARMATURE':
            for pBone in o.pose.bones:
                for pbC in pBone.constraints:
                    pBone.constraints.remove(pbC)
            print("Finished bone constraints")

        for C in o.constraints:
            o.constraints.remove(C)
        print("Finished object constraints")
        
        if 1 == 0:
            try:
                fcurves = o.animation_data.drivers
                for fc in fcurves:
                    fcurves.remove(fc)
            except:
                print("No drivers, moving on")
            print("Finished drivers")

    return True






def is_valid(object):
    obj = bpy.data.objects
    
    
    try:
        if isinstance(object, str):
            if object not in obj:
                return False
            OBJ = obj[object]
        else:
            OBJ = object
    except:
        return False
    try:
        if OBJ.name not in bpy.context.scene.objects:
            return False
        return True
    except Exception as e:
        return False
    
    print("utils::is_valid : fall-through")


















def has_armature(object=None, report=False):

    
    if len(bpy.context.selected_objects)== 0 and object == None:
        if report == True:
            print("has_armature: no object and no selection")
        return False

    obj = bpy.data.objects
    
    if object != None:
        if isinstance(object, str):
            OBJ = obj[object]
        else:
            OBJ = object
        if OBJ.type == 'ARMATURE':
            if report == True:
                print("has_armature: found", OBJ.name)

            return OBJ
        
        match = []
        for M in OBJ.modifiers:
            if M.type == 'ARMATURE':
                match.append(M)
        if len(match) == 1:
            M = match[0]
            armObj = M.object
            if is_valid(armObj):
                if report == True:
                    print("has_armature: found from mesh modifiers", OBJ.name)

                return armObj
            else:
                if report == True:
                    print("utils::has_armature reports : The armature that the single armature modifier points to is invalid")
                return False
        
        txt = ""
        if len(match) > 1:
            txt = "too many armature modifiers"
        if len(match) == 0:
            txt = "no armature modifiers"
        if report == True:
            print("utils::has_armature reports :", txt)
        return False

    
    
    selected = bpy.context.selected_objects
    if len(selected) == 0:
        if report == True:
            print("utils::has_armature reports: no argument and no selection, nothing to do")
        return False

    
    mesh = []
    arms = []
    for o in selected:
        if o.type == 'MESH':
            mesh.append(o)
        elif o.type == 'ARMATURE':
            arms.append(o)

    
    if len(mesh) == 0 and len(arms) > 1:
        if report == True:
            print("utils::has_armature reports : no mesh selected and too many armatures, expected 1 armature or 1 or more mesh and/or armature with it")
        return False

    
    if len(mesh) == 0 and len(arms) == 1:
        
        if report == True:
            print("utils::has_armature reports : Found armature on the single selected armature:", arms[0].name)
        return arms[0]

    
    if len(mesh) == 0:
        if report == True:
            print("utils::has_armature reports : after running excessive tests on the selected objects no qualified mesh or armatures were found")
        return False

    
    
    
    
    mods = set() 
    objs = set() 
    for o in mesh:
        mesh_mods = []
        for m in o.modifiers:
            if m.type == 'ARMATURE':
                mesh_mods.append(m)
        if len(mesh_mods) == 0:
            if report == True:
                print("No qualified modifiers on", o.name)
        else:
            if report == True:
                print("Found qualified modifiers on", o.name)
            if len(mesh_mods) > 1:
                if report == True:
                    print("Too many armature modifiers on", o.name)
            else:
                if mesh_mods[0].object == None:
                    if report == True:
                        print("Modifier points to nothing", o.name)
                else:
                    if is_valid(mesh_mods[0].object):
                        if report == True:
                            print("found valid armature modifier on", o.name)
                        objs.add(mesh_mods[0].object)

    if len(objs) > 1:
        if report == True:
            print("utils::has_armature reports : too many directions, the target objects for qualified mesh with qualified armatures is greater than 1")
        return False
    if len(objs) == 0:
        if report == True:
            print("utils::has_armature reports : no qualified armatures armatures were found on the selected mesh")
        return False

    
    
    return list(objs)[0]








def get_properties(group=None):
    props = {}
    for k in group.__annotations__.keys():
        v = getattr(group, k)
        props[k] = v
    return props

get_props = get_properties




def set_properties(group=None, props=None):
    for k in props:
        v = props[k]
        setattr(group, k, v)
    return True

set_props = set_properties










def duplicate(objects=None):
    """Duplicate objects using ops without them being selected and make a safe (active)
choice then return an expected result, False or only those objects that were
duplicated are selected"""

    if objects == None:
        sources = bpy.context.selected_objects
    else:
        if isinstance(objects, str):
            sources = [bpy.data.objects[objects]]
        elif isinstance(objects, list):
            sources = objects
        else:
            
            sources = [objects]

    if len(sources) == 0:
        print("utils::copy reports : No objects to process")
        return False

    if bpy.context.active_object not in sources:
        activate(sources[0])
    active = bpy.context.active_object
    for o in bpy.context.selected_objects:
        o.select_set(False)
    for o in sources:
        o.select_set(True)
    bpy.ops.object.duplicate()
    return bpy.context.selected_objects





def update():
    bpy.context.view_layer.update()









def compose_bone_transforms(inBone=None, outBone=None, location=False, rotation=False, scale=False, apply=False):
    if location == False and rotation == False and scale == False:
        print("utils::compose_bone_transforms reports : no directive")
        return False
    if inBone == None:
        print("utils::compose_bone_transforms reports : no input")
        return False
    if outBone == None:
        print("utils::compose_bone_transforms reports : no output")
        return False

    in_location, in_rotation, in_scale = inBone.matrix_local.decompose()
    out_location, out_rotation, out_scale = outBone.matrix_local.decompose()
    if location == True:
        out_location = in_location
    if rotation == True:
        out_rotation = in_rotation
    if scale == True:
        out_scale = in_scale
    L = mathutils.Matrix.Translation(out_location)
    R = out_rotation.to_matrix().to_4x4()
    S = mathutils.Matrix()
    for i in range(3):
        S[i][i] = out_scale[i]

    M = L @ R @ S

    if apply == True:
        outBone.matrix = M

    return M







def compose_transforms(matrix_in=None, matrix_out=None, location=False, rotation=False, scale=False):
    if location == False and rotation == False and scale == False:
        print("utils::compose_transforms reports : no directive")
        return False
    if matrix_in == None:
        print("utils::compose_transforms reports : no input")
        return False
    if matrix_out == None:
        print("utils::compose_transforms reports : no output")
        return False

    in_location, in_rotation, in_scale = matrix_in.decompose()
    out_location, out_rotation, out_scale = matrix_out.decompose()
    if location == True:
        out_location = in_location
    if rotation == True:
        out_rotation = in_rotation
    if scale == True:
        out_scale = in_scale
    L = mathutils.Matrix.Translation(out_location)
    R = out_rotation.to_matrix().to_4x4()
    S = mathutils.Matrix()
    for i in range(3):
        S[i][i] = out_scale[i]

    M = L @ R @ S

    return M














def vec_roll_to_mat3(vec, roll):
    nor = vec.normalized()
    THETA_THRESHOLD_NEGY = 1.0e-9
    THETA_THRESHOLD_NEGY_CLOSE = 1.0e-5

    
    bMatrix = mathutils.Matrix().to_3x3()

    theta = 1.0 + nor[1];

    if (theta > THETA_THRESHOLD_NEGY_CLOSE) or ((nor[0] or nor[2]) and theta > THETA_THRESHOLD_NEGY):

        bMatrix[1][0] = -nor[0];
        bMatrix[0][1] = nor[0];
        bMatrix[1][1] = nor[1];
        bMatrix[2][1] = nor[2];
        bMatrix[1][2] = -nor[2];
        if theta > THETA_THRESHOLD_NEGY_CLOSE:
            
            bMatrix[0][0] = 1 - nor[0] * nor[0] / theta;
            bMatrix[2][2] = 1 - nor[2] * nor[2] / theta;
            bMatrix[0][2] = bMatrix[2][0] = -nor[0] * nor[2] / theta;

        else:
            
            theta = nor[0] * nor[0] + nor[2] * nor[2];
            bMatrix[0][0] = (nor[0] + nor[2]) * (nor[0] - nor[2]) / -theta;
            bMatrix[2][2] = -bMatrix[0][0];
            bMatrix[0][2] = bMatrix[2][0] = 2.0 * nor[0] * nor[2] / theta;

    else:
        
        bMatrix = mathutils.Matrix().to_3x3()
        bMatrix[0][0] = bMatrix[1][1] = -1.0;

    
    rMatrix = mathutils.Matrix.Rotation(roll, 3, nor)

    
    mat = rMatrix @ bMatrix
    return mat
def mat3_to_vec_roll(mat):
    
    vec = mat.col[1]
    vecmat = vec_roll_to_mat3(mat.col[1], 0)
    vecmatinv = vecmat.inverted()
    rollmat = vecmatinv @ mat
    roll = math.atan2(rollmat[0][2], rollmat[2][2])
    return vec, roll





def get_bone_roll(mat):
    v, r = mat3_to_vec_roll(mat.to_3x3())
    return r






def make_single(obj):
    if isinstance(obj, str):
        OBJ = bpy.data.objects[obj]
    else:
        OBJ = obj

    state = get_state()
    OBJ.select_set(True)
    activate(OBJ)

    
    
    

    
    
    
    
    bpy.ops.object.mode_set(mode='OBJECT')


    bpy.ops.object.make_single_user(object=True, obdata=True, material=False, animation=False)
    set_state(state)
    return True
make_unique = make_single





def apply_transforms(object=None, rotation=True, location=True, scale=True):
    OBJ = object
    if isinstance(object, str):
        OBJ = bpy.data.objects[object]
    state = get_state()
    OBJ.select_set(True)
    activate(OBJ)
    bpy.ops.object.transform_apply( rotation=rotation, location=location, scale=scale )
    set_state(state)
    return True











def rotate_matrix(matrix=None, forward="X"):
    MBI =  matrix.inverted()
    R90 = mathutils.Matrix.Rotation(math.radians(90.0), 4, 'Z')
    R90I = R90.inverted()
    R180 = mathutils.Matrix.Rotation(math.radians(180.0), 4, 'Z')
    R180I = R180.inverted()

    if forward == '-Y':
        M = MBI @ R90I
        M = R90I @ M @ R90I
        return M
    if forward == 'X':
        
        M = R90I @ MBI
        M = M @ R180
        M = R90 @ M
        return M

    return False

















def get_object_props(object=None, prop=None, scope="all", report=True):

    
    def get_single_property(object, prop):
        
        fail = True
        try:
            p = object[prop].to_dict()
            return p
        except:
            pass
        try:
            p = object[prop].to_list()
            return p
        except:
            pass
        try:
            p = object[prop]
            if isinstance(p, str):
                return p
            elif isinstance(p, float):
                return p
            elif isinstance(p, int):
                return p
            elif isinstance(p, list):
                return p
        except:
            
            
            
            
            
            p = object[prop]
            return object[prop][p]

        if fail == True:
            print("Could not return the type of property targeted by", prop, "in object", object.name)
            return False

        return p
    

    OBJ = object
    if isinstance(OBJ, str):
        OBJ = bpy.data.objects[object]

    if scope == "all":
        props = {}
        props['object'] = {}
        for p in OBJ.keys():
            result = get_single_property(OBJ, p)
            if result != False:
                props['object'][p] = result
        if OBJ.type == 'ARMATURE':
            armObj = OBJ
            state = get_state()
            armObj.select_set(True)
            activate(armObj)
            props['bones'] = {}
            props['bones']['pose'] = {}
            props['bones']['data'] = {}
            props['bones']['edit'] = {}
            bpy.ops.object.mode_set(mode='EDIT')
            for pose_boneObj in armObj.pose.bones:
                bone = pose_boneObj.name
                data_boneObj = pose_boneObj.bone
                edit_boneObj = armObj.data.edit_bones[bone]
                for p in pose_boneObj.keys():
                    result = get_single_property(pose_boneObj, p)
                    if result != False:
                        props['bones']['pose'][p] = result
                for p in data_boneObj.keys():
                    result = get_single_property(data_boneObj, p)
                    if result != False:
                        props['bones']['data'][p] = result
                for p in edit_boneObj.keys():
                    result = get_single_property(edit_boneObj, p)
                    if result != False:
                        props['bones']['edit'][p] = result
            set_state(state)

        return props

    
    if prop == None:
        print("utils:get_prop : no property to extract")
        return False





def get_difference(base=0, offset=0):
    a=base
    b=offset
    if (a == b):
        return 0
    elif (a < 0) and (b < 0) or (a > 0) and (b > 0):
        if (a < b):
            return (abs(abs(a) - abs(b)))
        else:
            return -(abs(abs(a) - abs(b)))
    else:
        return math.copysign((abs(a) + abs(b)),b)






def get_percent(base=0, offset=0):
    a = base
    b = offset
    diff = abs(a - b)
    if diff == 0:
        return 0
    div = a/diff
    percent = 100/div
    return percent



def get_scale(base=0, offset=0):
    scale = ((float(offset)-base)/base)
    return scale




def to_deg(mat):
    eu = mat.to_euler()
    return [math.degrees(round(a, 4)) for a in eu]





def get_stored_scale(boneObj, S=None, truly_weird=True):

    
    s0 = mathutils.Vector(boneObj.get('scale0',(1,1,1)))
    
    
    
    
    if truly_weird:
        
        
        
        x = boneObj.get('restpose_scale_y', s0[0])
        y = boneObj.get('restpose_scale_x', s0[1])
        z = boneObj.get('restpose_scale_z', s0[2])
        sc = mathutils.Vector((x,y,z))
        
        
        sc0m = abs(sc.magnitude - s0.magnitude)
        sc0n = abs(sc.normalized().dot(s0.normalized()) - 1)
        if sc0m > 0.0001 and sc0n > 0.0001:
            s0 = sc
        
        
           
                

    
    ds = mathutils.Vector(boneObj.get('scale',(0,0,0)))
    
    

    s_ = (s0 + ds)
    
    s = s_.copy()
    s[0] = s_[1]
    s[1] = s_[0]
    if S == None:
        S = mathutils.Matrix()
    for i in range(3):
        if s[i] == 0:
            s[i] = 0.000001
        S[i][i] *= s[i]

    
    
    
    
    
    
    
    

    return S



def select(object, state):
    Obj = object
    if isinstance(object, str):
        Obj = bpy.data.objects[object]
    Obj.select = state



def set_inverse(context_py, cname):
    
    
    if bpy.app.version < (2, 90, 0):
        bpy.ops.constraint.childof_set_inverse(context_py, constraint=cname, owner="BONE")
    else:
        bpy.ops.constraint.childof_set_inverse(constraint=cname, owner="BONE")

    return True















def vertex_constraint(arm=None, bone=None, mesh=None, vertices=[], influence=1, location=True, rotation=True, scale=False):
    armObj = arm
    boneObj = bone
    meshObj = mesh
    if isinstance(arm, str):
        armObj = bpy.data.objects[arm]
    if isinstance(bone, str):
        boneObj = armObj.pose.bones[bone]
    if isinstance(mesh, str):
        meshObj = bpy.data.objects[mesh]
    if len(vertices) == 0:
        print("utils::vertex_constraint : No vertices were delivered, nothing to do ")
        return False

    
    G = meshObj.vertex_groups.new( name = boneObj.name )
    G.add(vertices, 1, 'REPLACE')

    
    armObj.data.bones.active = boneObj.bone 
    bc = boneObj.constraints

    conObj = bc.new('CHILD_OF')
    cname = conObj.name
    conObj.target = meshObj
    conObj.subtarget = boneObj.name
    conObj.influence = influence
    conObj.use_location_x = location
    conObj.use_location_y = location
    conObj.use_location_z = location
    conObj.use_rotation_x = rotation
    conObj.use_rotation_y = rotation
    conObj.use_rotation_z = rotation
    conObj.use_scale_x = scale
    conObj.use_scale_y = scale
    conObj.use_scale_z = scale

    
    
    
    context_py = bpy.context.copy()
    context_py["constraint"] = bc.active

    
    
    if 1 == 0:
        new_state = utils.get_state()
        aObj.select_set(True)
        utils.activate(aObj)
        bpy.ops.object.mode_set(mode='POSE')

    
    set_inverse(context_py, cname)
    
    
    conObj.name = "BB Sim " + cname

    
    
    
    
    
    
    
    if props['constraint_group_base'] not in armObj.pose.bone_groups:
        bpy.ops.pose.group_add()
    armObj.pose.bone_groups.active.name = props['constraint_group_base']
    armObj.pose.bone_groups.active.color_set = props['constraint_theme_base']
    group_base = sim.props['constraint_group_base']
    boneObj.bone_group = armObj.pose.bone_groups[group_base]

    return True






def rig_is_selected():
    if len(bpy.context.selected_objects) == 1:
        if bpy.context.selected_objects[0].type == 'ARMATURE':
            return bpy.context.selected_objects[0]
    return False













def is_visible(OBJ):
    pass

















def base_to_sign(base=0, offset=0):
    
    
    difference = abs(base - offset)
    final = difference
    if offset < base:
        final = ( difference - (difference * 2) )
    
    return final





def normalize_float(f, max=6):
    reduced = round(f, max)
    result = abs(reduced)
    if result <= 10** -max:
        result = reduced
    return result







def make_filenames(prefix="Anim", count=None, ext=".anim"):
    if count == 0:
        print("utils::make_filenames : no count specified")
        return False
    if count > 999:
        print("Can't exceed 999 items")
        return False

    n = 0
    file_names = []
    for a in range(count):
        
        n += 1
        ns = str(n)
        zf = ns.zfill(3)
        anim_name = prefix + "_" + zf + ext
        file_names.append(anim_name)

    return file_names
















