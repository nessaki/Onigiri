

bl_info = {
       "name": "Onigiri",
       "author": "Nessaki",
       "version": (3, 0, 5, 0),
       "blender": (2, 80, 0),
       "description": "A Japanese dish consisting of small balls or triangles of rice stuffed with a pickled or salted filling, and typically wrapped in dried seaweed.",
       "warning": "",
       "category": "3D View",
       "location": "View3D > Tools > Onigiri"
       }

print("NOTES:")
print("-------")
print(" * OnigiriCreateAnimationRig disabled until complete")
print(" * snap_symmetry_enabled : False")
print(" * OnigiriMotionHipCorrectionStart : Disabled")
print(" * OnigiriMotionHipCorrectionEnd : Disabled")
print(" * OnigiriMotionHipCorrectionReset : Disabled")
print(" * OnigiriOnemapReverse : Not used yet, see OnigiriInheritReverseMap")
print(" * Shape importer disabled, serves no user purpose, see (Body Shop)")
print(" * This old class has been disabled, watch for bugs: CharacterConverterExpandMapper")
print(" * Bulk animation exporter: export_mapped_animation needs work, see (export_retargeted_animation) instead")

import re
import os
import bpy
import sys
import json
import math
import time
import copy
import bmesh
import shutil 
import pickle
import pprint
import struct
import decimal
import tempfile
import mathutils
import importlib
import traceback

from collections import deque

import xml.etree.ElementTree as ET

from bpy_extras.io_utils import ImportHelper, ExportHelper
from bpy.utils import previews

from bpy.app.handlers import persistent

from . import mod_functions
from . import monitor
from . import mod_flags
from . import mod_settings

from .presets import skeleton as skel
from .presets import volumes
from .presets import bone_groups
from . import hierarchy
from . import anim
from . import animutils

from . import joint_data
from . import axis_defs
from . import icon_defs
from . import ico
from . import templates

from . import collada
from . import pill
from . import meshutils
from . import gestures

from . import edit

from . import rigutils

from .presets import rig_data

from . import bvh_tools as bvht
from . import bvh
from . import curves
from . import views
from . import slbvh
from . import utils

from . import shifter
from . import common
from . import collada_universal

from .mod_functions import *
from .monitor import *
from .mod_flags import *
from .mod_settings import *
from .hierarchy import bento_links
from .anim import *
from . import animesh
from .animesh import *
from . import mapper
from .mapper import *
from . import globals
from . import onemap
from . import snap
from . import splice
from . import dynamic
from . import convert
from . import sim
from . import latch
from . import motion
from . import devkit
from . import puppet
from . import reactor
from . import ragdoll
from . import shape
from . import visible
from . import sliders

if 1 == 0:
    reload_my_important_modules = [
        template_editor,
        ]
    for m in reload_my_important_modules:
        importlib.reload(m)
    from .template_editor import *

script_dir = os.path.dirname(os.path.abspath(__file__))

presets_path    =   bb_settings['paths']['presets']
data_path       =   bb_settings['paths']['data']
devkit_path     =   bb_settings['paths']['devkit']
code_path       =   bb_settings['paths']['code']
reset_file      =   bb_settings['files']['reset']
bvh_template    =   bb_settings['files']['bvh_template']
character_path  =   bb_settings['paths']['characters']

def get_icon(key):
    return ico.custom_icons[key].icon_id

@persistent
def clean_data(context):
    
    bb_paint = bpy.context.scene.get('bb_paint')
    if bb_paint:
        if bb_paint.get('paint_back_face') != None:
            bpy.data.brushes["Draw"].falloff_shape = 'PROJECTED'
            bpy.data.brushes["Draw"].use_frontface = False
            bpy.data.brushes["Draw"].use_frontface_falloff = False

    if 1 == 1: 
        if getattr(bpy.context.scene, "bb_anim", None) != None:
            
            bpy.context.scene.bb_anim.property_unset("export_sl_anim_label")
            bpy.context.scene.bb_anim.property_unset("export_sl_anim_label_short")
            bpy.context.scene.bb_anim.export_sl_anim_alert = False
            bpy.context.scene.bb_anim.export_sl_anim_old_alert = False

            bpy.context.scene.bb_anim_props.property_unset("export_sl_bvh_label")
            bpy.context.scene.bb_anim_props.property_unset("export_sl_bvh_label_short")
            bpy.context.scene.bb_anim_props.export_sl_bvh_alert = False

    if getattr(bpy.context.window_manager, "bb_retarget", None) != None:
        bbr = bpy.context.window_manager.bb_retarget
        bb_settings['terminate'] = True
        bbr.retarget_source_name = ""
        bb_settings['terminate'] = True
        bbr.retarget_target_name = ""
        bb_settings['terminate'] = True
        bbr.retarget_set_source = False
        bb_settings['terminate'] = True
        bbr.retarget_set_target = False
        bb_settings['terminate'] = True
        bbr.retarget_enabled = False
        bbr.retarget_text = ""
        
    if getattr(bpy.context.scene, "onigiri", None) != None:
        if bb_flags['debug'] == 1:
            print("Onigiri: clean_data")

        bb = bpy.context.scene.onigiri
        cleaned_list = []
        
        if hasattr(bb, 'map_to_template'):
            setattr(bpy.context.scene.onigiri, 'map_to_template', False)
            cleaned_list.append("map_to_template")
        if hasattr(bb, 'enforce_settings'):
            setattr(bpy.context.scene.onigiri, 'enforce_settings', False)
            cleaned_list.append("enforce_settings")
        if hasattr(bpy.context.scene, 'onigiri_template'):
            setattr(bpy.context.scene, 'onigiri_template', "")
            cleaned_list.append("onigiri_template -path")
        if hasattr(bb, 'custom_bone_list'):
            setattr(bpy.context.scene.onigiri, 'custom_bone_list', False)
            cleaned_list.append("custom_bone_list")
        
        if hasattr(bpy.context.scene, 'onigiri_custom_bone_list'):
            setattr(bpy.context.scene, 'onigiri_custom_bone_list', "")
            cleaned_list.append("onigiri_custom_bone_list -path")

        if len(cleaned_list) > 0:
            cleaned_list.clear()
            if bb_flags['debug'] == 1:
                print("Items cleaned:", cleaned_list)

    if getattr(bpy.context.window_manager, "bb_animesh", None) != None:
        ani = bpy.context.window_manager.bb_animesh
        if ani.get("animesh_mapper_enabled") == True:
            bb_settings['terminate'] = True
            ani.animesh_mapper_enabled = False
            bb_settings['terminate'] = True
            ani.animesh_suspend = False
            bb_settings['terminate'] = True
            ani.animesh_lock_source = False
            bb_settings['terminate'] = True
            ani.animesh_lock_target = False
            ani.animesh_source_name = ""
            ani.animesh_target_name = ""
            ani.animesh_targets = 0
            ani.animesh_menu_enabled = False
            del ani['targets']

@persistent
def clean_on_activate(context):
    
    clean_data(None) 
    try:
        bpy.app.handlers.depsgraph_update_post.remove(clean_on_activate)
    except:

        pass

onigiri_exists = False

@persistent
def sanity_check(context):

    if len(bpy.context.selected_objects) == 0:
        bb_settings['terminate'] = True
        bpy.context.scene.bb_arm_props.use_connect_all = False
        bpy.context.scene.bb_arm_props.use_connect_enabled = False

        bpy.context.scene.bb_run.last = ""

        return
    
    if bpy.context.active_object == None:
        return

    if bpy.context.active_object.type == 'ARMATURE':
        
        if bpy.context.active_object.mode == 'POSE' or bpy.context.active_object.mode == 'EDIT':
            bpy.context.scene.bb_arm_props.use_connect_enabled = True
        else:
            bpy.context.scene.bb_arm_props.use_connect_enabled = False

        if getattr(bpy.context.scene, "bb_run", None) == None:
            return

        if getattr(bpy.context.scene.bb_run, 'last', None) == bpy.context.active_object.name:
        
            return
        
        bpy.context.scene.bb_run.selected = bpy.context.active_object.name

        bpy.context.scene.bb_arm_props.use_connect_enabled = False
        
        if 'disable_use_connect' in bpy.context.active_object.keys():
            bb_settings['terminate'] = True
            bpy.context.scene.bb_arm_props.use_connect_all = bpy.context.active_object['disable_use_connect']
        else:
            bb_settings['terminate'] = True
            bpy.context.scene.bb_arm_props.use_connect_all = False
        
        if getattr(bpy.context.scene.bb_run, "selected", None) != None:

            bpy.context.scene.bb_run.last = bpy.context.scene.bb_run.selected
            bpy.context.scene.bb_run.running = True

        return 
    return 

@persistent
def joint_properties_handler(context):

    if getattr(bpy.context.window_manager.bb_joint_data, "joint_data_enabled", False) == False:
        return
    
    if len(bpy.context.selected_objects) != 1:
        return
    if bpy.context.selected_objects[0].type != 'ARMATURE':
        return
    if bpy.context.selected_objects[0].get('onigiri') == None:
        return

    ajd = bpy.context.window_manager.bb_joint_data
    jd = joint_data

    if selected_pose_bones() != 1:
        ajd.on_state = "off"
        return

    selected_bone = bpy.context.selected_pose_bones[0].name

    x,y,z = jd.joint_data[selected_bone]['loc_axis_inverted']
    ajd.loc_axis_inverted_x = True if x else False
    ajd.loc_axis_inverted_y = True if y else False
    ajd.loc_axis_inverted_z = True if z else False

    x,y,z = jd.joint_data[selected_bone]['loc_offset_inverted']
    ajd.loc_offset_inverted_x = True if x else False
    ajd.loc_offset_inverted_y = True if y else False
    ajd.loc_offset_inverted_z = True if z else False

    x,y,z = jd.joint_data[selected_bone]['rot_axis_inverted']
    ajd.rot_axis_inverted_x = True if x else False
    ajd.rot_axis_inverted_y = True if y else False
    ajd.rot_axis_inverted_z = True if z else False

    if jd.joint_data[selected_bone].get('copy') != "":
        ajd.on_state = "on"
        ajd.copy_joint_data_name = jd.joint_data[selected_bone]['copy']
    else:
        ajd.on_state = "off"

    if jd.joint_data[selected_bone]['locked'] == True:
        ajd.joint_locked = True
        jd.joint_data[selected_bone]['locked'] = True
    else:
        
        ajd.joint_locked = False
        jd.joint_data[selected_bone]['locked'] = False

    return

def cleanup():

    try:
        states = bpy.context.window_manager.bb_misc['hide_states']
        for s in states:
            rigutils.restore_hide_state(s)
    except:
        pass
    try:
        bpy.context.scene.bb_anim.property_unset("export_sl_anim_label")
        bpy.context.scene.bb_anim.export_sl_anim_alert = False
        bpy.context.scene.bb_anim.export_sl_anim_old_alert = False
        bpy.context.scene.bb_anim_props.property_unset("export_sl_bvh_label")
        bpy.context.scene.bb_anim_props.export_sl_bvh_alert = False
        ui_cleanup_finished = True
    except:
        pass
    try:
        if ui_cleanup_finished == True:
            return None
    except:
        pass

    return 1.0

print("Handlers loaded")
if 1 == 1:
    handlers_list = [
        clean_on_activate,
        
        ]
    bpy.app.handlers.load_post.clear()
    bpy.app.handlers.load_post.append(clean_data)
    bpy.app.timers.register(cleanup)

    for h in handlers_list:
        bpy.app.handlers.depsgraph_update_post.append(h)

icons_dir = script_dir + bb_settings["paths"]["icons"]

def test_flag(self, context):
    pass
    return

def set_flag(self, value):
    print("set_flag says:", self, value)
    return

def retarget_mode(context):

    bbr = bpy.context.window_manager.bb_retarget
    obj = bpy.data.objects

    source = bbr.retarget_source_name
    target = bbr.retarget_target_name

    if source not in obj:
        print("map source removed:", source)
        
        bbr.retarget_set_source = False
        return
    if target not in obj:
        print("map target removed:", target)
        
        bbr.retarget_set_target = False
        return

    if bb_flags['debug'] == 1:
        bb_settings['count'] += 1
        print("retarget_enabled", bbr.retarget_enabled)
        print("count:", bb_settings['count'])
        print("entering retarget mode with blender mode set to :", bpy.context.mode)

    if bpy.context.mode != 'POSE':
        bpy.app.handlers.depsgraph_update_post.remove(retarget_mode)
        bbr.retarget_text = "WARNING: Suspended!"
        return

    if bpy.context.selected_pose_bones is None:
        return
    if len(bpy.context.selected_pose_bones) != 1:
        return

    boneObj = bpy.context.selected_pose_bones[0]

    if bb_flags['debug'] == 1:
        print("==================================================")
        print("pose bone selected is:", boneObj.name)
        print("==================================================")

    if bbr.retarget_rig == bbr.retarget_source_name:
        if bb_flags['debug'] == 1:
            print("source rig activated")

        bbr.retarget_text = "Select a target bone"
 
        bbr.retarget_source_bone = boneObj.name

        if bbr.retarget_source_bone in obj[bbr.retarget_source_name]['bone_map']:

            target_bone_value = obj[bbr.retarget_source_name]['bone_map'][bbr.retarget_source_bone]
            
            del obj[bbr.retarget_target_name]['bone_map'][target_bone_value]
            
            bpy.context.view_layer.objects.active = bpy.data.objects[bbr.retarget_target_name]

            obj[bbr.retarget_target_name].data.bones[target_bone_value].select = True
            bpy.ops.pose.group_unassign()
            bpy.ops.pose.select_all(action = 'DESELECT')
            
            del obj[bbr.retarget_source_name]['bone_map'][bbr.retarget_source_bone]

        boneObj.bone_group = bpy.data.objects[bbr.retarget_rig].pose.bone_groups[bb_source_group]

        for b in obj[bbr.retarget_source_name].data.bones:
            b.hide_select = True
        for b in obj[bbr.retarget_target_name].data.bones:
            b.hide_select = False

        obj[bbr.retarget_source_name].data.bones[boneObj.name].select = False

        bbr.retarget_rig = bbr.retarget_target_name

    elif bbr.retarget_rig == bbr.retarget_target_name:
        if bb_flags['debug'] == 1:
            print("target rig activated")

        bbr.retarget_text = "Select a source bone"

        bbr.retarget_target_bone = boneObj.name

        if bbr.retarget_target_bone in obj[bbr.retarget_target_name]['bone_map']:

            source_bone_value = obj[bbr.retarget_target_name]['bone_map'][bbr.retarget_target_bone]

            del obj[bbr.retarget_source_name]['bone_map'][source_bone_value]

            bpy.context.view_layer.objects.active = bpy.data.objects[bbr.retarget_source_name]
            obj[bbr.retarget_source_name].data.bones[source_bone_value].select = True
            bpy.ops.pose.group_unassign()
            bpy.ops.pose.select_all(action = 'DESELECT')
            
            bpy.context.view_layer.objects.active = bpy.data.objects[bbr.retarget_source_name]

        obj[bbr.retarget_source_name]['bone_map'][bbr.retarget_source_bone] = bbr.retarget_target_bone
        
        obj[bbr.retarget_target_name]['bone_map'][bbr.retarget_target_bone] = bbr.retarget_source_bone

        boneObj.bone_group = bpy.data.objects[bbr.retarget_rig].pose.bone_groups[bb_target_group]

        for b in obj[bbr.retarget_target_name].data.bones:
            b.hide_select = True
        for b in obj[bbr.retarget_source_name].data.bones:
            b.hide_select = False

        obj[bbr.retarget_target_name].data.bones[boneObj.name].select = False

        bbr.retarget_rig = bbr.retarget_source_name

    return

def animation_retarget():
    obj = bpy.data.objects
    bbr = bpy.context.window_manager.bb_retarget

    if bb_flags['debug'] == 1:
        print("entering animation_retarget with armatures source/target", bbr.retarget_source_name, "/", bbr.retarget_target_name)

    if bbr.retarget_enabled == True:
        
        print("removing map data from animation retargeting")
        bbr.retarget_enabled = False

        if bbr.retarget_source_name_backup not in obj:
            print("animation source missing when attempting to clean up data")
            return
        if bbr.retarget_target_name_backup not in obj:
            print("target missing when attempting to clean up data")
            return

        restore_sources("edit")

        del obj[bbr.retarget_source_name_backup]['bone_map']
        del obj[bbr.retarget_target_name_backup]['bone_map']
        
        del obj[bbr.retarget_source_name_backup]['bone_data']
        del obj[bbr.retarget_target_name_backup]['bone_data']

        for boneObj in obj[bbr.retarget_source_name_backup].data.bones:
            boneObj.hide_select = False
        for boneObj in obj[bbr.retarget_target_name_backup].data.bones:
            boneObj.hide_select = False

        remove_bone_groups(bbr.retarget_source_name_backup)
        remove_bone_groups(bbr.retarget_target_name_backup)

        return

    elif bbr.retarget_enabled == False:
        print("adding map data to retargeting pair")
        
        if bbr.retarget_target_name_backup not in obj:
            print("animation target missing when attempting to setup data", )
            print("  orig", bbr.retarget_target_name)
            print("backup", bbr.retarget_target_name_backup)
            return
        if bbr.retarget_source_name_backup not in obj:
            print("animation source missing when attempting to setup data")
            print("  orig", bbr.retarget_source_name)
            print("backup", bbr.retarget_source_name_backup)
            return

        obj[bbr.retarget_source_name].show_in_front = True
        obj[bbr.retarget_target_name].show_in_front = True

        bpy.ops.object.select_all(action='DESELECT')

        print("WARNING: Source rigs must have no rotation transforms so I'll reset that for you")
        obj[bbr.retarget_source_name].select_set(True)
        bpy.ops.object.mode_set(mode='OBJECT')
        
        bpy.ops.object.transform_apply(rotation=True, location=False, scale=False)
        obj[bbr.retarget_source_name].select_set(False)
        bpy.context.view_layer.update()

        remove_bone_groups(bbr.retarget_source_name)
        remove_bone_groups(bbr.retarget_target_name)

        print("assuming safe mode", bpy.context.mode)

        create_bone_group(bbr.retarget_source_name, bb_source_group, bb_source_theme)
        create_bone_group(bbr.retarget_target_name, bb_target_group, bb_target_theme)

        obj[bbr.retarget_source_name]['bone_map'] = dict()
        obj[bbr.retarget_target_name]['bone_map'] = dict()

        obj[bbr.retarget_source_name_backup]['bone_data'] = dict()
        obj[bbr.retarget_target_name_backup]['bone_data'] = dict()

        for boneObj in obj[bbr.retarget_source_name_backup].data.bones:
            boneObj.hide_select = False
        for boneObj in obj[bbr.retarget_target_name_backup].data.bones:
            boneObj.hide_select = True

        bbr.retarget_rig = bbr.retarget_source_name_backup

        set_obj_mode("pose", [bbr.retarget_source_name, bbr.retarget_target_name])

        store_bone_data()

        for boneObj in obj[bbr.retarget_source_name].data.edit_bones:
            boneObj.use_connect = False

        bpy.ops.pose.select_all(action='DESELECT')

        bbr.retarget_enabled = True

        return

    print("WARNING: animation_retarget reports fall through, should not happen")
    return

def clean_rig_mapper(arm):
    ccp = bpy.context.window_manager.cc_props
    obj = bpy.data.objects

    if arm not in obj:
        return

    obj[arm].hide_select = False

    selected_objects = bpy.context.selected_objects

    if len(selected_objects) > 0:
        
        if bpy.context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')
    
    bpy.data.objects[arm].select_set(True)
    bpy.context.view_layer.objects.active = bpy.data.objects[arm]
    
    bpy.ops.object.mode_set(mode='POSE')
    
    for bone in obj[arm].data.bones:
        bone.hide_select = False
    
    bpy.ops.pose.select_all(action = 'SELECT')
    
    bpy.ops.pose.group_unassign()
    bpy.ops.pose.select_all(action = 'DESELECT')

    ccp.ccm_message = "Choose your rigs"

    bb_settings['terminate'] = True
    ccp.edit_mode = False

    print("clean_up_mapper reports: triggering hide_mapped_bones with value (False)")
    ccp.hide_mapped_bones = False

    print("clean_up_mapper reports: attempting to remove handler - edit.auto_weight_on_select")
    try:
        print("clean_up_mapper reports: handler - auto_weight_on_select - REMOVED")
        bpy.app.handlers.depsgraph_update_post.remove(edit.auto_weight_on_select)
    except:
        print("clean_up_mapper reports: handler - edit.auto_weight_on_select - NOTHING TO DO")

    return

def get_bone_prefix(arm):
    
    check_prefix = list()
    for bone in bpy.data.objects[arm].data.bones:
        check_prefix.append(bone.name)
    
    if len(check_prefix) == 0:
        return "" 

    prefix_len = len(check_prefix[0])
    for bone in check_prefix[1 : ]:
        prefix_len = min(prefix_len, len(bone))
        while not bone.startswith(check_prefix[0][ : prefix_len]):
            prefix_len -= 1
    prefix = check_prefix[0][ : prefix_len]
    return prefix

def remove_bone_prefix(arm, prefix):
    for bone in bpy.data.objects[arm].data.bones:
        bone_name = bone.name
        if bone_name.startswith(prefix):
            new_bone = bone_name.replace(prefix, "", 1)
            bone.name = new_bone
    return

def get_data_prefix(container):
    check_prefix = list()
    for data in container:
        check_prefix.append(data)
    prefix_len = len(check_prefix[0])
    for data in check_prefix[1 : ]:
        prefix_len = min(prefix_len, len(data))
        while not data.startswith(check_prefix[0][ : prefix_len]):
            prefix_len -= 1
    prefix = check_prefix[0][ : prefix_len]
    return prefix

def remove_data_prefix(container="", prefix=""):
    if bb_flags['debug'] == 1:
        print("Warning: remove_data_prefix may not be fully functional")

    if type(container) == dict:
        data_thing = dict()
        for data in container:
            if data.startswith(prefix):
                new_data = data.replace(prefix, "", 1)
                data_thing[new_data] = container[data]
    elif type(container) == set:
        data_thing = set()
        for data in container:
            if data.startswith(prefix):
                new_data = data.replace(prefix, "", 1)
                data_thing.add(data)
    elif type(container) == list:
        data_thing = list()
        for data in container:
            if data.startswith(prefix):
                new_data = data.replace(prefix, "", 1)
                data_thing.append(data)
    else:
        print("unrecognized type from remove_data_prefix")
        return None

    return data_thing

def apply_map_pose(arm, cc_pose):
    
    selected_objects = bpy.context.selected_objects

    mode = bpy.context.mode

    bpy.context.view_layer.objects.active = bpy.data.objects[arm]

    if mode != 'OBJECT':
        bpy.ops.object.mode_set(mode='OBJECT')
    bpy.ops.object.select_all(action='DESELECT')
    bpy.data.objects[arm].select_set(True)
    bpy.ops.object.mode_set(mode='POSE')
    bpy.ops.pose.select_all(action = 'DESELECT')

    for bone in cc_pose:
        
        if bone not in bpy.data.objects[arm].data.bones:
            continue
        
        old_rotation_mode = bpy.data.objects[arm].pose.bones[bone].rotation_mode
        bpy.data.objects[arm].pose.bones[bone].rotation_mode = 'QUATERNION'
        bpy.data.objects[arm].pose.bones[bone].matrix_basis = mathutils.Matrix(cc_pose[bone])
        bpy.data.objects[arm].pose.bones[bone].rotation_mode = old_rotation_mode
        
    bpy.ops.object.mode_set(mode='OBJECT')

    bpy.context.view_layer.update()

    children = list()
    children = bpy.data.objects[arm].children
    
    qualified_mesh = []
    for meshObj in children:
        if meshObj.type != 'MESH':
            continue
        qualified_mesh.append(meshObj)

    if len(qualified_mesh) == 0:
        txt = "There are no meshes associated with the armature."
        print(txt)
        return

    selected = {}
    for meshObj in children:
        for mod in meshObj.modifiers:
            if mod.type == 'ARMATURE':
                
                if meshObj.name in selected:
                    txt = "One of your selected mesh objects has more than one armature modifier: " + meshObj.name
                    print(txt)
                    popup(txt, "Error", "ERROR")
                    return {'FINISHED'}
                else:
                    
                    selected[meshObj.name] = meshObj.modifiers[mod.name]

        if 1 == 0:
            for mesh in selected:
                print("rebinding mesh", mesh)

                bpy.data.objects[mesh].select_set(True)
                bpy.context.view_layer.objects.active = bpy.data.objects[mesh]

                if bpy.data.objects[mesh].data.shape_keys:
                    
                    bpy.ops.object.shape_key_add(from_mix=False)
                    for k in bpy.data.objects[mesh].data.shape_keys.key_blocks:
                        bpy.data.objects[mesh].shape_key_remove(k)

                mod = selected[mesh] 
                my_mod = bpy.ops.object.modifier_copy(modifier=mod.name)

                try:
                    
                    bpy.ops.object.modifier_apply(apply_as='DATA', modifier=mod.name)
                except:
                    
                    try:
                        bpy.ops.object.modifier_apply(modifier=mod.name)
                        
                    except:
                        print("Internal Error 501 - Blender 2.9 alternative didn't work, this should not happen")
                        popup("Internal Error 501, contact support with the contents of the console window", "Fatal Error", "ERROR")

                bpy.ops.object.select_all(action='DESELECT')

    print("new rest pose disabled in pose code.. good!")
    if 1 == 0:
        bpy.ops.object.select_all(action='DESELECT')
        bpy.data.objects[arm].select_set(True)
        bpy.context.view_layer.objects.active = bpy.data.objects[arm]
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')

    bpy.ops.object.select_all(action='DESELECT')
    for obj in selected_objects:
        obj.select_set(True)

    return

def rebind(arm):

    selected_objects = bpy.context.selected_objects

    mode = bpy.context.mode

    activate(arm)

    if mode != 'OBJECT':
        bpy.ops.object.mode_set(mode='OBJECT')
    bpy.ops.object.select_all(action='DESELECT')
    bpy.data.objects[arm].select_set(True)
    bpy.ops.object.mode_set(mode='POSE')
    bpy.ops.pose.select_all(action = 'DESELECT')

    bpy.ops.object.mode_set(mode='OBJECT')

    children = list()
    children = bpy.data.objects[arm].children

    qualified_mesh = []
    for meshObj in children:
        if meshObj.type != 'MESH':
            continue
        qualified_mesh.append(meshObj)

    if len(qualified_mesh) == 0:
        txt = "There are no meshes associated with the armature when calling rebind."
        print(txt)
        popup("There are no meshes associated with the armature at this time", "Info", "INFO")
        return

    selected = {}
    for meshObj in children:
        for mod in meshObj.modifiers:
            if mod.type == 'ARMATURE':
                
                if meshObj.name in selected:
                    txt = "One of your selected mesh objects has more than one armature modifier: " + meshObj.name
                    print(txt)
                    popup(txt, "Error", "ERROR")
                    return {'FINISHED'}
                else:

                    selected[meshObj.name] = meshObj.modifiers[mod.name].name
                    
        for mesh in selected:
            utils.make_single(mesh)

        for mesh in selected:

            if bb_settings['debug'] == True:
                print("rebinding mesh rebind", mesh)

            bpy.data.objects[mesh].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects[mesh]

            if bpy.data.objects[mesh].data.shape_keys:
                
                bpy.ops.object.shape_key_add(from_mix=False)
                for k in bpy.data.objects[mesh].data.shape_keys.key_blocks:
                    bpy.data.objects[mesh].shape_key_remove(k)

            mod = selected[mesh] 

            my_mod = bpy.ops.object.modifier_copy(modifier=mod)

            try:
                print("Attempting to apply modifiers...")
                bpy.ops.object.modifier_apply(apply_as='DATA', modifier=mod)
            except:
                print("failed, attempting alternative for Blender 2.9")
                try:
                    bpy.ops.object.modifier_apply(modifier=mod)
                    print("Success for Blender 2.9")
                except:
                    if bpy.data.objects[mesh].select_get() == False:
                        print("init::An important object could not be selected:", mesh)
                    print("init::Internal Error 502 - Blender 2.9 alternative didn't work, this should not happen, is the object selectable?")
                    popup("init::Internal Error 502, see system console, object not selectable?", "Fatal Error", "ERROR")

    bpy.ops.object.select_all(action='DESELECT')
    bpy.data.objects[arm].select_set(True)
    bpy.context.view_layer.objects.active = bpy.data.objects[arm]

    bpy.ops.object.mode_set(mode='POSE')
    bpy.ops.pose.armature_apply()

    return

class OnigiriSlidersProperties(bpy.types.PropertyGroup):

    def update_sliders_blank(self, context):
        self["sliders_blank"] =  False
    sliders_blank : bpy.props.BoolProperty(
        default = False,
        update = update_sliders_blank
        )

    def sliders_menu_enabled(self,context):
        if self.sliders_menu_enabled == True:
            print("Body Shop - enabled")
        else:
            print("Body Shop - disabled")
            sliders.restore_rig()
    sliders_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "NOTE: For efficiency sake, disable this menu item when not in use!"            "\n\n"            "WARNING: Only use this with rigs and associated content that has not been scaled, i.e. your own custom content only. "            "There is no other reason to use this tool except for your content that is not transformed.  If you do not honor this "            "warning you may very well damage your product."            "\n\n"            "This is a slider system for use with correcting weight problems but you can also use it as a character "            "shaper if you're careful.  If you're freezing the mesh your bone properties will be returned to their "            "natural state, the sliders neutralized, and you can start a new round of shaping.  Note that it's always "            "best to do your major work on the mesh itself and only use this for tweaking and/or deformation testing",
        default = False,
        update=sliders_menu_enabled
        )

    def update_scale(self, context):
        if self.sliders_scale == True:
            self["sliders_location"] = False
    def update_location(self, context):
        if self.sliders_location == True:
           self["sliders_scale"] = False
    sliders_location : bpy.props.BoolProperty(
        name = "",
        description =            "Enable the position sliders for view and manipulation",
        default = False,
        update=update_location
        )
    sliders_scale : bpy.props.BoolProperty(
        name = "",
        description =            "Enable the sizing sliders for view and manipulation",
        default = True,
        update=update_scale
        )
    sliders_show_all : bpy.props.BoolProperty(
        name = "",
        description =            "Enable the view of all bones in the selected rig.  This can be a lot of clutter.  The default is to show only selected pose bones",
        default = False,
        )
    
    def sliders_set_rig(context):
        sliders.set_rig()
        return 1
    sliders_set_rig : bpy.props.IntProperty(
        name = "",
        description =            "- internal setter for sliders.set_rig()",
        default = 0,
        get=sliders_set_rig
        )
    def sliders_restore_rig(context):
        sliders.restore_rig()
        return 1
    sliders_restore_rig : bpy.props.IntProperty(
        name = "",
        description =            "- internal getter for sliders.restore_rig()",
        default = 0,
        get=sliders_restore_rig
        )

    def sliders_rig_display_stick(self, context):
            armObj = utils.rig_is_selected()
            if armObj != False:
                if self.sliders_rig_display_stick == True:
                    if armObj.get('bb_sliders_display_type') == None:
                        armObj['bb_sliders_display_type'] = armObj.data.display_type
                    armObj.data.display_type = 'STICK'

                else:
                    display_type = armObj.get('bb_sliders_display_type', armObj.data.display_type)
                    armObj.data.display_type = display_type

    sliders_rig_display_stick : bpy.props.BoolProperty(
        name = "",
        description =            "Enable the view of all bones in the selected rig.  This can be a lot of clutter.  The default is to show only selected pose bones",
        default = False,
        update=sliders_rig_display_stick
        )

class OnigiriSlidersShowAllBones(bpy.types.Operator):
    """Show all bones in the selected rig"""

    bl_idname = "onigiri.sliders_show_all_bones"
    bl_label = "Show All Bones"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_misc = bpy.context.window_manager.bb_misc
        bb_misc.enable_base_bones = True
        bb_misc.enable_face_bones = True
        bb_misc.enable_wing_bones = True
        bb_misc.enable_spine_bones = True
        bb_misc.enable_hand_bones = True
        bb_misc.enable_tail_bones = True
        bb_misc.enable_volume_bones = True
        bb_misc.enable_attach_bones = True
        bb_misc.enable_attach2_bones = True

        return {'FINISHED'}

class OnigiriSlidersResetSelected(bpy.types.Operator):
    """Reset all of the sliders for the selected pose bone for this transform.  To
reset all of your sliders on the selected pose bones select one of Position or Scale
and click this, then select the other and click this again"""

    bl_idname = "onigiri.sliders_reset_selected"
    bl_label = "Reset Selected"

    @classmethod
    def poll(cls, context):
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        return True

    def execute(self, context):
        bb_sliders = bpy.context.scene.bb_sliders

        for boneObj in bpy.context.selected_pose_bones:
            
            sliders.reset(boneObj)

        return {'FINISHED'}

class OnigiriSlidersResetAll(bpy.types.Operator):
    """Reset all of the sliders associated with this rig for this transform.  To
reset all of your sliders select one of Position or Scale and click this, then
select the other and click this again"""

    bl_idname = "onigiri.sliders_reset_all"
    bl_label = "Reset All"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        selected = bpy.context.selected_objects
        rigs = 0
        for o in selected:
            if o.type == 'ARMATURE':
                rigs += 1
        if rigs != 1:
            return False
        return True

    def execute(self, context):
        bb_sliders = bpy.context.scene.bb_sliders
        armObj = bpy.context.selected_objects[0]

        for boneObj in armObj.pose.bones:
            
            sliders.reset(boneObj)

        return {'FINISHED'}

class OnigiriSlidersStore(bpy.types.Operator):
    """Store (save) your mesh shape and rig configuration  for recovery using
(Restore) in case something goes wrong"""

    bl_idname = "onigiri.sliders_store"
    bl_label = "Restore Mesh Shape"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) > 0:
            return True
        return False

    def execute(self, context):

        selected = bpy.context.selected_objects

        rigs = []
        for o in selected:
            if o.type != 'MESH':
                continue
            o['bb_sliders_mesh'] = o.data.copy()
            o['bb_sliders_matrix_world'] = o.matrix_world.copy()

        for armObj in rigs:
            mesh = rigutils.get_associated_mesh
            if mesh == False:
                continue
            for o in mesh:
                o['bb_sliders_mesh'] = o.data.copy()
                o['bb_sliders_matrix_world'] = o.matrix_world.copy()

        for o in selected:
            if o.type == 'ARMATURE':
                for boneObj in o.data.bones:
                    boneObj['bb_sliders_matrix_local'] = boneObj.matrix_local.copy()
                    boneObj['bb_sliders_head_local'] = boneObj.head_local.copy()
                    boneObj['bb_sliders_tail_local'] = boneObj.tail_local.copy()

        return {'FINISHED'}

class OnigiriSlidersRestore(bpy.types.Operator):
    """Restore your mesh and rig to the last stored (saved) state"""

    bl_idname = "onigiri.sliders_restore"
    bl_label = "Restore Avatar"

    @classmethod
    def poll(cls, context):
        
        if bpy.context.mode == 'EDIT_MESH':
            return False
        if len(bpy.context.selected_objects) > 0:
            return True
        return False

    def execute(self, context):
        bb_slider = bpy.context.scene.bb_sliders
        selected = bpy.context.selected_objects
        state = utils.get_state()

        rigs = []
        for o in selected:
            if o.type == 'ARMATURE':
                rigs.append(o)
                continue
            if o.type != 'MESH':
                continue
            if o.get('bb_sliders_mesh'):
                print("Restoring selected mesh", o.name)
                meshData = o['bb_sliders_mesh']
                o.data = meshData
            if o.get('bb_sliders_matrix_world'):
                matrix = o['bb_sliders_matrix_world']
                o.matrix_world = mathutils.Matrix(matrix)

        for armObj in rigs:
            mesh = rigutils.get_associated_mesh(armObj)
            if mesh == False:
                continue

            for meshObj in mesh:
                if meshObj.get('bb_sliders_mesh'):
                    meshData = meshObj['bb_sliders_mesh']
                    print("restoring associated mesh", meshObj.name)
                    meshObj.data = meshData

                if meshObj.get('bb_sliders_matrix'):
                    matrix = meshObj['bb_sliders_matrix_world']
                    meshObj.matrix_world = mathutils.Matrix(matrix)

        for armObj in rigs:
            armObj.select_set(True)
            utils.activate(armObj)
            bpy.ops.object.mode_set(mode='EDIT')
            for boneObj in armObj.data.edit_bones:
                
                if boneObj.get('bb_sliders_matrix_local') == None:
                    print("Nothing stored, skipping (Restore)")
                    break
                matrix = mathutils.Matrix(boneObj['bb_sliders_matrix_local'])
                if matrix:
                    boneObj.matrix = mathutils.Matrix(matrix)
                head_local = boneObj['bb_sliders_head_local']
                if head_local:
                    boneObj.head = head_local
                tail_local = boneObj['bb_sliders_tail_local']
                if head_local:
                    boneObj.tail = tail_local
                if matrix:
                    roll = utils.get_bone_roll(matrix)
                    boneObj.roll = roll

                if 1 == 0:
                    matrix = mathutils.Matrix( boneObj.get('bb_sliders_matrix') )
                    if matrix:
                        boneObj.matrix = mathutils.Matrix(matrix)
                    head = boneObj.get('bb_sliders_head')
                    if head:
                        boneObj.head = head
                    tail = boneObj.get('bb_sliders_tail')
                    if tail:
                        boneObj.tail = tail
                    roll = boneObj.get('bb_sliders_roll')
                    if roll:
                        roll = boneObj.get('bb_sliders_roll')

            bpy.ops.object.mode_set(mode='OBJECT')
            armObj.select_set(False)

        utils.update()

        if 1 == 0:
            for armObj in rigs:
                armObj.select_set(True)
                utils.activate(armObj)
                for boneObj in armObj.pose.bones:
                    boneObj.matrix = mathutils.Matrix()
                utils.update()

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriSlidersApply(bpy.types.Operator):
    """Bake the shape into the mesh.  This will freeze the shape of the mesh and
# then reset the sliders for another go.  It will also store the mesh data before
freezing so that you can restore it, if there's no mesh data already"""

    bl_idname = "onigiri.sliders_apply"
    bl_label = "Apply Shape"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        rigs = 0
        for o in selected:
            if o.type == 'ARMATURE':
                rigs += 1
        if rigs != 1:
            return False
        return True

    def execute(self, context):
        bb_slider = bpy.context.scene.bb_sliders
        armObj = bpy.context.selected_objects[0]

        mesh = rigutils.get_associated_mesh(armObj)
        if len(mesh) == 0:
            print("no mesh associated with the armature")
            popup("There's no mesh to freeze", "Info", "INFO")
            return {'FINISHED'}

        for o in mesh:
            if o.get('bb_sliders_mesh') == None:
                o['bb_sliders_mesh'] = o.data.copy()
            if o.get('bb_sliders_matrix_world') == None:
                o['bb_sliders_matrix_world'] = o.matrix_world.copy()

        if 1 == 0:
            for boneObj in armObj.data.edit_bones:
                boneObj['bb_sliders_matrix'] = boneObj.matrix.copy()
                boneObj['bb_sliders_head'] = boneObj.head.copy()
                boneObj['bb_sliders_tail'] = boneObj.tail.copy()
                boneObj['bb_sliders_roll'] = boneObj.roll

        for boneObj in armObj.data.bones:
            boneObj['bb_sliders_matrix_local'] = boneObj.matrix_local.copy()
            boneObj['bb_sliders_head_local'] = boneObj.head_local.copy()
            boneObj['bb_sliders_tail_local'] = boneObj.tail_local.copy()

        rigutils.rebind(armObj, keep_animation=True)

        return {'FINISHED'}

class OnigiriSlidersClean(bpy.types.Operator):
    """During the slider process a copy of your mesh data is preserved and also stored
when you ask.  This can result in a large amount of unused data in your scene so it is
advised to clean this when you're done, by using this button"""

    bl_idname = "onigiri.sliders_clean"
    bl_label = "Select everything and click"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) > 0:
            return True
        return False

    def execute(self, context):
        bb_sliders = bpy.context.scene.bb_sliders
        for o in bpy.context.selected_objects:
            o.pop('bb_sliders_mesh', "")
            o.pop('bb_sliders_matrix_world', "")

        if o.type == 'ARMATURE':
            o.data.display_type = o.pop('bb_sliders_display_type', o.data.display_type)
        bb_sliders.property_unset("sliders_rig_display_stick")

        print("Cleaned")

        return {'FINISHED'}

class OnigiriSlidersMatch(bpy.types.Operator):
    """Match the adjustments you made to the other side of the rig.  If this is a
Onigiri rig the it will work, otherwise this feature is most likely disabled"""

    bl_idname = "onigiri.sliders_match"
    bl_label = "Match"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        rigs = 0
        for o in selected:
            if o.type == 'ARMATURE':
                rigs += 1
        if rigs != 1:
            return False

        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        
        if o.get('onigiri') == None:
            return False
        return True

class OnigiriSlidersAddSelected(bpy.types.Operator):
    """Add selected pose bones to the slider system
"""
    bl_idname = "onigiri.sliders_add_selected"
    bl_label = "Add Selected"

    @classmethod
    def poll(cls, context):
        
        selected = bpy.context.selected_objects
        rigs = 0
        for o in selected:
            if o.type == 'ARMATURE':
                rigs += 1
        if rigs != 1:
            return False

        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        return True

    def execute(self, context):
        def mookie(self, context):
            print("mookie doo")

        bb_sliders = bpy.context.scene.bb_sliders
        armObj = bpy.context.selected_objects[0]

        pose_bones = bpy.context.selected_pose_bones

        for boneObj in pose_bones:
            print("adding props to bone:", boneObj.name)

            boneObj['bb_sliders_enabled'] = True

        return {'FINISHED'}

        for boneObj in pose_bones:

            if boneObj.get('_RNA_UI'):
                if "bb_sliders_" in boneObj['_RNA_UI']:
                    continue

            if 1 == 0:
                boneObj['bb_sliders_scale'] = {
                    "name": "Scale:",
                    "description": "adjust bone scale",
                    "min": 0.0,
                    "max": 2.0,
                    "soft_min":0.0,
                    "soft_max":1.0,
                    }
            else:
                boneObj['bb_sliders_scale'] = 0.5

            boneObj["_RNA_UI"] = {}
            boneObj["_RNA_UI"]['bb_sliders_scale'] = {
                "name": "Scale:",
                "description": "adjust bone scale",
                "min": 0.0,
                "max": 2.0,
                "soft_min":0.0,
                "soft_max":1.0,
                "update": sliders.scale_update,
                }
            
        return {'FINISHED'}

class OnigiriRigsUseConnect(bpy.types.Operator):
    """This unlocks bones so that you can move them, it also locks them back up
to how they were before you unlocked them.  This cannot fix a damaged rig that
has floating bones.  This works for SL rigs only"""

    bl_idname = "onigiri.rigs_use_connect"
    bl_label = "Convert Character"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        o = selected[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        armObj = bpy.context.active_object
        state = utils.get_state()
        armObj.select_set(True)
        utils.activate(armObj)
        bpy.ops.object.mode_set(mode='EDIT')

        armObj['bb_bones_locked'] = None

        if self.action == "lock":
            for boneObj in armObj.data.edit_bones:
                bone = boneObj.name
                if bone not in skel.avatar_skeleton:
                    continue
                boneObj.use_connect = skel.avatar_skeleton[bone]['connected']
            armObj['bb_bones_locked'] = True

        elif self.action == "unlock":
            
            for boneObj in armObj.data.edit_bones:
                boneObj.use_connect = False
            armObj['bb_bones_locked'] = False

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriCharacterConverterProperties(bpy.types.PropertyGroup):

    def update_blank(self, context):
        self["blank"] =  False
    blank : bpy.props.BoolProperty(
        default = False,
        update = update_blank
        )
    
    def update_import_pose(self, context):
        if self.import_pose == True:
            self["keep_pose"] =  False
        else:
            self["keep_pose"] =  True
    def update_keep_pose(self, context):
        if self.keep_pose == True:
            self["import_pose"] =  False
        else:
            self["import_pose"] =  True
    import_pose : bpy.props.BoolProperty(
        name = "",
        description =            "A humanoid converted character should have a somewhat compatible pose that will work with some degree of success with in-world "            "animations.  For this to happen you must pose your character manually, or using the pose library, an animation or even one from "            "the map file.  This option, if enabled, will use the existing pose that was previously saved in the map file.",
        default = False,
        update = update_import_pose
        )
    keep_pose : bpy.props.BoolProperty(
        name = "",
        description =            "A humanoid converted character should have a somewhat compatible pose that will work with some degree of success with in-world "            "animations.  For this to happen you must pose your character manually, or using the pose library, an animation or even one from "            "the map file.  This option, if enabled, will use the pose that your character is currently in.",
        default = True,
        update = update_keep_pose
        )
    copy : bpy.props.BoolProperty(
        name = "",
        description =            "You have the option to make a copy of the items that will be converted instead of working directly on your content.",
        default = False,
        )
    anchor_unmapped : bpy.props.BoolProperty(
        name = "",
        description =            "Reskin unmapped bones that lead to an anchor that you already have mapped.  An anchor is a bone that is mapped from one "            "rig to another.  A reskin bone is a bone that is mapped to an anchor on the same rig because it will not be used.  The "            "reskin bone has its vertex groups merged with the anchor.  If you have loose bones that have no map but the chain in the "            "hierarchy leads them to an anchor then enabling this is effectively saying to (reskin) those to that anchor.  If an anchor "            "is not found in that loose chain then you have a map error and need to correct it.",
        default = True,
        )
    remove_unused : bpy.props.BoolProperty(
        name = "",
        description =            "Remove unused and unmappable bones"            "\n\n"            "If there are bones left over, after conversion, this option is for you.  When enabled it will simply remove them and the "            "associated vertex groups.  This is probably never what you want but if you know that there are items on the mesh that don't "            "need these joints then it shouldn't cause a problem.",
        default = True
        )
    remove_unknown : bpy.props.BoolProperty(
        name = "",
        description =            "Remove unknown vertex groups"            "\n\n"            "If there are unknown vertex groups left over after conversion they will be removed.  This could be the cause of a more serious "            "problem so keep an eye on the errors if you are using this.",
        default = True
        )
    apply_transforms : bpy.props.BoolProperty(
        name = "",
        description =            "This applies all transforms to the objects associated with the conversion before the conversion takes place.  This is "            "usually a good thing to do but I worry that it will break some content so it's here as an option.",
        default = True,
        )

class OnigiriCharacterConverterLoadMap(bpy.types.Operator, ImportHelper):
    """Load a conversion map.  Many known conversions are already available but you can
build a custom one, or adjust an existing one, using the Snap Mapper, Hybrid Mapper,
Manual Mapper or animation retargeter"""

    bl_idname = "onigiri.character_converter_load_map"
    bl_label = "Load Map"

    filename_ext = ".bbm"
    filter_glob : bpy.props.StringProperty(
        default='*.ccm;*bbm',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        return True

    def execute(self, context):
        
        bb_onemap = bpy.context.scene.bb_onemap

        arm = utils.has_armature(report=True)
        if arm == False:
            print("Map: No qualified armature was found, do you have multiple rigs targeted?")
            popup("The selection is invalid, see console", "Error", "ERROR")
            return {'FINISHED'}
        
        mesh = rigutils.get_mesh(arm)
        if mesh == False:
            print("Map returns from rigutils.get_mesh: No qualified mesh was found, this may be a bug?")
            popup("There were no qualified mesh in the selection, see console", "Error", "ERROR")
            return {'FINISHED'}

        armObj = arm

        file_path = self.properties.filepath
        path, name = os.path.split(self.properties.filepath)
        file_prefix = name.split(".")[0]
        ext = name.split(".")[-1]

        try:
            namespace = {}
            exec(open(file_path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        template = {}
        for container in namespace:
            
            if container.startswith("__"):
                continue
            template[container] = namespace[container]

        template_map = template.get('template_map', {})
        rename_map = template.get('rename', {})
        reskin_map = template.get('reskin', {})
        pose_map = template.get('pose', {})
        code_map = template.get('code', {}) 

        if len(rename_map) == 0:
            print("There's no proper map available in the map file for this process")
            popup("This map file is not compatible with the process", "Error", "ERROR")
            return {'FINISHED'}

        rename = {}
        bad_bones = []
        for bone in rename_map:
            if bone in armObj.data.bones:
                rename[bone] = rename_map[bone]
            else:
                bad_bones.append(bone)
        if len(rename) == 0:
            print("None of the bone maps in your map file matched the rig.  The following is a list of bones in the file...")
            print(bad_bones)
            popup("No matching bones.", "Error", "ERROR")
            return {'FINISHED'}

        print("Processing the following anchors:", rename)
        
        reskin = {}
        if len(reskin_map) == 0:
            print("No reskin bones")
        else:
            for anchor in reskin_map:
                bones = reskin_map[anchor]
                for rbone in bones:
                    if rbone in armObj.data.bones:
                        if anchor not in reskin:
                            reskin[anchor] = {}
                        
                        reskin[anchor][rbone] = ""

        if len(reskin) == 0:
            print("There's a reskin map but no usable bones")
        else:
            print("Processing reskin bones:", reskin)

        pose = {}
        bad_pose = []
        for bone in pose_map:
            if bone in armObj.data.bones:
                pose[bone] = pose_map[bone]
            else:
                bad_pose.append(bone)
        if len(bad_pose) > 0:
            print("Pose map contains bones that don't match your rig:", bad_pose)
        if len(pose) == 0:
            print("No pose map was usable")

        if len(code_map) == 0:
            print("No code map")

        armObj['bb_onemap_rename'] = rename
        armObj['bb_onemap_reskin'] = reskin
        armObj['bb_onemap_pose'] = pose
        armObj['bb_onemap_code'] = code_map

        return {'FINISHED'}

class OnigiriCharacterConverter(bpy.types.Operator):
    """Convert this character using a map to convert bone names and re-weight mesh
to bones that have been reskinned.  If there is a map on the rig already you
can use that instead, just don't load one"""

    bl_idname = "onigiri.character_converter"
    bl_label = "Convert Character"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        return True

    def execute(self, context):
        bb_cc = bpy.context.window_manager.bb_cc

        armObj = utils.has_armature()
        if armObj == False:
            print("Convert: No qualified armature was found, do you have multiple rigs targeted?")
            popup("The selection is invalid, see console", "Error", "ERROR")
            return {'FINISHED'}

        matrix_basis = {}
        for boneObj in armObj.pose.bones:
            mat = boneObj.matrix.copy()
            matb = animutils.get_matrix_basis(armature=armObj, bone=boneObj)
            matrix_basis[boneObj.name] = matb
        
        for boneObj in armObj.pose.bones:
            for C in boneObj.constraints:
                boneObj.constraints.remove(C)
        
        utils.update()
        for bone in matrix_basis:
            if bone not in armObj.data.bones:
                continue
            armObj.pose.bones[bone].matrix_basis = matrix_basis[bone]
        utils.update()

        mesh = rigutils.get_associated_mesh(armObj, report=True)
        if mesh == False:
            print("Convert returns from rigutils.get_associated_mesh: No qualified mesh was found, this may be a bug?")
            popup("There were no qualified mesh in the selection, see console", "Error", "ERROR")
            return {'FINISHED'}

        for o in mesh:
            for g in o.vertex_groups:
                g.lock_weight = False

        if armObj.get('onigiri_converted') != None:
            txt = "Armature converted already: " + "[" + armObj.name + "]"
            popup(txt, "Error", "ERROR")
            return {'FINISHED'}

        state = utils.get_state()

        if armObj.get('bb_onemap_rename') == None:
            print("No map on the rig")
            popup("No map available", "Error", "ERROR")
            utils.set_state(state)
            return {'FINISHED'}

        result = rigutils.check_maps(armature=armObj, report=False)
        if result == False:
            print("The map contained on the rig is not compatible")
            popup("Incompatible map, see console", "Error", "ERROR")
            utils.set_state(state)
            return {'FINISHED'}

        rename_map = armObj['bb_onemap_rename'].to_dict() 
        rename_original = armObj['bb_onemap_rename'].to_dict() 
        if armObj.get('bb_onemap_reskin') != None:
            reskin_map = armObj['bb_onemap_reskin'].to_dict()
            reskin_original = armObj['bb_onemap_reskin'].to_dict()  
        else:
            reskin_map = {}
            reskin_original = {}
        if armObj.get('bb_onemap_pose') != None:
            pose_map = armObj['bb_onemap_pose'].to_dict()
        else:
            pose_map = {}
        if armObj.get('bb_onemap_code') != None:
            code_map = armObj['bb_onemap_code'].to_dict()
        else:
            code_map = {}

        if bb_cc.copy == True:
            for o in mesh:
                o.select_set(True)
            armObj.select_set(True)
            utils.activate(armObj)
            bpy.ops.object.duplicate()
            mesh_objects = []
            for o in bpy.context.selected_objects:
                if o.type == 'MESH':
                    mesh_objects.append(o)
                elif o.type == 'ARMATURE':
                    armObj = o
                
                location_offset = 0.6
        else:
            mesh_objects = mesh
            
            location_offset = 0.0

        print("Making single user...")
        utils.make_single(armObj)
        new_objects = []
        for m in mesh_objects:
            
            try:
                utils.make_single(m)
                new_objects.append(m)
            except:
                print("Error, will be removed from list", m)
            
        mesh_objects = new_objects[:]

        armObj.animation_data_clear()

        if bb_cc.import_pose == True:
            if len(pose_map) == 0:
                print("apply imported pose was indicated but there isn't one")
            else:
                print("Applying imported pose...")
                rigutils.apply_map_pose(armature=armObj, pose=pose_map)

        temp_forward = {}
        temp_reverse = {}
        temp_rename = {}
        temp_reskin = {}
        
        anchors = set()
        for sbone in rename_map:
            anchors.add(rename_map[sbone])

        for boneObj in armObj.data.bones:
            bone = boneObj.name
            abone = bone
            while abone in armObj.data.bones or abone in anchors:
                tname = utils.get_temp_name()
                abone = bone + "_" + tname
            temp_forward[boneObj.name] = abone
            temp_reverse[abone] = boneObj.name

        for sbone in rename_map:
            if sbone not in temp_forward:
                continue
            temp_sbone = temp_forward[sbone] 
            tbone = rename_map[sbone] 
            temp_rename[temp_sbone] = rename_map[sbone]
        for abone in reskin_map:
            if abone not in temp_forward:
                continue
            temp_tbone = temp_forward[abone] 
            for rbone in reskin_map[abone]:
                if rbone not in temp_forward:
                    continue
                
                if temp_tbone not in temp_reskin:
                    temp_reskin[temp_tbone] = []
                temp_reskin[temp_tbone].append(temp_forward[rbone])

        rename_map = temp_rename
        reskin_map = temp_reskin

        for boneObj in armObj.data.bones:
            boneObj.name = temp_forward[boneObj.name]

        print("Rebinding...")
        rigutils.rebind(armObj)

        if bb_cc.apply_transforms == True:
            print("Applying transforms...")
            utils.apply_transforms(object=armObj, rotation=True, location=True, scale=True)
            for m in mesh_objects:
                utils.apply_transforms(object=m, rotation=True, location=True, scale=True)
        else:
            print("Apply transforms is disabled for testing, this may not be required")

        fixed_map = {}
        print("Checking if a reskin bone appears as an anchor, this would be a corrupt map")
        for anchor in reskin_map:
            for rbone in reskin_map[anchor]:
                if rbone in rename_map:
                    print("Found reskin bone in rename map, removing:", rbone)
                else:
                    if anchor not in fixed_map:
                        fixed_map[anchor] = list()
                    fixed_map[anchor].append(rbone)
        reskin_map = fixed_map

        end_bones = set()
        for boneObj in armObj.data.bones:
            if len(boneObj.children) == 0:
                end_bones.add(boneObj)

        floaters = {}

        print("Capturing floaters...")
        for boneObj in end_bones:
            bone_run = set()
            while True:
                bone = boneObj.name
                
                if bone in rename_map:
                    break
                bone_run.add(boneObj.name)
                if boneObj.parent:
                    boneObj = boneObj.parent
                else:
                    if len(bone_run) != 0:
                        if boneObj.name not in floaters:
                            floaters[boneObj.name] = set()
                        for rbone in bone_run:
                            floaters[boneObj.name].add(rbone)
                    break
        
        print("Capturing unmapped reskin bones...")
        more_skin = {} 
        for boneObj in end_bones:
            if boneObj.name in floaters:
                print("Floater hit, skipping...", boneObj.name)
                continue
            bone_run = set()
            while True:
                bone = boneObj.name

                if bone in rename_map:
                    if len(bone_run) != 0:
                        if bone not in more_skin:
                            more_skin[bone] = set()
                        for rbone in bone_run:
                            more_skin[bone].add(rbone)
                    if boneObj.parent:
                        boneObj = boneObj.parent
                        bone_run = set()
                        continue
                    break
                if boneObj.parent:
                    boneObj = boneObj.parent
                else:
                    
                    break
                bone_run.add(bone)

        if bb_cc.anchor_unmapped == True:
            print("Anchor unmapped enabled...")
            for anchor in more_skin:
                new_reskin = set(more_skin[anchor])
                if anchor not in reskin_map:
                    
                    reskin_map[anchor] = []
                old_reskin = set(reskin_map[anchor])
                for rbone in new_reskin:
                    if rbone not in old_reskin:
                        
                        reskin_map[anchor].append(rbone)

        if 1 == 0:
            for meshObj in mesh_objects:
                print("Processing weights for mesh", meshObj.name)
                for group in reskin_map:
                    print("Processing group:", group)
                    
                    qualified = []
                    rbones = reskin_map[group] 
                    for bone in rbones:
                        if bone in meshObj.vertex_groups:
                            qualified.append(bone)
                    
                    if len(qualified) == 0:
                        continue
                    for rbone in qualified:
                        print("merging", rbone, "to", group)

                        meshutils.merge_groups(group=rbone, target=group, mesh=meshObj, report=True)

        if 1 == 1:
            for meshObj in mesh_objects:
                
                print("Processing weights for mesh", meshObj.name)
                for target in reskin_map:

                    print("Processing group:", target)
                    qualified = []
                    rbones = reskin_map[target] 

                    for bone in rbones:
                        if bone in meshObj.vertex_groups:
                            qualified.append(bone)

                    if len(qualified) == 0:
                        print("No mappable vertex groups were present in", meshObj.name)
                        continue

                    if target not in meshObj.vertex_groups:
                        meshObj.vertex_groups.new(name=target)

                    qualified.append(target)
                    
                    meshutils.combine_groups(groups=qualified, target=target, mesh=meshObj)

        for o in bpy.context.selected_objects:
            o.select_set(False)

        print("removing bones ------------------------------------------")
        
        armObj.select_set(True)
        utils.activate(armObj)
        bpy.ops.object.mode_set(mode='EDIT')
        for anchor in reskin_map:
            for rbone in reskin_map[anchor]:
                if rbone in armObj.data.edit_bones:
                    boneObj = armObj.data.edit_bones[rbone]
                    armObj.data.edit_bones.remove(boneObj)

            print("removed bone:", rbone)
        print("removing bones ends --------------------------------------")

        bpy.ops.object.mode_set(mode='OBJECT')

        armObj['onigiri_converted'] = True
        presets = devkit.load_defaults(file="defaults", report=True)
        armObj['bb_devkit_preset'] = presets
        devkit.props['last_source'] = False

        bad_bones = []
        for boneObj in armObj.data.bones:
            if boneObj.name not in rename_map:
                bad_bones.append(boneObj.name)

        if len(bad_bones) > 0:
            if bb_cc.remove_unused == True:
                
                state = utils.get_state()
                armObj.select_set(True)
                utils.activate(armObj)
                bpy.ops.object.mode_set(mode='EDIT')
                for bone in bad_bones:
                    boneObj = armObj.data.edit_bones[bone]
                    armObj.data.edit_bones.remove(boneObj)
                bpy.ops.object.mode_set(mode='OBJECT')
                
                for meshObj in mesh_objects:
                    for g in bad_bones:
                        if g in meshObj.vertex_groups:
                            groupObj = meshObj.vertex_groups[g]
                            meshObj.vertex_groups.remove(groupObj)
                utils.set_state(state)
                print("Some bones were not mapped and not mappable automatically.  You have (Remove Unused) enabled")
                print("so these bones were removed from the rig and mesh.  This happens when there are bones present")
                print("in the rig that are not also present in the map, which is an incomplete map but may work anyway.")
                print("The bones affected are listed below...")
            else:
                print("There's a problem with your rig, some bones were unable to be mapped, they are listed below but")
                print("the item may still work in your target platform but if that platform is Second Life or Sansar")
                print("then this is unlikely.  To improve this condition use the feature (Remove Unused), this may be")
                print("enough to fix your rig without having to map anymore bones.")
                popup("Some bones were not processed, see System Console", "Info", "INFO")
            if len(bad_bones) > 0:
                for bone in bad_bones:
                    print(" *", bone)

        bad_groups = []
        for meshObj in mesh_objects:
            for g in meshObj.vertex_groups:
                gname = g.name
                if gname not in rename_map:
                    bad_groups.append(gname)

            if bb_cc.remove_unknown == True:
                for gname in bad_groups:
                    
                    if gname in meshObj.vertex_groups:
                        groupObj = meshObj.vertex_groups[gname]
                        meshObj.vertex_groups.remove(groupObj)
                    else:
                        print("A bad group marked for removal vanished during the process, this ain't gunna be easy!")
                        print("Object:", meshObj.name)
                        print("Bad Group:", gname)

        if len(bad_groups) > 0:
            print("Some vertex groups were left over that were unidentified...")
            for g in bad_groups:
                print(" *", g)
            if bb_cc.remove_unknown == False:
                print("You have (Remove Unknown) disabled.  You may wish to enable this to improve your condition")
            else:
                print("You have (Remove Unknown) enabled so these groups were removed.")
            if bb_cc.remove_unused == False:
                print("You may also wish to use this in combination with (Remove Unused).")

        for boneObj in armObj.data.bones:
            sbone = boneObj.name
            tbone = rename_map[sbone]
            print("Renaming", sbone, "to", tbone)
            boneObj.name = rename_map[sbone]

        for o in bpy.context.selected_objects:
            o.select_set(False)
        for meshObj in mesh_objects:
            meshObj.select_set(True)
        utils.activate(meshObj)

        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.object.mode_set(mode='OBJECT')

        armObj.select_set(True)

        return {'FINISHED'}

class OnigiriCharacterConverterPanel(bpy.types.Panel):
    """The simplified Character Converter panel for the new code"""
    bl_idname = "OBJECT_PT_converter"
    bl_label = "Character Converter"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):

        bb_cc = bpy.context.window_manager.bb_cc

        layout = self.layout
        box = layout.box()
        col = box.column(align = True)

        row = col.row(align=True)
        row.operator(
            "onigiri.character_converter_load_map",
            text="Load Map",
            icon_value = ico.custom_icons["load"].icon_id
            )
        row.operator(
            "onigiri.character_converter_reset",
            text="Remove Map",
            icon_value = ico.custom_icons["reset"].icon_id
            )
        row = col.row(align=True)
        bb_onemap_rename_text = " "
        bb_onemap_rename_icon = "blank"
        selected = bpy.context.selected_objects
        arms = []
        for o in selected:
            if o.type == 'ARMATURE':
                arms.append(o)
        if len(arms) == 1:
            if arms[0].get('bb_onemap_rename') != None:
                bb_onemap_rename_text = "Armature contains a map!"
                bb_onemap_rename_icon = "bone_black_red"
        row.prop(
            bb_cc,
            "blank",
            text=bb_onemap_rename_text,
            toggle = True,
            icon_value = ico.custom_icons[bb_onemap_rename_icon].icon_id
            )
        col = box.column(align = True)
        row = col.row(align=True)
        row.prop(
            bb_cc,
            "copy",
            toggle = True,
            text="Make Copy",
            icon_value = ico.custom_icons["copy"].icon_id
            )
        row = col.row(align=True)
        row.prop(
            bb_cc,
            "import_pose",
            toggle = True,
            text="Import Pose",
            icon_value = ico.custom_icons["blank"].icon_id
            )
        row.prop(
            bb_cc,
            "keep_pose",
            toggle = True,
            text="Keep Pose",
            icon_value = ico.custom_icons["blank"].icon_id
            )
        row = col.row(align=True)
        row.prop(
            bb_cc,
            "apply_transforms",
            toggle = True,
            text="Apply Transforms",
            icon_value = ico.custom_icons["blank"].icon_id
            )
        row.prop(
            bb_cc,
            "anchor_unmapped",
            toggle = True,
            text="Anchor Unmapped",
            icon_value = ico.custom_icons["blank"].icon_id
            )
        row = col.row(align=True)
        row.prop(
            bb_cc,
            "remove_unused",
            toggle = True,
            text="Remove Unused",
            icon_value = ico.custom_icons["blank"].icon_id
            )
        row.prop(
            bb_cc,
            "remove_unknown",
            toggle = True,
            text="Remove Unknown",
            icon_value = ico.custom_icons["blank"].icon_id
            )
        col = box.column(align = True)
        row = col.row(align=True)
        row.operator(
            "onigiri.character_converter",
            text="Convert",
            icon_value = ico.custom_icons["character_converter"].icon_id
            )

        layout = self.layout
        box = layout.box()
        col = box.column(align = True)
        row = col.row(align=True)
        row.label(
            text = "Converted Mesh Export: ",
            )
        row = col.row(align=True)
        row.prop(
            context.scene.bb_mesh,
            "process_volume_bones",
            toggle = True,
            text="Process Volume Bones",
            icon_value = ico.custom_icons["volume_bones"].icon_id
            )
        row = col.row(align=True)
        row.prop(
            context.scene.bb_mesh,
            "rotate_for_sl",
            toggle = True,
            text="Rotate For SL",
            icon_value = ico.custom_icons["rotate"].icon_id
            )

        row = col.row(align=True)
        row.prop(
            context.scene.bb_mesh,
            "project_rig",
            toggle = True,
            text="Project full rig",
            icon_value = ico.custom_icons["project"].icon_id
            )

        row = col.row(align=True)
        row.operator(
            "onigiri.collada_export",
            text="Export Mesh for SL / Opensim",
            icon_value = ico.custom_icons["export_mesh"].icon_id
            )

class OnigiriRigsMatchEditToView(bpy.types.Operator):
    """Match the edit bone view to the pose/data bone view.  To show or hide edit
bones you need to toggle one of the switches above and then hit this button"""

    bl_idname = "onigiri.rigs_match_edit_to_view"
    bl_label = "Show / Hide Edit Bones"

    @classmethod
    def poll(cls, context):
        if bpy.context.mode != 'EDIT_ARMATURE':
            return False
        return True

    def execute(self, context):
        armObj = bpy.context.object
        for boneObj in armObj.data.edit_bones:
            bone = boneObj.name
            
            if bone in armObj.data.bones:
                boneObj.hide = armObj.data.bones[bone].hide

        return {'FINISHED'}

class OnigiriRigsViewBones(bpy.types.Operator):
    """Hide selected bones or show all bones in this rig.  Note that the rig layers
may also be hiding bones associated with that layer"""

    bl_idname = "onigiri.rigs_view_bones"
    bl_label = "Show / Hide bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if bpy.context.active_object == None:
            return False
        if bpy.context.active_object.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        return True

    def execute(self, context):
        if self.action == "hide":
            for boneObj in bpy.context.selected_pose_bones:
                boneObj.bone.hide = True
        elif self.action == "show":
            for boneObj in bpy.context.active_object.pose.bones:
                boneObj.bone.hide = False
        else:
            print("Unknown action in (rigs_view_bones)")
        return {'FINISHED'}

class OnigiriOnemapProperties(bpy.types.PropertyGroup):

    def update_onemap_blank(self, context):
        bpy.context.scene.bb_onemap.property_unset("onemap_blank")
    onemap_blank : bpy.props.BoolProperty(default=False, update=update_onemap_blank)

    onemap_message : bpy.props.StringProperty(
        name = "",
        description =            "--internal",
        default = "Choose rig to map and click Start",
        )
    
    onemap_template_name : bpy.props.StringProperty(
        name = "",
        description =            "--internal",
        default = "",
        )

    def update_onemap_platform_opensim(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        if bb_onemap.onemap_platform_opensim == True:
            bb_onemap['onemap_platform_other'] = False
        if bb_onemap.onemap_platform_opensim == False:
            bb_onemap['onemap_platform_other'] = True

    def update_onemap_platform_other(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        if bb_onemap.onemap_platform_other == True:
            bb_onemap['onemap_platform_opensim'] = False
        if bb_onemap.onemap_platform_other == False:
            bb_onemap['onemap_platform_opensim'] = True

    onemap_platform_opensim : bpy.props.BoolProperty(
        name = "",
        description =            "For Second Life and Opensim"            "\n\n"            "This is just a quick button.  When SL / OS is enabled a rig for that platform will be generated.",
        default=True,
        update = update_onemap_platform_opensim
        )
    onemap_platform_other : bpy.props.BoolProperty(
        name = "",
        description =            "For another platform"            "\n\n"            "When this is enabled then you'll have to provide an output/target rig for your mapping.",
        default=False,
        update = update_onemap_platform_other
        )

    def update_onemap_edit(self, context):
        print("reskin triggered to off")
    onemap_edit : bpy.props.BoolProperty(
        name = "",
        description =            "Edit Mode"            "\n\n"            "When a bone is maded it becomes frozen so that you can't mess up your work.  Enabling this mode allows you to select "            "mapped bones and unmap them or add reskin bones to them.",
        default=False,
        update = update_onemap_edit
        )

    onemap_offset : bpy.props.FloatProperty(
        name = "",
        description =            "Output rig offset from input rig"            "\n\n"            "This is a distance offset from the input rig in order to get a better visual between the two rigs, so that they "            "don't occupy the same space.  You can alway suspend the process while mapping and move the rigs yourself.  Note "            "that this is only useful when the mapper generates the rig for you.",
        default = 0.6
         )

    onemap_started : bpy.props.StringProperty(
        name = "",
        description = "--internal",
        default = ""
        )

    onemap_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Expand the character mapper"            "\n\n"            "This is a generic character mapper that allows for any target and source platforms.  There is a reskin feature here "            "as well, much like the auto-weight mapper, but much easier to use.  The reskin idea may be a bit difficult to understand "            "but it's actually quite simple... if you think one or more bones are not compatible with the target platform you can "            "have the mesh weights attach to its parent bone, or some other anchor up the chain, and then this bone will be marked for "            "removal but the mesh will still move with the anchor bone you chose.",
        default = False
        )

    onemap_load_pose : bpy.props.BoolProperty(
        name = "",
        description =            "Load the pose that's stored in the map and apply it, if it exists.  This pose can then be saved with the map for "            "later use.  If you want to save this pose back to the file, make sure to enable the (Save Pose) option to store "            "your existing pose back to the file.",
        default = True
        )
    onemap_save_pose : bpy.props.BoolProperty(
        name = "",
        description =            "Save the current pose with your map"            "\n\n"            "If you want a usable pose for conversion you have to make one.  A good way to store poses is using the Onigiri "            "pose library features that can be found in two different places in the (Animation) section under (Pose Library) and "            "(Motion Processing).",
        default = True
        )
    
    onemap_apply_pose : bpy.props.BoolProperty(
        name = "",
        description =            "Apply the stored pose to your rig.  Sometimes when mapping a rig you may want to move and rotate bones around to get "            "a better view and this change will travel with your file, if you switch on (Save Pose).  This button will restore "            "the pose to the one that was loaded, if it exists.",
        default = False
        )

    onemap_view_map : bpy.props.BoolProperty(
        name = "",
        description =            "View the bone map",
        default = False
        )
    
    def update_onemap_view_reskin(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        if bb_onemap.onemap_view_reskin == False:
            bb_onemap["onemap_view_reskin"] = True
            onemap.props['view_reskin_bones'] = ""

    onemap_view_reskin : bpy.props.BoolProperty(
        name = "",
        description =            "View reskin bones for this anchor",
        default = False,
        update = update_onemap_view_reskin
        )

    def update_onemap_reskin(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        if self.onemap_reskin == True:
            
            if bb_onemap.onemap_move == True:
                bb_onemap["onemap_reskin"] = False
                return
            
            if onemap.props['input_bone'] == "":
                bb_onemap["onemap_reskin"] = False
                return
            
            inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
            if onemap.props['input_bone'] not in inRig.get('bb_onemap_rename', []):
                print("no map")
                bb_onemap["onemap_reskin"] = False
                return
            
            print("Reskin toggled to True")
            onemap.props['reskin_bone'] = onemap.props['input_bone']
        
        if self.onemap_reskin == False:
            
            bpy.ops.onigiri.onemap_reskin()

    def update_onemap_move(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        if self.onemap_move == True:

            if bb_onemap.onemap_reskin == True:
                bb_onemap["onemap_move"] = False
                return

            if onemap.props['input_bone'] == "":
                bb_onemap["onemap_move"] = False
                return

            inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
            if onemap.props['input_bone'] not in inRig.get('bb_onemap_rename', {}):
                bb_onemap["onemap_move"] = False
                return

            print("Move toggled to True")
            in_bone = onemap.props['input_bone']
            onemap.props['move_bone'] = in_bone
            inRig.pose.bones[in_bone].bone_group = inRig.pose.bone_groups['Move']

        if self.onemap_move == False:
            bpy.ops.onigiri.onemap_move()

    onemap_reskin : bpy.props.BoolProperty(
        name = "",
        description =            "Reskin Mode"            "\n\n"            "If you enable this it will lock the bone and enable reskin mode.  After enabling it choose 1 or more bones for reskinning "            "and then disable the button.  Those bones will be anchored to the one you see and removed during the conversion process.",
        default=False,
        update = update_onemap_reskin
        )
    onemap_move : bpy.props.BoolProperty(
        name = "",
        description =            "Move Mode"            "\n\n"            "Instructions:"            "\n\n"            " * Choose an anchor bone then enable this."            "\n"            " * Choose another anchor bone then disable this, the reskin branch will move and/or merge."            "\n\n"            "This allows you to move a reskin branch so that you don't have to rebuild it in case you anchored them to the "            "wrong bone.  This will merge reskin bones branches if you choose an anchor that has reskin bones.  This only works "            "with anchors, if you need it to work on a bone that's not mapped you map the bone first then transfer.",
        default=False,
        update = update_onemap_move
        )
    
    def trigger_onemap_set_error(self):
        
        bb_onemap = bpy.context.scene.bb_onemap
        if bpy.context.mode != 'POSE':
            bb_onemap.onemap_message = "Requires pose mode"
            return False
        if len(bpy.context.selected_objects) != 2:
            bb_onemap.onemap_message = "Requires 2 rigs selected"
            return False
        for o in bpy.context.selected_objects:
            if o.type != 'ARMATURE':
                bb_onemap.onemap_message = "Both objects must be armatures"
                return False
            if o.get('bb_onemap_director') == None and o.get('bb_onemap_actor') == None:
                bb_onemap.onemap_message = "Rig error, cyclic match not found!"
                return False
        bb_onemap.onemap_message = "Ready!"
        return True
    onemap_set_error : bpy.props.BoolProperty(

        get = trigger_onemap_set_error
        )

    def trigger_onemap_set_input_bone_group(self):
        
        bone_name = onemap.props['group_input_bone']
        
        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        if inRig == False:
            if onemap.props['HALT'] == True:
                return False
            print("FATAL ERROR: Missing input rig, save work and restart blender, test halted!")
            onemap.props['HALT'] = True
        outRig = inRig['bb_onemap_actor']

        inRig.pose.bones[bone_name].bone_group = inRig.pose.bone_groups['Anchor']
        
        bb_onemap_reskin = inRig.get('bb_onemap_reskin', [])
        if bone_name in bb_onemap_reskin:
            reskin_bones = bb_onemap_reskin[bone_name]
            for bone in reskin_bones:
                inRig.pose.bones[bone].bone_group = inRig.pose.bone_groups['Branch']

        return True

    def trigger_onemap_set_output_bone_group(self):
        
        outRig = bpy.context.active_object
        bone_name = onemap.props['group_output_bone']
        group_name = onemap.props['group_output_name']
        
        outRig.pose.bones[bone_name].bone_group = outRig.pose.bone_groups[group_name]
        return True

    def trigger_onemap_update_map(self):
        Rig = bpy.context.selected_objects[0]
        if Rig.get('bb_onemap_actor') == None:
            inRig = Rig.get('bb_onemap_director')
            if inRig == None:
                print("We have a Houston, there's no inRig when triggering the map updater")
                return True
            outRig = Rig
        else:
            inRig = Rig
            outRig = inRig.get('bb_onemap_actor')
            if outRig == None:
                print("We have a Houston, the inRig was identifed but contains no usable outRig")
                return True
        onemap.update_map(input=inRig, output=outRig, controllers=False)
        return True

    onemap_set_input_bone_group : bpy.props.BoolProperty(
        default=False,
        get = trigger_onemap_set_input_bone_group
        )
    onemap_set_output_bone_group : bpy.props.BoolProperty(
        default=False,
        get = trigger_onemap_set_output_bone_group
        )
    onemap_update_map : bpy.props.BoolProperty(
        default=False,
        
        get = trigger_onemap_update_map
        )

    def update_onemap_hide_rename_bones(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        outRig = inRig['bb_onemap_actor']
        bb_onemap_rename = inRig.get('bb_onemap_rename', {})
        for bone in bb_onemap_rename:
            if bone in inRig.data.bones:
                inRig.data.bones[bone].hide = bb_onemap.onemap_hide_rename_bones
    def update_onemap_hide_reskin_bones(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        outRig = inRig['bb_onemap_actor']
        bb_onemap_reskin = inRig.get('bb_onemap_reskin', {})
        for bone in bb_onemap_reskin:
            reskin_bones = bb_onemap_reskin[bone]
            for rbone in reskin_bones:
                if rbone in inRig.data.bones:
                    inRig.data.bones[rbone].hide = bb_onemap.onemap_hide_reskin_bones
    def update_onemap_hide_output_bones(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        outRig = inRig['bb_onemap_actor']
        bb_onemap_rename = inRig.get('bb_onemap_rename', {})
        for bone in bb_onemap_rename:
            tbone = bb_onemap_rename[bone]
            if tbone in outRig.data.bones:
                outRig.data.bones[tbone].hide = bb_onemap.onemap_hide_output_bones

    onemap_hide_rename_bones : bpy.props.BoolProperty(
        name = "",
        description =            "Click to restore the view of anchor bones.",
        default=False,
        update = update_onemap_hide_rename_bones
        )
    onemap_hide_reskin_bones : bpy.props.BoolProperty(
        name = "",
        description =            "Click to restore the view of reskin bones.",
        default=False,
        update = update_onemap_hide_reskin_bones
        )
    onemap_hide_output_bones : bpy.props.BoolProperty(
        name = "",
        description =            "Click to restore the view of output bones.",
        default=False,
        update = update_onemap_hide_output_bones
        )

    def update_onemap_follow(self, context):
        selected = bpy.context.selected_objects
        inRig = onemap.get_director(armature=selected[0].name)
        if inRig == False:
            self["onemap_follow"] = not self.onemap_follow
            return
        outRig = inRig['bb_onemap_actor']
        onemap.update_map(input=inRig, output=outRig)

    onemap_follow : bpy.props.BoolProperty(
        name = "",
        description =            "Enable this to make the Actor bones follow the Director, which should allow for easier mapping of some items when "            "you're able to see what's in motion.  After using this rotate a bone on the Actor or setup a test animation beforehand.",
        default=True,
        update = update_onemap_follow
        )

class OnigiriOneMapRemoveMap(bpy.types.Operator):
    """This deletes the map on the selected rig"""

    bl_idname = "onigiri.onemap_remove_map"
    bl_label = "Remove Map"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.get('bb_onemap_rename') == None or o.get('bb_onemap_rename') == None:
            return False
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        armObj = rigutils.is_armature()
        if armObj != False:
            inRig = onemap.get_director(armature=armObj.name)
            
            if inRig != False:
                inRig['bb_onemap_rename'] = {}
                inRig['bb_onemap_reskin'] = {}
                onemap.update_map(input=inRig, output=outRig)
        
        selected = bpy.context.selected_objects
        if len(selected) == 1:
            selected[0].pop('bb_onemap_rename', "")
            selected[0].pop('bb_onemap_reskin', "")

        print("Cleaned")

        return {'FINISHED'}

class OnigiriOnemapReverse(bpy.types.Operator):
    """Reverse the map.  This does not work with mapped reskin bones, it will bring
your map out of sync.  This is for retargeting animations only but the updated
Character Converter does a great job of reskinning without doing it manually"""

    bl_idname = "onigiri.onemap_reverse"
    bl_label = "Reverse map\n"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.get('bb_onemap_rename') == None:
            return False
        return True

    def execute(self, context):
        
        bb_inherit = bpy.context.window_manager.bb_inherit

        mapObj = bpy.context.selected_objects[0]
        rename_map = mapObj['bb_onemap_rename'].to_dict()
        rename_rev = {}
        for tbone in rename_map:
            sbone = rename_map[tbone]
            rename_rev[sbone] = tbone
        mapObj['bb_onemap_rename'] = rename_rev
        print("(onemap) : The rename map has been reversed")
        txt = "Your retarget map has been reversed, that means that the source bone\n"
        txt += "and the target bone names have been swapped in place.  This did not\n"
        txt += "effect your rig at all.  To have the same change for your rig you can\n"
        txt += "use the button next to this one (Convert Director to Actor) which will\n"
        txt += "change the bone names in your rig.  This type of rig change can only\n"
        txt += "happen if the source bones are named the same as the rig so you may\n"
        txt += "have to undo your name changes in the map by hitting this button again\n"
        txt += "in that case.\n"
        utils.popup(txt, "Map bone names changed!", "INFO")
        return {'FINISHED'}

class OnigiriOneMapNukeSelected(bpy.types.Operator):
    """Unmap the selected bones.  Unlike the in bone and out bone specific unmap
features this will remove all selected bones from the map, that's why it's
got that nuke sign O.o"""

    bl_idname = "onigiri.onemap_nuke_selected"
    bl_label = "Unmap selected bones"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            if o.type != 'ARMATURE':
                return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap

        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        if inRig == False:
            print("There seems to be a wrong rig selected.")
            popup("Bad rig selection", "Error", "ERROR")
            return {'FINISHED'}

        bb_onemap.onemap_nuke_selected = False

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = dict()
        if inRig.get('bb_onemap_reskin') == None:
            inRig['bb_onemap_reskin'] = dict()

        outRig = inRig['bb_onemap_actor']

        rename_map = inRig['bb_onemap_rename']
        reskin_map = inRig['bb_onemap_reskin']

        rename_rev = {}
        for sbone in rename_map:
            tbone = rename_map[sbone]
            rename_rev[tbone] = sbone

        selected = bpy.context.selected_pose_bones
        remove_bones = set()
        for boneObj in selected:
            bone = boneObj.name
            
            if boneObj.id_data == inRig:
                if bone in rename_map:
                    remove_bones.add(bone)
            
            if boneObj.id_data == outRig:
                if bone in rename_rev:
                    sbone = rename_rev[bone]
                    remove_bones.add(sbone)
        
        temp_reskin = set()
        for anchor in reskin_map:
            for bone in reskin_map[anchor]:
                temp_reskin.add(bone)
        for boneObj in selected:
            if boneObj.name in temp_reskin:
                remove_bones.add(boneObj.name)

        for input_bone in remove_bones:

            if input_bone in rename_map:
                
                rename_map.pop(input_bone)
            
            if input_bone in reskin_map:
                
                reskin_map.pop(input_bone, {})
            
            for bone in reskin_map:
                new_reskin = []
                for rbone in reskin_map[bone]:
                    if input_bone == rbone:
                        
                        continue
                    new_reskin.append(rbone)
                reskin_map[bone] = new_reskin

        inRig['bb_onemap_rename'] = rename_map
        inRig['bb_onemap_reskin'] = reskin_map

        bb_onemap["onemap_reskin"] = False
        bb_onemap["onemap_move"] = False

        onemap.props['input_bone'] = ""
        onemap.props['output_bone'] = ""
        onemap.props['move_bone'] = ""
        onemap.props['group_input_bone'] = ""
        onemap.props['group_input_name'] = ""

        onemap.update_map(input=inRig, output=outRig, rename=rename_map, reskin=reskin_map)

        for boneObj in outRig.data.bones:
            boneObj.select = False
        for boneObj in inRig.data.bones:
            boneObj.select = False

        return {'FINISHED'}

class OnigiriOneMapMesh(bpy.types.Operator):
    """Show / Hide associated mesh"""

    bl_idname = "onigiri.onemap_mesh"
    bl_label = "Mesh Hide / Show"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        if inRig == False:
            print("The Director rig is not available, this is a programming error")
            return {'FINISHED'}

        if self.action == "hide":
            state = True
        elif self.action == "show":
            state = False
        else:
            print("unknown state, this is a bug")
            return {'FINISHED'}

        utils.view_mesh(armature=inRig.name, view=state)

        return {'FINISHED'}

class OnigiriOneMapBones(bpy.types.Operator):
    """Show / Hide additional bones"""

    bl_idname = "onigiri.onemap_bones"
    bl_label = "Show / Hide additional bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        if inRig == False:
            print("The Director rig is not available, this is a programming error")
            return {'FINISHED'}
        outRig = inRig['bb_onemap_actor']
        if self.action == "show":
            
            rigutils.get_layer_state(outRig)
            
            for boneObj in outRig.data.bones:
                boneObj.hide = False

        else:
            for boneObj in outRig.data.bones:
                state = boneObj.get('hide', False)
                boneObj.hide = state
            
        return {'FINISHED'}

class OnigiriOneMapReskinToParent(bpy.types.Operator):
    """Reskin the selected bone to the parent, if the parent is mapped."""

    bl_idname = "onigiri.onemap_reskin_to_parent"
    bl_label = "Reskin to parent"

    @classmethod
    def poll(cls, context):
        bb_onemap = bpy.context.scene.bb_onemap
        o = bpy.context.active_object
        if o == None:
            return False
        if o.type != 'ARMATURE':
            return False
        if o.get('bb_onemap_rename') == None:
            return False
        if bpy.context.mode != 'POSE':
            return False
        selected = bpy.context.selected_pose_bones
        if len(selected) != 1:
            return False
        if selected[0].parent == None:
            return False
        if selected[0].parent.name not in o['bb_onemap_rename']:
            return False
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap

        bb_onemap["onemap_reskin"] = False
        bb_onemap["onemap_move"] = False

        pBone = bpy.context.selected_pose_bones[0]
        onemap.props['reskin_bone'] = pBone.name
        bpy.ops.onigiri.onemap_reskin()

        pBone.bone.select = False
        pBone.bone.parent.select = True

        return {'FINISHED'}

class OnigiriOneMapBonesMap(bpy.types.Operator):
    """Click a bone on the input rig and a bone on the output rig, then click this button.
If the bone is mapped already the reskin bones will travel with it.  If it's a reskin
bone it'll be mapped as expected and removed from its source branch"""

    bl_idname = "onigiri.onemap_map_bones"
    bl_label = "Map these bones"

    @classmethod
    def poll(cls, context):
        bb_onemap = bpy.context.scene.bb_onemap
        if len (bpy.context.selected_objects) == 0:
            return False
        
        arms = 0
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                arms += 1
        if arms > 2:
            return False
        if arms < 2:
            return False
        if o.get('bb_onemap_director') == None and o.get('bb_onemap_actor') == None:
            return False
        if onemap.props['input_bone'] == "" or onemap.props['output_bone'] == "":
            return False
        
        if bb_onemap.onemap_reskin == True:
            return False
        if bb_onemap.onemap_move == True:
            return False
        
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap

        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        if inRig == False:
            print("Something is wrong with your state, I was unable to find the input rig to map your bones")
            popup("Fatal Error, check System Console", "Fatal Error", "ERROR")
            return {'FINISHED'}

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = dict()
        if inRig.get('bb_onemap_reskin') == None:
            inRig['bb_onemap_reskin'] = dict()

        outRig = inRig['bb_onemap_actor']
        in_bone = onemap.props['input_bone']
        out_bone = onemap.props['output_bone']

        rename_map = inRig['bb_onemap_rename'].to_dict()
        reskin_map = inRig['bb_onemap_reskin'].to_dict()

        old_reskin = []

        old_rename_map = copy.deepcopy(rename_map)
        for bone in old_rename_map:
            tbone = rename_map[bone]
            if out_bone == tbone:
                print("Removing old key", bone, "for output", out_bone)
                del rename_map[bone]
                old_reskin = reskin_map.pop(bone, [])
        if reskin_map.get(in_bone) == None:
            reskin_map[in_bone] = old_reskin
        else:
            reskin_map[in_bone].extend(old_reskin)

        for bone in reskin_map:
            new_reskin = []
            for rbone in reskin_map[bone]:
                if in_bone == rbone:
                    continue
                new_reskin.append(rbone)
            reskin_map[bone] = new_reskin

        rename_map.pop(in_bone, "")
        
        rename_map[in_bone] = out_bone

        onemap.update_map(input=inRig, output=outRig, rename=rename_map, reskin=reskin_map)

        inRig['bb_onemap_rename'] = rename_map
        inRig['bb_onemap_reskin'] = reskin_map

        for boneObj in inRig.data.bones:
            boneObj.select = False
        for boneObj in outRig.data.bones:
            boneObj.select = False

        onemap.props['input_bone'] = ""
        onemap.props['output_bone'] = ""

        return {'FINISHED'}

class OnigiriOneMapRemoveInputBone(bpy.types.Operator):
    """Click this to remove the bone from the map"""

    bl_idname = "onigiri.onemap_remove_input_bone"
    bl_label = "Remove Bone"

    bone : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        bb_onemap = bpy.context.scene.bb_onemap
        if len (bpy.context.selected_objects) == 0:
            return False
        
        arms = 0
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                arms += 1
        if arms > 2:
            return False
        if arms < 2:
            return False
        
        if o.get('bb_onemap_director') == None and o.get('bb_onemap_actor') == None:
            return False
        
        if onemap.props['input_bone'] == "":
            return False
        
        if bb_onemap.onemap_reskin == True:
            return False
        if bb_onemap.onemap_move == True:
            return False
        
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap

        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        if inRig == False:
            print("Something is wrong with your state, I was unable to find the input rig to map your bones")
            popup("Fatal Error, check System Console", "Fatal Error", "ERROR")
            return {'FINISHED'}

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = dict()
        if inRig.get('bb_onemap_reskin') == None:
            inRig['bb_onemap_reskin'] = dict()

        outRig = inRig['bb_onemap_actor']

        rename_map = inRig['bb_onemap_rename']
        reskin_map = inRig['bb_onemap_reskin']

        input_bone = self.bone

        if input_bone in rename_map:
            print("removing rename bone:", input_bone)
            rename_map.pop(input_bone)
        
        if input_bone in reskin_map:
            print("removing anchor bone:", input_bone)
            reskin_map.pop(input_bone, {})
        
        for bone in reskin_map:
            new_reskin = []
            for rbone in reskin_map[bone]:
                if input_bone == rbone:
                    print("removing reskin bone", input_bone, "attached to anchor", bone)
                    continue
                new_reskin.append(rbone)
            reskin_map[bone] = new_reskin

        onemap.update_map(input=inRig, output=outRig, rename=rename_map, reskin=reskin_map)

        inRig['bb_onemap_rename'] = rename_map
        inRig['bb_onemap_reskin'] = reskin_map

        for boneObj in inRig.data.bones:
            boneObj.select = False
        for boneObj in outRig.data.bones:
            boneObj.select = False

        onemap.props['input_bone'] = ""
        onemap.props['output_bone'] = ""

        return {'FINISHED'}

class OnigiriOneMapRemoveOutputBone(bpy.types.Operator):
    """Click this to remove the bone from the map"""

    bl_idname = "onigiri.onemap_remove_output_bone"
    bl_label = "Remove Bone"

    bone : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        bb_onemap = bpy.context.scene.bb_onemap
        if len (bpy.context.selected_objects) == 0:
            return False
        
        arms = 0
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                arms += 1
        if arms > 2:
            return False
        if arms < 2:
            return False
        
        if o.get('bb_onemap_director') == None and o.get('bb_onemap_actor') == None:
            return False
        
        if onemap.props['output_bone'] == "":
            return False
        
        if bb_onemap.onemap_reskin == True:
            return False
        if bb_onemap.onemap_move == True:
            return False
        
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap

        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        if inRig == False:
            print("Something is wrong with your state, I was unable to find the input rig to map your bones")
            popup("Fatal Error, check System Console", "Fatal Error", "ERROR")
            return {'FINISHED'}

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = dict()
        if inRig.get('bb_onemap_reskin') == None:
            inRig['bb_onemap_reskin'] = dict()

        outRig = inRig['bb_onemap_actor']

        rename_map = inRig['bb_onemap_rename']
        reskin_map = inRig['bb_onemap_reskin']

        input_bone = self.bone

        old_rename_bones = []
        for bone in rename_map:
            if input_bone == rename_map[bone]:
                old_rename_bones.append(bone)
        if len(old_rename_bones) > 1:
            print("Attempting to remove the bone", input_bone, "resulted in the discovery of duplicate maps.")
            print("All of these will be removed, shown below:")
            print(old_rename_bones)
        for bone in old_rename_bones:
            rename_map.pop(bone)
        for bone in old_rename_bones:
            if bone in reskin_map:
                print("Removed anchor")
                reskin_map.pop(bone)

        old_rename_bones.append(input_bone)
        bad_bones = set(old_rename_bones)
        for bone in reskin_map:
            new_bones = []
            for rbone in reskin_map[bone]:
                if rbone in bad_bones:
                    print("Found duplicate misplaced reskin bone in anchor", bone, "which will be removed")
                    continue
                new_bones.append(rbone)
            reskin_map[bone] = new_bones

        onemap.update_map(input=inRig, output=outRig, rename=rename_map, reskin=reskin_map)

        inRig['bb_onemap_rename'] = rename_map
        inRig['bb_onemap_reskin'] = reskin_map

        for boneObj in inRig.data.bones:
            boneObj.select = False
        for boneObj in outRig.data.bones:
            boneObj.select = False

        onemap.props['input_bone'] = ""
        onemap.props['output_bone'] = ""

        return {'FINISHED'}

class OnigiriOneMapReskin(bpy.types.Operator):
    """--internal"""
    bl_idname = "onigiri.onemap_reskin"
    bl_label = "reskin"

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap

        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        outRig = inRig['bb_onemap_actor']

        if inRig.get('bb_onemap_rename') == None: 
            inRig['bb_onemap_rename'] = {}
        if inRig.get('bb_onemap_reskin') == None:
            inRig['bb_onemap_reskin'] = {}

        bb_onemap_rename = inRig['bb_onemap_rename'].to_dict()
        bb_onemap_reskin = inRig['bb_onemap_reskin'].to_dict()

        in_bone = onemap.props['input_bone']

        if len(bpy.context.selected_pose_bones) == 0:
            print("No bones were selected for reskinning")
        else:
            
            anchor_bone = onemap.props['reskin_bone']

            print("anchor is:", anchor_bone)
            print("number selected:", len(bpy.context.selected_pose_bones))

            qualified_bones = []
            for boneObj in bpy.context.selected_pose_bones:
                
                if boneObj.id_data != inRig:
                    continue
                
                if boneObj.name in bb_onemap_rename:
                    continue
                if boneObj.name == anchor_bone:
                    continue
                qualified_bones.append(boneObj.name)
            reskin_bones = bb_onemap_reskin.get(anchor_bone, [])

            reskin_bones.extend(qualified_bones)
            if len(reskin_bones) != 0:
                inRig['bb_onemap_reskin'][anchor_bone] = reskin_bones
                onemap.update_map(input=inRig, output=outRig)

                for bone in reskin_bones:
                    inRig.pose.bones[bone].bone_group = inRig.pose.bone_groups['Branch']

        print("Color reskin bone exiting resking without resetting fake properties") 
        
        return {'FINISHED'}

class OnigiriOneMapMove(bpy.types.Operator):
    """--internal"""
    bl_idname = "onigiri.onemap_move"
    bl_label = "move"

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap

        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = dict()
        if inRig.get('bb_onemap_reskin') == None:
            inRig['bb_onemap_reskin'] = dict()

        outRig = inRig['bb_onemap_actor']

        rename_map = inRig['bb_onemap_rename'].to_dict()
        reskin_map = inRig['bb_onemap_reskin'].to_dict()
        old_bone = onemap.props['move_bone']
        new_bone = onemap.props['input_bone']

        if old_bone not in rename_map or new_bone not in rename_map:
            
            txt = ""
            if old_bone not in rename_map:
                txt = "The original bone is not mapped" 
            if new_bone not in rename_map:
                txt += "\n"
                txt += "The new bone is not mapped"
            print("Nothing to do, make sure both bones are mapped before you transfer reskin bones.")
            
            for boneObj in inRig.data.bones:
                boneObj.select = False
            for boneObj in outRig.data.bones:
                boneObj.select = False
            onemap.props['input_bone'] = ""
            onemap.props['output_bone'] = ""
            onemap.props['move_bone'] = ""
            
            onemap.update_map(input=inRig, output=outRig, rename=rename_map, reskin=reskin_map)
            bpy.context.scene.bb_onemap.onemap_message = "ERROR: both bones must be mapped first"
            return {'FINISHED'}

        print("Moving", old_bone, "to", new_bone)

        old_reskin = []
        
        if old_bone in reskin_map:
            old_reskin.extend(reskin_map[old_bone])
            del reskin_map[old_bone]

        if new_bone in reskin_map:
            old_reskin.extend(reskin_map[new_bone])
            del reskin_map[new_bone]

        if len(old_reskin) > 0:
            reskin_map[new_bone] = old_reskin

        reskin_map[new_bone] = old_reskin

        for boneObj in inRig.data.bones:
            boneObj.select = False
        for boneObj in outRig.data.bones:
            boneObj.select = False

        onemap.props['input_bone'] = ""
        onemap.props['output_bone'] = ""
        onemap.props['move_bone'] = ""

        inRig['bb_onemap_reskin'] = reskin_map

        onemap.update_map(input=inRig, output=outRig, rename=rename_map, reskin=reskin_map)

        return {'FINISHED'}

class OnigiriOneMapViewReskin(bpy.types.Operator):
    """Click to view the reskin bones for this anchor.  This will also select the
input bone / anchor and make it active"""

    bl_idname = "onigiri.onemap_view_reskin"
    bl_label = "View reskin"

    bone : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        onemap.props['view_reskin_bones'] = self.bone
        print("Viewing reskin bones for", self.bone)
        
        for boneObj in bpy.context.selected_pose_bones:
            rigObj = boneObj.id_data
            bone = boneObj.name
            rigObj.data.bones[bone].select = False
        
        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        inRig.data.bones[self.bone].select = True
        
        inRig.data.bones.active = inRig.data.bones[self.bone]

        return {'FINISHED'}

class OnigiriOneMapSelectReskinBone(bpy.types.Operator):
    """Clicking this will select the reskin bone in the 3d view and make it active"""
    bl_idname = "onigiri.onemap_select_reskin_bone"
    bl_label = "Select reskin bone"

    bone : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap

        for boneObj in bpy.context.selected_pose_bones:
            rigObj = boneObj.id_data
            bone = boneObj.name
            rigObj.data.bones[bone].select = False

        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        inRig.data.bones[self.bone].select = True
        
        inRig.data.bones.active = inRig.data.bones[self.bone]

        return {'FINISHED'}

class OnigiriOneMapSelectOutputBone(bpy.types.Operator):
    """Clicking this will select the output bone in the 3d view and make it active"""
    bl_idname = "onigiri.onemap_select_output_bone"
    bl_label = "Select output bone"

    bone : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap

        for boneObj in bpy.context.selected_pose_bones:
            rigObj = boneObj.id_data
            bone = boneObj.name
            rigObj.data.bones[bone].select = False
        
        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        outRig = inRig['bb_onemap_actor']
        outRig.data.bones[self.bone].select = True
        
        outRig.data.bones.active = outRig.data.bones[self.bone]

        return {'FINISHED'}

class OnigiriOneMapAction(bpy.types.Operator):
    """Choose your input rig (Actor) then click this button"""

    bl_idname = "onigiri.onemap_action"
    bl_label = "Start the mapper"

    @classmethod
    def poll(cls, context):
        bb_onemap = bpy.context.scene.bb_onemap
        arms = 0
        if len (bpy.context.selected_objects) == 0:
            return False
        
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                arms += 1
            if arms != 1:
                return False
        
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                inRig = o

        if bpy.context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}

        frame_start, frame_end = animutils.get_frame_range(inRig, start=True) 

        director_states = rigutils.get_layer_state(inRig)

        utils.activate(inRig)

        inRig['bb_onemap_data'] = inRig.data.copy()
        inRig['bb_onemap_matrix'] = inRig.matrix_world.copy()

        mesh = [o for o in inRig.children if o.type == 'MESH']
        inRig['bb_onemap_mesh'] = mesh

        if inRig.animation_data != None:
            if inRig.animation_data.action != None:
                inRig['bb_onemap_action'] = inRig.animation_data.action.name

        for o in mesh:
            o['bb_onemap_data'] = o.data.copy()
            o['bb_onemap_matrix'] = o.matrix_world.copy()

        for boneObj in inRig.data.bones:
            boneObj['head'] = boneObj.head_local.copy()
            boneObj['tail'] = boneObj.tail_local.copy()
            
            matrix_local = boneObj.matrix_local.copy()
            boneObj['roll'] = utils.get_bone_roll(matrix_local)
            boneObj['matrix_local'] = matrix_local
        
        for boneObj in inRig.pose.bones:
            
            boneObj['matrix_basis'] = boneObj.matrix_basis.copy()

        rigutils.rebind(inRig)

        bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)

        if 1 == 0:
            
            print("Applying transforms to outRig, keep an eye on this")
            inRig.select_set(False)
            outRig.select_set(True)
            utils.activate(outRig)
            bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)
            outRig.select_set(False)
            inRig.select_set(True)
            utils.activate(inRig)

        if bb_onemap.onemap_platform_opensim == True:
            outRig = rigutils.build_rig(rig_class="pos", rotate=True)
            outRig['bb_onemap_director'] = inRig 
            inRig['bb_onemap_actor'] = outRig 
            
            onemap.props['bb_onemap_director'] = inRig
            onemap.props['bb_onemap_actor'] = outRig

            loc = inRig.location.y
            loc += bb_onemap.onemap_offset
            outRig.location.y = loc

            onemap.props['bb_onemap_state'] = "started"
            bb_onemap.onemap_message = "Start picking"

            actor_states = rigutils.get_layer_state(outRig)

            print("Attaching proxy")
            state = utils.get_state()
            onemap.attach_proxy(inRig=inRig, outRig=outRig)
            utils.set_state(state)
            
            if inRig.get('bb_onemap_rename') == None:
                inRig['bb_onemap_rename'] = {}
            if inRig.get('bb_onemap_reskin') == None:
                inRig['bb_onemap_reskin'] = {}

            for bone in inRig['bb_onemap_rename']:
                if bone in outRig.data.bones:
                    outRig.data.bones[bone].hide = False
            
            for boneObj in outRig.data.bones:
                boneObj['hide'] = boneObj.hide

            onemap.ready(input=inRig, output=outRig)

            bb_onemap.onemap_follow = True

            rigutils.set_layer_state(armature=outRig, state=actor_states)

        else:
            
            bb_onemap.onemap_message = "Pick Output Rig"

            onemap.props['bb_onemap_director'] = inRig
            onemap.props['bb_onemap_state'] = "pick"

        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                for boneObj in o.data.bones:
                    boneObj.select = False

        rigutils.set_layer_state(armature=inRig, state=director_states)

        return {'FINISHED'}

class OnigiriOneMapOutputPick(bpy.types.Operator):
    """Choose your output rig and click this button"""

    bl_idname = "onigiri.onemap_pick_output"
    bl_label = "Pick Output Rig"

    @classmethod
    def poll(cls, context):
        bb_onemap = bpy.context.scene.bb_onemap
        arms = 0
        if len (bpy.context.selected_objects) != 1:
            return False
        for o in bpy.context.selected_objects:
            if o.type != 'ARMATURE':
                return False
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        obj = bpy.data.objects
        armObj = bpy.context.selected_objects[0]
        
        inRig = onemap.props['bb_onemap_director']

        if inRig == "":
            print("There's no rig chain to follow, the input rig property is missing")
            popup("Input rig can't be found, I don't know what happened", "Fatal Error", "ERROR")
            return {'FINISHED'}
        if inRig.name not in bpy.context.scene.objects:
            print("The matching input rig is missing from the scene:", input_rig)
            popup("Input rig is missing from the scene", "Fatal Error", "ERROR")
            return {'FINISHED'}
        
        if armObj.name == inRig.name:
            print("The output rig cannot be the same as the input rig.")
            popup("The output rig and input rig cannot be the same", "Error", "ERROR")
            return {'FINISHED'}

        rigutils.get_layer_state(armObj)
        rigutils.get_layer_state(inRig)
        for boneObj in armObj.data.bones:
            boneObj.hide = False
        for boneObj in inRig.data.bones:
            boneObj.hide = False

        armObj['bb_onemap_director'] = inRig
        inRig['bb_onemap_actor'] = armObj

        onemap.props['bb_onemap_director'] = inRig
        onemap.props['bb_onemap_actor'] = armObj

        onemap.props['bb_onemap_state'] = "started"
        bb_onemap_message = "Start Picking"

        outRig = armObj
        
        print("Attaching proxy")
        state = utils.get_state()
        onemap.attach_proxy(inRig=inRig, outRig=outRig)
        utils.set_state(state)
        
        onemap.ready(output=armObj, input=inRig)

        onemap.props['target'] = "other"

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}
        for bone in inRig['bb_onemap_rename']:
            if bone in outRig.data.bones:
                outRig.data.bones[bone].hide = False
        
        for boneObj in outRig.data.bones:
            boneObj['hide'] = boneObj.hide

        return {'FINISHED'}

class OnigiriOneMapReset(bpy.types.Operator):
    """Reset everything in the mapper and rigs"""

    bl_idname = "onigiri.onemap_reset"
    bl_label = "Reset"

    @classmethod
    def poll(cls, context):
        bb_onemap = bpy.context.scene.bb_onemap
        
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap

        armObj = bpy.context.selected_objects[0]

        inRig = onemap.get_director(armature=armObj.name)
        if inRig == False:
            print("No matching rig, attempting to reset other data anyway...")
        
        else:
            
            outRig = inRig.get('bb_onemap_actor')
            if outRig != None:
                if outRig.name in bpy.context.scene.objects:
                    outRig.pop('bb_onemap_director', "")
            inRig.pop('bb_onemap_actor', "")
            inRig.pop('bb_onemap_map', "")
            inRig.pop('bb_onemap_state', "")

        armObj.pop('bb_onemap_actor', "")
        armObj.pop('bb_onemap_state', "")

        bb_onemap['onemap_reskin'] = False
        bb_onemap['onemap_move'] = False

        bpy.ops.object.mode_set(mode='OBJECT')
        for o in bpy.context.selected_objects:
            o.select_set(False)

        if inRig != False:
            if inRig.get('bb_onemap_proxy') != None:
                proxyRig = inRig['bb_onemap_proxy']
                proxyRig.pop('bb_onemap_proxy', "")
                if utils.is_valid(proxyRig):
                    proxyRig.select_set(True)

            if onemap.props['target'] != "other":
                print("Target is NOT other")
                outRig.select_set(True)
                bpy.context.view_layer.objects.active = outRig
                bpy.ops.object.delete()

            onemap.props['target'] = ""

            for boneObj in inRig.pose.bones:
                cname = boneObj.get('bb_onemap_cname')
                if cname ==  None:
                    print("Controllers are missing on", inRig.name, "for bone", boneObj.name, "... aborting")
                    break
                if cname in boneObj.constraints:
                    conObj = boneObj.constraints[cname]
                    boneObj.constraints.remove(conObj)
                boneObj.pop('bb_onemap_cname', "")
            bpy.context.view_layer.update()

            for boneObj in inRig.pose.bones:
                boneObj.matrix_basis = mathutils.Matrix(boneObj['matrix_basis'])
                boneObj.pop('matrix_basis', "")

            if 1 == 1:
                inRig.data = inRig['bb_onemap_data']
                inRig.matrix_world = mathutils.Matrix(inRig['bb_onemap_matrix'])
                mesh = inRig['bb_onemap_mesh']
                for o in mesh:
                    if utils.is_valid(o):
                        o.data = o['bb_onemap_data']
                        o.matrix_world = mathutils.Matrix(o['bb_onemap_matrix'])

                        if 1 == 0:
                            
                            coords = o['bb_onemap_coords']
                            for v in o.data.vertices:
                                v.co = coords[v.index]

            action = inRig.get('bb_onemap_action')
            
            if action != None:
                if inRig.animation_data == None:
                    inRig.animation_data_create()
                
                action = bpy.data.actions.get(action)
                if action != None:
                    inRig.animation_data.action = action

                if 1 == 0:
                    
                    if inRig.data.bones[0].get('matrix_local') != None:
                        
                        inRig.select_set(True)
                        utils.activate(inRig)
                        bpy.ops.object.mode_set(mode='EDIT')
                        bone_data = {}
                        for boneObj in inRig.data.edit_bones:
                            bone_data[boneObj.name] = {}
                            bone_data[boneObj.name]['use_connect'] = boneObj.use_connect
                            bone_data[boneObj.name]['parent'] = boneObj.parent
                        for boneObj in inRig.data.edit_bones:
                            boneObj.parent = None
                        for boneObj in inRig.data.edit_bones:
                            boneObj.head = inRig.data.bones[boneObj.name]['head']
                            boneObj.tail = inRig.data.bones[boneObj.name]['tail']
                            boneObj.roll = inRig.data.bones[boneObj.name]['roll']
                        
                        bpy.ops.object.mode_set(mode='OBJECT')
                        for boneObj in bpy.data.pose.bones:
                            boneObj.matrix = boneObj.bone
                        
                        bpy.ops.object.mode_set(mode='EDIT')
                        for boneObj in inRig.data.edit_bones:
                            boneObj.use_connect = boneObj['use_connect']
                            boneObj.parent = boneObj['parent']
                        bpy.ops.object.mode_set(mode='OBJECT')
                        
                        for boneObj in inRig.pose.bones:
                            boneObj.matrix = boneObj['matrix']

        for prop in onemap.props:
            onemap.props[prop] = ""
        onemap.props['bb_onemap_state'] = False
        bb_onemap.property_unset("onemap_message")
        bb_onemap.property_unset("onemap_template_name")

        bb_onemap["onemap_follow"] = False
        armObj.select_set(True)
        bpy.context.view_layer.objects.active = armObj

        return {'FINISHED'}

class OnigiriOnemapMapLoad(bpy.types.Operator, ImportHelper):
    """Load a Onigiri map, all maps are supported.  Note that maps with
multiple rig targets are not supported, only the first rig will be used.
Loading a map merges it with the existing one"""

    bl_idname = "onigiri.onemap_load_map"
    bl_label = "Load Map"

    filter_glob : bpy.props.StringProperty(
        default='*.ctm;*.ccm;*bbm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        bb_onemap = bpy.context.scene.bb_onemap
        if len(bpy.context.selected_objects) == 0:
            return False
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap

        mapObj = bpy.context.selected_objects[0] 

        file_path = self.properties.filepath
        path, name = os.path.split(self.properties.filepath)
        file_prefix = name.split(".")[0]
        ext = name.split(".")[-1]

        try:
            namespace = {}
            exec(open(file_path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        template = {}
        for container in namespace:
            
            if container.startswith("__"):
                continue
            template[container] = namespace[container]

        template_map = template.get('template_map', {})
        rename_map = template.get('rename', {})
        reskin_map = template.get('reskin', {})
        pose_map = template.get('pose', {})
        code_map = template.get('code', {}) 
        lock_map = template.get('lock', {}) 

        rename = {}
        reskin = {}
        bone_map = {} 

        if len(rename_map) != 0:
            print("Found CCM")
            for bone in rename_map:
                rename[bone] = rename_map[bone]
                if bone in reskin_map:
                    reskin[bone] = reskin_map[bone] 
            mapObj['bb_onemap_rename'] = rename
            mapObj['bb_onemap_reskin'] = reskin
        
        elif len(template_map) != 0:
            print("Found CTM")
            for sbone in template_map:
                (tarm, tbone), = template_map[sbone].items()
                bone_map[tbone] = sbone
            mapObj['bb_onemap_rename'] = bone_map
            mapObj['bb_onemap_reskin'] = reskin
        if pose_map != None:
            mapObj['bb_onemap_pose'] = pose_map
            print("Pose map loaded!")
        if code_map != None:
            mapObj['bb_onemap_code'] = code_map
            print("Code map loaded!")
        if lock_map != None:
            mapObj['bb_onemap_lock'] = lock_map
            print("Lock map loaded!")

        all_input = set()
        for bone in rename:
            all_input.add(bone)
        for bone in reskin:
            all_input.add(bone)
            
            for rbone in reskin[bone]:
                all_input.add(rbone)
        for bone in bone_map:
            all_input.add(bone)

        if mapObj.type == 'ARMATURE':
            armObj = mapObj
            bad_bones = []
            good_bones = []
            for bone in all_input:
                if bone not in armObj.data.bones:
                    bad_bones.append(bone)
                else:
                    good_bones.append(bone)

            if len(good_bones) == 0:
                print("None of the bones in the loaded map match your source rig")
                popup("None of the bones in the map matched", "Error", "ERROR")
            if len(bad_bones) > 0:
                print("Some bones did not match your source rig, see below:")
                print(bad_bones)

            bb_onemap.onemap_template_name = file_prefix

            if bb_onemap.onemap_load_pose == True:
                bb_onemap_pose = armObj.get('bb_onemap_pose')
                if bb_onemap_pose == None:
                    print("No stored pose")
                else:
                    for bone in pose_map:
                        
                        if bone not in armObj.data.bones:
                            continue
                        
                        old_rotation_mode = armObj.pose.bones[bone].rotation_mode
                        armObj.pose.bones[bone].rotation_mode = 'QUATERNION'
                        armObj.pose.bones[bone].matrix_basis = mathutils.Matrix(pose_map[bone])
                        armObj.pose.bones[bone].rotation_mode = old_rotation_mode

            inRig = onemap.get_director(armature=armObj.name)
            if inRig != False:
                outRig = inRig['bb_onemap_actor']

                for bone in inRig['bb_onemap_rename']:
                    if bone in outRig.data.bones:
                        outRig.data.bones[bone].hide = False
                
                for boneObj in outRig.data.bones:
                    boneObj['hide'] = boneObj.hide

                onemap.update_map(input=inRig, output=outRig, rename=rename_map, reskin=reskin_map)

        else:
            print("Not an armature, can't apply a pose or check bones")

        return {'FINISHED'}

class OnigiriOnemapMapSave(bpy.types.Operator, ExportHelper):
    """This will save a hybrid map that is compatible with both CCM and CTM.  The
file type exported will be a hybrid Onigiri Map (bbm) and will contain all
necessary items for both map types so you won't lose any data"""

    bl_idname = "onigiri.onemap_save_map"
    bl_label = "Save Map"

    filename_ext = ".bbm"

    filter_glob : bpy.props.StringProperty(
        default='*.bbm',
        options={'HIDDEN'}
        )
    def invoke(self, context, event):
        save_path = script_dir + data_path
        
        self.filepath = save_path + bpy.context.scene.bb_onemap.onemap_template_name
        wm = context.window_manager.fileselect_add(self)

        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        bb_onemap = bpy.context.scene.bb_onemap
        if len(bpy.context.selected_objects) == 0:
            return False
        
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        path = self.properties.filepath

        inRig = bpy.context.selected_objects[0]

        if inRig == False:
            print("The input rig was unattainable but checking this one...")

        inRig = bpy.context.selected_objects[0]
        if inRig.type != 'ARMATURE':
            print("The first selected object in your set is not an armature, searging...")
            for inRig in bpy.context.selected_objects:
                if inRig.type == 'ARMATURE':
                    print("Found an armature:", inRig.name)
                break
        if inRig.type != 'ARMATURE':
            print("Couldn't find an armature in  your selection, giving up!")
            popup("There are no viable armatures in your selection, see System Console", "Error", "ERROR")
            return {'FINISHED'}
        print("Attempting to export map...")
        result = onemap.save_map(input=inRig, file=self.filepath)
        if result == False:
            print("Something weird happened when saving the map")
            popup("Something strange happened when saving", "Error", "ERROR")

        print("Map saved!")

        return {'FINISHED'}

class OnigiriOnemapMapApplyPose(bpy.types.Operator):
    """This cannot be used while the mapper is engaged.  When working with a map
sometimes it's helpful to move and rotate bones.  This button will restore your
pose to the loaded one so that it can be saved with your map"""

    bl_idname = "onigiri.onemap_apply_pose"
    bl_label = "Apply Pose"

    @classmethod
    def poll(cls, context):
        
        if bpy.context.mode == 'POSE':
            return False
        bb_onemap = bpy.context.scene.bb_onemap
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        
        inRig = bpy.context.selected_objects[0]

        bb_onemap_pose = inRig.get('bb_onemap_pose')
        if bb_onemap_pose == None:
            print("No stored pose")
            popup("No stored pose", "Error", "ERROR")
            return {'FINISHED'}

        for bone in bb_onemap_pose:
            
            if bone not in inRig.data.bones:
                continue
            
            old_rotation_mode = inRig.pose.bones[bone].rotation_mode
            inRig.pose.bones[bone].rotation_mode = 'QUATERNION'
            inRig.pose.bones[bone].matrix_basis = mathutils.Matrix(bb_onemap_pose[bone])
            inRig.pose.bones[bone].rotation_mode = old_rotation_mode

        return {'FINISHED'}

class OnigiriOnemapMapStorePose(bpy.types.Operator):
    """This cannot be used while the mapper is engaged!  Store the existing pose to
your data set, which can then be exported with your map if you choose that option.
This stores the existing pose onto the rig data"""

    bl_idname = "onigiri.onemap_store_pose"
    bl_label = "Store Pose"

    @classmethod
    def poll(cls, context):
        
        if bpy.context.mode == 'POSE':
            return False
        bb_onemap = bpy.context.scene.bb_onemap
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        inRig = bpy.context.selected_objects[0]

        pose_map = {}
        for boneObj in inRig.pose.bones:
            
            old_rotation_mode = boneObj.rotation_mode
            boneObj.rotation_mode = 'QUATERNION'
            matrix_basis = animutils.get_matrix_basis(armature=inRig, bone=boneObj)
            pose_map[boneObj.name] = matrix_basis
            boneObj.rotation_mode = old_rotation_mode

        inRig['bb_onemap_pose'] = pose_map
        popup("Remember to use (Save Pose) when saving your map", "Finished", "INFO")

        return {'FINISHED'}

class OnigiriOnemapMapPose(bpy.types.Operator):
    """Use this to add or remove the pose associated with the rig and potential saved
map.  The pose will be saved along with the conversion map, if there is one.  If
there's no conersion map on the rig then the pose map will have no where to save"""

    bl_idname = "onigiri.onemap_pose"
    bl_label = "Add / Del Pose"

    action : bpy.props.StringProperty(default="add")

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        inRig = bpy.context.selected_objects[0]

        if self.action == "add":
            pose_map = {}
            for boneObj in inRig.pose.bones:
                
                old_rotation_mode = boneObj.rotation_mode
                boneObj.rotation_mode = 'QUATERNION'
                matrix_basis = animutils.get_matrix_basis(armature=inRig, bone=boneObj)
                pose_map[boneObj.name] = matrix_basis
                boneObj.rotation_mode = old_rotation_mode

            inRig['bb_onemap_pose'] = pose_map
            print("Pose added")
        elif self.action == "del":
            inRig.pop('bb_onemap_pose', "")
            print("Pose removed")

        return {'FINISHED'}

class OnigiriOnemapMapRemovePrefix(bpy.types.Operator):
    """Remove prefix from the map.  This affects target bones only"""

    bl_idname = "onigiri.onemap_remove_prefix"
    bl_label = "Remove Prefix"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.get('bb_onemap_rename') == None:
            return False
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap

        mapObj = bpy.context.selected_objects[0]
        rename_map = mapObj['bb_onemap_rename'].to_dict()
        reskin_map = mapObj.get('bb_onemap_reskin', {})
        pose_map = mapObj.get('bb_onemap_pose', {})

        bones = []
        for bone in rename_map:
            bones.append(bone)
        prefix = os.path.commonprefix(bones)
        if prefix == "":
            print("No prefix")
            return {'FINISHED'}

        new_rename = {}
        new_reskin = {}
        new_pose = {}
        for anchor in rename_map:
            new_anchor = anchor.replace(prefix, "", 1)
            
            new_rename[new_anchor] = rename_map[anchor]
            if anchor in reskin_map:
                new_reskin_bones = []
                reskin_bones = reskin_map[anchor]
                for rbone in reskin_bones:
                    new_reskin_bones.append( rbone.replace(prefix, "", 1) )
                new_reskin[new_anchor] = new_reskin_bones
            if anchor in pose_map:
                new_pose[new_anchor] = pose_map[anchor]
        mapObj['bb_onemap_rename'] = new_rename
        if len(new_reskin) > 0:
            mapObj['bb_onemap_reskin'] = new_reskin
        if len(new_pose) > 0:
            mapObj['bb_onemap_pose'] = new_pose

        return {'FINISHED'}

class OnigiriOnemapMapRenameBones(bpy.types.Operator):
    """This renames all of the target bones, including the associated maps, to something
more readable if they're mapped.  If they are not mapped you'll get gibberish.  Unmapped
bones will be gibberish so only do this if they're already gibberish"""

    bl_idname = "onigiri.onemap_rename_bones"
    bl_label = "Rename Bones"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        armObj = bpy.context.selected_objects[0]
        utils.activate(armObj)
        rename_map = armObj['bb_onemap_rename']
        reskin_map = armObj.get('bb_onemap_reskin', {})
        pose_map = armObj.get('bb_onemap_pose', {})

        old_new = {}
        new_old = {}
        all_bones = set(b.name for b in armObj.data.bones)
        for boneObj in armObj.data.bones:
            new_bone = utils.get_safe_name(names=all_bones, report=True)
            if new_bone == False:
                print("There was an error when processing a bone to acquire a unique name")
                popup("There was a naming collision when processing new names for the bones", "Name Collision", "ERROR")
                return {'FINISHED'}
            all_bones.add(new_bone)
            old_new[boneObj.name] = new_bone
            new_old[new_bone] = boneObj.name

        bad_bones = []
        for bone in rename_map:
            if bone not in armObj.data.bones:
                bad_bones.append(bone)
        for bone in bad_bones:
            rename_map.pop(bone)
            reskin_map.pop(bone, '')
        bad_bones = []
        for bone in pose_map:
            if bone not in old_new: 
                bad_bones.append(bone)
        for bone in bad_bones:
            pose_map.pop(bone, '')

        new_reskin_map = {}
        for anchor in reskin_map:
            reskin = reskin_map[anchor]
            for rbone in reskin:
                if rbone not in armObj.data.bones:
                    continue
                if anchor not in new_reskin_map:
                    new_reskin_map[anchor] = []
                new_reskin_map[anchor].append(rbone)
        reskin_map = new_reskin_map 

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in armObj.data.edit_bones:
            bone = boneObj.name
            boneObj.name = old_new[bone]

        new_rename = {}
        new_reskin = {}
        for anchor in rename_map:
            
            tbone = rename_map[anchor]
            new_anchor = tbone + "_" + old_new[anchor]

            new_rename[new_anchor] = tbone

            temp_anchor = old_new[anchor]
            armObj.data.edit_bones[temp_anchor].name = new_anchor
            if anchor in reskin_map:
                new_reskin[new_anchor] = []
                for rbone in reskin_map[anchor]:
                    new_reskin[new_anchor].append(old_new[rbone])
        bpy.ops.object.mode_set(mode='OBJECT')

        new_pose = {}
        for bone in pose_map:
            new_pbone = old_new[bone]
            new_pose[new_pbone] = pose_map[bone]

        armObj['bb_onemap_rename'] = new_rename
        if len(new_reskin) > 0:
            armObj['bb_onemap_reskin'] = new_reskin
        if len(new_pose) > 0:
            armObj['bb_onemap_pose'] = new_pose

        return {'FINISHED'}

class OnigiriOnemapMapRemoveUnused(bpy.types.Operator):
    """Remove unused bones from the map.  This may not be what you want unless your map
has grown large over time where there are just too many unmappable bones for the expected
rigs you'll be working with.  Make sure your selected rig is the one you want"""

    bl_idname = "onigiri.onemap_remove_unused"
    bl_label = "Remove Unused"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_onemap = bpy.context.scene.bb_onemap
        armObj = bpy.context.selected_objects[0]
        utils.activate(armObj)
        rename_map = armObj['bb_onemap_rename']
        reskin_map = armObj.get('bb_onemap_reskin', {})
        pose_map = armObj.get('bb_onemap_pose', {})

        bad_bones = []
        for bone in rename_map:
            if bone not in armObj.data.bones:
                bad_bones.append(bone)
        for bone in bad_bones:
            rename_map.pop(bone)
            reskin_map.pop(bone, '')
        bad_bones = []
        for bone in pose_map:
            if bone not in armObj.data.bones:
                bad_bones.append(bone)
        for bone in bad_bones:
            pose_map.pop(bone, '')

        new_reskin_map = {}
        for anchor in reskin_map:
            reskin = reskin_map[anchor]
            for rbone in reskin:
                if rbone not in armObj.data.bones:
                    continue
                if anchor not in new_reskin_map:
                    new_reskin_map[anchor] = []
                new_reskin_map[anchor].append(rbone)
        reskin_map = new_reskin_map 

        if len(bad_bones) > 0:
            print("The following references were removed from the maps:")
            for bone in bad_bones:
                print(" -", bone)
            popup("Some references were removed, see System Console", "Info", "INFO")
        else:
            print("There were no bad references")

        armObj['bb_onemap_rename'] = rename_map
        if len(reskin_map) > 0:
            armObj['bb_onemap_reskin'] = reskin_map
        if len(pose_map) > 0:
            armObj['bb_onemap_pose'] = pose_map

        return {'FINISHED'}

class OnigiriSnapProperties(bpy.types.PropertyGroup):

    def update_snap_blank(self, context):
        bpy.context.window_manager.bb_snap["snap_blank"] = False
    snap_blank : bpy.props.BoolProperty(
        default = False,
        update = update_snap_blank
        )

    snap_export_mapped_old : bpy.props.BoolProperty(
        name = "",
        description =            "Enable this if you want the old behavior back"            "\n\n"            "The custom character exporter has evolved over time just as the SL skinned mesh exporter has.  They have grown out "            "of sync, however, and the similarities between the two types of exports have drifted that I decided to test the new "            "devkit mesh exporter on this type of set and it worked.  I'm leaving in the ability to use the old type in case the new "            "one has unforeseen bugs and it's not bad for testing.  There are limitations to the old type and one of which is that "            "there is no (Export path to pelvis) calculations done so keep that in mind, it could ruin your day",
        default = False
        )

    snap_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description = "Enable view of visual map options (Snap Mapper)",
        default = False
        )
    snap_mapped_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description = "Enable view of mapped bones",
        default = False
        )
    snap_fill_protect : bpy.props.BoolProperty(
        name = "",
        description =            "The chain mapper (fill) will stop when it encounters an already mapped bone.  This feature makes sure of that.  "            "If you don't care that it overwrites your existing maps then turn this off.",
        default = True
        )
    snap_fill_cross : bpy.props.BoolProperty(
        name = "",
        description =            "When (save/protect) is enabled so that you don't overwrite your existing mapped bones you can allow the fill mapper "            "to jump over them and continue mapping if this is enabled.",
        default = False
        )
    snap_fill_limit : bpy.props.IntProperty(
        name = "",
        description =            "Maximum number of child links to follow.  A 0 means infinite.  A 1 is equal to what the mapper already does but "            "I allowed it here to test the speed of the feature.  A 2 is the minimum amount of effective links where this feature "            "is useful and a 0 is, of course, no limit.",
        min = 0,
        default = 0
        )
    snap_fill_next : bpy.props.BoolProperty(
        name = "",
        description =            "When you're doing a (Fill) or (Collect) it's nice to keep working with the bone bag and just choose another sequence "            "parent to fill the target instead of going back and forth.  With this feature enabled the targets next parent in the "            "hierarchy will be selected and placed in the selected Directors bone slot ready for you to keep picking.  If there is "            "no parent then nothing happens.  If you have (Protect) enabled and the very next parent is a mapped bone it ends.",
        default = True
        )
    snap_deformable : bpy.props.BoolProperty(
        name = "",
        description =            "Only allow mapping of bones that affect the mesh (use_deform == True). This prevents your IK and extraneous controllers from "            "getting into the mix and wasting bones."            "\n\n"            "If you want to map attachment bones you need to enable their deform property first.  To do this go into the panel named "            "(Skinning / Weights) and look at the toggle switch named (Skin to Attachments on / off).  If the indicator is red then "            "click it to turn it green.  If you are having trouble there could be a synch issue, just toggle it once then back to green",
        default = True
        )
    snap_release : bpy.props.BoolProperty(
        name = "",
        description =            "With this enabled your Actor bones will stay where they are placed, if they are not mapped back to their original position "            "when you unmap them.  This allows you to move your Actor bones around for convenient visual sorting without them snapping "            "back to their default locations.  If you map a bone it is released from this modify state when you unmap it so that your "            "your visual is consistent with what is mapped and what is not mapped.",
        default = False
        )

    def update_snap_follow(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        if len(bpy.context.selected_objects) == 0:
            bb_snap["snap_follow"] = False
        o = bpy.context.selected_objects[0]
        inRig = snap.get_director(armature=o.name)
        if inRig == False:
            bb_snap["snap_follow"] = False
            return
        bb_snap["snap_lead"] = False
        outRig = inRig['bb_snap_actor']
        
        snap.apply_map(director=inRig, actor=outRig)
    snap_follow : bpy.props.BoolProperty(
        name = "",
        description = "With this enabled the mapped bones will immediately follow the Director when animated",
        default = True,
        update = update_snap_follow
        )
    def update_snap_lead(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        if len(bpy.context.selected_objects) == 0:
            bb_snap["snap_lead"] = False
        o = bpy.context.selected_objects[0]
        inRig = snap.get_director(armature=o.name)
        if inRig == False:
            bb_snap["snap_lead"] = False
            return
        bb_snap["snap_follow"] = False
        outRig = inRig['bb_snap_actor']
        
        snap.apply_map(director=inRig, actor=outRig)
    snap_lead : bpy.props.BoolProperty(
        name = "",
        description = "With this enabled the Director bones will follow the actor bones when animated or otherwise moved",
        default = False,
        update = update_snap_lead
        )

    def update_snap_symmetry_enabled(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        
        if self.snap_symmetry_enabled == False:
            if bb_snap.snap_symmetry_director == False:
                snap.props['director_side_a'] = ""
                snap.props['director_side_b'] = ""
                snap.props['director_side_difference'] = ""
                snap.props['director_symmetry_display'] = ""
            if bb_snap.snap_symmetry_actor == False:
                snap.props['actor_side_a'] = ""
                snap.props['actor_side_b'] = ""
                snap.props['actor_side_difference'] = ""
                snap.props['actor_symmetry_display'] = ""

    snap_symmetry_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Enable Symmetry"            "\n\n"            "If you've chosen a pair for each rig then symmetry will be attempted.  This can fail and then you'll have to "            "manually do the other side but it should not fail often if it's a good rig.",
       default = False
        )

    def update_snap_symmetry_director(self, context):
        if self.snap_symmetry_director == True:
            if snap.props['director_side_a'] == "" or snap.props['director_side_b'] == "":
                self["snap_symmetry_director"] = False
            else:
                
                result = snap.get_difference(snap.props['director_side_a'], snap.props['director_side_a'])
                if result == False:
                    print("The bones chosen were not compatible as a symmetric pair")
                    print(snap.props['director_side_a'])
                    print(snap.props['director_side_b'])
                    
                    self.snap_symmetry_director = False
                else:
                    snap.props['director_symmetry_display'] = "Locked"

        else:
            snap.props['director_side_a'] = ""
            snap.props['director_side_b'] = ""
            snap.props['director_side_difference'] = ""
            snap.props['director_symmetry_display'] = "Choose Side A"
            snap.props['last_selected_director_bone'] = ""
            for o in bpy.context.selected_objects:
                if o.type == 'ARMATURE':
                    for boneObj in o.data.bones:
                        boneObj.select = False
    def update_snap_symmetry_actor(self, context):
        if self.snap_symmetry_actor == True:
            if snap.props['actor_side_a'] == "" or snap.props['actor_side_b'] == "":
                self["snap_symmetry_actor"] = False
            else:
                result = snap.get_difference(snap.props['director_side_a'], snap.props['director_side_a'])
                if result == False:
                    print("The bones chosen were not compatible as a symmetric pair")
                    print(snap.props['actor_side_a'])
                    print(snap.props['actor_side_b'])
                    
                    self.snap_symmetry_actor = False
                else:
                    snap.props['actor_symmetry_display'] = "Locked"
        else:
            snap.props['actor_side_a'] = ""
            snap.props['actor_side_b'] = ""
            snap.props['actor_side_difference'] = ""
            snap.props['actor_symmetry_display'] = "Choose Side A"
            snap.props['last_selected_actor_bone'] = ""
            for o in bpy.context.selected_objects:
                if o.type == 'ARMATURE':
                    for boneObj in o.data.bones:
                        boneObj.select = False

    snap_symmetry_director : bpy.props.BoolProperty(
        name = "",
        description =            "Choose first director bone",
        default = False,
        update = update_snap_symmetry_director
        )
    snap_symmetry_actor : bpy.props.BoolProperty(
        name = "",
        description =            "Choose first actor bone",
        default = False,
        update = update_snap_symmetry_actor
        )

    snap_distance : bpy.props.FloatProperty(
        name = "",
        description = "Distance between actor and director",
        default = 0.6
        )
    snap_message : bpy.props.StringProperty(
        name = "",
        description = "--internal",
        default = ""
        )
    snap_template_name : bpy.props.StringProperty(
        name = "",
        description = "--internal",
        default = ""
        )
    
    def update_snap_target(self, context):
        state = self.snap_target
        if len(bpy.context.selected_objects) != 1:
            self["snap_target"] = not state 
            return
        o = bpy.context.selected_objects[0]
        
        inRig = snap.get_director(armature=o.name)
        if inRig != False:
            self["snap_target"] = False
            return
        
        if o.type != 'ARMATURE':
            self["snap_target"] = False
            return
        
        if o.get('bb_snap_actor') != None or o.get('bb_snap_director') != None:
            self["snap_target"] = not state 
            return
        if self.snap_target == True:
            self.snap_target_name = o.name
            return
        else:
            self.snap_target_name = ""
        return
    snap_target : bpy.props.BoolProperty(
        name = "",
        description =            "Target platform is other than SL/OS"            "\n\n"            "Select your target platform rig and enable this, your rig name will be recorded and then you'll choose "            "the custom rig and click (Action!)."            "\n\n"            "For convenience it's assumed that the target platform is Second Life or Opensim but this button allows you "            "to choose a rig instead of having one automatically generated, where that rig will be your target platform rig "            "and will be recorded when you enable this button.",
        default = False,
        update = update_snap_target
        )
    snap_target_name : bpy.props.StringProperty(
        name = "",
        description = "--internal",
        default = "",
        )

class OnigiriSnapMesh(bpy.types.Operator):
    """Show / Hide associated mesh"""

    bl_idname = "onigiri.snap_mesh"
    bl_label = "Mesh Hide / Show"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.active_object.name)
        if inRig == False:
            
            print("No snap director, trying motion director")
            inRig = motion.get_director(bpy.context.active_object)
            if inRig == False:
                print("The Director rig is not available, trying selected rig.")
                inRig = bpy.context.selected_objects[0]

        if self.action == "hide":
            state = True
        elif self.action == "show":
            state = False
        else:
            print("unknown state, this is a bug")
            return {'FINISHED'}

        print("OnigiriSnapMesh show/hide new function includes children/skinned .")
        utils.view_associated_mesh(armature=inRig.name, view=state, children=True, skinned=True)

        return {'FINISHED'}

class OnigiriSnapViewActorBones(bpy.types.Operator):
    """Show all bones or restore the bone view of the target system (Actor) rig, if present"""

    bl_idname = "onigiri.snap_view_actor_bones"
    bl_label = "Show / Hide bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.selected_objects[0].name)
        if inRig == False:
            print("The Director rig is not available, this is a programming error")
            return {'FINISHED'}
        outRig = inRig['bb_snap_actor']
        if self.action == "show":
            for boneObj in outRig.data.bones:
                boneObj.hide = False
        else:
            rigutils.show_bones(armature=outRig, default=True)

        return {'FINISHED'}

class OnigiriSnapDeformDirectorBones(bpy.types.Operator):
    """Enable or Disable the deformable property of a bone.  These are bones that, while they exist, will not
be exported with the animation and, if set properly, neither the mesh.  They also will not influence the
mesh deformations"""

    bl_idname = "onigiri.snap_deform_director_bones"
    bl_label = "Eneble / Disable deformable"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        armObj = bpy.context.selected_objects[0]
        
        inRig = snap.get_director(armObj)
        if inRig != False:
            armObj = inRig

        if self.action == "enable":
            if bpy.context.selected_pose_bones:
                for boneObj in bpy.context.selected_pose_bones:
                    print("Setting bone", boneObj.name, "from", boneObj.bone.use_deform, "to True")
                    boneObj.bone.use_deform = True
            else:
                print("No pose bones selected")
                popup("Select pose bones to set as deform, there are none selected", "Info", "INFO")
                return {'FINISHED'}

        elif self.action == "disable":
            for boneObj in bpy.context.selected_pose_bones:
                print("Setting bone", boneObj.name, "from", boneObj.bone.use_deform, "to False")
                boneObj.bone.use_deform = False
        else:
            print("Unknown action:", self.action)

        print("Done!")

        return {'FINISHED'}

class OnigiriSnapViewDirectorBones(bpy.types.Operator):
    """Some bones on your character (Director) may be hidden making it difficult to understand which ones
to map.  Use these buttons to reveal or restore those states.  (Show Deformable) bones, this is probably
what you want, (Hide Erroneous), you may want this as well.  You can (Restore) if you like"""

    bl_idname = "onigiri.snap_view_director_bones"
    bl_label = "Show / Hide bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        armObj = bpy.context.selected_objects[0]
        
        inRig = snap.get_director(armObj)
        if inRig != False:
            armObj = inRig

        rigutils.set_deform_view(armObj, action=self.action)

        print("Done!")

        return {'FINISHED'}

class OnigiriSnapViewMappedBones(bpy.types.Operator):
    """A set of buttoms to hide and show the mapped bones.  This is convenient when a rig is very complicated
and you want to clear to view to see which bones are left that are unmapped."""

    bl_idname = "onigiri.snap_view_mapped_bones"
    bl_label = "Hide / Show mapped bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        armObj = bpy.context.selected_objects[0]

        inRig = snap.get_director(armObj)
        if inRig == False:
            print("There's no director so there's nothing engaged to hide")
            popup("I couldn't find the director, is the mapper engaged?", "Error", "ERROR")
            return {'FINISHED'}

        outRig = inRig['bb_snap_actor']

        print("Found outRig:", outRig.name)

        if inRig.get('bb_onemap_rename') == None:
            rename_map = {}
        else:
            rename_map = inRig.get('bb_onemap_rename')

        if self.action == "hide":
            state = True
        elif self.action == "show":
            state = False
        else:
            print("Unknown action")
            return {'FINISHED'}

        rename_rev = {}
        for sbone in rename_map.keys():
            tbone = rename_map[sbone]
            rename_rev[tbone] = sbone

        for sbone in rename_map.keys():
            if sbone in inRig.data.bones:
                inRig.data.bones[sbone].hide = state
            tbone = rename_map[sbone]
            if tbone in outRig.data.bones:
                outRig.data.bones[tbone].hide = state

        return {'FINISHED'}

class OnigiriOnemapViewActorBones(bpy.types.Operator):
    """Show all bones or restore the bone view of the target system (Actor) rig, if present"""

    bl_idname = "onigiri.onemap_view_actor_bones"
    bl_label = "Show / Hide bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
        if inRig == False:
            print("The Director rig is not available, this is a programming error")
            return {'FINISHED'}
        outRig = inRig['bb_onemap_actor']
        if self.action == "show":
            for boneObj in outRig.data.bones:
                boneObj.hide = False
        else:
            rigutils.show_bones(armature=outRig, default=True)

        return {'FINISHED'}

class OnigiriOnemapViewDirectorBones(bpy.types.Operator):
    """Some bones on your character (Director) may be hidden making it difficult to understand which ones
to map.  Use these buttons to reveal or restore those states.  (Show Deformable) bones, this is probably
what you want, (Hide Erroneous), you may want this as well.  You can (Restore) if you like"""

    bl_idname = "onigiri.onemap_view_director_bones"
    bl_label = "Show / Hide bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        armObj = bpy.context.selected_objects[0]
        
        inRig = onemap.get_director(armObj)
        if inRig != False:
            armObj = inRig

        rigutils.set_deform_view(armObj, action=self.action)

        print("Done!")

        return {'FINISHED'}

class OnigiriSnapMapCollect(bpy.types.Operator):
    """This will map the selected bones to the recorded Director and walk down the hierarchy depositing
them until there are no more selected bones left.  This may work in production but I put it here for
prototype work and debugging"""

    bl_idname = "onigiri.snap_map_collect"
    bl_label = "Map selected bones"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        if snap.props['director_bone'] == "":
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.active_object.name)
        if inRig == False:
            print("The Director rig is not available, this is a programming error")
            return {'FINISHED'}
        outRig = inRig['bb_snap_actor']

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}

        director_bone = snap.props['director_bone']
        
        actor_bones = [] 
        director_bones_list = []
        
        for boneObj in bpy.context.selected_pose_bones:
            if boneObj.id_data == outRig:
                actor_bones.append(boneObj.name)

        if len(actor_bones) == 0:
            print("No actor bones selected for mapping using this feature")
            return {'FINISHED'}

        cBone = inRig.pose.bones[director_bone]
        while cBone != None:
            director_bones_list.append(cBone.name)
            cBone = cBone.parent

        director_bones = {}
        for bone in reversed(director_bones_list):
            
            if bb_snap.snap_deformable == True:
                if inRig.data.bones[bone].use_deform == False:
                    continue
            director_bones[bone] = ""

        rename_map = inRig['bb_onemap_rename']

        snap.props['undo'] = inRig['bb_onemap_rename'].to_dict()

        rename_rev = {}
        for sbone in rename_map.keys():
            tbone = rename_map[sbone]
            rename_rev[tbone] = sbone

        director_bone = None
        count = 0
        for actor_bone in actor_bones:
            
            if bb_snap.snap_fill_limit != 0 and count == bb_snap.snap_fill_limit:
                break
            if len(director_bones) == 0:
                break

            if bb_snap.snap_fill_protect == True:
                if actor_bone in rename_rev:
                    continue

            dcount = len(director_bones)
            director_bone = None
            for c in range(dcount):
                bone, Nothing = director_bones.popitem()
                if bb_snap.snap_fill_protect == True:
                    if bone in rename_map:
                        continue

                director_bone = bone
                break
            
            if director_bone == None:
                break
            snap.props['actor_bone'] = actor_bone
            snap.props['director_bone'] = director_bone
            rename_map[director_bone] = actor_bone
            snap.apply_map(director=inRig, actor=outRig)
            count += 1

        snap.props['actor_bone'] = ""
        snap.props['director_bone'] = ""

        if bb_snap.snap_fill_next == True:
            if director_bone != None:
                if inRig.pose.bones[director_bone].parent:
                    boneObj = inRig.pose.bones[director_bone].parent
                    bone = boneObj.name
                    
                    if bb_snap.snap_fill_protect == True:
                        if bone not in rename_map:
                            boneObj.bone.select = True
                            snap.props['director_bone'] = bone
                    else:
                        boneObj.bone.select = True
                        snap.props['director_bone'] = bone

        return {'FINISHED'}

class OnigiriSnapMapDeposit(bpy.types.Operator):
    """Make sure one of your Director bones is active then you can select multiple director bones to deposit
Actor bones onto them.  This is required when you want to map a set of bones that are not parented"""

    bl_idname = "onigiri.snap_map_deposit"
    bl_label = "Deposit selected bones"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.active_object.name)
        if inRig == False:
            print("The Director rig is not available, this is a programming error")
            return {'FINISHED'}
        outRig = inRig['bb_snap_actor']

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}

        actor_bones = [] 
        director_bones_list = []
        
        for boneObj in bpy.context.selected_pose_bones:
            if boneObj.id_data == outRig:
                
                if outRig.get('onigiri') == None:
                    
                    if bb_snap.snap_deformable == True:
                        if boneObj.bone.use_deform == False:
                            print("Skipping non-deformabone bone:", boneObj.name)
                            continue
                actor_bones.append(boneObj.name)

            if boneObj.id_data == inRig:
                director_bones_list.append(boneObj.name)
            
        if len(actor_bones) == 0:
            print("No actor bones selected for mapping using this feature")
            return {'FINISHED'}

        director_bones = {}
        for bone in reversed(director_bones_list):
            
            if bb_snap.snap_deformable == True:
                if inRig.data.bones[bone].use_deform == False:
                    continue
            director_bones[bone] = ""

        rename_map = inRig['bb_onemap_rename']

        snap.props['undo'] = inRig['bb_onemap_rename'].to_dict()

        rename_rev = {}
        for sbone in rename_map.keys():
            tbone = rename_map[sbone]
            rename_rev[tbone] = sbone

        director_bone = None
        count = 0
        for actor_bone in actor_bones:
            
            if bb_snap.snap_fill_limit != 0 and count == bb_snap.snap_fill_limit:
                break
            if len(director_bones) == 0:
                break

            if bb_snap.snap_fill_protect == True:
                if actor_bone in rename_rev:
                    continue

            dcount = len(director_bones)
            director_bone = None
            for c in range(dcount):
                bone, Nothing = director_bones.popitem()
                if bb_snap.snap_fill_protect == True:
                    if bone in rename_map:
                        continue

                director_bone = bone
                break
            
            if director_bone == None:
                break
            snap.props['actor_bone'] = actor_bone
            snap.props['director_bone'] = director_bone
            rename_map[director_bone] = actor_bone
            snap.apply_map(director=inRig, actor=outRig)
            count += 1

        snap.props['actor_bone'] = ""
        snap.props['director_bone'] = ""

        if 1 == 0:
        
            if director_bone != None:
                if inRig.pose.bones[director_bone].parent:
                    boneObj = inRig.pose.bones[director_bone].parent
                    bone = boneObj.name
                    
                    if bb_snap.snap_fill_protect == True:
                        if bone not in rename_map:
                            boneObj.bone.select = True
                            snap.props['director_bone'] = bone
                    else:
                        boneObj.bone.select = True
                        snap.props['director_bone'] = bone

        return {'FINISHED'}

class OnigiriSnapMapFill(bpy.types.Operator):
    """This is a map button but follows a chain of child to parent bones until it reaches a terminator, your
maximum chosen or a mapped bone.  You can turn off (safe) to allow it to overwrite your already
mapped bones if you want"""

    bl_idname = "onigiri.snap_map_fill"
    bl_label = "Map by hierarchy"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        if snap.props['actor_bone'] == "" or snap.props['director_bone'] == "":
            return False
        if len(bpy.context.selected_pose_bones) != 1:
            return
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.active_object.name)
        if inRig == False:
            print("The Director rig is not available, this is a programming error")
            return {'FINISHED'}
        outRig = inRig['bb_snap_actor']
        relations = outRig['bb_snap_relations']

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}

        actor_bone = snap.props['actor_bone']
        director_bone = snap.props['director_bone']
        actor_bones = [] 
        director_bones_list = []

        cbone = outRig.pose.bones[actor_bone].name
        while True:
            
            pbone = relations[cbone]['parent']
            if pbone == "":
                break
            actor_bones.append(cbone)
            cbone = pbone

        cBone = inRig.pose.bones[director_bone]
        while cBone != None:
            director_bones_list.append(cBone.name)
            cBone = cBone.parent

        director_bones = {}
        for bone in reversed(director_bones_list):
            
            if bb_snap.snap_deformable == True:
                if inRig.data.bones[bone].use_deform == False:
                    print("Skipping non deform bone:", bone)
                    continue
            director_bones[bone] = ""

        rename_map = inRig['bb_onemap_rename']

        snap.props['undo'] = inRig['bb_onemap_rename'].to_dict()

        rename_rev = {}
        for sbone in rename_map.keys():
            tbone = rename_map[sbone]
            rename_rev[tbone] = sbone

        director_bone = None
        count = 0
        for actor_bone in actor_bones:
            
            if bb_snap.snap_fill_limit != 0 and count == bb_snap.snap_fill_limit:
                break
            if len(director_bones) == 0:
                break
            
            if bb_snap.snap_fill_protect == True:
                if actor_bone in rename_rev:
                    if bb_snap.snap_fill_cross == False:
                        break
                    continue

            dcount = len(director_bones)
            
            director_bone = None
            for c in range(dcount):
                bone, Nothing = director_bones.popitem()

                if bb_snap.snap_fill_protect == True:
                    if bone in rename_map:
                        if bb_snap.snap_fill_cross == False:
                            break
                        continue
                director_bone = bone
                break
            
            if director_bone == None:
                break
            snap.props['actor_bone'] = actor_bone
            snap.props['director_bone'] = director_bone
            rename_map[director_bone] = actor_bone
            snap.update_map(inRig=inRig, anchor=director_bone, target=actor_bone, report=True)
            snap.apply_map(director=inRig, actor=outRig)
            count += 1

        snap.props['actor_bone'] = ""
        snap.props['director_bone'] = ""

        if bb_snap.snap_fill_next == True:
            if director_bone != None:
                if inRig.pose.bones[director_bone].parent:
                    boneObj = inRig.pose.bones[director_bone].parent
                    bone = boneObj.name
                    
                    if bb_snap.snap_fill_protect == True:
                        if bone not in rename_map:
                            boneObj.bone.select = True
                            snap.props['director_bone'] = bone
                    else:
                        boneObj.bone.select = True
                        snap.props['director_bone'] = bone

        return {'FINISHED'}

class OnigiriSnapSelectEndBones(bpy.types.Operator):
    """This will select all end bones in the Actor rig, this adds to your selection if there is one, for
your convenience.  If you want only end bones then de-select by clicking off of the rig then use this, or
use (Deselect Non End Bones)"""

    bl_idname = "onigiri.snap_select_ends"
    bl_label = "Select End Bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.active_object.name)
        if inRig == False:
            print("The Director rig is not available, trying selected rig.")
            inRig = bpy.context.selected_objects[0]
        outRig = inRig['bb_snap_actor']

        relations = outRig.get('bb_snap_relations', None)

        if relations == None:
            print("Programming error possibly, no relationship data is available")
            popup("Relationship data missing, contact programmer", "Collect error", "ERROR")
            return {'FINISHED'}

        rename_map = inRig.get('bb_onemap_rename', {})
        if inRig.get('bb_onemap_rename') != None:
            rename_map = inRig['bb_onemap_rename'].to_dict()

        rename_rev = {}
        for dbone in rename_map:
            abone = rename_map[dbone]
            rename_rev[abone] = dbone

        for boneObj in outRig.pose.bones:
            bone = boneObj.name
            if boneObj.id_data == outRig:
                
                if boneObj.name == 'mSkull':
                    print("Skipping mSkull")
                    continue
                if bone not in relations:
                    print("Missing critical bone in relationship map:", bone)
                    continue
                if len(relations[bone]['children']) == 0:
                    
                    if skel.avatar_skeleton[bone]['type'] == 'collision':
                        continue
                    if skel.avatar_skeleton[bone]['type'] == 'attachment':
                        continue
                    
                    if bone not in rename_rev:
                        boneObj.bone.select = True

        print("selected ends")

        return {'FINISHED'}

class OnigiriSnapDeselectNonEndBones(bpy.types.Operator):
    """This will deselect all non end bones in your current selection"""

    bl_idname = "onigiri.snap_deselect_non_ends"
    bl_label = "Select Non End Bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.active_object.name)
        if inRig == False:
            print("The Director rig is not available, trying selected rig.")
            inRig = bpy.context.selected_objects[0]
        outRig = inRig['bb_snap_actor']

        relations = outRig.get('bb_snap_relations', None)

        if relations == None:
            print("Programming error possibly, no relationship data is available")
            popup("Relationship data missing, contact programmer", "Collect error", "ERROR")
            return {'FINISHED'}

        for boneObj in outRig.pose.bones:
            bone = boneObj.name
            if boneObj.id_data == outRig:
                if bone not in relations:
                    print("Missing critical bone in relationship map:", bone)
                    continue
                if len(relations[bone]['children']) > 0:
                    boneObj.bone.select = False

        print("deselected non ends")

        return {'FINISHED'}

class OnigiriSnapSelectVolumeBones(bpy.types.Operator):
    """Volume joints are selected as a result of selecting safe bones but if they are hidden
they are not used.  If you want to just select volume joints then make sure nothing
else is selected on the Actor and use this button"""

    bl_idname = "onigiri.snap_select_volume_bones"
    bl_label = "Select Volume Bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap

        inRig = snap.get_director(armature=bpy.context.active_object.name)

        if inRig == False:
            print("The Director rig is not available, trying selected rig.")
            inRig = bpy.context.selected_objects[0]
        outRig = inRig['bb_snap_actor']
        if outRig == None:
            print("Target is not available")
            popup("Target missing", "Error", "ERROR")
            return {'FINISHED'}

        for boneObj in outRig.data.bones:
            if boneObj.name in volumes.vol_joints:
                boneObj.select = True

        print("selected volume joints")

        return {'FINISHED'}

class OnigiriSnapSelectAttachBones(bpy.types.Operator):
    """You can animate all of the attachment bones.  You can skin to all of the attachment bones, LL seems to
have fixed the problem with uploading bones with spaces in them, Onigiri exports these bones using an
under_score to replace the space and the SL uploading apparently supports that now"""

    bl_idname = "onigiri.snap_select_attach_bones"
    bl_label = "Select Attachment Bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap

        inRig = snap.get_director(armature=bpy.context.active_object.name)

        if inRig == False:
            print("The Director rig is not available, trying selected rig.")
            inRig = bpy.context.selected_objects[0]
        outRig = inRig['bb_snap_actor']
        if outRig == None:
            print("Target is not available")
            popup("Target missing", "Error", "ERROR")
            return {'FINISHED'}

        for boneObj in outRig.data.bones:
            bone = boneObj.name
            if bone in skel.avatar_skeleton:
                if skel.avatar_skeleton[bone]['type'] == 'attachment':
                    boneObj.select = True

        print("selected attach joints")

        return {'FINISHED'}

class OnigiriSnapSelectDirectorBone(bpy.types.Operator):
    """
"""

    bl_idname = "onigiri.snap_select_director_bone"
    bl_label = "Select This Bone"

    bone : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.active_object.name)
        if inRig == False:
            print("The Director rig is not available, trying selected rig.")
            inRig = bpy.context.selected_objects[0]
        outRig = inRig['bb_snap_actor']

        for boneObj in inRig.data.bones:
            boneObj.select = False

        for boneObj in outRig.data.bones:
            boneObj.select = False

        inRig.data.bones[self.bone].select = True

        print("selected", self.bone)

        return {'FINISHED'}

class OnigiriSnapSelectActorBone(bpy.types.Operator):
    """
"""

    bl_idname = "onigiri.snap_select_actor_bone"
    bl_label = "Select This Bone"

    bone : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.active_object.name)
        if inRig == False:
            print("The Director rig is not available, trying selected rig.")
            inRig = bpy.context.selected_objects[0]
        outRig = inRig['bb_snap_actor']

        for boneObj in inRig.data.bones:
            boneObj.select = False

        for boneObj in outRig.data.bones:
            boneObj.select = False
        outRig.data.bones[self.bone].select = True

        print("selected", self.bone)

        return {'FINISHED'}

class OnigiriSnapMapAdd(bpy.types.Operator):
    """Map the chosen bones"""

    bl_idname = "onigiri.snap_map_add"
    bl_label = "Map the chosen bones"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        if snap.props['actor_bone'] == "" or snap.props['director_bone'] == "":
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.active_object.name)
        if inRig == False:
            print("The Director rig is not available, this is a programming error")
            return {'FINISHED'}
        outRig = inRig['bb_snap_actor']

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}

        snap.props['undo'] = inRig['bb_onemap_rename'].to_dict()

        actor_bone = snap.props['actor_bone']
        director_bone = snap.props['director_bone']

        if bb_snap.snap_deformable == True:
            if inRig.data.bones[director_bone].use_deform == False:
                print("snap_deforable is enabled but use_deform is False:", director_bone)
                popup("Deformable is enabled and the bone is not qualified")
                return {'FINISHED'}

        snap.update_map(inRig=inRig, anchor=director_bone, target=actor_bone, report=True)

        snap.apply_map(director=inRig, actor=outRig)

        snap.props['actor_bone'] = ""
        snap.props['director_bone'] = ""

        return {'FINISHED'}

class OnigiriSnapMapRemove(bpy.types.Operator):
    """Remove the selected bone from the map"""

    bl_idname = "onigiri.snap_map_remove"
    bl_label = "Remove selected bone"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.active_object.name)
        if inRig == False:
            print("The Director rig is not available, this is a programming error")
            return {'FINISHED'}
        outRig = inRig['bb_snap_actor']

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}

        directors = []
        actors = []
        for boneObj in bpy.context.selected_pose_bones:
            if boneObj.id_data == inRig:
                directors.append(boneObj.name)
            elif boneObj.id_data == outRig:
                actors.append(boneObj.name)
            else:
                print("Got an included bone that doesn't match the rigs, [bone/rig]:", boneObj.name, boneObj.id_data.name)

        rename_map = inRig['bb_onemap_rename']

        snap.props['undo'] = inRig['bb_onemap_rename'].to_dict()

        for bone in directors:
            rename_map.pop(bone, "")
        rename_map_rev = {}
        for sbone in rename_map:
            tbone = rename_map[sbone]
            rename_map_rev[tbone] = sbone
        for bone in actors:
            if bone in rename_map_rev:
                sbone = rename_map_rev[bone]
                rename_map.pop(sbone, "")
            
        inRig['bb_onemap_rename'] = rename_map

        snap.apply_map(director=inRig, actor=outRig)

        for boneObj in inRig.data.bones:
            boneObj.select = False
        for boneObj in outRig.data.bones:
            boneObj.select = False

        snap.props['actor_bone'] = ""
        snap.props['director_bone'] = ""

        return {'FINISHED'}

class OnigiriSnapMapRemoveSingle(bpy.types.Operator):
    """Remove this bone from the map"""

    bl_idname = "onigiri.snap_map_remove_single"
    bl_label = "Remove this bone"

    bone : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.active_object.name)
        if inRig == False:
            print("The Director rig is not available, this is a programming error")
            return {'FINISHED'}
        outRig = inRig['bb_snap_actor']

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}

        rename_map = inRig['bb_onemap_rename']
        rename_map.pop(self.bone, "")
        inRig['bb_onemap_rename'] = rename_map

        snap.apply_map(director=inRig, actor=outRig)

        for boneObj in inRig.data.bones:
            boneObj.select = False
        for boneObj in outRig.data.bones:
            boneObj.select = False

        snap.props['actor_bone'] = ""
        snap.props['director_bone'] = ""

        return {'FINISHED'}

class OnigiriSnapMapUndo(bpy.types.Operator):
    """Undo the most recent map.  This will revert the map back to
the one before the last bone map was applied"""

    bl_idname = "onigiri.snap_map_undo"
    bl_label = "Undo recent"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        if len(snap.props['undo']) == 0:
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        inRig = snap.get_director(armature=bpy.context.active_object.name)
        if inRig == False:
            print("The Director rig is not available, this is a programming error")
            return {'FINISHED'}
        outRig = inRig['bb_snap_actor']

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}

        rename_map = snap.props['undo'].copy()
        inRig['bb_onemap_rename'] = rename_map

        snap.apply_map(director=inRig, actor=outRig)

        for boneObj in inRig.data.bones:
            boneObj.select = False
        for boneObj in outRig.data.bones:
            boneObj.select = False

        snap.props['undo'] = {}
        snap.props['actor_bone'] = ""
        snap.props['director_bone'] = ""

        return {'FINISHED'}

class OnigiriSnapPrepare(bpy.types.Operator):
    """Your visual experience will suffer if your target platform rig is scaled, has an animation or is otherwise
transformed in any way.  This button fixes that but is destructive, save your work"""

    bl_idname = "onigiri.snap_prepare"
    bl_label = "Prepare Rig"

    quiet : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        armObj = bpy.context.selected_objects[0]
        frame_start = 1
        if armObj.animation_data:
            if armObj.animation_data.action:
                frame_start = armObj.animation_data.action.frame_range[0]
        bpy.context.scene.frame_set(frame_start)
        
        armObj.animation_data_clear()
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.transform_apply(scale=True, rotation=True, location=False)

        if self.quiet != "True":
            popup("Finished!", "Info", "INFO")

        return {'FINISHED'}

class OnigiriSnapAction(bpy.types.Operator):
    """Choose your Director / Character and click this.  I'll be referring to your awesome cool character as
the Director since it is in control of the Actor rig"""

    bl_idname = "onigiri.snap_action"
    bl_label = "Select a Director"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        
        inRig = snap.get_director(armature=bpy.context.selected_objects[0].name)
        if inRig == False:
            return True
        if inRig.get('bb_snap_actor') != None:
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap

        bpy.ops.object.mode_set(mode='OBJECT')

        inRig = bpy.context.selected_objects[0]

        state = utils.get_state()
        try:
            print("Resetting retargeter if it's engaged")
            bpy.ops.onigiri.motion_reset(report=False)
        except:
            print("Retargeter was not engaged")
        utils.set_state(state)
        
        if bb_snap.snap_target == True:
            if inRig.name == bb_snap.snap_target_name:
                print("Target and source are the same, this can't work")
                popup("Target and source are the same", "Error", "ERROR")
                return {'FINISHED'}

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in inRig.data.edit_bones:
            boneObj.use_connect = False
        bpy.ops.object.mode_set(mode='OBJECT')

        if bb_snap.snap_target == False:
            outRig = rigutils.build_rig(rig_class="pos", rotate=True)
        else:
            inRig.select_set(False)
            outRig = bpy.data.objects[bb_snap.snap_target_name]
            outRig.select_set(True)
            utils.activate(outRig)

            print("Custom rig targets will be damaged from this action, animations cannot survive the pre-processing")
            print("-")
            print("Unlinking animation data...")
            JUNK, JUNK = animutils.get_frame_range(outRig, start=True)
            outRig.animation_data_clear()
            print("Applying rest pose...")
            rigutils.apply_pose(outRig)
            print("-")

        recover_data = {}
        for boneObj in outRig.pose.bones:
            dBone = boneObj.bone
            bone = boneObj.name
            recover_data[bone] = {}
            recover_data[bone]['matrix'] = boneObj.matrix.copy()
            parent = ""
            if dBone.parent:
                parent = dBone.parent.name
            recover_data[bone]['parent'] = parent

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in outRig.data.edit_bones:
            bone = boneObj.name
            recover_data[bone]['head'] = boneObj.head.copy()
            recover_data[bone]['tail'] = boneObj.tail.copy()
            recover_data[bone]['roll'] = boneObj.roll

        bpy.ops.object.mode_set(mode='OBJECT')
        outRig['bb_snap_recover'] = recover_data
        outRig['bb_snap_display'] = outRig.data.display_type
        inRig['bb_snap_display'] = inRig.data.display_type

        relations = snap.get_relations(outRig)
        outRig['bb_snap_relations'] = relations

        inRig['bb_snap_actor'] = outRig
        outRig['bb_snap_director'] = inRig

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in outRig.data.edit_bones:
            boneObj.use_connect = False
            boneObj.parent = None
        bpy.ops.object.mode_set(mode='OBJECT')
        
        if bb_snap.snap_target == False:
            for boneObj in outRig.data.bones:
                if boneObj.name in volumes.vol_joints:
                    boneObj.hide=True

        loc = inRig.location.y
        loc += bb_snap.snap_distance
        outRig.location.y = loc

        inRig.data.display_type = 'OCTAHEDRAL'
        inRig['bb_show_in_front'] = inRig.show_in_front
        inRig.show_in_front = False
        outRig.data.display_type = 'STICK'
        outRig.show_in_front = True

        con_DISCARD = rigutils.add_empty_constraints(source=outRig.name, target=inRig.name, transform='COPY_LOCATION', space='WORLD', influence=0)
        con_DISCARD = rigutils.add_empty_constraints(source=outRig.name, target=inRig.name, transform='COPY_ROTATION', space='WORLD', influence=0)

        bone_data_DISCARD = rigutils.get_bone_data(
            armature=inRig.name, deform_only=False, store=True, rotation=True, location=False, scale=True, pose=True)
        bone_data_DISCARD = rigutils.get_bone_data(
            armature=outRig.name, deform_only=False, store=True, rotation=False, location=False, scale=False)

        inRig.select_set(True)
        outRig.select_set(True)

        for g in inRig.pose.bone_groups:
            inRig.pose.bone_groups.remove(g)
        for g in outRig.pose.bone_groups:
            outRig.pose.bone_groups.remove(g)

        bpy.ops.object.mode_set(mode='POSE')

        bpy.context.view_layer.objects.active = inRig
        bpy.ops.pose.group_add()
        inRig.pose.bone_groups.active.name = snap.props['director_group_base']
        inRig.pose.bone_groups.active.color_set = snap.props['director_theme_base']
        bpy.ops.pose.group_add()
        inRig.pose.bone_groups.active.name = snap.props['director_group_mapped']
        inRig.pose.bone_groups.active.color_set = snap.props['director_theme_mapped']

        bpy.context.view_layer.objects.active = outRig
        bpy.ops.pose.group_add()
        outRig.pose.bone_groups.active.name = snap.props['actor_group_base']
        outRig.pose.bone_groups.active.color_set = snap.props['actor_theme_base']
        bpy.ops.pose.group_add()
        outRig.pose.bone_groups.active.name = snap.props['actor_group_mapped']
        outRig.pose.bone_groups.active.color_set = snap.props['actor_theme_mapped']

        snap.apply_map(director=inRig, actor=outRig)

        if 1 == 0:
            for boneObj in inRig.data.bones:
                boneObj.select = False
            for boneObj in outRig.data.bones:
                boneObj.select = False

            snap.props['actor_bone'] = ""
            snap.props['director_bone'] = ""
            bb_snap.snap_message = "Start picking"

        return {'FINISHED'}

class OnigiriSnapNuke(bpy.types.Operator):
    """Blender is still not ready, if you open up the System Console you will see the errors fly by sometimes.
This tool is a scene wide cleaner and will destroy your hard work BE CAREFUL!  This tools is here to remove
all influences and controllers that may slow down the mapping process"""

    bl_idname = "onigiri.snap_nuke"
    bl_label = "Nuke Controllers"

    def execute(self, context):
        state = utils.get_state()

        utils.nuke_controllers()

        print("Operation Nuke Completed!  Have a nice day ]o/")
        utils.set_state(state)
        return {'FINISHED'}

class OnigiriSnapDestroy(bpy.types.Operator):
    """Destroy Map Data.  This will find all associated items with a selected rig or a single mesh and
remove all mapped data associated with it and their flags"""

    bl_idname = "onigiri.snap_destroy"
    bl_label = "Destroy Mapped Data"

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                armObj = snap.get_director(armature=o.name)
                if armObj != False:
                    for k in armObj.keys():
                        armObj.pop(k, "")
        for o in bpy.context.selected_objects:
            for k in o.keys():
                o.pop(k, "")
        arms = []
        for o in bpy.context.selected_objects:
            for mObj in o.modifiers:
                if mObj.type == 'ARMATURE':
                    arms.append(mObj.object)
        for o in arms:
            for k in o.keys():
                o.pop(k, "")

        return {'FINISHED'}

class OnigiriSnapClean(bpy.types.Operator):
    """Clean out the map data"""

    bl_idname = "onigiri.snap_clean"
    bl_label = "Clear maps"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        armObj = bpy.context.selected_objects[0]
        inRig = snap.get_director(armature=armObj.name)
        if inRig != False:
            outRig = inRig['bb_snap_actor']
            
            inRig['bb_onemap_rename'] = {}
            snap.apply_map(director=inRig, actor=outRig)
            inRig.pop('bb_onemap_rename', [])
            inRig.pop('bb_onemap_reskin', [])
            inRig.pop('bb_onemap_pose', [])
            inRig.pop('bb_onemap_code', [])
            inRig.pop('bb_snap_map', [])
            inRig.pop('bb_snap_follow', [])
        else:
            inRig = armObj
            inRig.pop('bb_onemap_rename', [])
            inRig.pop('bb_onemap_reskin', [])
            inRig.pop('bb_onemap_pose', [])
            inRig.pop('bb_onemap_code', [])
            inRig.pop('bb_snap_map', [])
            inRig.pop('bb_snap_follow', [])

        return {'FINISHED'}

class OnigiriSnapReset(bpy.types.Operator):
    """Reset the state, you will lose all data so save your map if you want it"""

    bl_idname = "onigiri.snap_reset"
    bl_label = "Reset everything"

    report : bpy.props.BoolProperty(default=True)

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        armObj = bpy.context.selected_objects[0]

        state = utils.get_state()

        inRig = snap.get_director(armature=armObj.name)
        if inRig == False:
            print("Nothing to do, can't find a pair, no Director")
            popup("Can't find an engaged set", "Error", "ERROR")
            utils.set_state(state)
            return {'FINISHED'}

        outRig = inRig.get('bb_snap_actor')
        if outRig != None:
            if outRig.name in bpy.context.scene.objects:
                
                outRig.pop('bb_snap_director', '')
                inRig.pop('bb_snap_actor', '')

        inRig.pop('bb_onemap_reskin', [])
        inRig.pop('bb_onemap_pose', [])
        inRig.pop('bb_onemap_code', [])
        inRig.pop('bb_snap_actor', [])
        inRig.pop('bb_snap_map', [])
        inRig.pop('bb_snap_follow', [])
        if inRig.get('bb_snap_display'):
            inRig.data.display_type = inRig['bb_snap_display']
            inRig.pop('bb_snap_display', "")
            inRig.show_in_front = inRig.pop('bb_show_in_front', True)

        if outRig != None:
            for o in bpy.context.selected_objects:
                o.select_set(False)
            
            outRig.select_set(True)
            bpy.context.view_layer.objects.active = outRig
            for boneObj in outRig.pose.bones:
                for C in boneObj.constraints:
                    boneObj.constraints.remove(C)
            recover_data = outRig['bb_snap_recover']
            bpy.ops.object.mode_set(mode='EDIT')
            for boneObj in outRig.data.edit_bones:
                boneObj.head = recover_data[boneObj.name]['head']
                boneObj.tail = recover_data[boneObj.name]['tail']
                boneObj.roll = recover_data[boneObj.name]['roll']
                parent = recover_data[boneObj.name]['parent']
                if parent != "":
                    boneObj.parent = outRig.data.edit_bones[parent]
            bpy.ops.object.mode_set(mode='OBJECT')
            outRig.data.display_type = outRig['bb_snap_display']
            for boneObj in outRig.pose.bones:
                boneObj.matrix = mathutils.Matrix(recover_data[boneObj.name]['matrix'])

            if bb_snap.snap_target == False:
                outRig.select_set(True)
            else:
                outRig.select_set(False)
                outRig.pop('bb_snap_relations', "")
            bpy.context.view_layer.objects.active = outRig
            bpy.ops.object.delete()
            inRig.select_set(True)
            bpy.context.view_layer.objects.active = inRig

        snap.props['actor_bone'] = ""
        snap.props['director_bone'] = ""

        bb_snap["snap_target"] = False
        bb_snap.snap_target_name = ""

        return {'FINISHED'}

class OnigiriSnapMapAcquire(bpy.types.Operator):
    """If your set is engaged in the Character Mapper / Retargeter section you can
use this button to get the details from there, then you can work on it here and/or
save it"""

    bl_idname = "onigiri.snap_acquire_map"
    bl_label = "Acquire Map"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        obj = bpy.data.objects

        mapObj = bpy.context.selected_objects[0] 

        inRig = snap.get_director(armature=mapObj.name)
        if inRig != False:
            mapObj = inRig
        else:
            print("Set does not contain a Director, loading map onto object instead")

        if mapObj.get('targets') != None:
            target = mapObj['targets'][0] 
            if target in bpy.context.scene.objects:
                mapObj = obj[target]
            else:
                print("Target 0 is not in the scene")
                popup("Target 0 is not in the scene")
                return {'FINISHED'}

        for o in bpy.context.selected_objects:
            o.select_set(False)
        mapObj.select_set(True)
        utils.activate(mapObj)

        if mapObj.get('bone_map') == None:
            print("No map to acquire")
            popup("No map to acquire", "Info", "INFO")
            return {'FINISHED'}

        rename = {}
        reskin = {}
        bone_map = {}
        template_map = mapObj['bone_map'].to_dict()

        for sbone in template_map:
            (tarm, tbone), = template_map[sbone].items()
            
            bone_map[sbone] = tbone

        mapObj['bb_onemap_rename'] = bone_map
        mapObj['bb_onemap_reskin'] = reskin

        all_input = set()
        for bone in rename:
            all_input.add(bone)
        for bone in reskin:
            all_input.add(bone)
            
            for rbone in reskin[bone]:
                all_input.add(rbone)
        for bone in bone_map:
            all_input.add(bone)

        mapObj['bb_snap_map'] = "[From Mapper]"

        if mapObj.type == 'ARMATURE':
            armObj = mapObj
            bad_bones = []
            good_bones = []
            for bone in all_input:
                if bone not in armObj.data.bones:
                    bad_bones.append(bone)
                else:
                    good_bones.append(bone)

            if len(good_bones) == 0:
                print("None of the bones in the loaded  map match your source rig")
                popup("None of the bones in the map matched", "Error", "ERROR")
            if len(bad_bones) > 0:
                print("Some bones did not match your source rig, see below:")
                print(bad_bones)

        if inRig != False:
            outRig = inRig['bb_snap_actor']
            snap.apply_map(director=inRig, actor=outRig)

        print("map acquired")
        return {'FINISHED'}

class OnigiriSnapMapApply(bpy.types.Operator, ImportHelper):
    """You can apply a map from here for convenience.  A map is meant to travel
with a rig unless you removed it so there may very well be a map already on the
associated rig"""

    bl_idname = "onigiri.snap_apply_map"
    bl_label = "Load Map"

    filter_glob : bpy.props.StringProperty(
        default='*.ctm;*.ccm;*bbm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        
        mapObj = utils.has_armature(report=True)
        if mapObj == False:
            print("-------------------------------------------------------------------")
            print("There's no qualified armature associated with the selected objects.")
            print("There may be too many armatures associated or none at all or there")
            print("the armature modifiers may point to different armatures.  An error")
            print("may have been produced above the dotted line to indicate which of")
            print("these conditions occurred")
            print("-------------------------------------------------------------------")
            text = "There was an error processing your armature, see System Console for details.\n"
            text += "A map must be loaded onto an armature, and only one armature, in order\n"
            text += "for it to be used by any of the mappers or custom exporter."
            utils.popup(text, "Error", "ERROR")
            return {'FINISHED'}

        print("Found armature:", mapObj.name)

        file_path = self.properties.filepath
        path, name = os.path.split(self.properties.filepath)
        file_prefix = name.split(".")[0]
        ext = name.split(".")[-1]

        try:
            namespace = {}
            exec(open(file_path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        template = {}
        for container in namespace:
            
            if container.startswith("__"):
                continue
            template[container] = namespace[container]

        template_map = template.get('template_map', {})
        rename_map = template.get('rename', {})

        rename = {}
        bone_map = {} 

        if len(rename_map) != 0:
            print("Found CCM")
            for bone in rename_map:
                rename[bone] = rename_map[bone]
            mapObj['bb_onemap_rename'] = rename
        elif len(template_map) != 0:
            print("Found CTM")
            for sbone in template_map:
                (tarm, tbone), = template_map[sbone].items()
                bone_map[tbone] = sbone
            mapObj['bb_onemap_rename'] = bone_map

        return {'FINISHED'}

class OnigiriSnapMapLoad(bpy.types.Operator, ImportHelper):
    """Load a Onigiri map, all maps are supported.  Note that maps with
multiple rig targets are not supported, only the first rig will be used.
Loading a map removes the current one so be careful"""

    bl_idname = "onigiri.snap_load_map"
    bl_label = "Load Map"

    filter_glob : bpy.props.StringProperty(
        default='*.ctm;*.ccm;*bbm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap

        mapObj = bpy.context.selected_objects[0] 
        inRig = snap.get_director(armature=mapObj.name)
        if inRig != False:
            mapObj = inRig
        else:
            print("Set does not contain a Director, loading map onto object instead")

        file_path = self.properties.filepath
        path, name = os.path.split(self.properties.filepath)
        file_prefix = name.split(".")[0]
        ext = name.split(".")[-1]

        try:
            namespace = {}
            exec(open(file_path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        template = {}
        for container in namespace:
            
            if container.startswith("__"):
                continue
            template[container] = namespace[container]

        template_map = template.get('template_map', {})
        rename_map = template.get('rename', {})
        reskin_map = template.get('reskin', {})
        pose_map = template.get('pose', {})
        code_map = template.get('code', {}) 
        lock_map = template.get('lock', {}) 

        rename = {}
        reskin = {}
        bone_map = {} 

        if len(rename_map) != 0:
            print("Found CCM")
            for bone in rename_map:
                rename[bone] = rename_map[bone]
                if bone in reskin_map:
                    reskin[bone] = reskin_map[bone] 
            mapObj['bb_onemap_rename'] = rename
            mapObj['bb_onemap_reskin'] = reskin
        
        elif len(template_map) != 0:
            print("Found CTM")
            for sbone in template_map:
                (tarm, tbone), = template_map[sbone].items()
                bone_map[tbone] = sbone
            mapObj['bb_onemap_rename'] = bone_map
            mapObj['bb_onemap_reskin'] = reskin
        if pose_map != None:
            mapObj['bb_onemap_pose'] = pose_map
            print("Pose map loaded!")
        if code_map != None:
            mapObj['bb_onemap_code'] = code_map
            print("Code map loaded!")
        if lock_map != None:
            print("Lock map loaded!")
            mapObj['bb_onemap_lock'] = lock_map

        all_input = set()
        for bone in rename:
            all_input.add(bone)
        for bone in reskin:
            all_input.add(bone)
            
            for rbone in reskin[bone]:
                all_input.add(rbone)
        for bone in bone_map:
            all_input.add(bone)

        mapObj['bb_snap_map'] = file_prefix

        if mapObj.type == 'ARMATURE':
            armObj = mapObj
            bad_bones = []
            good_bones = []
            for bone in all_input:
                if bone not in armObj.data.bones:
                    bad_bones.append(bone)
                else:
                    good_bones.append(bone)

            if len(good_bones) == 0:
                print("None of the bones in the loaded  map match your source rig")
                popup("None of the bones in the map matched", "Error", "ERROR")
            if len(bad_bones) > 0:
                print("Some bones did not match your source rig, see below:")
                print(bad_bones)

        else:
            print("Not an armature, can't apply a pose or check bones")

        if inRig != False:
            outRig = inRig['bb_snap_actor']
            snap.apply_map(director=inRig, actor=outRig)

        return {'FINISHED'}

class OnigiriSnapMapSave(bpy.types.Operator, ExportHelper):
    """This will save a hybrid map that is compatible with both CCM and CTM.  The
file type exported will be a hybrid Onigiri Map (bbm) and will contain all
necessary items for both map types so you won't lose any data"""

    bl_idname = "onigiri.snap_save_map"
    bl_label = "Save Map"

    filename_ext = ".bbm"

    filter_glob : bpy.props.StringProperty(
        default='*.bbm',
        options={'HIDDEN'}
        )
    def invoke(self, context, event):
        save_path = script_dir + data_path
        
        self.filepath = save_path + bpy.context.scene.bb_onemap.onemap_template_name
        wm = context.window_manager.fileselect_add(self)

        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        if bpy.context.active_object == None:
            return False
        o = bpy.context.active_object
        rename_map = o.get('bb_onemap_rename', [])
        inRig = snap.get_director(armature=o.name)
        if inRig != False:
            rename_map = inRig.get('bb_onemap_rename', [])
        if len(rename_map) == 0:
            return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        path = self.properties.filepath

        armObj = bpy.context.active_object
        if armObj.get('bb_onemap_rename') == None:
            inRig = snap.get_director(armature=armObj.name)
            if inRig == False:
                print("Can't find a map to save")
                popup("No available map to save", "Error", "ERROR")
                return {'FINISHED'}
        else:
            inRig = armObj

        result = snap.save_map(input=inRig, file=self.filepath)
        if result == False:
            print("Something weird happened when saving the map")
            popup("Something strange happened when saving", "Error", "ERROR")

        else:
            print("Map saved!")

        return {'FINISHED'}

class OnigiriSnapConvert(bpy.types.Operator):
    """This converts your director to the actor bone names along with the weight
maps, this is potentially destructive and possibly not completely reversible
so save your work.  If you have no reskin bones you should be ok"""

    bl_idname = "onigiri.snap_convert"
    bl_label = "Convert to Actor"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        for boneObj in o.data.bones:
            if boneObj.get('bb_name') != None:
                return False
        return True

    def execute(self, context):
        bb_snap = bpy.context.window_manager.bb_snap
        armObj = bpy.context.selected_objects[0]

        rename_map = armObj.get('bb_onemap_rename')
        if rename_map == None:
            print("No map on the rig to use, load a map first or create one")
            popup("There's no map on the rig", "Error", "ERROR")
            return {'FINISHED'}
        rename_map = armObj['bb_onemap_rename'].to_dict()

        qualified = set()
        for bone in rename_map:
            if bone in armObj.data.bones:
                qualified.add(bone)
        if len(qualified) == 0:
            print("No matching bones")
            popup("No matching bones", "Map Error", "ERROR")
            return {'FINISHED'}

        for boneObj in armObj.data.bones:
            boneObj['bb_name'] = boneObj.name

        new_forward = {}
        new_reverse = {}
        for boneObj in armObj.data.bones:
            bone = boneObj.name 
            while bone in armObj.data.bones or bone in new_forward:
                bone = utils.get_temp_name()
            new_forward[boneObj.name] = bone
            new_reverse[bone] = boneObj.name
        
        for boneObj in armObj.data.bones:
            bone = boneObj.name
            boneObj.name = new_forward[bone]
        
        for boneObj in armObj.data.bones:
            bone = boneObj.name
            sbone = new_reverse[bone]
            if sbone in rename_map:
                tbone = rename_map[sbone]
                boneObj.name = tbone
            
            else:
                new_bone = sbone + "_" + bone
                boneObj.name = new_bone

        print("conversion complete")
        popup("Conversion complete", "Finished", "INFO")

        return {'FINISHED'}

class OnigiriSnapConvertUndo(bpy.types.Operator):
    """This will undo what the conversion did"""

    bl_idname = "onigiri.snap_convert_undo"
    bl_label = "Undo Convert"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        for boneObj in o.data.bones:
            if boneObj.get('bb_name') != None:
                return True
        return False

    def execute(self, context):
        armObj = bpy.context.selected_objects[0]

        for boneObj in armObj.data.bones:
            bone = boneObj.get('bb_name')
            if bone != None:
                boneObj.name = bone
                del boneObj['bb_name']
        print("Repair complete")
        popup("Repair complete", "Finished", "INFO")

        return {'FINISHED'}

class OnigiriSnapExportMesh(bpy.types.Operator, ExportHelper):
    """This uses the map that you generated, which is stored on the associated rig of
the mesh, to rename the bones on export instead of damaging your item.  This way you
keep your product as is with the ability to continue working on it"""

    bl_idname = "onigiri.snap_export_mesh"
    bl_label = "Custom Rig Mesh Exporter"

    filename_ext = ".dae"
    filter_glob : bpy.props.StringProperty(
        default='*.dae',
        options={'HIDDEN'}
    )

    @classmethod
    def poll(cls, context):
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):
        
        pre_select = bpy.context.selected_objects
        selected = []
        m_count = 0
        for o in pre_select:
            if o.type == 'MESH':
                if len(o.vertex_groups) > 0:
                    m_count += 1
                    selected.append(o)
            else:
                selected.append(o)

        if m_count == 0:
            txt = "\n"
            txt += "None of the selected mesh contain vertex groups, which means there's nothing to export\n"
            txt += "Please check your skinning before proceeding, exported mesh using Onigiri is\n"
            txt += "expected to be weighted, there's no other reason to export mesh using Onigiri\n"
            txt += "except in this situation.  If you need to export static mesh use the Blender tools.\n\n"
            print(txt)
            utils.popup(txt, "Error", "ERROR")
            return {'FINISHED'}

        obj = bpy.data.objects
        bb_snap = bpy.context.window_manager.bb_snap
        path = self.properties.filepath
        state = utils.get_state()

        arm, mesh = sim.get_sim_armature(objects=selected)
        if arm == False:
            print("Not a sim object, testing for typical rig")

            arm, mesh = meshutils.get_one_armature(objects=selected)
            print("arm:", arm)
            if arm == False:
                print("There is no usable armature associated with the mesh")
                popup("Armature failure, see console", "Error", "ERROR")
                return {'FINISHED'}

        armObj = obj[arm]

        if armObj.get('bb_onemap_rename') == None:
            print("Can't find a map to use")
            popup("No available map to use", "Error", "ERROR")
            return {'FINISHED'}

        rename_map = armObj['bb_onemap_rename'].to_dict()

        armObj.select_set(True)
        for m in mesh:
            obj[m].select_set(True)
            obj[m]['name'] = obj[m].name
        utils.activate(armObj)
        armObj['name'] = armObj.name
        bpy.ops.object.duplicate()

        delete = bpy.context.selected_objects

        for o in delete:
            utils.make_unique(o) 

        print("INIT: Adjusted sim type not has (dynamic) or (object) types that can trigger sim.export_fix()")
        for o in delete:
            if o.get('bb_sim_type') == "dynamic":
                print(" sim type is dynaimc, calling sim.export_fix() for", o.name)
                sim.export_fix(o)

        frame_current = bpy.context.scene.frame_current
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                if o.animation_data != None:
                    if o.animation_data.action != None:
                        frame_start = o.animation_data.action.frame_range[0]
                        bpy.context.scene.frame_set(frame_start)
                        bpy.context.scene.frame_set(frame_current)
            
            o.animation_data_clear()
                
        bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)

        proxy_mesh = []
        temp_name = utils.get_temp_name()
        for o in bpy.context.selected_objects:
            old_name = o.name
            o.name = o['name'] + "_" + temp_name
            if o.type == 'ARMATURE':
                proxyObj = o
            elif o.type == 'MESH':
                proxy_mesh.append(o)
            else:
                print("Incompatible object in selection:", o.name)

        changed_map = {}  
        missing_from_map = []

        rename_set = set()  
        for sbone in rename_map:
            tbone = rename_map[sbone]
            rename_set.add(sbone)

        for boneObj in proxyObj.data.bones:
            bone = boneObj.name

            temp_name = bone
            while temp_name in proxyObj.data.bones or temp_name in rename_set:
                name = utils.get_temp_name()
                temp_name = bone + "_" + name

            boneObj.name = temp_name

            if bone not in rename_map:
                
                if boneObj.use_deform == True:
                    
                    missing_from_map.append(bone)
                else:
                    print("Skipping missing map bone flagged as non deformable:", bone)
            else:
                changed_map[boneObj.name] = rename_map[bone]

        missing_from_rig = []
        for boneObj in proxyObj.data.bones:
            bone = boneObj.name
            
            if bone not in changed_map:
                
                if boneObj.use_deform == True:
                    missing_from_rig.append(bone)
                else:
                    print("Skpping missing bone flagged as use_deform = False, which is expected", bone)
            else:
                boneObj.name = changed_map[bone]
        
        if len(missing_from_map) > 0:
            print("There were bones in your rig that are missing from the map.  This is a mapped mesh (custom) exporter,")
            print("it does not support the reskin kludge.  Make sure all of your bones are mapped in order for your")
            print("character to work properly.")
            print("The following bones are missing from the map:")
            print(missing_from_map)
            
            if 1 == 0:
                for o in delete:
                    o.select_set(True)
                utils.activate(o)
                bpy.ops.object.delete()
                utils.set_state(state)
                return {'FINISHED'}
        if len(missing_from_rig) > 0:
            print("There were bones in your map that are missing from the rig.  This is not always an error.")
            print("The following mapped bones are missing from the rig:")
            print(missing_from_rig)

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in proxyObj.data.edit_bones:
            roll = boneObj.roll
            head = boneObj.head.copy()
            tail = boneObj.tail.copy()
            boneObj['roll'] = roll
            boneObj['head'] = head.copy()
            boneObj['tail'] = tail.copy()
        bpy.ops.object.mode_set(mode='OBJECT')

        slRig = rigutils.build_rig(rig_class="pos", rotate=True)
        delete.append(slRig) 

        slRig.location = proxyObj.location
        
        bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)

        bpy.ops.object.mode_set(mode='EDIT')

        for boneObj in slRig.data.edit_bones:
            boneObj.use_connect = False

        for boneObj in proxyObj.data.bones:
            bone = boneObj.name
            if bone not in slRig.data.bones:
                print("Custom rig bone missing from SL target:", bone)
                continue
            sBone = slRig.data.edit_bones[bone]
            sBone.head = boneObj['head'].to_list()
            sBone.tail = boneObj['tail'].to_list()
            sBone.roll = boneObj['roll']
        bpy.ops.object.mode_set(mode='OBJECT')

        for o in delete:
            if o.type == 'MESH':
                for m in o.modifiers:
                    if m.type == 'ARMATURE':
                        m.object = slRig
            
            if o.parent:
                if o.parent == proxyObj:
                    o.parent = slRig

        armature = slRig.name

        for o in delete:
            if o.type == 'MESH':
                o.select_set(True)

        ccp = bpy.context.window_manager.cc_props
        bb_mesh = bpy.context.scene.bb_mesh
        bb_devkit = bpy.context.scene.bb_devkit

        export_path_to_pelvis = bb_devkit.export_path_to_pelvis
        export_full_rig = bb_devkit.export_full_rig
        
        rotate_for_sl = bb_devkit.rotate_for_sl
        apply_scale = bb_devkit.apply_scale
        apply_location = bb_devkit.apply_location
        apply_rotation = bb_devkit.apply_rotation

        fix_broken_bones = bb_devkit.fix_broken_bones

        bb_devkit.fix_broken_bones = False
        export_deform_bones_only = bb_devkit.dae_deform_bones_only
        print("Setting rig data to True, if this causes and issue contact support in Discord")
        bb_devkit.use_rig_data = True
        print("Setting onigiri_converted flag on the rig to ensure custom bone properties")
        proxyObj['onigiri_converted'] = True

        if bb_mesh.remove_empty_groups == True:
            
            bpy.ops.onigiri.remove_unused_groups(method="best")

        file_path = tempfile.gettempdir() + "/onigiri_" + get_unique_name_short() + ".dae"

        rotate_for_sl = True
        if rotate_for_sl == True:
            global_forward = '-X'
        else:
            global_forward = 'Y'

        bpy.ops.wm.collada_export(
            filepath = file_path,
            check_existing = True,
            apply_modifiers = bb_mesh.export_apply_modifiers,
            selected = bb_mesh.export_selected,
            include_children = bb_mesh.export_include_children,
            include_armatures = bb_mesh.export_include_armatures,
            include_shapekeys = bb_mesh.export_include_shapekeys,
            include_animations = bb_mesh.export_include_animations,
            deform_bones_only = export_deform_bones_only,
            triangulate = bb_mesh.export_triangulate,
            use_object_instantiation = bb_mesh.export_use_object_instantiation,
            use_blender_profile = bb_mesh.export_use_blender_profile,
            sort_by_name = bb_mesh.export_sort_by_name,
            open_sim = bb_mesh.export_open_sim,
            export_object_transformation_type_selection = 'matrix',
            export_global_forward_selection=global_forward,
            export_global_up_selection='Z',
            apply_global_orientation=rotate_for_sl,
            )
        
        file_in = file_path
        file_out = self.properties.filepath

        custom_bind_data = True
        if custom_bind_data == True:
            print("Converting mapped mesh dae:", file_in)
            if bb_snap.snap_export_mapped_old == True:
                collada.export_custom(
                    armature=armature, write_nodes=True, file_in=file_in, file_out=file_out
                    )
            else:

                matrices = devkit.get_matrices(armature=slRig, base=None, use_bind_pose=False, report=True)

                result = devkit.export_dae(matrices=matrices, joint='bone_data', file=self.filepath, real=armObj)

        else:
            f_in = open(file_in, "r", encoding='UTF8')
            file_content = f_in.read()
            f_in.close()
            f_out = open(file_out, "w", encoding='UTF8')
            f_out.write(file_content)
            f_out.close()

        try:
            os.remove(file_path)
            print("BB mapped dae cleanup")
        except:
            print("BB Warning: unable to remove temporary file:", file_path)

        bb_devkit["export_path_to_pelvis"] = export_path_to_pelvis
        bb_devkit["export_full_rig"] = export_full_rig
        bb_devkit["rotate_for_sl"] = rotate_for_sl
        bb_devkit["apply_scale"] = apply_scale
        bb_devkit["apply_location"] = apply_location
        bb_devkit["apply_rotation"] = apply_rotation
        bb_devkit["fix_broken_bones"] = fix_broken_bones

        for o in delete:
            o.select_set(True)
        utils.activate(o)
        if 1 == 1:
            bpy.ops.object.delete()
            utils.set_state(state)

        return {'FINISHED'}

class OnigiriEditTemplateProperties(bpy.types.PropertyGroup):

    editor_manual_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Expand the manual editors",
        default = False
        )
    
    onemap_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Expand the character mapper"            "\n\n"            "This is a generic character mapper that allows for any target and source platforms.  There is a reskin feature here "            "as well, much like the auto-weight mapper, but much easier to use.  The reskin idea may be a bit difficult to understand "            "but it's actually quite simple... if you think one or more bones are not compatible with the target platform you can "            "have the mesh weights attach to its parent bone, or some other anchor up the chain, and then this bone will be marked for "            "removal but the mesh will still move with the anchor bone you chose.",
        default = False
        )

    load_txt_reversed : bpy.props.BoolProperty(
        name = "",
        description =            "Load the text file with reversed bone order matching"            "\n\n"            "When making a text file to be converted into a CTM you'll usually put the name of the bone from the rig that you want to "            "convert into the first slot and then put the target system into the second slot.  These virtual (slots) are just a line "            "separated by a space.  Unfortunately some bones have spaces in them and the first bone cannot be defined with a space so "            "you may have to use the reverse in order to map your bones, if using a text file.  However, if both the source and the "            "target have spaces in their bones then even the reverse button, right here, won't help you and you'll have to map those "            "bones using this interface instead.  With that in mind, what this switch does is simple reverses the target/source order "            "after reading the file in and is just a convenience in case one of the systems doesn't have spaces in the bones.  Honestly "            "no bone should ever have a space, or white space, in its name but some armatures do this.",
        default = False
        )

    def update_info_onigiri_load_generic_template(self, context):
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbe = bpy.context.window_manager.bb_edit_template
        
        bb_settings['terminate'] = True
        bbe.info_onigiri_load_generic_template = False
        return
    info_onigiri_load_generic_template : bpy.props.BoolProperty(
        name = "Template Converter",
        description =            "\n"            "The button you have hovered over is informative only, read below...\n\n"            "This feature is provided in order to convert a template map from one type to another for use in various areas of Onigiri."            "\n",
        default = False,
        update = update_info_onigiri_load_generic_template,
    )

    disable_map_pose : bpy.props.BoolProperty(
        name = "Push this to disable loading the pose",
        description =            "When you're loading multiple maps you may want to keep a single working pose but not the rest.  Use this disable button "            "to prevent the loader from including the pose into the next loaded map.  When you have a pose in one of them that you're "            "sure about then you can re-enable the loading of the pose to allow the loader to record the included pose data.  In order to "            "check the pose, you can apply it to your skeleton in the Animation rollout and Enable Posing Library.  From there you can "            "load a pose from a CCM file to see what it looks like.  CTM files do not have poses in them so this can only apply to CCM.",
        default = False,
        )
    disable_map_code : bpy.props.BoolProperty(
        name = "",
        description =            "Code Loading"            "\n\n"            "In some newer versions of Onigiri we'll start using macros to help process difficult characters.  This code is "            "embedded in the map file and is only used where indicated and is always defaulted to OFF.  If the code is indicated "            "you should probably use it.  This feature allows you to disable overwrite of previously loaded code if you know that "            "a previously loaded map has usable code and you don't want to replace it.  This feature works just like the pose loader.",
        default = True,
        )

    def update_info_onigiri_combine_generic_template(self, context):
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbe = bpy.context.window_manager.bb_edit_template
        
        bb_settings['terminate'] = True
        bbe.info_onigiri_combine_generic_template = False
        return
    info_onigiri_combine_generic_template : bpy.props.BoolProperty(
        name = "Combine Templates",
        description =            "\n"            "The button you have hovered over is informative only, read below...\n\n"            "This feature will allow you to load multiple modules to combine them for storing into a new map.  This merge "            "feature will allow you to work on different sections of your rig, or have multiple people working on different sections, "            "and then later combine them using this tool.  Each map that is loaded takes precedence over all other previously loaded maps, "            "which is to say, if there are duplicate mapped bones, the newest loaded map will override any existing duplicate maps."            "\n",
        default = False,
        update = update_info_onigiri_combine_generic_template,
    )

    message : bpy.props.StringProperty(default="look here for messages")

    show_map : bpy.props.BoolProperty(
        description =            "Click to expand and show the map"            "\n\n"            "A display of icons will appear for each source bone, target armature and target bone.  The icon is simply a dot with a color "            "legend indicating a bone state.  In standard mode the icons are black and you are simply editing maps without the need for any "            "armatures.  In map mode, as with the other mappers, there are at least 2 armatures required for active mapping.  In this state "            "the icon colors will be red, green or yellow.  "            "\n\n"            "Red - missing item"            "\n"            "Green - item matches"            "\n"            "Yellow - the item would match if not for the prefix"            "\n",
        default = False
    )

    show_rigs : bpy.props.BoolProperty(
        description =            "Click to enable and show a list of rigs contained within the template",
        default = False,
        
    )

    def update_source_active(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        if bbe.terminate == True:
            bbe.terminate = False
            return

        print("entered update for source_active")
        return 

    source_active : bpy.props.BoolProperty(
        description =            "Click to disable the active map, your changes will not be harmed but you need to save your work to a file using the save "            "feature because it does not save with the blender file",
        default = False,
        update = update_source_active
    )

    def update_move_name(self,context):
        bbe = bpy.context.window_manager.bb_edit_template
        if bbe.terminate == True:
            bbe.terminate = False
            return
        
        if bbe.move_name == bbe.move_name_backup:
            print("Property move_name updater running, no name change, returning")
            bbe.message = "Same name, nothing changed"
            del bbe['name']
            del bbe['item']
            return
        
        if bbe.move_name.strip() == "":
            print("we're not allowing empty names today, come back tomorrow")
            bbe.message = "Empty string"
            del bbe['name']
            del bbe['item']
            return

        tarms = dict()
        for sbone in bbe['template_editing']:
            (tarm, tbone), = bbe['template_editing'][sbone].items()
            tarms[tarm] = tbone

        if bbe.move_name in tarms:
            
            template_new = dict()
            target_bones = dict()
            for sbone in bbe['template_editing']:
                (tarm, tbone), = bbe['template_editing'][sbone].items()
                if tarm == bbe.move_name_backup:
                    template_new[sbone] = {bbe.move_name : tbone}
                    target_bones[tbone] = ""
            
            for sbone in bbe['template_editing']:
                (tarm, tbone), = bbe['template_editing'][sbone].items()
                if tarm == bbe.move_name_backup:
                    continue
                if tbone in target_bones:
                    continue
                template_new[sbone] = {tarm : tbone}

        else:
            template_new = dict()
            for sbone in bbe['template_editing']:
                (tarm, tbone), = bbe['template_editing'][sbone].items()
                
                if tarm == bbe.move_name_backup:
                    template_new[sbone] = {bbe.move_name : tbone}
            for sbone in bbe['template_editing']:
                (tarm, tbone), = bbe['template_editing'][sbone].items()
                
                if tarm == bbe.move_name_backup:
                    continue
                template_new[sbone] = {tarm : tbone}

        bbe.message = "rig name changed from " + bbe.move_name_backup + " to " + bbe.move_name
        bbe['template_editing'] = template_new

        if bbe.get('template_editing_undo'):
            del bbe['template_editing_undo']

        del bbe['name']
        del bbe['item']

    def update_sbone_name(self,context):
        bbe = bpy.context.window_manager.bb_edit_template
        if bbe.terminate == True:
            bbe.terminate = False
            return
        
        if bbe.sbone_name == bbe.sbone_name_backup:
            print("Property sbone_name updater running, no name change, returning")
            bbe.message = "Same name, nothing changed"
            del bbe['name']
            del bbe['item']
            return
        
        if bbe.sbone_name.strip() == "":
            print("we're not allowing empty names today, come back tomorrow")
            bbe.message = "Empty string"
            del bbe['name']
            del bbe['item']
            return
        
        if bbe.sbone_name in bbe['template_editing']:
            print("Name collision, change the name of the other one if you want to move this stream")
            bbe.message = "[The name " + '"' + bbe.sbone_name + '"' + " would collide with another bone" + "]"
            del bbe['name']
            del bbe['item']
            return

        print("Property sbone_name updater running to change bone map from", bbe.sbone_name_backup, "to", bbe.sbone_name)

        last_edit = {}
        
        bbe['template_editing_undo'] = dict()
        bbe['template_editing_undo']['old'] = {}
        bbe['template_editing_undo']['new'] = {}
        bbe['template_editing_undo']['map'] = {}
        bbe['template_editing_undo']['old'][bbe.sbone_name_backup] = bbe['template_editing'][bbe.sbone_name_backup]
        
        bbe['template_editing_undo']['new'][bbe.sbone_name] = bbe['template_editing'][bbe.sbone_name_backup]
        
        bbe['template_editing_undo']['map'][bbe.sbone_name] = bbe.sbone_name_backup

        template = bbe['template_editing'].to_dict()
        template_new = dict()
        template_new[bbe.sbone_name] = template[bbe.sbone_name_backup]
        for t in template:
            if t == bbe.sbone_name_backup:
                continue
            template_new[t] = template[t]

        bbe.sbone_name_backup = bbe.sbone_name
        bbe['template_editing'] = template_new

        del bbe['name']
        del bbe['item']

        bbe.message = "name changed"

        return

    def update_tbone_name(self,context):
        bbe = bpy.context.window_manager.bb_edit_template
        if bbe.terminate == True:
            bbe.terminate = False
            return

        sbone = bbe['name']

        (tarm, tbone), = bbe['template_editing'][sbone].items()

        if bbe.tbone_name == bbe.tbone_name_backup:
            print("Property tbone_name updater running, no name change, returning")
            bbe.message = "Same name, nothing changed"
            del bbe['name']
            del bbe['item']
            return
        
        if bbe.tbone_name.strip() == "":
            print("we're not allowing empty names today, come back tomorrow")
            bbe.message = "Empty string"
            del bbe['name']
            del bbe['item']
            return

        tbone_items = set()
        for k in bbe['template_editing']: 
            (rig, tbone), = bbe['template_editing'][k].items()
            if rig == tarm:
                tbone_items.add(tbone)

        if bbe.tbone_name in tbone_items:
            print("Name collision, change the name of the other one if you want to move this stream")
            bbe.message = "The name " + '"' + bbe.tbone_name + '"' + " would collide with another bone"
            del bbe['name']
            del bbe['item']
            return

        print("Property tbone_name updater running to change target from", tarm, bbe.tbone_name_backup, "to", tarm, bbe.tbone_name)

        last_edit = {}
        
        bbe['template_editing_undo'] = dict()
        bbe['template_editing_undo']['old'] = {}
        bbe['template_editing_undo']['new'] = {}
        bbe['template_editing_undo']['map'] = {}
        bbe['template_editing_undo']['old'][sbone] = bbe['template_editing'][sbone]
        
        bbe['template_editing_undo']['new'][sbone] = {tarm : bbe.tbone_name}
        
        bbe['template_editing_undo']['map'][bbe.tbone_name] = bbe.tbone_name_backup

        template = bbe['template_editing'].to_dict()
        template_new = dict()
        template_new[sbone] = {tarm : bbe.tbone_name}

        for t in template:
            if t == sbone:
                continue
            template_new[t] = template[t]

        bbe.tbone_name_backup = bbe.tbone_name
        bbe['template_editing'] = template_new

        del bbe['name']
        del bbe['item']

        bbe.message = "name changed"

        return

    def update_tarm_name(self,context):
        bbe = bpy.context.window_manager.bb_edit_template
        if bbe.terminate == True:
            bbe.terminate = False
            return

        sbone = bbe['name']

        (tarm, tbone), = bbe['template_editing'][sbone].items()

        if bbe.tarm_name == bbe.tarm_name_backup:
            print("Property tarm_name updater running, no name change, returning")
            bbe.message = "Same name, nothing changed"
            del bbe['name']
            del bbe['item']
            return
        
        if bbe.tarm_name.strip() == "":
            print("we're not allowing empty names today, come back tomorrow")
            bbe.message = "Empty string"

            del bbe['name']
            del bbe['item']
            return
        
        tarm_items = {}
        for k in bbe['template_editing']:
            (arm, bone), = bbe['template_editing'][k].items()
            if bbe.tarm_name == arm:
                
                print("The target armature rename would have collided:", tarm)
                bbe.message = bbe.tarm_name + " would have collided, use rig options to merge"
                del bbe['name']
                del bbe['item']
                return

        last_edit = {}
        
        bbe['template_editing_undo'] = dict()
        bbe['template_editing_undo']['old'] = {}
        bbe['template_editing_undo']['new'] = {}
        bbe['template_editing_undo']['map'] = {}
        bbe['template_editing_undo']['old'][sbone] = bbe['template_editing'][sbone]
        
        bbe['template_editing_undo']['new'][sbone] = {bbe.tarm_name : tbone}
        
        bbe['template_editing_undo']['map'][bbe.tarm_name] = bbe.tarm_name_backup

        template = bbe['template_editing'].to_dict()
        template_new = dict()
        template_new[sbone] = {bbe.tarm_name : tbone}

        for t in template:
            if t == sbone:
                continue
            template_new[t] = template[t]

        bbe.tarm_name_backup = bbe.tarm_name
        bbe['template_editing'] = template_new
        del bbe['name']
        del bbe['item']

        bbe.message = "name changed"

        return

    move_name : bpy.props.StringProperty(default="", update=update_move_name)
    move_name_backup : bpy.props.StringProperty(default="")
    tarm_name : bpy.props.StringProperty(default="", update=update_tarm_name)
    tarm_name_backup : bpy.props.StringProperty(default="")
    sbone_name : bpy.props.StringProperty(default="", update=update_sbone_name)
    sbone_name_backup : bpy.props.StringProperty(default="")
    tbone_name : bpy.props.StringProperty(default="", update=update_tbone_name)
    tbone_name_backup : bpy.props.StringProperty(default="")

    terminate : bpy.props.BoolProperty(default=False)

class OnigiriLoadGenericTemplate(bpy.types.Operator, ImportHelper):
    """OLD: This should be obsolete now.  Use the (Template Composer) to load any
template and just have the single file, it will save as BBM, our new default
hybrid map, that supports all tools.  If there's an error let me know"""

    bl_idname = "onigiri.load_generic_template"
    bl_label = "Load *.ccm, *.ctm"

    filter_glob : bpy.props.StringProperty(
        default='*.ccm;*.ctm',
        options={'HIDDEN'}
        )

    def execute(self, context):
        obj = bpy.data.objects
        bbe = bpy.context.window_manager.bb_edit_template
        path = self.properties.filepath

        try:
            namespace = {}
            exec(open(path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        template = {}
        for container in namespace:
            
            if container.startswith("__"):
                continue
            template[container] = namespace[container]

        if template != None:
            bbe['template_map_convert'] = {}

            bbe['template_map_convert'] = template

        if 'template_map' in template:
            bbe['map_type_convert'] = "ctm"
        if 'rename' in template:
            bbe['map_type_convert'] = "ccm"

        return {'FINISHED'}

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriSaveCCM(bpy.types.Operator, ExportHelper):
    bl_idname = "onigiri.save_ccm"
    bl_label = "Save Converted Template"

    filename_ext = ".ccm"

    filter_glob : bpy.props.StringProperty(
        default='*.ccm',
        options={'HIDDEN'}
        )

    @classmethod
    def poll(cls, context):
        bbe = bpy.context.window_manager.bb_edit_template
        if bbe.get('template_map_convert') == None:
            return False
        if bbe['template_map_convert'] == "":
            return False
        if bbe.get('map_type_convert') == None:
            return False
        if bbe['map_type_convert'] == "ccm":
            return False
        return True

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        path = self.properties.filepath

        if bbe['map_type_convert'] == "ccm":
            txt = "Conversion type is the same as the loaded map: " + bbe['map_type']
            print(txt)
            utils.popup(txt, "Error", "ERROR")
            return {'FINISHED'}

        template = bbe['template_map_convert']['template_map'].to_dict()

        container = dict()
        for mbone in template:
            (tarm, tbone), = template[mbone].items()
            container[tbone] = mbone

        formatted_maps = "# Auto generated by Onigiri - Character Converter from CTM\n"
        rename_maps = "rename = {\n";

        for tbone in container:
            rename_maps += "    " + '"' + tbone + '": ' + '"' + container[tbone] + '"' + ",\n"
        rename_maps += "    }\n"

        formatted_maps += rename_maps

        output = open(path, 'w', encoding='UTF8')
        output.write(formatted_maps)
        output.close()

        del bbe['template_map_convert']
        del bbe['map_type_convert']

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriSaveCTM(bpy.types.Operator, ExportHelper):
    bl_idname = "onigiri.save_ctm"
    bl_label = "Save Converted Template"

    filename_ext = ".ctm"

    filter_glob : bpy.props.StringProperty(
        default='*.ctm',
        options={'HIDDEN'}
        )

    @classmethod
    def poll(cls, context):
        bbe = bpy.context.window_manager.bb_edit_template
        if bbe.get('template_map_convert') == None:
            return False
        if bbe['template_map_convert'] == "":
            return False
        if bbe.get('map_type_convert') == None:
            return False
        if bbe['map_type_convert'] == "ctm":
            return False
        return True

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        path = self.properties.filepath

        if bbe['map_type_convert'] == "ctm":
            txt = "Conversion type is the same as the loaded map: " + bbe['map_type']
            print(txt)
            utils.popup(txt, "Error", "ERROR")
            return {'FINISHED'}

        template = bbe['template_map_convert'].to_dict()

        target = "arm_" + utils.get_unique_name_short()

        container = dict()
        for tbone in template['rename']:
            mbone = template['rename'][tbone]
            container[mbone] = {target: tbone}

        formatted_maps = "# Character Template Map auto-generated by Onigiri from CCM\n"
        formatted_maps += "template_map = {\n"
        for sbone in container:
            (tarm, tbone), = container[sbone].items()
            formatted_maps += "    " + '"' + sbone + '": ' + '{' + "\n"
            formatted_maps += "        " + '"' + tarm +'": ' + '"' + tbone + '",' + "\n" + "        },\n"
        formatted_maps += "    }\n"

        output = open(path, 'w', encoding='UTF8')
        output.write(formatted_maps)
        output.close()

        del bbe['template_map_convert']

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriLoadTemplates(bpy.types.Operator, ImportHelper):
    """Load multiple templates.  This is a new Hybrid composer that will save all
data that's loaded, but every newly loaded map that contains existing bones will
over write those bones, this is expected behavior and desirable"""

    bl_idname = "onigiri.load_templates"
    bl_label = "Load ccm, ctm, bbm"

    filter_glob : bpy.props.StringProperty(
        default='*.ccm;*.ctm;*.bbm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        obj = bpy.data.objects
        bbe = bpy.context.window_manager.bb_edit_template

        template = {}
        try:
            namespace = {}
            exec(open(self.filepath, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("error loading template")
            print(traceback.format_exc())
            return {'FINISHED'}

        for container in namespace:
            
            if container.startswith("__"):
                continue
            template[container] = namespace[container]

        known_maps = {'template_map', 'rename', 'reskin', 'pose', 'code'}

        template_map = template.get('template_map', {})
        rename_map = template.get('rename', {})
        reskin_map = template.get('reskin', {})
        pose_map = template.get('pose', {})
        code_map = template.get('code', {}) 

        bbe['bb_onemap_unknown'] = {}
        for map_type in template:
            if map_type not in known_maps:
                print("Unknown map, saving raw:", map_type)
                bbe['bb_onemap_unknown'][map_type] = template[map_type]

        loaded_maps = bbe.get('bb_onemap_list', [])
        if len(loaded_maps) > 0:
            print("-----------------------------------------------------")
            print("Existing maps, appending new ones")
            print("-----------------------------------------------------")

            rename_old = bbe.get('bb_onemap_rename', {})
            if len(rename_old) == 0:
                print("rename was not defined")
            reskin_old = bbe.get('bb_onemap_reskin', {})
            if len(rename_old) == 0:
                print("no reskin data to process")
            pose_old = bbe.get('bb_onemap_pose', {})
            if len(pose_old) == 0:
                print("no pose data to process")

            template_old = bbe.get('bb_onemap_template', {})
            template_new = {}  
            if len(template_old) == 0:
                print("Old template definition is available and stored, ")
                template_new = template_old

            code_new = {} 
            code_old = bbe.get('bb_onemap_code', {})
            if len(code_old) == 0:
                print("No old code to process")
            if len(code_map) == 0:
                print("No new code to process")
            else:
                print ("Loaded code:", code_map)
                if bbe.disable_map_code == False:
                    print("... over write old code")
                    code_new = code_map
                else:
                    print("... keeping old code")
                    code_new = code_old

            rename_old_rev = {}
            for sbone in rename_old:
                tbone = rename_old[sbone]
                rename_old_rev[tbone] = sbone
            rename_map_rev = {}
            for sbone in rename_map:
                tbone = rename_map[sbone]
                rename_map_rev[tbone] = sbone

            for sbone in rename_map:
                tbone = rename_map[sbone]
                if tbone in rename_old_rev:
                    if sbone == rename_old_rev[tbone]:
                        print("Incoming name collision, removing:", sbone)
                        rename_old.pop(sbone)

            for sbone in rename_map:
                tbone = rename_map[sbone]
                rename_old[sbone] = tbone
            rename_new = rename_old

            print("reskin_map:", reskin_map)

            old_anchors = {}
            new_anchors = {}
            for bone in reskin_map:
                bone_list = reskin_map[bone]
                
                if len(bone_list) > 0:
                    new_anchors[bone] = bone_list[:]
            for bone in reskin_old:
                bone_list = reskin_old[bone]
                if len(bone_list) > 0:
                    old_anchors[bone] = bone_list[:]

            print("------------------------------------------")
            print("old_anchors:", old_anchors)
            print("new_anchors:", new_anchors)
            print("------------------------------------------")

            anchors = set()
            missing_anchors = []
            for anchor in old_anchors:
                if anchor not in rename_old:
                    missing_anchors.append(anchor)
                    print("Incoming anchor is missing from composed map, ignoring:", anchor)
                else:
                    anchors.add(anchor)
            for anchor in new_anchors:
                if anchor not in rename_map:
                    missing_anchors.append(anchor)
                    print("Incoming anchor is missing from composed map, ignoring:", anchor)
                else:
                    anchors.add(anchor)

            all_anchors = {}
            for bone in anchors:
                reskin_list = old_anchors.get(bone, [])
                reskin_list.extend( new_anchors.get(bone, []) )
                
                reskin_set = set(reskin_list)
                all_anchors[bone] = list(reskin_set)

            for anchor in all_anchors:
                reskin_list = all_anchors[anchor]
                reskin_keepers = []
                for rbone in reskin_list:
                    if rbone in rename_old:
                        print("Found reskin bone in rename map, ignoring:", rbone)
                    else:
                        reskin_keepers.append(rbone)
                all_anchors[anchor] = reskin_keepers[:]

            all_reskin = {} 
            for anchor in all_anchors:
                reskin_list = all_anchors[anchor]
                reskin_save = []
                for rbone in reskin_list:
                    if rbone in all_reskin:
                        if anchor in new_anchors:
                            
                            reskin_save.append(rbone)
                    else:
                        reskin_save.append(rbone)
                all_anchors[anchor] = reskin_save[:]
            reskin_new = all_anchors

            pose_new = pose_map
            if bbe.disable_map_pose == False:
                if len(pose_old) > 0:
                    for bone in pose_map:
                        pose_old[bone] = pose_map[bone]
            pose_new = pose_old

        else:
            rename_new = rename_map
            reskin_new = reskin_map
            template_new = template_map
            code_new = code_map
            pose_new = pose_map

        loaded_maps = bbe.get('bb_onemap_list', [])
        file_name = bpy.path.basename(self.properties.filepath)
        suffix_name = os.path.splitext(file_name)[0]
        loaded_maps.append(suffix_name)
        bbe['bb_onemap_list'] = loaded_maps

        bbe['bb_onemap_rename'] = rename_new
        bbe['bb_onemap_reskin'] = reskin_new
        bbe['bb_onemap_code'] = code_new
        bbe['bb_onemap_template'] = template_new
        bbe['bb_onemap_pose'] = pose_new

        template = {}

        return {'FINISHED'}

class OnigiriSaveTemplates(bpy.types.Operator, ExportHelper):
    """Save the result of the combined templates"""

    bl_idname = "onigiri.save_templates"
    bl_label = "Save bbm"

    filename_ext = ".bbm"

    filter_glob : bpy.props.StringProperty(
        default='*.bbm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        bbe = bpy.context.window_manager.bb_edit_template
        if len( bbe.get('bb_onemap_list', []) ) == 0:
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bbe = bpy.context.window_manager.bb_edit_template

        file_name = bpy.path.basename(self.properties.filepath)
        suffix_name = os.path.splitext(file_name)[0]
        file_in = self.properties.filepath

        known_maps = {'template_map', 'rename', 'reskin', 'pose', 'code'}

        template = {}
        if bbe.get('bb_onemap_rename') != None:
            template['rename'] = bbe['bb_onemap_rename'].to_dict()
        if bbe.get('bb_onemap_reskin') != None:
            template['reskin'] = bbe['bb_onemap_reskin'].to_dict()
        if bbe.get('bb_onemap_code') != None:
            template['code'] = bbe['bb_onemap_code'].to_dict()
        if bbe.get('bb_onemap_pose') != None:
            template['pose'] = bbe['bb_onemap_pose'].to_dict()

        if bbe.get('bb_onemap_unknown') != None:
            for map_type in bbe['bb_onemap_unknown']:
                template[map_type] = bbe['bb_onemap_unknown'][map_type].to_dict()

        onemap.save_hybrid_template(template=template, file=self.filepath)

        template = {}
        bbe.pop('bb_onemap_list', [])

        return {'FINISHED'}

class OnigiriResetTemplates(bpy.types.Operator):
    """Reset template composer"""

    bl_idname = "onigiri.reset_templates"
    bl_label = "Reset Template Composer"

    def execute(self, context):
        obj = bpy.data.objects
        bbe = bpy.context.window_manager.bb_edit_template

        bbe.pop('bb_onemap_list', [])
        bbe.pop('bb_onemap_rename', {})
        bbe.pop('bb_onemap_reskin', {})
        bbe.pop('bb_onemap_code', {})
        bbe.pop('bb_onemap_pose', {})
        bbe.pop('bb_onemap_unknown', {})

        return {'FINISHED'}

class OnigiriCombineGenericTemplate(bpy.types.Operator, ImportHelper):
    """Here you can load multiple templates to create a composition that had
previously been mapped separately, see (!) button"""

    bl_idname = "onigiri.combine_generic_template"
    bl_label = "Load ccm, ctm, bbm"

    filter_glob : bpy.props.StringProperty(
        default='*.ccm;*.ctm;*.bbm',
        options={'HIDDEN'}
        )

    def execute(self, context):
        obj = bpy.data.objects
        bbe = bpy.context.window_manager.bb_edit_template
        path = self.properties.filepath

        low_path = path.lower()
        if low_path.endswith("." + "ccm"):
            my_type = "ccm"
        elif low_path.endswith("." + "bbm"):
            my_type = "ccm"
        elif low_path.endswith("." + "ctm"):
            my_type = "ctm"
        else:
            print("OnigiriCombineGenericTemplate reports: Unknown map type in file - ", path)
            utils.popup("Unknown map type in file, check console for details", "Error", "ERROR")
            return {'FINISHED'}

        if bbe.get('map_type_combine') != None:
            if bbe['map_type_combine'] == my_type:
                pass
            else:
                print("OnigiriCombineGenericTemplate reports: existing template is", bbe['map_type_combine'], "but user wants something else")
                txt = "You can only combine maps of the same type.  To start over use the reset button"
                print(txt)
                utils.popup(txt, "Error", "ERROR")
                return {'FINISHED'}
        
        else:
            bbe['map_type_combine'] = my_type

        path_head, path_tail = os.path.split(path)

        print("Adding module: filename:", path_tail)

        try:
            namespace = {}
            exec(open(path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        template = {}
        for container in namespace:
            
            if container.startswith("__"):
                continue
            template[container] = namespace[container]

        if template != "":
            
            if bbe.get('template_map_combine') == None:
                bbe['template_map_combine'] = {}
                
                bbe['map_files_combine'] = [path_tail]
            
            else:

                print("---------------------------------------------------------------")
                print("path_tail")

                print("---------------------------------------------------------------")

                if bbe.get('map_files_combine') == None:
                    bbe['map_files_combine'] = list()
                if path_tail in bbe['map_files_combine']:
                    txt = "OnigiriCombineGenericTemplate reports: already recorded - " + path_tail
                    print(txt)
                    utils.popup(txt, "Error", "ERROR")
                    return {'FINISHED'}

                map_files = bbe['map_files_combine']
                map_files.append(path_tail)
                bbe['map_files_combine'] = map_files

            template_map = bbe['template_map_combine'].to_dict()
            for root_key in template:
                if template_map.get(root_key) == None:
                    template_map[root_key] = dict()
                for sub_key in template[root_key]:
                    template_map[root_key].update({sub_key : template[root_key][sub_key]})

            for root_key in template_map:
                
                if root_key == "pose":
                    if bbe.disable_map_pose == True:
                        continue

            bbe['template_map_combine'] = template_map

        return {'FINISHED'}

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriSaveCombinedCCM(bpy.types.Operator, ExportHelper):
    bl_idname = "onigiri.save_combined_ccm"
    bl_label = "Save Combined Template"

    filename_ext = ".ccm"

    filter_glob : bpy.props.StringProperty(
        default='*.ccm',
        options={'HIDDEN'}
        )

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        path = self.properties.filepath

        template = bbe['template_map_combine'].to_dict()

        formatted_maps = "# Auto generated by Onigiri - Character Converter from Combined CCM\n"
        for k in template:
            formatted_maps += k + " = "
            formatted_maps += json.dumps(template[k], indent=4)
            formatted_maps += "\n"

        output = open(path, 'w', encoding='UTF8')
        output.write(formatted_maps)
        output.close()

        del bbe['template_map_combine']
        del bbe['map_type_combine']

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriSaveCombinedCTM(bpy.types.Operator, ExportHelper):
    bl_idname = "onigiri.save_combined_ctm"
    bl_label = "Save Combined Template"

    filename_ext = ".ctm"

    filter_glob : bpy.props.StringProperty(
        default='*.ctm',
        options={'HIDDEN'}
        )

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        path = self.properties.filepath

        template = bbe['template_map_combine'].to_dict()

        formatted_maps = "# Character Template Map auto-generated by Onigiri from CTM\n"

        for k in template:
            formatted_maps += k + " = "
            formatted_maps += json.dumps(template[k], indent=4)
            formatted_maps += "\n"

        output = open(path, 'w', encoding='UTF8')
        output.write(formatted_maps)
        output.close()

        del bbe['template_map_combine']
        del bbe['map_type_combine']

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriResetCombinedTemplates(bpy.types.Operator):
    """Click to reset the composer so you can have a clean slate"""
    bl_idname = "onigiri.reset_template_composer"
    bl_label = "Reset Composer"

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        del bbe['template_map_combine']
        del bbe['map_type_combine']
        del bbe['map_files_combine']
        return {'FINISHED'}

class OnigiriEditTemplateNewCTM(bpy.types.Operator):
    """Start a new map
"""

    bl_idname = "onigiri.edit_template_new_ctm"
    bl_label = "Create a new template"

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template

        if bbe.get('template_editing') != None:
            print("Create new CTM runs but there's already a template in the mapper")
            utils.popup("You have an active ctm, reset it to start a new one", "Template Exists", "INFO")
            return {'FINISHED'}

        sbone = utils.get_unique_name_short()
        tarm = utils.get_unique_name_short()
        tbone = utils.get_unique_name_short()
        bbe['template_editing'] = {sbone: {tarm: tbone}}

        return {'FINISHED'}

class OnigiriEditTemplateLoadFromTXT(bpy.types.Operator, ImportHelper):
    """Load a text file to create a template from that file.  The format for this file is one bone
map per line.  The SL bone is first and the second part is the target bone on the same line.
SL bones don't have spaces but your target can.
"""

    bl_idname = "onigiri.edit_template_load_txt"
    bl_label = "Open TXT"

    filename_ext = ".txt"

    filter_glob : bpy.props.StringProperty(
        default='*.txt',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_edit_template = bpy.context.window_manager.bb_edit_template
        bpy.ops.onigiri.edit_template_reset()

        template = {}

        try:
            with open(self.filepath, encoding='UTF8') as fh:
                for line in fh:
                    test_list = line.split()
                    if len(test_list) < 2:
                        continue
                    sbone, tbone = line.strip().split(' ', 1)
                    template[sbone] = tbone.strip()
        except Exception as e:
            print("Couldn't read:", self.filepath)
            print(traceback.format_exc())
            utils.popup("Couldn't read file", "Error reading", "ERROR")
            return {'FINISHED'}

        used_targets = {}
        duplicates = {}
        template_map = {}
        for sbone in template:
            tbone = template[sbone]
            if tbone in used_targets:
                duplicates[tbone] = ""
                continue
            if bb_edit_template.load_txt_reversed == True:
                used_targets[sbone] = "" 
                template_map[tbone] = {}
                template_map[tbone]["Target"] = sbone

            else:
                used_targets[tbone] = "" 
                template_map[sbone] = {}
                template_map[sbone]["Target"] = tbone

        if len(duplicates) > 0:
            print("There were duplicate targets in your map, they were removed:", duplicates)
            utils.popup("Duplicates were found and removed, see console.", "Info", "INFO")

        bb_edit_template['template_editing'] = template_map

        return {'FINISHED'}

class OnigiriEditTemplateLoadFromCTM(bpy.types.Operator, ImportHelper):
    """Load a CTM or BBM into the manual editor.
"""

    bl_idname = "onigiri.edit_template_load_ctm"
    bl_label = "Edit Template"

    filename_ext = ".ctm"

    target : bpy.props.StringProperty(default="template_editing")

    filter_glob : bpy.props.StringProperty(
        default='*.ctm;*.bbm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_edit_template = bpy.context.window_manager.bb_edit_template
        bpy.ops.onigiri.edit_template_reset()

        try:
            namespace = {}
            exec(open(self.filepath, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("error loading ctm")
            print(traceback.format_exc())
            return {'FINISHED'}

        template_map = {}
        try:
            template_map.update(namespace['template_map'])
        except:
            txt = "No template_map found in the ctm"
            print(txt)
            utils.popup(txt, "Error", "ERROR")
            return {'FINISHED'}

        bb_edit_template[self.target] = template_map

        return {'FINISHED'}

class OnigiriEditTemplateSaveFromCTM(bpy.types.Operator, ExportHelper):
    """Save your loaded map as a BBM
"""
    bl_idname = "onigiri.edit_template_save_ctm"
    bl_label = "Save Template"

    filename_ext = ".bbm"
    filter_glob : bpy.props.StringProperty(
        default='*.bbm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_edit_template = bpy.context.window_manager.bb_edit_template

        if bb_edit_template.get('template_editing'):

            template_map = bb_edit_template['template_editing'].to_dict()
            
            result = onemap.save_template(template=template_map, file=self.filepath)

            if result == False:
                print("Couln't write file:", self.filepath)
            return {'FINISHED'}

            formatted_text = utils.format_ctm(template_map)

            try:
                f = open(self.filepath, "w", encoding='UTF8')
                f.write(formatted_text)
                f.close()
                
                print("Template saved as:", self.filepath)
            except Exception as e:
                
                print("Couldn't write file:", self.filepath)
                print(traceback.format_exc())
        else:
            print("Property (template_editing) was missing when attempting to access it, we got ghosts!")

        return {'FINISHED'}

class OnigiriEditTemplatePickSource(bpy.types.Operator):
    """Picking a source rig enables the active mapping process where you can pick bones in
the interface for your source and targets.  Even this mapping process is for data only and
does not actually do anything except build a data set for you"""

    bl_idname = "onigiri.edit_template_pick_source"
    bl_label = "Choose a rig for your source bones and click this button\n"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type == 'ARMATURE':
            return True
        return False

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        obj = bpy.data.objects

        armObj = bpy.context.selected_objects[0]
        sarm = armObj.name
        print("source picked", sarm)
        bbe.terminate = True
        bbe.source_active = True
        return {'FINISHED'}

class OnigiriEditTemplatePickTarget(bpy.types.Operator):
    """Choose a target rig and click this button to add it to your map.
"""

    bl_idname = "onigiri.edit_template_pick_target"
    bl_label = "Choose a target rig\n"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False

        bbe = bpy.context.window_manager.bb_edit_template
        return bbe.source_active

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        obj = bpy.data.objects

        armObj = bpy.context.selected_objects[0]
        tarm = armObj.name
        print("target picked", tarm)
        bbe.terminate = True

        if bbe.get('template_editor_targets') == None:
            bbe['template_editor_targets'] = dict()

        if tarm in bbe['template_editor_targets']:
            print("target exists already:", tarm)
            utils.popup("Target already chosen", "Info", "INFO")
        else:
            bbe['template_editor_targets'][tarm] = {}

        return {'FINISHED'}

class OnigiriEditTemplateMoveTarget(bpy.types.Operator):
    """WARNING: This will merge or rename a rig stream.  Any target bones that match
within a merger will be overwritten by the renamed stream.  There is no recovery from this.
Any stored undo will be removed
"""

    bl_idname = "onigiri.edit_template_move_target"
    bl_label = "Click to globally change the rig name or merge\n"

    name : bpy.props.StringProperty(default="")

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        obj = bpy.data.objects

        if self.name == bbe.get('name'):
            
            del bbe['name']
            del bbe['item']
            return {'FINISHED'}

        bbe['item'] = "move"
        bbe['name'] = self.name

        bbe.terminate = True
        bbe.move_name = self.name
        bbe.move_name_backup = self.name

        return {'FINISHED'}

class OnigiriEditTemplateRemovePrefix(bpy.types.Operator):
    """This remove the bone prefix from the associated rig, if there is one"""

    bl_idname = "onigiri.edit_template_remove_prefix"
    bl_label = "Remove prefix"

    target : bpy.props.StringProperty(default="")

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        obj = bpy.data.objects

        template = bbe['template_editing'].to_dict()

        names = []
        template_new = {}
        for sbone in template:
            (tarm, tbone), = template[sbone].items()
            if tarm == self.target:
                names.append(tbone)
            
            template_new[sbone] = {tarm : tbone}
        
        prefix = os.path.commonprefix(names)
        if prefix != "":
            print("prefix:", prefix)
            for sbone in template:
                (tarm, tbone), = template[sbone].items()
                if tarm == self.target:
                    if tbone.startswith(prefix):
                        new_bone = tbone.replace(prefix, "", 1)
                        template_new[sbone] = {tarm:new_bone}
                else:
                    print("Bone is identified as having a prefix but when attempting to remove it there was none!", bone)

        bbe['template_editing'] = template_new

        return {'FINISHED'}

class OnigiriEditTemplateRemoveTarget(bpy.types.Operator):
    """WARNING:  This will remove a target rig from your map completely.  This
is not usually what you need but it's here for convenience.
"""

    bl_idname = "onigiri.edit_template_remove_target"
    bl_label = "Click to globally remove a target from your map\n"

    name : bpy.props.StringProperty(default="")

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        obj = bpy.data.objects

        if self.name == bbe.get('name'):
            
            del bbe['name']
            del bbe['item']
            return {'FINISHED'}

        print("Removing target armature stream for:", self.name)

        template_new = {}
        template = bbe['template_editing'].to_dict()
        for sbone in template:
            (tarm, tbone), = template[sbone].items()
            if tarm == self.name:
                continue
            template_new[sbone] = {tarm : tbone}

        bbe['template_editing'] = template_new
        bbe.terminate = True
        bbe.move_name = ""
        bbe.move_name_backup = ""

        if bbe.get('name'):
            del bbe['name']
        if bbe.get('item'):
            del bbe['item']

        if len(bbe['template_editing']) == 0:
            
            print("All target rigs were removed, resetting")
            bpy.ops.onigiri.edit_template_reset()

        if bbe.get('template_editing_undo'):
            undo_stream = bbe['template_editing_undo']['new'].to_dict()
            (sbone, tarm_tbone), = undo_stream.items()
            (tarm, tbone), = tarm_tbone.items()
            if tarm == self.name:
                print("removed undo for target armature:", self.name)
                del bbe['template_editing_undo']

        return {'FINISHED'}

class OnigiriEditTemplateReset(bpy.types.Operator):
    """This will clear out the editor, make sure you saved your work if you want to keep it"""

    bl_idname = "onigiri.edit_template_reset"
    bl_label = "Edit Template Reset"

    def execute(self, context):
        
        bbe = bpy.context.window_manager.bb_edit_template
        if bbe.get('template_editing') != None:
            del bbe['template_editing']
        if bbe.get('template_editing_undo') != None:
            del bbe['template_editing_undo']
        if bbe.get('item') != None:
            del bbe['item']
        if bbe.get('name') != None:
            del bbe['name']

        bbe.show_rigs = False
        bbe.terminate = True
        bbe.move_name = ""
        bbe.move_name_backup = ""
        bbe.terminate = True
        bbe.source_active = False

        bbe.item_name = ""
        bbe.item_name_backup = ""

        return {'FINISHED'}

class OnigiriEditTemplateRemoveBone(bpy.types.Operator):
    """The X indicates a state:

red, source is a root bone but target is not
white/black, target is a root bone but source is not
white, root to root
black, not in map mode"""

    bl_idname = "onigiri.edit_template_remove_bone"
    bl_label = "Click to remove this bone from the map\n"

    bone : bpy.props.StringProperty(default="")

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        try:
            del bbe['template_editing'][self.bone]
            if len(bbe['template_editing']) == 0:
                del bbe['template_editing']
            print("Removed", self.bone)
        except:
            print("Couldn't remove bone, this is weird:", self.bone)

        if bbe.get('template_editing_undo') != None:
            undo_stream = bbe['template_editing_undo']['new'].to_dict()
            (sbone, tarm_tbone), = undo_stream.items()
            if self.bone == sbone:
                print("removed undo for bone:", self.bone)
                del bbe['template_editing_undo']

        return {'FINISHED'}

class OnigiriEditTemplateAddBone(bpy.types.Operator):
    """Add a bone to the map.  Unique names will be given to each element.  Obviously
you'll want to rename them to bones and rigs you'll expect to be working with.  If you
get an error about a collision just try again
"""
    bl_idname = "onigiri.edit_template_add_bone"
    bl_label = "Click to manually add a bone to the mapper\n"

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template

        sbone = utils.get_unique_name_short()
        tarm = utils.get_unique_name_short()
        tbone = utils.get_unique_name_short()

        tarm = sbone
        tbone = sbone

        if sbone in bbe['template_editing']:
            print("uuid was present in the map as a source bone, maybe try again?")
            utils.popup("the uniquly created name for the source bone existed in the map, see console", "Collision", "ERROR")
            return {'FINISHED'}

        template = bbe['template_editing'].to_dict()
        template_new = dict()
        template_new[sbone] = {}
        template_new[sbone][tarm] = tbone

        print("OnigiriEditTemplateAddBone : Generated bone defs:", sbone, tarm, tbone)

        for sbone in template:
            (tarm, tbone), = template[sbone].items()
            template_new[sbone] = {}
            template_new[sbone][tarm] = tbone

        bbe['template_editing'] = template_new

        return {'FINISHED'}

class OnigiriEditTemplateChangeRigName(bpy.types.Operator):
    """This changes a single bone branch and will split into a different stream.
This is usually not what you want, if you want to rename a rig globally use the
Rig Tools options
"""

    bl_idname = "onigiri.edit_template_change_rig_name"
    bl_label = "Click to change the name of the target rig\n"

    name : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_edit_template = bpy.context.window_manager.bb_edit_template
        obj = bpy.data.objects

        if self.name == bb_edit_template.get('name'):
            
            del bb_edit_template['name']
            del bb_edit_template['item']
            return {'FINISHED'}

        bb_edit_template['item'] = "tarm"
        bb_edit_template['name'] = self.name

        (tarm, tbone), = bb_edit_template['template_editing'][self.name].items()
        bb_edit_template.terminate = True
        bb_edit_template.tarm_name = tarm
        bb_edit_template.tarm_name_backup = tarm

        return {'FINISHED'}

class OnigiriEditTemplateChangeSourceBone(bpy.types.Operator):
    """Changing a source bone name to another takes the stream with it, which is to say the
target rig and target bone stay the same.  The only change you'll see is the source bone name.
"""
    bl_idname = "onigiri.edit_template_change_source_bone"
    bl_label = "Click to change the name of the source bone\n"

    name : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_edit_template = bpy.context.window_manager.bb_edit_template
        obj = bpy.data.objects

        if self.name == bb_edit_template.get('name'):
            
            del bb_edit_template['name']
            del bb_edit_template['item']
            return {'FINISHED'}

        bb_edit_template['item'] = "sbone"
        bb_edit_template['name'] = self.name

        bb_edit_template.terminate = True
        bb_edit_template.sbone_name = self.name
        bb_edit_template.sbone_name_backup = self.name

        return {'FINISHED'}

class OnigiriEditTemplateChangeTargetBone(bpy.types.Operator):
    """Change the target bone name, presumably to make it match an existing bone in the
target rig.  The entire stream goes with it, source bone and target rig.
"""

    bl_idname = "onigiri.edit_template_change_target_bone"
    bl_label = "Click to change the name of the target bone\n"

    name : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_edit_template = bpy.context.window_manager.bb_edit_template
        obj = bpy.data.objects

        if self.name == bb_edit_template.get('name'):
            
            del bb_edit_template['name']
            del bb_edit_template['item']
            return {'FINISHED'}

        bb_edit_template['item'] = "tbone"
        bb_edit_template['name'] = self.name

        (tarm, tbone), = bb_edit_template['template_editing'][self.name].items()
        bb_edit_template.terminate = True
        bb_edit_template.tbone_name = tbone
        bb_edit_template.tbone_name_backup = tbone

        return {'FINISHED'}

class OnigiriEditTemplateUndo(bpy.types.Operator):
    """This will undo the last change you made, the display with the red recycle
icon will show what is in storage.  You only get one of these so if you made a
mistake take advantage of this right away!"""

    bl_idname = "onigiri.edit_template_undo"
    bl_label = "Click this to recover from a mistake\n"

    @classmethod
    def poll(cls, context):
        bbe = bpy.context.window_manager.bb_edit_template
        if bbe.get('template_editing_undo') == None:
            return False
        return True

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template

        old_stream = bbe['template_editing_undo']['old'].to_dict()
        new_stream = bbe['template_editing_undo']['new'].to_dict()

        (old_bone, tarm_tbone), = old_stream.items()
        (new_bone, junk), = new_stream.items()

        template = bbe['template_editing'].to_dict()
        template_new = dict()
        template_new[old_bone] = tarm_tbone
        for t in template:
            if t == new_bone:
                continue
            template_new[t] = template[t]

        bbe['template_editing'] = template_new

        bbe.terminate = True
        bbe.sbone_name = old_bone
        bbe.sbone_name_backup = old_bone

        (new, old), = bbe['template_editing_undo']['map'].items()
        bbe.message = new + " restored to " + old

        del bbe['template_editing_undo']

        return {'FINISHED'}

class OnigiriPanelTemplateEditor(bpy.types.Panel):
    """This is CTM Editor"""
    bl_idname = "OBJECT_PT_bento_buddy_template_tools"
    bl_label = "Template Creator / Editor"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        obj = bpy.data.objects
        selected = bpy.context.selected_objects
        
        bbe =               bpy.context.window_manager.bb_edit_template
        bb_edit_template =  bpy.context.window_manager.bb_edit_template

        scale_factor = 21
        
        icon_repeat = int(round(bpy.context.region.width / scale_factor))

        editor_manual_menu_enabled_icon = "menu_closed"
        if bbe.editor_manual_menu_enabled == True:
            editor_manual_menu_enabled_icon = "menu_opened"

        row = self.layout.row(align=True)
        row.prop(
            bbe,
            "editor_manual_menu_enabled",
            toggle=True,
            text = "Expand manual editor",
            icon_value = ico.custom_icons[editor_manual_menu_enabled_icon].icon_id
            )
        if bbe.editor_manual_menu_enabled == True:
            layout = self.layout
            box = layout.box()
            box.label(
                text = "Template Converter:",
                )
            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.load_generic_template",
                text="Load ctm or ccm",
                icon_value = ico.custom_icons["load"].icon_id
                )
            row.prop(
                bbe,
                "info_onigiri_load_generic_template",
                toggle=True,
                text = "",
                icon_value = ico.custom_icons["alert"].icon_id
                )
            row = col.row(align=True)

            row.operator(
                "onigiri.save_ccm",
                text="Save as Character Converter",
                icon_value = ico.custom_icons["save"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.save_ctm",
                text="Save as Template Map",
                icon_value = ico.custom_icons["save"].icon_id
                )
            
            layout = self.layout
            box = layout.box()
            box.label(
                text = "Template Composer:",
                )
            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.load_templates",
                text = "Load a template",
                icon_value = ico.custom_icons["load"].icon_id
                )
            
            row.prop(
                bbe,
                "disable_map_pose",
                text = "",
                toggle = True,
                icon_value = ico.custom_icons["disable_map_pose"].icon_id
                )
            row.prop(
                bbe,
                "disable_map_code",
                text = "",
                toggle = True,
                icon_value = ico.custom_icons["code_disabled"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.save_templates",
                text = "Save loaded templates as one",
                icon_value = ico.custom_icons["save"].icon_id
                )
            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.reset_templates",
                text = "Reset Composer",
                icon_value = ico.custom_icons["reset"].icon_id
                )

            layout = self.layout
            row = col.row(align=True)
            row.label(
                text = "- maps loaded -",
                )
            
            for m in bbe.get('bb_onemap_list', []):
                row = col.row(align=True)
                row.label(
                    text = "[" + m + "]",
                    )

            layout = self.layout

            box = layout.box()
            box.label(
                text = "Manual Template Creator / Editor:",
                )
            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.edit_template_new_ctm",
                text = "New map",
                icon_value = ico.custom_icons["magic"].icon_id
                )
            row.operator(
                "onigiri.edit_template_load_ctm",
                text = "Load ctm / bbm",
                icon_value = ico.custom_icons["load"].icon_id
                )

            test_ccm = False
            if test_ccm == True:
                row.operator(
                    "onigiri.edit_template_load_ccm",
                    text = "Load ccm",
                    icon_value = ico.custom_icons["load"].icon_id
                    )

            row.operator(
                "onigiri.edit_template_load_txt",
                text = "Load txt",
                icon_value = ico.custom_icons["load"].icon_id
                )
            row.prop(
                bb_edit_template,
                "load_txt_reversed",
                toggle=True,
                text = "",
                icon_value = ico.custom_icons["loop"].icon_id
                )

            if test_ccm == True:
                row = col.row(align=True)
                row.operator(
                    "onigiri.edit_template_save_ccm",
                    text = "Save ccm",
                    icon_value = ico.custom_icons["save"].icon_id
                    )

            if bb_edit_template.get('template_editing'):
                row = col.row(align=True)
                row.operator(
                    "onigiri.edit_template_save_ctm",
                    text = "Save bbm",
                    icon_value = ico.custom_icons["save"].icon_id
                    )

                if bb_edit_template.show_map == True:
                    edit_template_show_map_icon = "menu_opened"
                else:
                    edit_template_show_map_icon = "menu_closed"
                if bb_edit_template.show_rigs == True:
                    edit_template_show_rigs_icon = "menu_opened"
                else:
                    edit_template_show_rigs_icon = "menu_closed"

                col = box.column(align = True)
                row = col.row(align=True)
                row.prop(
                    bb_edit_template,
                    "show_map",
                    toggle=True,
                    text = "Expand Map",
                    icon_value = ico.custom_icons[edit_template_show_map_icon].icon_id
                    )

                row.prop(
                    bb_edit_template,
                    "show_rigs",
                    toggle=True,
                    text = "Rig Options",
                    icon_value = ico.custom_icons[edit_template_show_rigs_icon].icon_id
                    )

                if bb_edit_template.show_map == True or bb_edit_template.show_rigs == True:

                        row = col.row(align=True)
                        for i in range(icon_repeat):
                            row.label(
                                text = "",
                                icon_value = ico.custom_icons["line_thin_white"].icon_id
                                )

                        row = col.row(align=True)
                        
                        row.label(
                            text = "[" +bbe.message + "]",
                            )
                        
                        if bbe.get('template_editing_undo') != None:
                            edit_template_undo_icon = "reset_warning"
                            row_state = True
                        else:
                            edit_template_undo_icon = "reset"
                            row_state = False

                        row.operator(
                            "onigiri.edit_template_undo",
                            text = "",
                            icon_value = ico.custom_icons[edit_template_undo_icon].icon_id
                            )

                if bb_edit_template.show_rigs == True:
                    row = col.row(align=True)

                    for i in range(icon_repeat):
                        row.label(
                            text = "",
                            icon_value = ico.custom_icons["line_thin_white"].icon_id
                            )

                    if 1 == 0:
                        row = col.row(align=True)
                        if bbe.source_active == True:
                            row.prop(
                                bbe,
                                "source_active",
                                toggle = True,
                                text = "Source Active",
                                icon_value = ico.custom_icons["walking_black"].icon_id
                                )
                        else:
                            row.operator(
                                "onigiri.edit_template_pick_source",
                                text = "Pick the source rig",
                                icon_value = ico.custom_icons["walking_blue"].icon_id
                                )
                        row.operator(
                            "onigiri.edit_template_pick_target",
                            text = "Pick a target rig",
                            icon_value = ico.custom_icons["walking_red"].icon_id
                            )

                        col = box.column(align = True)
                        row = col.row(align=True)
                        row.label(
                            text = "This is the manual mapper, automated features are on the way",
                            )
                        row = col.row(align=True)

                    targets = dict()
                    for sbone in bbe.get('template_editing', []):
                        (tarm, tbone), = bbe['template_editing'][sbone].items()
                        targets[tarm] = "" 
                    for target in targets:
                        row = col.row(align=True)
                        row.operator(
                            "onigiri.edit_template_move_target",
                            text = "",
                            icon_value = ico.custom_icons["edit_red"].icon_id
                            ).name = target
                        if bb_edit_template.get('item') == "move" and bb_edit_template.get('name') == target:
                            row.prop(
                                bb_edit_template,
                                "move_name",
                                text = "",
                                )
                        else:
                            row.label(
                                text = target,
                                )
                        row.operator(
                            "onigiri.edit_template_remove_prefix",
                            text = "",
                            icon_value = ico.custom_icons["prefix_remove"].icon_id
                            ).target = target

                        row.operator(
                            "onigiri.edit_template_remove_target",
                            text = "",
                            icon_value = ico.custom_icons["x_red"].icon_id
                            ).name = target

                if bb_edit_template.show_map == True:
                    edit_template_change_source_bone_icon = "edit"
                    edit_template_change_target_bone_icon = "edit"
                    edit_template_change_rig_name_icon = "edit"

                    row = col.row(align=True)

                    if bb_edit_template.get('template_editing'):
                        row = col.row(align=True)
                        for i in range(icon_repeat):
                            row.label(
                                text = "",
                                icon_value = ico.custom_icons["line_thin_white"].icon_id
                                )

                        row = col.row(align=True)
                        row.label(
                            text = "Source Bone",
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row.label(
                            text = "Target Rig",
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row.label(
                            text = "Target Bone",
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row.operator(
                            "onigiri.edit_template_reset",
                            text = "",
                            icon_value = ico.custom_icons["reset"].icon_id
                            )
                        scale_factor = 21
                        icon_repeat = int(round(bpy.context.region.width / scale_factor))
                        row = col.row(align=True)
                        
                        for i in range(icon_repeat):
                            row.label(
                                text = "",
                                icon_value = ico.custom_icons["line_thin_white"].icon_id
                                )

                        row = col.row(align=True)
                        row.operator(
                            "onigiri.edit_template_add_bone",
                            text = "",
                            icon_value = ico.custom_icons["magic"].icon_id
                            )
                        row.label(
                            text = "Manually add a custom bone to the map",
                            )

                    for sbone in bb_edit_template['template_editing']:

                        row = col.row(align=True)
                        (tarm, tbone), = bb_edit_template['template_editing'][sbone].items()

                        row.operator(
                            "onigiri.edit_template_change_source_bone",
                            text = "",
                            icon_value = ico.custom_icons[edit_template_change_source_bone_icon].icon_id
                            ).name = sbone

                        if bb_edit_template.get('item') == "sbone" and bb_edit_template.get('name') == sbone:
                            row.prop(
                                bb_edit_template,
                                "sbone_name",
                                text = "",
                                )
                        else:
                            row.label(
                                text = sbone
                                )
                        row.operator(
                            "onigiri.edit_template_change_rig_name",
                            text = "",
                            icon_value = ico.custom_icons[edit_template_change_rig_name_icon].icon_id
                            ).name = sbone

                        if bb_edit_template.get('item') == "tarm" and bb_edit_template.get('name') == sbone:
                            row.prop(
                                bb_edit_template,
                                "tarm_name",
                                text = "",
                                )
                        else:
                            row.label(
                                text = tarm
                                )
                        row.operator(
                            "onigiri.edit_template_change_target_bone",
                            text = "",
                            icon_value = ico.custom_icons[edit_template_change_target_bone_icon].icon_id
                            ).name = sbone

                        if bb_edit_template.get('item') == "tbone" and bb_edit_template.get('name') == sbone:
                            row.prop(
                                bb_edit_template,
                                "tbone_name",
                                text = "",
                                )
                        else:
                            row.label(
                                text = tbone
                                )
                        row.operator(
                            "onigiri.edit_template_remove_bone",
                            text = "",
                            icon_value = ico.custom_icons["x_black"].icon_id
                            ).bone = sbone

        layout = self.layout
        row = self.layout.row(align=True)
        bb_onemap = bpy.context.scene.bb_onemap

        onemap_menu_enabled_icon = "menu_closed"
        if bb_edit_template.onemap_menu_enabled == True:
            onemap_menu_enabled_icon = "menu_opened"

        row.prop(
            bb_edit_template,
            "onemap_menu_enabled",
            text = "Hybrid Mapper",
            icon_value = ico.custom_icons[onemap_menu_enabled_icon].icon_id
            )
        
        if bb_edit_template.onemap_menu_enabled == True:
            layout = self.layout
            box = layout.box()

            box.label(
                text = bb_onemap.onemap_message,
                )
            col = box.column(align = True)

            row = col.row(align=True)
            row.operator(
                "onigiri.snap_nuke",
                text = "Nuke Influences",
                icon_value = ico.custom_icons["nuke"].icon_id
                )
            row.operator(
                "onigiri.motion_match_map",
                text="Match Map",
                icon_value = ico.custom_icons["match"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bb_onemap,
                "onemap_platform_opensim",
                toggle = True,
                text = "SL / Opensim Target",
                icon_value = ico.custom_icons["opensim"].icon_id
                )
            row.prop(
                bb_onemap,
                "onemap_platform_other",
                toggle = True,
                text = "Custom Target",
                icon_value = ico.custom_icons["controller"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.onemap_load_map",
                text = "Load Map",
                icon_value = ico.custom_icons["load"].icon_id
                )
            row.operator(
                "onigiri.onemap_save_map",
                text = "Save Map",
                icon_value = ico.custom_icons["save"].icon_id
                )
            
            row = col.row(align=True)
            row.prop(
                bb_onemap,
                "onemap_load_pose",
                toggle = True,
                text = "Load Pose",
                )
            row.prop(
                bb_onemap,
                "onemap_save_pose",
                toggle = True,
                text = "Save Pose",
                )
            
            row.operator(
                "onigiri.onemap_apply_pose",
                text = "Apply Pose",
                )
            row.operator(
                "onigiri.onemap_store_pose",
                text = "Store Pose",
                )

            row = col.row(align=True)
            row.prop(
                bb_onemap,
                "onemap_blank",
                toggle = True,
                text = "Last Loaded: " + bb_onemap.onemap_template_name,
                )
            
            row = col.row(align=True)
            has_prefix_text = "No prefix"
            has_prefix_icon = "bone_black"
            selected = bpy.context.selected_objects
            if len(selected) == 1:
                rename_map = selected[0].get('bb_onemap_rename')
                if rename_map != None:
                    anchors = []
                    for bone in rename_map.keys():
                        anchors.append(bone)
                    has_prefix = os.path.commonprefix(anchors)
                    if has_prefix != "":
                        has_prefix_text = "This map contains a prefix"
                        has_prefix_icon = "bone_red"

            row.operator(
                "onigiri.onemap_remove_prefix",
                text = has_prefix_text,
                icon_value = ico.custom_icons[has_prefix_icon].icon_id
                )
            row.operator(
                "onigiri.onemap_remove_unused",
                text="Remove Unused",
                icon_value = ico.custom_icons["bone_black"].icon_id
                )

            bb_onemap_state = onemap.props['bb_onemap_state']
            row = col.row(align=True)
            if bb_onemap_state == "started":
                row.enabled = False
                row.operator(
                    "onigiri.onemap_action",
                    text = "Ready",
                    icon_value = ico.custom_icons["play_red"].icon_id
                    )
            elif bb_onemap_state == "pick":
                row.operator(
                    "onigiri.onemap_pick_output",
                    text = "Pick Output Rig",
                    icon_value = ico.custom_icons["play_green"].icon_id
                    )
            
            else:
                row.operator(
                    "onigiri.onemap_action",
                    text = "Action!",
                    icon_value = ico.custom_icons["action"].icon_id
                    )
            row.prop(
                bb_onemap,
                "onemap_offset",
                toggle = True,
                text = "Offset:",
                )
            
            row = col.row(align=True)
            row.operator(
                "onigiri.snap_mesh",
                text = "Hide Mesh",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "hide"
            row.operator(
                "onigiri.snap_mesh",
                text = "Show Mesh",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "show"
            
            col = box.column(align = True)
            row = col.row(align=True)

            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.onemap_view_actor_bones",
                text = "Reset Bone View",
                icon_value = ico.custom_icons["bone_red"].icon_id
                ).action = "hide"
            row.operator(
                "onigiri.onemap_view_actor_bones",
                text = "Show All Bones",
                icon_value = ico.custom_icons["bone_red"].icon_id
                ).action = "show"

            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.onemap_view_director_bones",
                text = "Show Deformable",
                icon_value = ico.custom_icons["bone_blue"].icon_id
                ).action = "show"
            row.operator(
                "onigiri.onemap_view_director_bones",
                text = "Hide Erroneous",
                icon_value = ico.custom_icons["bone_blue"].icon_id
                ).action = "hide"
            row = col.row(align=True)
            row.operator(
                "onigiri.onemap_view_director_bones",
                text = "Restore View",
                icon_value = ico.custom_icons["bone_blue"].icon_id
                ).action = "restore"
            row.operator(
                "onigiri.onemap_view_director_bones",
                text = "Clear Saves States",
                icon_value = ico.custom_icons["bone_blue"].icon_id
                ).action = "clear"

            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.onemap_remove_map",
                text = "Remove Map",
                icon_value = ico.custom_icons["x_red"].icon_id
                )
            row.operator(
                "onigiri.onemap_reset",
                text = "Reset Stage",
                icon_value = ico.custom_icons["reset"].icon_id
                )
            row = col.row(align=True)

            if len(bpy.context.selected_objects) != 0:
                inRig = onemap.get_director(armature=bpy.context.selected_objects[0].name)
                if inRig != False:
                    outRig = inRig['bb_onemap_actor']
                    if bb_onemap_state == "started":

                        col = box.column(align = True)
                        row = col.row(align=True)

                        bb_input_rig = inRig.name
                        bb_output_rig = inRig['bb_onemap_actor'].name
                        row.prop(
                            bb_onemap,
                            "onemap_blank",
                            toggle = True,
                            text = "IN: " + bb_input_rig,
                            icon_value = ico.custom_icons["running_guy"].icon_id
                            )
                        row.prop(
                            bb_onemap,
                            "onemap_blank",
                            toggle = True,
                            text = "OUT: " + bb_output_rig,
                            icon_value = ico.custom_icons["running_guy"].icon_id
                            )
                        
                        if 1 == 0:
                            row = col.row(align=True)
                            row.operator(
                                "onigiri.onemap_mesh",
                                text = "Hide Mesh",
                                icon_value = ico.custom_icons["blank"].icon_id
                                ).action = "hide"
                            row.operator(
                                "onigiri.onemap_mesh",
                                text = "Show Mesh",
                                icon_value = ico.custom_icons["blank"].icon_id
                                ).action = "show"
                        
                        row = col.row(align=True)
                        row.operator(
                            "onigiri.onemap_bones",
                            text = "Restore Bone View",
                            icon_value = ico.custom_icons["blank"].icon_id
                            ).action = "restore" 
                        row.operator(
                            "onigiri.onemap_bones",
                            text = "Show All Bones",
                            icon_value = ico.custom_icons["blank"].icon_id
                            ).action = "show"

                        col = box.column(align = True)
                        row = col.row(align=True)

                        row.scale_y = 1.5
                        row.operator(
                            "onigiri.onemap_map_bones",
                            text = "Map These Bones",
                            icon_value = ico.custom_icons["map"].icon_id
                            )
                        row.operator(
                            "onigiri.onemap_reskin_to_parent",
                            text = "Reskin to Parent",
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row = col.row(align=True)

                        row.operator(
                            "onigiri.onemap_nuke_selected",
                            text = "Unmap Selected",
                            icon_value = ico.custom_icons["nuke"].icon_id
                            )
                        row = col.row(align=True)

                        row.prop(
                            bb_onemap,
                            "onemap_follow",
                            toggle = True,
                            text = "Follow",
                            icon_value = ico.custom_icons["follow"].icon_id
                            )

                        col = box.column(align = True)
                        row = col.row(align=True)

                        if bpy.context.mode == 'POSE':
                            if len(bpy.context.selected_pose_bones) == 1:
                                pBone = bpy.context.selected_pose_bones[0]
                                if pBone.id_data == inRig:
                                    onemap.props['input_bone'] = pBone.name
                                elif pBone.id_data == outRig:
                                    onemap.props['output_bone'] = pBone.name
                                
                        input_bone = onemap.props['input_bone']
                        output_bone = onemap.props['output_bone']
                        if bb_onemap.onemap_reskin == True:
                            input_bone = onemap.props['reskin_bone']
                        if bb_onemap.onemap_move == True:
                            output_bone = onemap.props['move_bone']

                        if input_bone == "":
                            input_bone = " "
                        if output_bone == "":
                            output_bone = " "

                        if input_bone != onemap.props['last_input_bone']: 
                            
                            if bb_onemap.onemap_move == False and bb_onemap.onemap_reskin == False:
                                FAKE_PROPERTY_SETTER = bb_onemap.onemap_update_map
                                
                                if input_bone in inRig.get('bb_onemap_rename', {}):
                                    
                                    onemap.props['group_input_bone'] = input_bone

                                    FAKE_PROPERTY_SETTER = bb_onemap.onemap_set_input_bone_group
                                
                                onemap.props['last_input_bone'] = input_bone

                        if 1 == 0:
                            
                            if bb_onemap.onemap_move == False and bb_onemap.onemap_reskin == False:
                                FAKE_PROPERTY_SETTER = bb_onemap.onemap_update_map
                                
                                output_bb_onemap_rename =inRig.get('bb_onemap_rename', {})
                                for bone in output_bb_onemap_rename:
                                    if output_bone == output_bb_onemap_rename[bone]:
                                        onemap.props['group_output_name'] = "Selected"
                                        onemap.props['group_output_bone'] = output_bone
                                        
                                        FAKE_PROPERTY_SETTER = bb_onemap.onemap_set_output_bone_group
                                    
                            onemap.props['last_output_bone'] = output_bone

                        row = col.row(align=True)
                        row.operator(
                            "onigiri.onemap_remove_input_bone",
                            text = "",
                            icon_value = ico.custom_icons["x_red"].icon_id
                            ).bone = input_bone
                        row.prop(
                            bb_onemap,
                            "onemap_reskin",
                            toggle = True,
                            text = input_bone,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row.operator(
                            "onigiri.onemap_remove_output_bone",
                            text = "",
                            icon_value = ico.custom_icons["x_red"].icon_id
                            ).bone = output_bone
                        row.prop(
                            bb_onemap,
                            "onemap_move",
                            toggle = True,
                            text = output_bone,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )

                        row = col.row(align=True)
                        row.prop(
                            bb_onemap,
                            "onemap_reskin",
                            toggle = True,
                            text = "Add Reskin Bones",
                            icon_value = ico.custom_icons["alert"].icon_id
                            )
                        row.prop(
                            bb_onemap,
                            "onemap_move",
                            toggle = True,
                            text = "Move This Branch",
                            icon_value = ico.custom_icons["alert"].icon_id
                            )

                        col = box.column(align = True)
                        row = col.row(align=True)

                        if 1 == 1:
                            FAKE_PROPERTY_SETTING = bb_onemap.onemap_set_error
                            if FAKE_PROPERTY_SETTING == False:
                                return None

                        mapped_input_bone = " "
                        mapped_output_bone = " "
                        pbones = bpy.context.selected_pose_bones
                        if len(pbones) == 1:
                            if pbones[0].id_data == inRig:
                                bb_onemap_rename = inRig.get('bb_onemap_rename', {})
                                if pbones[0].name in bb_onemap_rename:
                                    mapped_input_bone = pbones[0].name
                                    mapped_output_bone = bb_onemap_rename[mapped_input_bone]
                            elif pbones[0].id_data == outRig:
                                bb_onemap_rename = inRig.get('bb_onemap_rename', {})
                                for bone in bb_onemap_rename:
                                    if pbones[0].name == bb_onemap_rename[bone]:
                                        mapped_output_bone = pbones[0].name
                                        mapped_input_bone = bone

                        mapped_input_bone_icon = "dot_blue"
                        mapped_output_bone_icon = "dot_red"
                        if mapped_input_bone == " ":
                            mapped_input_bone_icon = "dot_black"
                        if mapped_output_bone == " ":
                            mapped_output_bone_icon = "dot_black"

                        row.prop(
                            bb_onemap,
                            "onemap_blank",
                            toggle = True,
                            text = mapped_input_bone,
                            icon_value = ico.custom_icons[mapped_input_bone_icon].icon_id
                            )
                        row.prop(
                            bb_onemap,
                            "onemap_blank",
                            toggle = True,
                            text = mapped_output_bone,
                            icon_value = ico.custom_icons[mapped_output_bone_icon].icon_id
                            )

                        col = box.column(align = True)
                        row = col.row(align=True)

                        row.prop(
                            bb_onemap,
                            "onemap_hide_rename_bones",
                            toggle = True,
                            text = "Hide Anchor",
                            icon_value = ico.custom_icons["view_anchor_bones"].icon_id
                            )
                        row.prop(
                            bb_onemap,
                            "onemap_hide_reskin_bones",
                            toggle = True,
                            text = "Hide Reskin",
                            icon_value = ico.custom_icons["view_reskin_bones"].icon_id
                            )
                        row.prop(
                            bb_onemap,
                            "onemap_hide_output_bones",
                            toggle = True,
                            text = "Hide Output",
                            icon_value = ico.custom_icons["view_output_bones"].icon_id
                            )

                        col = box.column(align = True)
                        row = col.row(align=True)

                        row.prop(
                            bb_onemap,
                            "onemap_view_map",
                            toggle = True,
                            text = "View Map",
                            icon_value = ico.custom_icons["map"].icon_id
                            )

                        if bb_onemap.onemap_view_map == True:
                            
                            col = box.column(align = True)
                            row = col.row(align=True)

                            bb_onemap_rename = inRig.get('bb_onemap_rename', {})
                            bb_onemap_reskin = inRig.get('bb_onemap_reskin', {})
                            for bone_in in bb_onemap_rename:
                                bone_out = bb_onemap_rename[bone_in]
                                row = col.row(align=True)

                                if onemap.props['view_reskin_bones'] == bone_in:
                                    row.prop(
                                        bb_onemap,
                                        "onemap_view_reskin",
                                        text = bone_in,
                                        toggle = True,
                                        icon_value = ico.custom_icons["bone_black"].icon_id
                                        )
                                    row.operator(
                                        "onigiri.onemap_select_output_bone",
                                        text = bone_out,
                                        icon_value = ico.custom_icons["bone_red"].icon_id
                                        ).bone = bone_out
                                    reskin_bones = bb_onemap_reskin.get(bone_in, [])
                                    for view_reskin_bone in reskin_bones:
                                        row = col.row(align=True)
                                        row.operator(
                                            "onigiri.onemap_select_reskin_bone",
                                            text = view_reskin_bone,
                                            icon_value = ico.custom_icons["bone_green"].icon_id
                                            ).bone = view_reskin_bone
                                else:
                                    row.operator(
                                        "onigiri.onemap_view_reskin",
                                        text = bone_in,
                                        icon_value = ico.custom_icons["bone_blue"].icon_id
                                        ).bone = bone_in
                                    row.operator(
                                        "onigiri.onemap_select_output_bone",
                                        text = bone_out,
                                        icon_value = ico.custom_icons["bone_red"].icon_id
                                        ).bone = bone_out
                                
        layout = self.layout
        row = self.layout.row(align=True)
        bb_snap = bpy.context.window_manager.bb_snap

        snap_menu_enabled_icon = "menu_closed"
        if bb_snap.snap_menu_enabled == True:
            snap_menu_enabled_icon = "menu_opened"

        row.prop(
            bb_snap,
            "snap_menu_enabled",
            text = "Visual Snap Mapper",
            icon_value = ico.custom_icons[snap_menu_enabled_icon].icon_id
            )
        if bb_snap.snap_menu_enabled == True:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)
            row.operator(
                "onigiri.snap_nuke",
                text = "Nuke Influences",
                icon_value = ico.custom_icons["nuke"].icon_id
                )
            row.operator(
                "onigiri.snap_prepare",
                text = "Prepare Target",
                icon_value = ico.custom_icons["clean"].icon_id
                )

            row = col.row(align=True)
            row.operator(
                "onigiri.snap_load_map",
                text = "Load Map",
                icon_value = ico.custom_icons["load"].icon_id
                )
            row.operator(
                "onigiri.snap_save_map",
                text = "Save Map",
                icon_value = ico.custom_icons["save"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.snap_convert",
                text = "Director to Actor",
                icon_value = ico.custom_icons["follow"].icon_id
                )
            row.operator(
                "onigiri.snap_convert_undo",
                text = "Undo D2A",
                icon_value = ico.custom_icons["reset"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.onemap_reverse",
                text = "Reverse Map",
                icon_value = ico.custom_icons["to_actor"].icon_id
                )
            row.operator(
                "onigiri.motion_match_map",
                text="Match Map",
                icon_value = ico.custom_icons["match"].icon_id
                )
 
            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.snap_clean",
                text = "Clear maps",
                icon_value = ico.custom_icons["clean"].icon_id
                )
            row.operator(
                "onigiri.snap_reset",
                text = "Reset stage",
                icon_value = ico.custom_icons["reset"].icon_id
                )
            row = col.row(align=True)

            snap_template_name = ""
            if len(bpy.context.selected_objects) > 0:
                snap_template_name = bpy.context.selected_objects[0].get('bb_snap_map', "")
                mapObj = snap.get_director(armature=bpy.context.selected_objects[0].name)
                if mapObj != False:
                    snap_template_name = mapObj.get('bb_snap_map', "")
            row.prop(
                bb_snap,
                "snap_blank",
                toggle = True,
                text = "Last Loaded: " + snap_template_name,
                icon_value = ico.custom_icons["blank"].icon_id
                )

            row = col.row(align=True)
            row.operator(
                "onigiri.snap_mesh",
                text = "Hide Mesh",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "hide"
            row.operator(
                "onigiri.snap_mesh",
                text = "Show Mesh",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "show"

            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.snap_view_actor_bones",
                text = "Reset Bone View",
                icon_value = ico.custom_icons["bone_red"].icon_id
                ).action = "hide"
            row.operator(
                "onigiri.snap_view_actor_bones",
                text = "Show All Bones",
                icon_value = ico.custom_icons["bone_red"].icon_id
                ).action = "show"

            row = col.row(align=True)
            row.operator(
                "onigiri.snap_view_mapped_bones",
                text = "Hide Mapped Bones",
                icon_value = ico.custom_icons["bone_mixed"].icon_id
                ).action = "hide"
            row.operator(
                "onigiri.snap_view_mapped_bones",
                text = "Show Mapped Bones",
                icon_value = ico.custom_icons["bone_yellow_blue"].icon_id
                ).action = "show"

            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.snap_view_director_bones",
                text = "Show Deformable",
                icon_value = ico.custom_icons["bone_blue"].icon_id
                ).action = "show"
            row.operator(
                "onigiri.snap_view_director_bones",
                text = "Hide Erroneous",
                icon_value = ico.custom_icons["bone_blue"].icon_id
                ).action = "hide"
            row = col.row(align=True)
            row.operator(
                "onigiri.snap_deform_director_bones",
                text = "Enable Deform",
                icon_value = ico.custom_icons["bone_blue"].icon_id
                ).action = "enable"
            row.operator(
                "onigiri.snap_deform_director_bones",
                text = "Disable Deform",
                icon_value = ico.custom_icons["bone_blue"].icon_id
                ).action = "disable"
            row = col.row(align=True)
            row.operator(
                "onigiri.snap_view_director_bones",
                text = "Restore View",
                icon_value = ico.custom_icons["bone_blue"].icon_id
                ).action = "restore"
            row.operator(
                "onigiri.snap_view_director_bones",
                text = "Clear Saves States",
                icon_value = ico.custom_icons["bone_blue"].icon_id
                ).action = "clear"

            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.snap_action",
                text = "Action!",
                icon_value = ico.custom_icons["action"].icon_id
                )
            row.prop(
                bb_snap,
                "snap_target",
                toggle = True,
                text = "Custom Target",
                icon_value = ico.custom_icons["target"].icon_id
                )

            row = col.row(align=True)
            row.prop(
                bb_snap,
                "snap_blank",
                toggle = True,
                text = "Distance",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bb_snap,
                "snap_distance",
                toggle = True,
                text = "",
                
                )

            if len(bpy.context.selected_objects) != 2:
                return None
            if bpy.context.mode != 'POSE':
                return None
            
            inRig = snap.get_director(armature=bpy.context.active_object.name)
            if inRig == False:
                return None
            outRig = inRig['bb_snap_actor']

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_snap,
                "snap_blank",
                toggle = True,
                text = "Director: " + inRig.name,
                icon_value = ico.custom_icons["director"].icon_id
                )
            row.prop(
                bb_snap,
                "snap_blank",
                toggle = True,
                text = "Actor: " + outRig.name,
                icon_value = ico.custom_icons["running_guy"].icon_id
                )

            director_bone = ""
            actor_bone = ""
            dbone_mapped = " "
            abone_mapped = " "
            if len(bpy.context.selected_pose_bones) == 1:
                pBone = bpy.context.selected_pose_bones[0]
                if pBone.id_data == inRig:
                    director_bone = pBone.name
                    snap.props['director_bone'] = director_bone
                if pBone.id_data == outRig:
                    actor_bone = pBone.name
                    snap.props['actor_bone'] = actor_bone

            if inRig.get('bb_onemap_rename') != None:
                rename_mapped = inRig['bb_onemap_rename'].to_dict()
            else:
                rename_mapped = {}
            rename_reversed = {}
            for dmapped in rename_mapped:
                amapped = rename_mapped[dmapped]
                rename_reversed[amapped] = dmapped
            if director_bone in rename_mapped:
                dbone_mapped = director_bone
                abone_mapped = rename_mapped[director_bone]
            
            if actor_bone in rename_reversed:
                abone_mapped = actor_bone
                dbone_mapped = rename_reversed[actor_bone]
            
            row = col.row(align=True)
            row.prop(
                bb_snap,
                "snap_blank",
                toggle = True,
                text = dbone_mapped,
                icon_value = ico.custom_icons["bone_black"].icon_id
                )
            row.prop(
                bb_snap,
                "snap_blank",
                toggle = True,
                text = abone_mapped,
                icon_value = ico.custom_icons["bone_black"].icon_id
                )

            if 1 == 0:
                if bb_snap.snap_symmetry_enabled == True:
                    if pBone.id_data == inRig:
                        
                        if bb_snap.snap_symmetry_director == False:
                            
                            if snap.props['last_selected_director_bone'] == "":
                                snap.props['last_selected_director_bone'] = pBone.name
                                snap.props['director_side_a'] = pBone.name
                                snap.props['director_symmetry_display'] = "Choose Side B"
                            else:
                                if pBone.name != snap.props['last_selected_director_bone']:
                                    if snap.props['director_side_b'] == "":
                                        snap.props['director_side_b'] = pBone.name
                                    else:
                                        snap.props['last_selected_director_bone'] = pBone.name
                                        snap.props['director_side_a'] = snap.props['director_side_b']
                                        snap.props['director_side_b'] = pBone.name
                                    snap.props['last_selected_director_bone'] = pBone.name
                                    snap.props['director_symmetry_display'] = "Click This"
                    if pBone.id_data == outRig:
                        if bb_snap.snap_symmetry_actor == False:
                            if snap.props['last_selected_actor_bone'] == "":
                                snap.props['last_selected_actor_bone'] = pBone.name
                                snap.props['actor_side_a'] = pBone.name
                                snap.props['actor_symmetry_actor'] = "Choose Side B"
                            else:
                                if pBone.name != snap.props['last_selected_actor_bone']:
                                    if snap.props['actor_side_b'] == "":
                                        snap.props['actor_side_b'] = pBone.name
                                    else:
                                        snap.props['last_selected_actor_bone'] = pBone.name
                                        snap.props['actor_side_a'] = snap.props['actor_side_b']
                                        snap.props['actor_side_b'] = pBone.name
                                    snap.props['last_selected_actor_bone'] = pBone.name
                                    snap.props['actor_symmetry_display'] = "Click This"
                
            if True == False: 
                col = box.column(align = True)
                row = col.row(align=True)
                row.prop(
                    bb_snap,
                    "snap_symmetry_enabled",
                    toggle = True,
                    text = "Symmetry",
                    icon_value = ico.custom_icons["sync"].icon_id
                    )

            if bb_snap.snap_symmetry_enabled == True:
                
                row = col.row(align=True)
                row.prop(
                    bb_snap,
                    "snap_symmetry_director",
                    text = snap.props['director_symmetry_display'] + " ",
                    icon_value = ico.custom_icons["bone_black_red"].icon_id
                    )
                row.prop(
                    bb_snap,
                    "snap_symmetry_actor",
                    text = snap.props['actor_symmetry_display'] + " ",
                    icon_value = ico.custom_icons["bone_yellow_blue"].icon_id
                    )
                
                row = col.row(align=True)
                row.prop(
                    bb_snap,
                    "snap_blank",
                    text = "Side A: " + snap.props['director_side_a'],
                    icon_value = ico.custom_icons["bone_red"].icon_id
                    )
                row.prop(
                    bb_snap,
                    "snap_blank",
                    text = "Side A: " + snap.props['actor_side_a'],
                    icon_value = ico.custom_icons["bone_blue"].icon_id
                    )
                row = col.row(align=True)
                row.prop(
                    bb_snap,
                    "snap_blank",
                    text = "Side B: " + snap.props['director_side_b'],
                    icon_value = ico.custom_icons["bone_red"].icon_id
                    )
                row.prop(
                    bb_snap,
                    "snap_blank",
                    text = "Side B: " + snap.props['actor_side_b'],
                    icon_value = ico.custom_icons["bone_blue"].icon_id
                    )
            
            actor_bone = snap.props['actor_bone']
            director_bone = snap.props['director_bone']
            
            if actor_bone == "": actor_bone = " "
            if director_bone == "": director_bone = " "

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_snap,
                "snap_blank",
                text = director_bone,
                toggle = True,
                icon_value = ico.custom_icons["bone_blue"].icon_id
                )
            row.prop(
                bb_snap,
                "snap_blank",
                text = actor_bone,
                toggle = True,
                icon_value = ico.custom_icons["bone_red"].icon_id
                )

            row = col.row(align=True)
            row = col.split(factor=0.5, align=True)
            row.scale_y = 1.3
            row.operator(
                "onigiri.snap_map_add",
                text = "Map these bones",
                icon_value = ico.custom_icons["map_bones"].icon_id
                )

            row.operator(
                "onigiri.snap_map_remove",
                text = "Unmap",
                icon_value = ico.custom_icons["map_bones_reverse"].icon_id
                )
            
            row.operator(
                "onigiri.snap_map_undo",
                text = "Undo",
                icon_value = ico.custom_icons["rotate"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_snap,
                "snap_follow",
                toggle = True,
                text = "Follow",
                icon_value = ico.custom_icons["follow"].icon_id
                )
            
            if 1 == 0:
                row.prop(
                    bb_snap,
                    "snap_lead",
                    toggle = True,
                    text = "Lead",
                    icon_value = ico.custom_icons["lead"].icon_id
                    )

            snap_release_icon = "locked_black"
            if bb_snap.snap_release == True:
                snap_release_icon = "unlocked_black"
            row.prop(
                bb_snap,
                "snap_release",
                toggle = True,
                text = "Release",
                icon_value = ico.custom_icons[snap_release_icon].icon_id
                )

            row = col.row(align=True)

            row.prop(
                bb_snap,
                "snap_fill_protect",
                toggle = True,
                text = "Protect",
                icon_value = ico.custom_icons["safe"].icon_id
                )
            row.prop(
                bb_snap,
                "snap_fill_cross",
                toggle = True,
                text = "Cross",
                icon_value = ico.custom_icons["integrity_check"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bb_snap,
                "snap_fill_next",
                toggle = True,
                text = "Next",
                icon_value = ico.custom_icons["next_red_blue"].icon_id
                )
            row.prop(
                bb_snap,
                "snap_deformable",
                toggle = True,
                text = "Deformable",
                icon_value = ico.custom_icons["bone_bent"].icon_id
                )

            row = col.row(align=True)
            row.operator(
                "onigiri.snap_select_ends",
                text = "Select Safe",
                icon_value = ico.custom_icons["select_ends"].icon_id
                )
            row.operator(
                "onigiri.snap_deselect_non_ends",
                text = "Exclude Non Safe",
                icon_value = ico.custom_icons["deselect_non_ends"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.snap_select_volume_bones",
                text = "Select Volumes",
                icon_value = ico.custom_icons["select_volumes"].icon_id
                )
            row.operator(
                "onigiri.snap_select_attach_bones",
                text = "Select Attach",
                icon_value = ico.custom_icons["select_attach"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.snap_map_fill",
                text = "Fill",
                icon_value = ico.custom_icons["link"].icon_id
                )
            row.prop(
                bb_snap,
                "snap_fill_limit",
                toggle = True,
                text = "Chain Limit:",
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.snap_map_collect",
                text = "Collect",
                icon_value = ico.custom_icons["bones"].icon_id
                )
            row.operator(
                "onigiri.snap_map_deposit",
                text = "Deposit",
                icon_value = ico.custom_icons["bones_blue"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)

            snap_mapped_menu_enabled_icon = "menu_closed"
            if bb_snap.snap_mapped_menu_enabled == True:
                snap_mapped_menu_enabled_icon = "menu_opened"

            row.prop(
                bb_snap,
                "snap_mapped_menu_enabled",
                text = "View mapped bones",
                icon_value = ico.custom_icons[snap_menu_enabled_icon].icon_id
                )
            if bb_snap.snap_mapped_menu_enabled == True:
                
                abone_icon = "bone_red"
                rename_map = inRig.get('bb_onemap_rename', {})
                for dbone in rename_map.keys():
                    abone = rename_map[dbone]
                    if dbone == director_bone:
                        dbone_icon = "bone_red"
                    else:
                        dbone_icon = "bone_blue"
                    if abone == actor_bone:
                        abone_icon = "bone_blue"
                    else:
                        abone_icon = "bone_red"

                    row = col.row(align=True)
                    row.operator(
                        "onigiri.snap_select_director_bone",
                        text = dbone,
                        icon_value = ico.custom_icons[dbone_icon].icon_id
                        ).bone = dbone
                    row.operator(
                        "onigiri.snap_select_actor_bone",
                        text = abone,
                        icon_value = ico.custom_icons[abone_icon].icon_id
                        ).bone = abone
                    row.operator(
                        "onigiri.snap_map_remove_single",
                        text = "",
                        icon_value = ico.custom_icons["x_red"].icon_id
                        ).bone = dbone

class OnigiriEditTemplateLoadFromCCM(bpy.types.Operator, ImportHelper):
    """Load a CCM into the manual editor.
"""

    bl_idname = "onigiri.edit_template_load_ccm"
    bl_label = "Edit Template"

    filename_ext = ".ccm"

    target : bpy.props.StringProperty(default="template_editing")

    filter_glob : bpy.props.StringProperty(
        default='*.ccm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template
        bpy.ops.onigiri.edit_template_reset()

        try:
            namespace = {}
            exec(open(self.filepath, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("error loading ccm")
            print(traceback.format_exc())
            return {'FINISHED'}

        rename = {}
        reskin = {}
        pose = {}
        try:
            rename.update(namespace['rename'])
        except:
            txt = "No bone map was found in the ccm"
            print(txt)
            utils.popup(txt, "Error", "ERROR")
            return {'FINISHED'}
        try:
            reskin.update(namespace['reskin'])
        except:
            
            reskin = dict()
            print("No reskin data, that's not a fatal error but the definition should exist at least")
        try:
            pose.update(namespace['pose'])
        except:
            pose = dict()
            print("No pose data, that's not a fatal error but the definition should exist at least")

        bbe['template_ccm'] = dict()
        bbe['template_ccm']['rename'] = rename
        bbe['template_ccm']['reskin'] = reskin
        bbe['template_ccm']['pose'] = pose

        return {'FINISHED'}

class OnigiriEditTemplateSaveFromCCM(bpy.types.Operator, ExportHelper):
    """Save your loaded map as a CCM
"""
    bl_idname = "onigiri.edit_template_save_ccm"
    bl_label = "Save Template"

    filename_ext = ".ccm"
    filter_glob : bpy.props.StringProperty(
        default='*.ccm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bbe = bpy.context.window_manager.bb_edit_template

        if bbe.get('template_ccm'):

            template_map = bbe['template_ccm'].to_dict()
            formatted_text = utils.format_ccm(template_map)

            try:
                f = open(self.filepath, "w", encoding='UTF8')
                f.write(formatted_text)
                f.close()
                
                print("Template saved as:", self.filepath)
            except Exception as e:
                
                print("Couldn't write file:", self.filepath)
                print(traceback.format_exc())
        else:
            print("Property (template_ccm) was missing when attempting to access it, we got ghosts!")

        return {'FINISHED'}

class OnigiriShapeProperties(bpy.types.PropertyGroup):

    def update_shape_blank(self, context):
        self["shape_blank"] = False
    shape_blank : bpy.props.BoolProperty(
        default = False,
        update = update_shape_blank
        )

    shape_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Show / Hide the avatar shape features"            "\n\n"            "This is on the road map, we have an intuitive way to give you control over your shape without using unintuitive sliders.  "            "You'll be able to pick directly on your character and alter the appearence.  A set of sliders will be provided for use as "            "well but not required, these sliders allow you to see what the resulting numbers will be in SL but the shape export is "            "just fine for that and you never need to type this stuff in yourself.  Again, this is not functdional, it simply loads "            "a set of shape figures into the buffer where it can later be used for the indicated purpose, then that same information "            "is written back to a file.  This is effectively a shell to be filled later.",
        default = False
        )

    def update_shape_tab(self, context):
        
        print("---------------------")
        for tab in shape.props['tabs']:
            
            tab_prop = "shape_tab_" + tab
            new_state = getattr(self, tab_prop)
            old_state = shape.props['tabs'][tab]
            
            if new_state == old_state:
                print("match:", tab_prop, old_state)
                self[tab_prop] = False
                shape.props['tabs'][tab] = False
            else:
                print("no match:", tab_prop, old_state)
                shape.props['tabs'][tab] = new_state
 
    shape_tab_body : bpy.props.BoolProperty(
        name = "",
        description =            "Body Sliders"            "\n\n"            "Height, Body Thickness, Body Fat, Hover",
        default = False,
        update = update_shape_tab
        )
    shape_tab_head : bpy.props.BoolProperty(
        name = "",
        description =            "Head Sliders"            "\n\n"            "Head Size, Head Stretch, Head Shape, Egg Head, Head Length, Face Shear, Forehead Angle, "            "Lower Cheek, Brow Size, Upper Cheeks, Cheek Bones",
        default = False,
        update = update_shape_tab
        )
    shape_tab_eyes : bpy.props.BoolProperty(
        name = "",
        description =            "Eyes Sliders"            "\n\n"            "Eye Size, Eye Opening, Eye Spacing, Outer Eye Corner, Inner Eye Corner, Eye Depth, "            "Upper Eyelid Fold, Eye Bags, Puffy Eyelids",
        default = False,
        update = update_shape_tab
        )
    shape_tab_ears : bpy.props.BoolProperty(
        name = "",
        description =            "Ears Sliders"            "\n\n"            "Ear Size, Ear Tips",
        default = False,
        update = update_shape_tab
        )
    shape_tab_nose : bpy.props.BoolProperty(
        name = "",
        description =            "Nose Sliders"            "\n\n"            "Nose Size, Nose Width, Nostril Width, Nostril Division, Nose Thickness, Upper Bridge, "            "Lower Bridge, Bridge Width, Nose Tip Angle, Nose Tip Shape, Crooked Nose",
        default = False,
        update = update_shape_tab
        )
    shape_tab_mouth : bpy.props.BoolProperty(
        name = "",
        description =            "Mouth Sliders"            "\n\n"            "Lip Width, Lip Fullness, Lip Thickness, Lip Ratio, Mouth Position, Mouth Corner, Lip Cleft Depth, Lip Cleft, Shift Mouth",
        default = False,
        update = update_shape_tab
        )
    shape_tab_chin : bpy.props.BoolProperty(
        name = "",
        description =            "Chin Sliders"            "\n\n"            "Chin Angle, Jaw Shape, Chin Depth, Jaw Angle, Jaw Jut, Chin-Neck",
        default = False,
        update = update_shape_tab
        )
    shape_tab_torso : bpy.props.BoolProperty(
        name = "",
        description =            "Torso Sliders"            "\n\n"            "Torso Muscles, Neck Thickness, Neck Length, Shoulders, Breast Size, Breast Buoyancy, "            "Breast Cleavage, Arm Length, Hand Size, Torso Length, Love Handles, Belly Size",
        default = False,
        update = update_shape_tab
        )
    shape_tab_legs : bpy.props.BoolProperty(
        name = "",
        description =            "Leg Sliders"            "\n\n"            "Leg Muscles, Leg Length, Hip Width, Hip Length, Butt Size, Saddle Bags, Knee Angle, Foot Size",
        default = False,
        update = update_shape_tab
        )

class OnigiriShapeLoad(bpy.types.Operator, ImportHelper):
    """Load your XML that you exported from Second Life into the rig"""

    bl_idname = "onigiri.shape_load"
    bl_label = "Load XML"

    filter_glob : bpy.props.StringProperty(
        default='*.xml',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        if selected[0].type != 'ARMATURE':
            return False
        o = selected[0]
        
        return True
 
    def execute(self, context):
        bb_shape = bpy.context.window_manager.bb_shape
        armObj = bpy.context.object
        xml = shape.import_shape(file=self.filepath)
        if xml != None:
            armObj['bb_shape_data'] = xml

        else:
            print("Couldn't load shape, unknown error")
            popup("Shape failed to parse, not sure why", "Error", "ERROR")
            return {'FINISHED'}

        path, name = os.path.split(self.properties.filepath)

        armObj['bb_shape_data'] = xml
        armObj['bb_shape_name'] = name

        print("Shape loaded:", name)

        return {'FINISHED'}

class OnigiriShapeSave(bpy.types.Operator, ExportHelper):
    """Save your altered XML file for use in Second Life in the appearance shape
editor"""

    bl_idname = "onigiri.shape_save"
    bl_label = "Save Second Life XML Shape"

    filename_ext = ".xml"

    filter_glob : bpy.props.StringProperty(
        default='*.xml',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        if selected[0].type != 'ARMATURE':
            return False
        o = selected[0]
        
        if o.get('bb_shape_data') == None:
            return False
        
        return True

    def execute(self, context):
        bb_shape = bpy.context.window_manager.bb_shape
        
        armObj = bpy.context.object
        
        utils.activate(armObj)
        
        xml = armObj['bb_shape_data'].to_dict()
        result = shape.save_shape(shape=xml, file=self.filepath)
        if result == False:
            print("Somthing went wrong")
        else:
            print("saved xml shape to:", self.filepath)
        return {'FINISHED'}

class OnigiriShapeReset(bpy.types.Operator):
    """Reset the shape sliders to default for the indicated type"""

    bl_idname = "onigiri.shape_reset"
    bl_label = "Reset shape"

    @classmethod
    def poll(cls, context):
        
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        if selected[0].type != 'ARMATURE':
            return False
        o = selected[0]
        if o.get('bb_shape_data') == None:
            return False
        return True

    def execute(self, context):
        bb_shape = bpy.context.window_manager.bb_shape
        armObj = bpy.context.object
        utils.activate(armObj)
        xml = armObj['bb_shape_data'].to_dict()

        print("would have reset")

        return {'FINISHED'}

class OnigiriShapeRemove(bpy.types.Operator):
    """Remove all shape sliders and influences from the rig.  This is destructive
so you may want to save your changes"""

    bl_idname = "onigiri.shape_remove"
    bl_label = "Remove Sliders"

    @classmethod
    def poll(cls, context):
        
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        if selected[0].type != 'ARMATURE':
            return False
        o = selected[0]
        if o.get('bb_shape_data') == None:
            return False
        return True

    def execute(self, context):
        armObj = bpy.context.object
        utils.activate(armObj)

        armObj.pop('bb_shape_director', "")
        armObj.pop('bb_shape_actor', "")
        armObj.pop('bb_shape_data', "")
        armObj.pop('bb_shape_name', "")

        print("would have removed")

        return {'FINISHED'}

class OnigiriControllerProperties(bpy.types.PropertyGroup):

    controller_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Show / Hide the avatar controller features"            "\n\n"            "This is more advanced but may be even easier to use, strangely enough.  From here you can target controllers to your "            "custom rig that drive a Onigiri rig, which allows you to do a variety of things.  One thing you can do is to retarget "            "animations, like the other more complicated tool, but also you can configure a rig with ik controllers, drivers and "            "anything else you want then attach a Onigiri rig to it for more animation control.  The tool can take a template from "            "a CTM or CCM but please be aware the, while CTM's are capable of addressing multiple rigs, this particular tool will not "            "read past the first rig encountered in the CTM, which simplifies the process a great deal.",
        default = False
        )
    
    controller_type_name : bpy.props.StringProperty(
        name = "",
        description =            "--internal",
        default = ""
        )
    
    controller_type_toggle : bpy.props.BoolProperty(
        name = "",
        description =            "Controller type"            "\n\n"            "This is the type of controller you want to apply, or is already applied, to the rig set.",
        default = True
        )

    controller_template_name : bpy.props.StringProperty(
        name = "",
        description =            "--intermal",
        default = ""
        )

    def update_controller_stabilize(self, context):
        if self.controller_stabilize == True:
            bpy.ops.onigiri.controller_stabilize(action="on")
        else:
            bpy.ops.onigiri.controller_stabilize(action="off")
    controller_stabilize : bpy.props.BoolProperty(
        name = "",
        description =            "This will attach a frozen controller to any bones that aren't mapped in order to stabilize your animation.  You can also "            "achieve a similar result by exporting a deformer mesh which may be preferable if you've already uploaded your animations.  "            "This adds an additional level of complexity since there will be two additional rigs but they are disposable.  If you get "            "confused just delete them and retarget again.  One rig is deal with unforsean problems with custom rigs and the other, "            "the stabilizer, deals with a known issue we call (wobble).",
        default = True,
        
        )

    controller_distance : bpy.props.FloatProperty(
        name = "",
        description =            "This has no effect on your animation, it is purely visual, but may be convenient"            "\n\n"            "This is a depth factor.  The character depth is measured and the factor of its body depth, which would be length if it's "            "a quadruped, times the value (dimensions.y * n) will be the distance the resulting armature will be from the character, "            "unless the armature bones are glued to the character, then this isn't used and another method, for your convenience is "            "is used in order to give you easy access to the armature.",
        default = 0.0
        )
    def update_controller_glued(self, context):
        
        if self.controller_glued == False:
            armObj = bpy.context.selected_objects[0]
            for boneObj in armObj.pose.bones:
                for c in boneObj.constraints:
                    if c.type == 'COPY_ROTATION' or c.type == 'COPY_LOCATION':
                        c.target_space = 'LOCAL'
                        c.owner_space = 'LOCAL'
            
            source_map = armObj['bone_map'].to_dict()
            for boneObj in armObj.data.bones:
                sbone = boneObj.name
                if sbone in source_map:
                    continue
                boneObj.hide = True
            armObj['controller_glued'] = False
            bpy.context.window_manager.bb_controller.property_unset("controller_glued")

    controller_glued : bpy.props.BoolProperty(
        name = "",
        description =            "Disable glued bones"            "\n\n"            "Disable this to detach the bones of the retarget armature from your animation source",
        default = True,
        update = update_controller_glued
        )

    controller_to_animation : bpy.props.BoolProperty(
        name = "",
        description =            "Send details to animation tools"            "\n\n"            "This will send the range of your current animation to the (range) and (loop) settings in the "            "animation export tool.  The alternative is to use the (Acquire) button in the animation exporter "            "to grab the ranges.  Keep in mind that the (Loop) feature must be enabled in order for loop to work.",
        default = True,
        )

class OnigiriControllerRetarget(bpy.types.Operator):
    """Select your animated rig.  Load a map onto it if your rig bones are not
name compliant.  Click "Retarget Animation".  Export the animation from the
resulting, selected, rig.  When finished simply delete the rig"""

    bl_idname = "onigiri.controller_retarget"
    bl_label = "Retarget"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_controller = bpy.context.window_manager.bb_controller
        obj = bpy.data.objects

        targetObj = bpy.context.selected_objects[0]

        print("target armature is:", targetObj.name)

        bone_map = targetObj.get('bone_map')

        if bone_map == None:
            print("No existing bone map, checking for bone matches")
            bad_bones = []
            good_bones = []
            
            for boneObj in targetObj.data.bones:
                bone = boneObj.name
                if bone in mod_data.all_mbones:
                    good_bones.append(bone)
                else:
                    bad_bones.append(bone)
            if len(good_bones) == 0:
                print("There were no mappable bones, please load a template")
                popup("NO mappable bones, use a template", "Error", "ERROR")
                return {'FINISHED'}

            if len(bad_bones) != 0:
                print("Some bones can't be mapped and are shown below:")
                print(bad_bones)
                print("The following bones are mappable:")
                print(good_bones)

            target_map = {}
            source_map = {}
            tarm = targetObj.name
            sarm = "FakeRig"
            for tbone in good_bones:
                sbone = tbone 
                target_map[tbone] = {}
                target_map[tbone][sarm] = sbone
                source_map[sbone] = {}
                source_map[sbone][tarm] = tbone

        else:
            print("Found existing bone map, checking if it's compatible")
            bad_bones = []
            good_bones = []
            qualified_bones = []
            for bone in bone_map:
                if bone not in targetObj.data.bones:
                    bad_bones.append(bone)
                else:
                    qualified_bones.append(bone)
            if len(qualified_bones) == 0:
                print("The map being used isn't compatible with your rig.")
                popup("The loaded map is not compatible", "Error", "ERROR")
                return {'FINISHED'}
            if len(bad_bones) > 0:
                print("Some bones didn't match the source rig in the map:")
                print(bad_bones)

            for tbone in qualified_bones:
                (sarm, sbone), = bone_map[tbone].items()
                if sbone in mod_data.all_mbones:
                    good_bones.append(tbone)
            if len(good_bones) == 0:
                print("None of the bones in the map were viable.")
                popup("There are no bones that exist in the target that are compatible with the source", "Error", "ERROR")
                return {'FINISHED'}
            
            target_map = {}
            source_map = {}
            tarm = targetObj.name
            sarm = "FakeRig"
            for tbone in good_bones:
                (old_arm, sbone), = bone_map[tbone].items()
                target_map[tbone] = {}
                target_map[tbone][sarm] = sbone
                source_map[sbone] = {}
                source_map[sbone][tarm] = tbone

        sourceObj = rigutils.build_rig(rig_class="pos", rotate=True)

        if sourceObj == False:
            print("Something happened when attepmting to generate a Second Life rig")
            popup("Unknown error when generating a rig, see Console", "Fatal Error", "ERROR")
            return {'FINISHED'}

        new_map = {}
        sarm = sourceObj.name
        for tbone in target_map:
            (arm, sbone), = target_map[tbone].items()
            new_map[tbone] = {sarm : sbone}
        sourceObj['bone_map'] = source_map
        targetObj['bone_map'] = new_map
    
        for o in bpy.context.selected_objects:
            o.select_set(False)
        targetObj.select_set(True)
        bpy.context.view_layer.objects.active = targetObj
        bpy.ops.object.duplicate()
        proxyObj = bpy.context.object

        frame_current = bpy.context.scene.frame_current

        if proxyObj.animation_data == None:
            print("No animation data, timeline won't be altered")
        elif proxyObj.animation_data.action == None:
                print("No action is associated with the armature, timeline won't be altered")
        else:
            frame_start, frame_end = proxyObj.animation_data.action.frame_range
            print("Found action, setting frame to start:", frame_start)
            bpy.context.scene.frame_set(frame_start)

            if bb_controller.controller_to_animation == True:
                print("Running acquire_animation_details")
                bpy.ops.onigiri.acquire_animation_details()

            proxyObj.animation_data_clear()

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.transform_apply(scale=True, rotation=True, location=False)

        edit_bones = {}
        bpy.ops.object.mode_set(mode='EDIT')

        for boneObj in proxyObj.data.edit_bones:
            boneObj.use_connect = False

        for boneObj in proxyObj.data.edit_bones:
            bone = boneObj.name
            edit_bones[bone] = {}
            edit_bones[bone]['head'] = boneObj.head.copy()
            edit_bones[bone]['tail'] = boneObj.tail.copy()
            edit_bones[bone]['roll'] = boneObj.roll
        bpy.ops.object.mode_set(mode='OBJECT')

        sourceObj.location.x = proxyObj.location.x
        sourceObj.location.y = proxyObj.location.y

        size_y = proxyObj.dimensions.y
        final_y = proxyObj.location.y + (size_y * bb_controller.controller_distance)

        bpy.ops.object.delete()

        sourceObj.select_set(True)
        bpy.context.view_layer.objects.active = sourceObj

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in sourceObj.data.edit_bones:
            boneObj.use_connect = False

        for boneObj in sourceObj.data.edit_bones:
            sbone = boneObj.name
            if sbone in source_map:
                (tarm, tbone), = source_map[sbone].items()
                boneObj.head = edit_bones[tbone]['head']
                boneObj.tail = edit_bones[tbone]['tail']
                boneObj.roll = edit_bones[tbone]['roll']
        bpy.ops.object.mode_set(mode='OBJECT')

        if 1 == 0:
            sourceObj['controller_glued'] = False
            space = "LOCAL"
            for s in targetObj.scale:
                if s != 1.0:
                    sourceObj['controller_glued'] = True
                    space = "WORLD"
                    break
        else:
            space = "WORLD"
            sourceObj['controller_glued'] = True

        if space == "LOCAL":
            
            for boneObj in sourceObj.data.bones:
                sbone = boneObj.name
                if sbone in source_map:
                    continue
                boneObj.hide = True

        con = "COPY_ROTATION"
        rigutils.add_constraints(
            source=sarm, target=tarm,
            bone_map=source_map,
            constraint=con,
            space=space)
        con = "COPY_LOCATION"
        rigutils.add_constraints(
            source=sarm, target=tarm,
            bone_map=source_map,
            constraint=con,
            space=space)

        sourceObj.location.y = final_y

        bpy.context.scene.frame_set(frame_current)

        sourceObj['controller_target'] = targetObj

        if bb_controller.controller_stabilize == True:
            
            influence = 0
            if bb_controller.controller_stabilize == True:
                influence = 1

            bone_map = set()
            for boneObj in sourceObj.data.bones:
                if boneObj.name not in sourceObj['bone_map']:
                    bone_map.add(boneObj.name)

            if 1 == 1:
                glueObj = rigutils.freeze(armature=sourceObj.name, bones=bone_map, transforms=True, influence=influence)
                glueObj.select_set(False)
                glueObj.name = "_STABILIZER"
                sourceObj['bb_controller_stabilizer'] = glueObj
                targetObj['bb_controller_stabilizer'] = glueObj
                
                for boneObj in glueObj.data.bones:
                    boneObj.hide = True

        sourceObj.select_set(True)
        bpy.context.view_layer.objects.active = sourceObj
        
        bpy.ops.object.transform_apply(scale=True, rotation=True, location=False)
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')

        targetObj['controller_source'] = sourceObj

        return {'FINISHED'}

class OnigiriControllerShowBones(bpy.types.Operator):
    """Show or Hide bones"""

    bl_idname = "onigiri.controller_show_bones"
    bl_label = "Hide or Show bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        if bpy.context.selected_objects[0].get('bone_map') == False:
            return False
        if bpy.context.selected_objects[0].get('controller_target') == False:
            return False
        return True

    def execute(self, context):
        
        armObj = bpy.context.selected_objects[0]

        if self.action == "show":
            for boneObj in armObj.data.bones:
                boneObj.hide = False
        elif self.action == "hide_mapped":
            for bone in armObj['bone_map']:
                armObj.data.bones[bone].hide = True
        elif self.action == "hide_unmapped":
            for boneObj in armObj.data.bones:
                if boneObj.name in armObj['bone_map']:
                    continue
                boneObj.hide = True

        return {'FINISHED'}

class OnigiriControllerGlue(bpy.types.Operator):
    """Glue the mapped bones in case your animation rig has as a scale.  Do NOT
apply the scale or it will ruin the animation.  Use this "glue" option instead"""

    bl_idname = "onigiri.controller_glue"
    bl_label = "Glue bones in case of scale"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        if bpy.context.selected_objects[0].get('bone_map') == False:
            return False
        if bpy.context.selected_objects[0].get('controller_target') == False:
            return False
        return True

    def execute(self, context):
        
        armObj = bpy.context.selected_objects[0]

        if armObj.get('controller_glued') == None:
            armObj['controller_glued'] = False

        for boneObj in armObj.pose.bones:
            for c in boneObj.constraints:
                if c.type == 'COPY_ROTATION' or c.type == 'COPY_LOCATION':
                    c.target_space = 'WORLD'
                    c.owner_space = 'WORLD'

        for boneObj in armObj.data.bones:
            boneObj.hide = False

        armObj['controller_glued'] = True

        if armObj.get('controller_target') != None:
            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.armature_apply()
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)

        return {'FINISHED'}

class OnigiriControllerStabilize(bpy.types.Operator):
    """--internal"""

    bl_idname = "onigiri.controller_stabilize"
    bl_label = "Nothing to see here"

    action : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_controller = bpy.context.window_manager.bb_controller
        
        if len(bpy.context.selected_objects) != 1:
            print("nothing selected")
            return {'FINISHED'}
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            print("Not an armature")
            return {'FINISHED'}
        if bpy.context.selected_objects[0].get('bone_map') == False:
            print("No bone map available")
            return {'FINISHED'}
        if bpy.context.selected_objects[0].get('controller_target') == False:
            print("Rig does not appear to be retargeting anyting")
            return {'FINISHED'}

        armObj = bpy.context.selected_objects[0]

        glueObj = armObj.get('bb_controller_stabilizer')
        if glueObj == None:
            print("This rig does not have a stabilizer")
            bb_controller["controller_stabilize"] = False
            return {'FINISHED'}

        for boneObj in armObj.pose.bones:
            for c in boneObj.constraints:
                if c.type == 'COPY_TRANSFORMS':
                    if self.action == "on":
                        if boneObj.name in armObj['bone_map']:
                            c.influence = 0
                        else:
                            c.influence = 1
                    else:
                        c.influence = 0

        print("stabilizer is", self.action)

        return {'FINISHED'}

class OnigiriControllerPelvisTransform(bpy.types.Operator):
    """Lock the pelvis relative location and/or rotation transforms so that it can
bounce and rotate with your custom rig/avatar.  This is usually what you want.  This
is only useful for relative controllers, bipeds are usually relative"""

    bl_idname = "onigiri.controller_transform_pelvis"
    bl_label = "Set controller type"

    action : bpy.props.StringProperty(default="")
    
    transform : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        if bpy.context.selected_objects[0].get('onigiri') == None:
            return False
        if bpy.context.selected_objects[0].get('bone_map') == None:
            return False
        return True

    def execute(self, context):
        bb_controller = bpy.context.window_manager.bb_controller
        obj = bpy.data.objects

        armObj = bpy.context.selected_objects[0]

        print("would have enabled or disabled the indicated transform for the pelvis")

        ctype = armObj.get('constraint_type')
        if ctype == None:
            print("No constraint type detected, this might be a bug")
            popup("Missing constraint type", "Error", "ERROR")
            return {'FINISHED'}
 
        print("pelvis transform controller not finished")

        return {'FINISHED'}

class OnigiriControllerMapReset(bpy.types.Operator):
    """Remove the helper objects from the scene.  This cleans up stale helper
objects if you've left them in the scene.  This is for the entire scene so
you may want to save before using this.
"""

    bl_idname = "onigiri.controller_reset"
    bl_label = "Reset"

    def execute(self, context):

        helpers = {'bb_controller_stabilizer', 'controller_target', 'bb_frozen_target'}

        collected = []
        subject = None
        for o in bpy.context.scene.objects:
            if o.type != 'ARMATURE':
                continue
            if 'controller_source' in o:
                subject = o
                continue
            for k in o.keys():
                if k in helpers:
                    collected.append(o)
        for o in bpy.context.selected_objects:
            o.select_set(False)
        for o in collected:
            o.select_set(True)
        utils.activate(o)
        bpy.ops.object.delete()

        if subject != None:
            subject.select_set(True)
            utils.activate(subject)

        return {'FINISHED'}

class OnigiriControllerMapRemove(bpy.types.Operator):
    """Remove the map data from the selected rig"""

    bl_idname = "onigiri.controller_remove_map"
    bl_label = "Remove map"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        if bpy.context.selected_objects[0].get('bone_map') == None:
            return False
        return True

    def execute(self, context):
        bb_controller = bpy.context.window_manager.bb_controller
        obj = bpy.data.objects
        
        bpy.context.selected_objects[0].pop('bone_map', "") 
        bpy.context.selected_objects[0].pop('controller_target', "") 
        print("Bone map removed from", bpy.context.selected_objects[0].name)
        return {'FINISHED'}

class OnigiriControllerSet(bpy.types.Operator):
    """Set the type of controller"""

    bl_idname = "onigiri.controller_set"
    bl_label = "Set controller type"

    def execute(self, context):
        print("would have set")

        return {'FINISHED'}

class OnigiriControllerAdd(bpy.types.Operator):
    """Add a type of constraint controller"""

    bl_idname = "onigiri.controller_add"
    bl_label = "Add constraint"

    constraint : bpy.props.StringProperty(default="COPY_TRANSFORMS")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) < 2:
            return False
        
        rig_count = 0
        got_bb = False
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                rig_count += 1
                if o.get('onigiri') != None:
                    got_bb = True
        if rig_count == 2 and got_bb:
            return True
        return False

    def execute(self, context):
        
        bb_controller = bpy.context.window_manager.bb_controller
        print("would have added a", self.constraint, "constraint")

        return {'FINISHED'}

class OnigiriControllerRemove(bpy.types.Operator):
    """Remove the controllers that you added.  Hopefully this only removes the
controllers made by this tool set"""

    bl_idname = "onigiri.controller_remove"
    bl_label = "Remove constraint"

    @classmethod
    def poll(cls, context):
        pass
        return True

    def execute(self, context):
        bb_controller = bpy.context.window_manager.bb_controller
        print("would have removed the controller")

        return {'FINISHED'}

class OnigiriControllerTemplateLoad(bpy.types.Operator, ImportHelper):
    """Load a CTM or CCM.  While a CTM can contain more than one rig target this
particular tool cannot process them, it will only process the first rig.  If you
need to adjust a CTM for this purpose use the Template Editor"""

    bl_idname = "onigiri.controller_load_template"
    bl_label = "Load Map"

    filter_glob : bpy.props.StringProperty(
        default='*.ctm;*.ccm;*.bbm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        if selected[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):

        bb_controller = bpy.context.window_manager.bb_controller
        targetObj = bpy.context.selected_objects[0]

        file_path = self.properties.filepath
        path, name = os.path.split(self.properties.filepath)
        ext = name.split(".")[-1]

        try:
            namespace = {}
            exec(open(file_path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        template = {}
        for container in namespace:
            
            if container.startswith("__"):
                continue
            template[container] = namespace[container]

        if template.get('rename') != None:
            bad_bones = []
            good_bones = []
            bone_map = {}
            for tbone in template['rename']:
                if tbone not in targetObj.data.bones:
                    bad_bones.append(tbone)
                else:
                    good_bones.append(tbone)
                    sbone = template['rename'][tbone]
                    bone_map[tbone] = {"Armature": sbone} 
            if len(good_bones) == 0:
                print("None of the bones in the map (anchor map) matches your rig")
                popup("This map doesn't match your rig", "Error", "ERROR")
                return {'FINISHED'}
            if len(bad_bones) != 0:
                print("Some (anchor) map bones didn't match your rig, see below:")
                print(bad_bones)
                popup("Some bones didn't match", "Info", "INFO")
            targetObj['bone_map'] = bone_map

        elif template.get('template_map') != None:
            bad_bones = []
            good_bones = []
            bone_map = {}
            for sbone in template['template_map']:
                (tarm, tbone), = template['template_map'][sbone].items()
                if tbone not in targetObj.data.bones:
                    bad_bones.append(tbone)
                else:
                    good_bones.append(tbone)
                    bone_map[tbone] = {"Armature": sbone} 
            if len(good_bones) == 0:
                print("None of the bones in the map (template_map) matches your rig")
                popup("This map doesn't match your rig", "Error", "ERROR")
                return {'FINISHED'}
            if len(bad_bones) != 0:
                print("Some (template_map) bones didn't match your rig, see below:")
                print(bad_bones)
                popup("Some bones didn't match", "Info", "INFO")
            targetObj['bone_map'] = bone_map

        file_prefix = name.split(".")[0]
        bb_controller.controller_template_name = file_prefix

        return {'FINISHED'}

class OnigiriDynamicProperties(bpy.types.PropertyGroup):

    def update_dynamic_blank(self, context):
        self["dynamic_blank"] = False
    dynamic_blank : bpy.props.BoolProperty(
        default = False,
        update = update_dynamic_blank
        )

    dynamic_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Enable he use of dynamic constraint testing.  This allows you to apply various constraints.",
        default = False
        )
    dynamic_template_name : bpy.props.StringProperty(
        description = "--internal",
        default = ""
        )
    dynamic_distance : bpy.props.FloatProperty(
        name = "",
        description =            "This is the distance a Onigiri rig will be placed away from the source (Animated Rig)",
        default = 0.6
        )
    dynamic_message : bpy.props.StringProperty(
        name = "",
        description = "--internal",
        default = ""
        )
    def update_dynamic_location(self, context):
        bb_dynamic = bpy.context.window_manager.bb_dynamic
        if len(bpy.context.selected_objects) != 1:
            self["dynamic_location"] = False
            return
        armObj = bpy.context.selected_objects[0]
        if armObj.type != 'ARMATURE':
            self["dynamic_location"] = False
            return
        
        inRig = dynamic.get_director(armature=armObj.name)
        if inRig == False:
            outRig = armObj
        else:
            outRig = inRig['bb_dynamic_actor']
        boneObj = outRig.pose.bones[0]
        for C in boneObj.constraints:
            if C.type == 'COPY_LOCATION':
                C.influence = self.dynamic_location
    def update_dynamic_rotation(self, context):
        bb_dynamic = bpy.context.window_manager.bb_dynamic
        if len(bpy.context.selected_objects) != 1:
            self["dynamic_rotation"] = False
            return
        armObj = bpy.context.selected_objects[0]
        if armObj.type != 'ARMATURE':
            self["dynamic_rotation"] = False
            return
        
        inRig = dynamic.get_director(armature=armObj.name)
        if inRig == False:
            outRig = armObj
        else:
            outRig = inRig['bb_dynamic_actor']
        boneObj = outRig.pose.bones[0]
        for C in boneObj.constraints:
            if C.type == 'COPY_ROTATION':
                C.influence = self.dynamic_rotation

    dynamic_location : bpy.props.BoolProperty(
        name = "",
        description =            "Enable and Disable location retargeting for the anchor bone, hip/pelvis/mPelvis",
        update = update_dynamic_location
        )
    dynamic_rotation : bpy.props.BoolProperty(
        name = "",
        description =            "Enable and Disable rotation retargeting for the anchor bone, hip/pelvis/mPelvis",
        update = update_dynamic_rotation
        )

class OnigiriDynamicLoad(bpy.types.Operator, ImportHelper):
    """Load a template"""

    bl_idname = "onigiri.dynamic_load"
    bl_label = "Load Map"

    filter_glob : bpy.props.StringProperty(
        default='*.ctm;*.ccm;*.bbm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}
    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        if selected[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):

        bb_dynamic = bpy.context.window_manager.bb_dynamic
        targetObj = bpy.context.selected_objects[0]

        file_path = self.properties.filepath
        path, name = os.path.split(self.properties.filepath)
        ext = name.split(".")[-1]

        try:
            namespace = {}
            exec(open(file_path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        template = {}
        for container in namespace:
            
            if container.startswith("__"):
                continue
            template[container] = namespace[container]

        if template.get('rename') != None:
            bad_bones = []
            good_bones = []
            bone_map = {}
            for tbone in template['rename']:
                if tbone not in targetObj.data.bones:
                    bad_bones.append(tbone)
                else:
                    good_bones.append(tbone)
                    sbone = template['rename'][tbone]
                    bone_map[tbone] = sbone
            if len(good_bones) == 0:
                print("None of the bones in the map (anchor map) matches your rig")
                popup("This map doesn't match your rig", "Error", "ERROR")
                return {'FINISHED'}
            if len(bad_bones) != 0:
                print("Some (anchor) map bones didn't match your rig, see below:")
                print(bad_bones)
                
            targetObj['bb_dynamic_template'] = bone_map

        elif template.get('template_map') != None:
            bad_bones = []
            good_bones = []
            bone_map = {}
            for sbone in template['template_map']:
                (tarm, tbone), = template['template_map'][sbone].items()
                if tbone not in targetObj.data.bones:
                    bad_bones.append(tbone)
                else:
                    good_bones.append(tbone)
                    bone_map[sbone] = tbone
            if len(good_bones) == 0:
                print("None of the bones in the map (template_map) matches your rig")
                popup("This map doesn't match your rig", "Error", "ERROR")
                return {'FINISHED'}
            if len(bad_bones) != 0:
                print("Some (template_map) bones didn't match your rig, see below:")
                print(bad_bones)
                
            targetObj['bb_dynamic_template'] = bone_map

        file_prefix = name.split(".")[0]
        bb_dynamic.dynamic_template_name = file_prefix

        return {'FINISHED'}

class OnigiriDynamicController(bpy.types.Operator):
    """Set anchor transforms.  You can enable/disable rotation and/or location
influence on the pelvis/mPelvis/hip, this is the anchor"""

    bl_idname = "onigiri.dynamic_controller"
    bl_label = "Start the retargeter"

    action : bpy.props.StringProperty(default="COPY_LOCATION")

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        if selected[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_dynamic = bpy.context.window_manager.bb_dynamic
        armObj = bpy.context.selected_objects[0]

        if self.action == "COPY_LOCATION":
            bb_dynamic.dynamic_location = True
        elif self.action == "COPY_ROTATION":
            bb_dynamic.dynamic_rotation = True

        self.action = ""

        return {'FINISHED'}

class OnigiriDynamicAction(bpy.types.Operator):
    """Start the custom retargeter"""

    bl_idname = "onigiri.dynamic_action"
    bl_label = "Start the retargeter"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        if selected[0].type != 'ARMATURE':
            return False
        if dynamic.get_director(armature=selected[0].name) != False:
            return False
        return True

    def execute(self, context):
        bb_dynamic = bpy.context.window_manager.bb_dynamic
        inRig = bpy.context.selected_objects[0]

        utils.activate(inRig)

        if inRig.get('bb_dynamic_template') == None:
            bpy.ops.object.duplicate()
            outRig = bpy.context.object
            inRig['bb_dynamic_actor'] = outRig
            
            for k in outRig.keys():
                outRig.pop(k, "")
            
            bone_map = {}
            for boneObj in inRig.data.bones:
                bone_map[boneObj.name] = boneObj.name
            inRig['bb_dynamic_template'] = bone_map
        else:
            
            outRig = rigutils.build_rig(rig_class="pos", rotate=True)
            inRig['bb_dynamic_actor'] = outRig

        outRig['bb_dynamic_director'] = inRig

        outRig.location = inRig.location
        offset = inRig.location.y + bb_dynamic.dynamic_distance
        outRig.location.y = offset

        outRig.animation_data_clear()
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.transform_apply(scale=True, rotation=True, location=False)

        outRig.select_set(False)
        inRig.select_set(True)
        utils.activate(inRig)
        bpy.ops.object.duplicate()
        proxyRig = bpy.context.object
        proxyRig.name = "DELETE_ME_RETARGET_PROXY"

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in proxyRig.data.edit_bones:
            boneObj.use_connect = False
            
        bpy.ops.object.mode_set(mode='OBJECT')

        proxyRig['bb_dynamic_director'] = inRig
        proxyRig['bb_dynamic_actor'] = outRig
        inRig['bb_dynamic_proxy'] = proxyRig

        frame_start = 1
        if proxyRig.animation_data:
            if proxyRig.animation_data.action:
                frame_start = proxyRig.animation_data.action.frame_range[0]
        bpy.context.scene.frame_set(frame_start)

        proxyRig.animation_data_clear()
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.transform_apply(scale=True, rotation=True, location=False)

        bone_map = inRig['bb_dynamic_template'].to_dict()

        if 1 == 0:
            remove_bones = []
            for boneObj in proxyRig.data.bones:
                if boneObj.name not in bone_map:
                    remove_bones.append(boneObj.name)
            bpy.ops.object.mode_set(mode='EDIT')
            for bone in remove_bones:
                boneObj = proxyRig.data.edit_bones[bone]
                proxyRig.data.edit_bones.remove(boneObj)
            bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in proxyRig.data.edit_bones:
            boneObj.use_connect = False
            boneObj.parent = None
        bpy.ops.object.mode_set(mode='OBJECT')

        reverse_map = {}
        for tbone in bone_map:
            sbone = bone_map[tbone]
            reverse_map[sbone] = tbone
        dynamic.add_constraints(
            source=proxyRig.name, target=outRig.name,
            bone_map=reverse_map, constraint='COPY_ROTATION',
            space='WORLD', influence=1)
        
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')
        
        for boneObj in proxyRig.pose.bones:
            for C in boneObj.constraints:
                boneObj.constraints.remove(C)
        
        match_map = {}
        for bone in bone_map:
            match_map[bone] = bone
        dynamic.add_constraints(
            source=proxyRig.name, target=outRig.name,
            bone_map=match_map, constraint='COPY_LOCATION',
            space='WORLD', influence=1)
        
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')
        
        for boneObj in proxyRig.pose.bones:
            for C in boneObj.constraints:
                boneObj.constraints.remove(C)

        dynamic.add_constraints(
            source=proxyRig.name, target=inRig.name,
            bone_map=match_map, constraint='CHILD_OF',
            influence=1, location=True, rotation=True, scale=True )

        if 1 == 0:
            proxyRig.select_set(False)
            outRig.select_set(True)
            utils.activate(outRig)
            dynamic.add_constraints(
                source=outRig.name, target=proxyRig.name,
                bone_map=bone_map, constraint='CHILD_OF',
                influence=1, location=True, rotation=True, scale=True)
        if 1 == 1:
            proxyRig.select_set(False)
            outRig.select_set(True)
            utils.activate(outRig)
            dynamic.add_constraints(
                source=outRig.name, target=proxyRig.name,
                bone_map=bone_map, constraint='COPY_ROTATION',
                space='POSE', influence=1, location=True, rotation=True, scale=True)

        boneObj = outRig.pose.bones[0]
        proxy_anchor = proxyRig.pose.bones[0].name
        
        outRig.data.bones.active = boneObj.bone 
        bc = boneObj.constraints
        conObj = bc.new('COPY_LOCATION')
        conObj.target = proxyRig
        conObj.subtarget = proxy_anchor
        conObj.owner_space = 'POSE'
        conObj.influence = 1

        if 1 == 0:
            boneObj = proxyRig.pose.bones[0]
            inrig_anchor = inRig.pose.bones[0].name
            for C in boneObj.constraints:
                if C.type == 'CHILD_OF':
                    C.influence = 0
            proxyRig.data.bones.active = boneObj.bone 
            bc = boneObj.constraints
            conObj = bc.new('COPY_LOCATION')
            conObj.target = inRig
            conObj.subtarget = inrig_anchor
            conObj.owner_space = 'WORLD'
            conObj.influence = 1

        inRig['bb_dynamic_location'] = True
        inRig['bb_dynamic_rotation'] = True

        proxyRig.hide_set(True)

        return {'FINISHED'}

class OnigiriDynamicCleanRig(bpy.types.Operator):
    """Clean properties, constraints, drivers.  This should remove any interfering
items from the selected rig.  If he retargeter is engaged it will detach the tools
that were used to setup the retargeter and you will have to clean these manually"""

    bl_idname = "onigiri.dynamic_clean_rig"
    bl_label = "Clean Rig"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        if selected[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_dynamic = bpy.context.window_manager.bb_dynamic
        
        armObj = bpy.context.selected_objects[0]
        props = armObj.keys()
        print("Attempting to remove all properties from rig", armObj.name)
        for p in props:
            armObj.pop(p, "")
        rigutils.remove_deps(armature=armObj.name)

        return {'FINISHED'}

class OnigiriDynamicReset(bpy.types.Operator):
    """Reset everything.  You should do this before saving, it removes transient
objects."""

    bl_idname = "onigiri.dynamic_reset"
    bl_label = "Reset"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        if selected[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_dynamic = bpy.context.window_manager.bb_dynamic
        armObj = bpy.context.selected_objects[0]

        inRig = dynamic.get_director(armature=armObj.name)
        if inRig == False:
            print("Nothing to cleanlup")
            return {'FINISHED'}
        outRig = inRig.get('bb_dynamic_actor')
        proxyRig = inRig.get('bb_dynamic_proxy')
        for o in bpy.context.selected_objects:
            o.select_set(False)

        if proxyRig != None:
            if proxyRig.name in bpy.context.scene.objects:
                proxyRig.hide_set(False)
                proxyRig.select_set(True)
                utils.activate(proxyRig)
        if outRig != None:
            if outRig.name in bpy.context.scene.objects:
                outRig.select_set(True)
                utils.activate(outRig)
        if len(bpy.context.selected_objects) != 0:
            bpy.ops.object.delete()

        for k in inRig.keys():
            inRig.pop(k, "")

        inRig.select_set(True)
        utils.activate(inRig)

        return {'FINISHED'}

class OnigiriDynamicExport(bpy.types.Operator, ExportHelper):
    """This is like the mapped mesh exporter except it does not require any
other input, the assumption is that you want to remove empty vertex groups
and that you'll allow fitted mesh bones, if they are mapped"""

    bl_idname = "onigiri.dynamic_export"
    bl_label = "Export Mapped Mesh"

    def execute(self, context):
        bb_dynamic = bpy.context.window_manager.bb_dynamic
        armObj = bpy.context.selected_objects[0]

        return {'FINISHED'}

class OnigiriDynamicMapRemove(bpy.types.Operator):
    """Remove Map"""

    bl_idname = "onigiri.dynamic_remove_map"
    bl_label = "Remove Map"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        if selected[0].type != 'ARMATURE':
            return False
        if selected[0].get('bb_dynamic_template') == None:
            return False
        return True

    def execute(self, context):
        bb_dynamic = bpy.context.window_manager.bb_dynamic
        armObj = bpy.context.selected_objects[0]
        armObj.pop('bb_dynamic_template', {})
        return {'FINISHED'}

msg = bpy.ops.view3d.message
class OnigiriMessage(bpy.types.Operator):
    """something"""

    bl_idname = "view3d.message"
    bl_label = "what is this"

    message : bpy.props.StringProperty(default="")

    def execute(self, context):
        self.report({'INFO'}, self.message)
        return {'FINISHED'}

class OnigiriPopup(bpy.types.Operator):
    """nothing to see  here"""
    bl_idname = "onigiri.popup"
    bl_label = "Error:"

    message : bpy.props.StringProperty(
        name = "this_name",
        description = "this_description",
        default = "this_default"
    )

    def invoke(self, context, event):
        return bpy.context.window_manager.invoke_props_dialog(self, width = 480, height = 500)

    def execute(self, context):
        self.report({'INFO'}, self.message)
        print(self.message)
        return {'FINISHED'}

    def draw(self, context):

        layout = self.layout
        labels = make_lines(text=self.message, before="", after="", max=478)
        print("entering for lines")
        for line in labels:
            print("line:", line)
            row = self.layout.row(align=True)
            layout.label(
                text = line,
                )
        row = self.layout.row(align=True)
        layout.label(
            text = self.message,
            )

class CharacterConverterConvertReset(bpy.types.Operator):
    """This removes the manually loaded Character Converter map.  It does not remove
the map on your rig, which can also be used for conversion"""

    bl_idname = "onigiri.character_converter_reset"
    bl_label = "Remove loaded map"

    def execute(self, context):
        ccp = bpy.context.window_manager.cc_props

        bpy.context.window_manager.cc_props.cc_map_filename = ""

        if len(bpy.context.selected_objects) == 1:
            o = bpy.context.selected_objects[0]
            o.pop('bb_onemap_rename', "")
            o.pop('bb_onemap_reskin', "")
            o.pop('bb_onemap_repose', "")
            o.pop('bb_onemap_code', "")

        return {'FINISHED'}

class CharacterConverterConvert(bpy.types.Operator):
    """Convert this character using a map to convert bone names and re-weight mesh
to bones that have been reskinned.  The rig must be selected.  If there is a map
on the rig already you can use that instead, just don't load one"""

    bl_idname = "onigiri.character_converter_operator"
    bl_label = "Character Converter for Onigiri"

    @classmethod
    def poll(cls, context):
        
        if len(bpy.context.selected_objects) == 0:
            return False
        
        for obj in bpy.context.selected_objects:
            if obj.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        ccp = bpy.context.window_manager.cc_props

        original_selection = [o for o in bpy.context.selected_objects]
        active_object = bpy.context.active_object

        old_mode = bpy.context.mode
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'

        selected_arm = []

        for obj in bpy.context.selected_objects:
            if obj.type == 'ARMATURE':
                selected_arm.append(obj)

        if len(selected_arm) > 1:
            txt = "I can only convert one armature at a time."
            print(txt)
            popup(txt, "Armature Error", "ERROR")
            return {'FINISHED'}

        if len(selected_arm) == 0:
            txt = "I need at least one armature to work with, none are selected."
            print(txt)
            popup(txt, "Armature Error", "ERROR")
            return {'FINISHED'}

        for o in bpy.context.selected_objects:
            o.select_set(False)
        for o in original_selection:
            if o.type == 'ARMATURE':
                o.select_set(True)
                bpy.context.view_layer.objects.active = o
                bpy.ops.object.mode_set(mode='OBJECT')
                o.select_set(False)
        for o in original_selection:
            o.select_set(True)
        bpy.context.view_layer.objects.active = active_object

        armObj = selected_arm[0]

        print("CharacterConverterConvert reports: selected_arm[0] = armObj.name", armObj.name)

        if ccp.cc_apply_transforms == True:
            mod_functions.apply_transform_chain(armObj.name)

        if armObj.get('onigiri_converted') == 1:
            txt = "Armature converted already: " + "[" + armObj.name + "]"
            popup(txt, "Error", "ERROR")
            return {'FINISHED'}

        children = list()
        children = armObj.children

        qualified_mesh = []
        for meshObj in children:
            if meshObj.type != 'MESH':
                continue
            qualified_mesh.append(meshObj)
        
        if len(qualified_mesh) == 0:
            txt = "There are no meshes associated with the armature."
            print(txt)
            popup(txt, "Armature Error", "ERROR")
            return {'FINISHED'}

        cc_rename = {}
        cc_reskin = {}
        cc_pose = {}

        map_file = bpy.context.window_manager.cc_props.cc_map_filename

        if map_file == "":
            print("No loaded map, checking rig for onemap...")
            cc_rename = armObj.get('bb_onemap_rename')
            cc_reskin = armObj.get('bb_onemap_reskin', {})
            cc_pose = armObj.get('bb_onemap_pose', {})
            if cc_rename == None:
                print("There's no loaded map and no map on the rig")
                popup("There's no loaded map and no map on the rig", "Map Error", "ERROR")
                return {'FINISHED'}
        else:

            try:
                namespace = {}
                exec(open(map_file, 'r', encoding='UTF8').read(), namespace)
                cc_rename.update(namespace['rename'])
                cc_reskin.update(namespace['reskin'])
            except Exception as e:
                txt = traceback.format_exc()
                print(txt)
                
                if len(cc_rename) == 0:
                    popup("There was an error when attempting to read your map file, see the console for details")
                    return {'FINISHED'}
                
                print("Missing reskin, probably a conerted ctm")
                cc_reskin = {}

            try:
                cc_pose.update(namespace['pose'])
            except:
                print("no pose during convert, skipping")

        if len(cc_rename) == 0:
            txt = "Your target list is empty, there's nothing to do.  Please put at least one rename = {element: mBone}"
            print(txt)
            popup(txt, "CCM Error", "ERROR")
            return {'FINISHED'}

        bad_reskin_anchor = []
        for sbone in cc_reskin:
            if sbone == "":
                print("One of your reskin anchors is missing, this is produced by an inconsistant state in the mapper...")
                print("You can manually fix this by editing the associated CCM and looking for the (reskin) section where")
                print("you will find an empty double quote", '""', "and from there maybe you can determine which anchor")
                print("bone it belongs to.  Below is the section containing the missing anchor and its reskin bones...")
                print(sbone, cc_reskin[sbone])
                bad_reskin_anchor.append(sbone)
                popup("Empty reskin anchor, see Console and edit your CCM manually", "Empty reskin anchor!", "ERROR")
        if len(bad_reskin_anchor) > 0:
            print("Removing empty reskin group:")
            for sbone in bad_reskin_anchor:
                del cc_reskin[sbone]
        
        if len(bad_reskin_anchor) > 1:
            print("bad_reskin_anchor has entities larger than 1, this is impossible, check the CCM")

        for sbone in cc_reskin:
            for dbone in cc_reskin[sbone]:
                if dbone in cc_rename.keys():
                    txt = "A (rename) bone matches a (reskin) removable bone, that is an error in  your CCM: " + dbone
                    print(txt)
                    popup(txt, "CCM Error", "ERROR")
                    return {'FINISHED'}

        tbones = {}
        for tBone in armObj.data.bones:
            
            tbones[tBone.name] = tBone.name + "_" + get_unique_name_short()

        arm = armObj.name

        print("Establishing rig stiffen fix kludge around line 8460, pleas note this if you run into issues")
        def kludge_stiffen(arm):

            state = utils.get_state()
            bpy.data.objects[arm].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects[arm]
            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.select_all(action = 'SELECT')
            
            rigutils.remove_deps(armature=arm)
            bpy.ops.pose.select_all(action = 'DESELECT')
            bpy.ops.object.mode_set(mode='OBJECT')
            rebind(arm)
            utils.set_state(state)

        if armObj.animation_data != None:
            if armObj.animation_data.action != None:
                armObj.animation_data.action = None

        if ccp.cc_bake_map_pose == 1:
            print("CharacterConverterConvert reports: bake map pose indicated...")
            if len(cc_pose) > 0:
                
                apply_map_pose(arm, cc_pose)
            
            kludge_stiffen(arm)

        elif ccp.cc_bake_current_pose == 1:
            print("CharacterConverterConvert reports: bake current pose indicated for armature - ", arm)

            kludge_stiffen(arm)

        else:
            print("CharacterConverterConvert reports: No pose bake indicated", ccp.cc_bake_pose_type)

        state = save_state()
        if ccp.preserve_animation == False:
            
            print("Animation not preserved")
            apply_transforms(object=arm, rotation=True, scale=True)
            for meshObj in qualified_mesh:
                apply_transforms(object=meshObj.name, rotation=True, scale=True)
        else:
            print("Attempting to preserve animation")
            
            apply_transforms(object=meshObj.name, rotation=True)

        restore_state(state)

        if ccp.cc_weight_unmapped_groups == True:

            mesh_groups = {}
            for meshObj in qualified_mesh:
                mesh_groups[meshObj.name] = set()
                for gl in meshObj.vertex_groups:
                    mesh_groups[meshObj.name].add(gl.name)

            mapped_skin = set()
            for rbone in cc_reskin:
                mapped_skin.update(cc_reskin[rbone])

            bone_branches = {}
            used_bones = set()
            for rbone in cc_rename:
                if rbone not in tbones.keys():
                    continue
                
                descendants = armObj.data.bones[rbone].children_recursive
                if len(descendants) == 0:
                    continue
                
                for child in descendants:
                    
                    if child.name in cc_rename.keys():
                        continue
                    
                    if child.name not in used_bones and child.name not in mapped_skin:
                        used_bones.add(child.name) 
                        bone_branches.setdefault(rbone, [])
                        bone_branches[rbone].append(child.name)

            if context.mode != 'OBJECT':
                bpy.ops.object.mode_set(mode='OBJECT')

            verified_mesh = []
            not_selectable = False
            for meshObj in qualified_mesh:
                if meshObj.type != 'MESH':
                    print("Found non-mesh item, skipping:", meshObj.name)
                    continue
                
                meshObj.select_set(True)
                if meshObj.select_get() == False:
                    print("Mesh is not selectable so it can't be processed:", meshObj.name)
                    not_selectable = True
                    continue
                verified_mesh.append(meshObj)

            qualified_mesh = verified_mesh

            if not_selectable:
                print("Some mesh were not able to be selected so they were not processed")
                print("You can use the (Viewable - Open Your Eyes) feature for a quick fix but don't rely on this.")
                print("Make your mesh viewable and selectable from the outliner.")
                popup("Some mesh were not selectable so were not processed, see System Console", "Inaccessible Mesh", "ERROR")

            source_weights = set()
            for meshObj in qualified_mesh:
                bpy.ops.object.select_all(action='DESELECT')
                meshObj.select_set(True)
                bpy.context.view_layer.objects.active = meshObj

                for group in mesh_groups[meshObj.name]:
                    if group not in bone_branches.keys():
                        continue
                    
                    source_weights.clear()
                    source_weights = set(bone_branches[group])

                    temp_grp = group + "_" + get_unique_name_short()
                    combine_weights(temp_grp, source_weights, group)
                    del_g = meshObj.vertex_groups.get(group)
                    meshObj.vertex_groups.remove(del_g)
                    meshObj.vertex_groups[temp_grp].name = group
                    for rgroup in bone_branches[group]:
                        if rgroup in mesh_groups[meshObj.name]:
                            del_g = meshObj.vertex_groups.get(rgroup)
                            meshObj.vertex_groups.remove(del_g)

            bpy.ops.object.mode_set(mode='OBJECT')
            if bpy.context.window_manager.cc_props.cc_add_missing_groups == True:
                for meshObj in qualified_mesh:
                    bpy.ops.object.select_all(action='DESELECT')
                    meshObj.select_set(True)
                    bpy.context.view_layer.objects.active = meshObj
                    for target in cc_reskin:
                        
                        if any(i in cc_reskin[target] for i in mesh_groups[meshObj.name]):
                            if target not in mesh_groups[meshObj.name]:
                                if bb_settings['debug'] == True:
                                    print("adding missing target - group / mesh |", target, meshObj.name)
                                    print("type:", type(mesh_groups[meshObj.name]))
                                meshObj.vertex_groups.new(name=target)
                                mesh_groups[meshObj.name].add(target)

            source_weights = set()

            weight_group_error = 0
            weight_group_names = list()

            for meshObj in qualified_mesh:
                bpy.ops.object.select_all(action='DESELECT')
                meshObj.select_set(True)
                bpy.context.view_layer.objects.active = meshObj

                for group in cc_reskin:
                    if group not in mesh_groups[meshObj.name]:
                        if bb_settings['debug'] == True:
                            print("skin target missing from mesh:", meshObj.name, group)
                        continue
                    source_weights.clear()
                    
                    for rgroup in cc_reskin[group]:
                        if rgroup not in mesh_groups[meshObj.name]:
                            if bb_settings['debug'] == True:
                                print("skin source missing from mesh:", meshObj.name, rgroup)
                            continue
                        source_weights.add(rgroup)
     
                    temp_grp = group + "_" + get_unique_name_short()
                    combine_weights(temp_grp, source_weights, group)
                    del_g = meshObj.vertex_groups.get(group)
                    meshObj.vertex_groups.remove(del_g)
                    meshObj.vertex_groups[temp_grp].name = group
                    for rgroup in cc_reskin[group]:

                        if rgroup in mesh_groups[meshObj.name]:

                            del_g = meshObj.vertex_groups.get(rgroup)

                            if del_g != None:
                                meshObj.vertex_groups.remove(del_g)
                            else:
                                weight_group_error += 1
                                weight_group_names.append(rgroup)
                                
                                if 1 == 0:
                                    print("====================================")
                                    print("Onigiri - WARNING: Blender tossed me a bug and returned a None value unexpectedly!")
                                    print("------------------------------------")
                                    print("DEBUG: rgroup is -", rgroup)
                                    print(" *del_g =", del_g)
                                    print("------------------------------------")
                                    print("This does not appear to be fatal")
                                    print("====================================")
            
            if weight_group_error > 0:
                
                print("Warning!:")
                print("An important bone group may be missing from an intermediate joint.")
                print("The following weight groups were empty when attempting to assign them to a new map...")
                print("-------------------------------------------------")
                print(weight_group_names)
                print("-------------------------------------------------")
                print("One possible fix is to hide mapped bones and see what's missing.")
                print("The reason this happened is that the algorithm to map end bones failed")
                print("because of an interruption in the hierarchy.  To test this you can turn off")
                print("(Weight un-mapped groups) and if you don't get an error then find the bone")
                print("causing this problem.")

        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')
        armObj.select_set(True)

        bpy.context.view_layer.objects.active = armObj
        bpy.ops.object.mode_set(mode='EDIT')

        tbone_data = {}
        mbone_data = {}
        for tBone in tbones:
            
            nBone = tbones[tBone]
            tbone_data[tBone] = {}
            tbone_data[tBone]['temp'] = nBone
            tbone_data[tBone]['head'] = armObj.data.edit_bones[tBone].head
            tbone_data[tBone]['tail'] = armObj.data.edit_bones[tBone].tail
            tbone_data[tBone]['use_connect'] = armObj.data.edit_bones[tBone].use_connect
            
            if tBone in cc_rename.keys():
                mBone = cc_rename[tBone]
                tbone_data[tBone]['mbone'] = mBone
                mbone_data[mBone] = {}
                mbone_data[mBone]['tbone'] = tBone

        if bpy.context.window_manager.cc_props.cc_remove_unused_bones == True:
            print("removing unused bones...")
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.select_all(action='DESELECT')
            armObj.select_set(True)
            bpy.context.view_layer.objects.active = armObj
            bpy.ops.object.mode_set(mode='EDIT')

            for tbone in tbones:
                if tbone not in cc_rename.keys():
                    armObj.data.edit_bones.remove(armObj.data.edit_bones[tbone])

        if bpy.context.window_manager.cc_props.cc_rename_to_targets == True:
            print("renaming bones...")

            for tbone in cc_rename:
                if tbone in tbones.keys():
                    armObj.data.edit_bones[tbone].name = tbones[tbone]

            for tbone in tbones:
                if tbone in cc_rename.keys():
                    ubone = tbones[tbone]
                    armObj.data.edit_bones[ubone].name = cc_rename[tbone]

        if bpy.context.window_manager.cc_props.cc_connect_links == True:
            print("connecting bones..")

            children = list()
            for tbone in cc_rename:
                
                if tbone in tbones:

                    if bpy.context.window_manager.cc_props.cc_rename_to_targets == False:
                        
                        mbone = tbone
                    else:
                        
                        mbone = cc_rename[tbone]

                    children = armObj.data.edit_bones[mbone].children
                    if len(children) != 1:
                        continue
                    
                    cbone = children[0]

                    if bpy.context.window_manager.cc_props.cc_rename_to_targets == False:
                        ctbone = tbone
                    else:
                        ctbone =  mbone_data[cbone.name]['tbone']
                    use_connect = tbone_data[ctbone]['use_connect']

                    if use_connect == True:
                        armObj.data.edit_bones[mbone].tail = armObj.data.edit_bones[cbone.name].head
                        
                        armObj.data.edit_bones[cbone.name].use_connect = True
                else:
                    pass
                    
        link_error = 0
        if bpy.context.window_manager.cc_props.cc_integrity_check == True:
            
            for boneObj in armObj.data.edit_bones:
                bone = boneObj.name
                if bone not in bento_links:
                    link_error = 1
                    print("Bone missing from SL hierarchy during integrity check, aborting:", bone)
                    break
                parent = bento_links[bone]
                if parent == "":
                    print("Found root bone:", bone)
                    continue
                if parent not in armObj.data.edit_bones:
                    link_error = 1
                    print("Missing parent bone in hierarchy, this maybe erroneous if it is a (Spine) bone:", parent)
                    continue
                if armObj.data.edit_bones[bone].parent is None:
                    link_error = 1
                    print("Fixing missing parent for bone:", bone)
                    armObj.data.edit_bones[bone].parent = armObj.data.edit_bones[parent]

                elif armObj.data.edit_bones[bone].parent.name != parent:
                    link_error = 1
                    bad_parent = armObj.data.edit_bones[bone].parent.name
                    print("Fixing wrong parent for bone", bone, "with parent", bad_parent, "- re-parenting to", parent)
                    armObj.data.edit_bones[bone].parent = armObj.data.edit_bones[parent]
                else:
                    
                    pass

        if link_error == 1:
            txt = "There was a problem with the hierarchy, check the console for details"
            print("There was at least 1 problem when checking the integrity of the converted rig")
            
        print("Converted rig:", armObj.name)

        armObj['onigiri_converted'] = 1

        if bpy.context.window_manager.cc_props.cc_apply_bone_roll== True:
            apply_sl_bone_roll(armObj.name)
        else:
            print("ATTENTION! skipping apply_sl_bone_roll")

        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')
        for obj in original_selection:
            obj.select_set(True)
        bpy.context.view_layer.objects.active = active_object

        obj = bpy.data.objects
        print("Checking weight group integrity...")
        wrong_groups = {}
        wrong_groups_error = False
        for meshObj in qualified_mesh:
            mesh = meshObj.name
            print("Processing mesh:", mesh)

            wrong_groups[mesh] = list()
            for vgObj in obj[mesh].vertex_groups:
                if vgObj.name not in armObj.data.bones:
                    wrong_groups_error = True
                    wrong_groups[mesh].append(vgObj.name)
        if wrong_groups_error == True:
            print("There was an error processing your map, at least one important bone was not mapped properly.")
            print("Any bones that have mesh weight data and are not mapped will have free floating vertices, these must be mapped.")
            print("If the bones are end bones Onigiri can pick them up and auto-weight them but the ones below are not that type.")
            print("Revisit your map and see where the error is and map those bones to an anchor, possibly for re-skinning.")
            print("The following are a list of vertex groups, which are bone names, that did not match...")
            for m in wrong_groups:
                if len(wrong_groups[m]) == 0:
                    continue
                print("mesh: ", m)
                for g in wrong_groups[m]:
                    print(" - bone:", g)

        removed_groups = []
        if ccp.cc_remove_unmatched_groups == True:
            for meshObj in qualified_mesh:
                for g in meshObj.vertex_groups:
                    if g.name not in armObj.data.bones:
                        gname = g.name
                        meshObj.vertex_groups.remove(g)
                        print("Vertex group removed:", gname)
                        removed_groups.append(gname)
                    if len(removed_groups) > 0:
                        print("The effected groups were removed and your mesh may still be able to upload:", removed_groups)
        
        if ccp.cc_full_rig == True:
            for boneObj in armObj.data.bones:
                if boneObj.name in skel.avatar_skeleton:
                    continue
                print("Incompatible bone for SL:", boneObj.name)
                print("There's at least one bone in the resulting converted armature that does not match an SL compatible one")
                print("The conversion completed as expected but the feature to convert to full sl rig cannot be implemented")
                popup("Full rig chosen but the rig is not compatible with SL, see console", "Info", "INFO")
                return {'FINISHED'}
            
            armObj.select_set(True)
            bpy.ops.onigiri.convert_to_full_rig()

        return {'FINISHED'}

class CharacterConverterMergeCCMPose(bpy.types.Operator, ImportHelper):
    """Merge a pose from a Character Converter Module"""
    bl_idname = "bb_converter.merge_ccm_pose"
    bl_label = "Merge a CC Pose into the panel"

    filter_glob : bpy.props.StringProperty(
        default='*.ccm;*.bbm',
        options={'HIDDEN'}
    )

    def execute(self, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        pose_file = self.properties.filepath
        ccm_pose = {}
        try:
            namespace = {}
            exec(open(pose_file, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("There was a problem reading your CCM file, the following trace might give a clue what happened")
            print(traceback.format_exc())
            return {'FINISHED'}

        try:
            ccm_pose.update(namespace['pose'])
        except:
            print("I couldn't find the pose in the CCM file")
            popup("No pose found in CCM", "CCM Pose Missing", "INFO")
            return {'FINISHED'}

        new_poses = ccl['poses_stored'].to_dict()

        ext = get_unique_name_short()
        new_pose = "ccm_" + ext
        if new_pose in ccl['poses_stored']:
            txt = "Internal renaming error when attempting to generate a unique pose name, " + new_pose
            print(txt)
            popup("Internal naming error, fix your pose names, check console for details", "Pose Name Error", "ERROR")
            
            ext = get_unique_name()
            new_pose = "ccm_" + ext
            if new_pose in ccl['poses_stored']:
                txt = "Last ditch attempt to create a unique name failed, try renaming some existing, similar, items first: " + new_pose
                print (txt)
                return {'FINISHED'}

        new_poses[new_pose] = {"pose_matrix": ccm_pose}

        for p in new_poses:
            pose_matrix = new_poses[p]['pose_matrix']
            prefix = get_data_prefix(pose_matrix)
            
            new_poses[p]['pose_prefix'] = prefix

        ccl['poses_stored'] = new_poses

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class CharacterConverterLoadPoseLib(bpy.types.Operator, ImportHelper):
    """Load a pose library into the panel"""
    bl_idname = "bb_converter.load_pose_library"
    bl_label = "Load pose library"

    filename_ext = ".bpl"

    filter_glob : bpy.props.StringProperty(
        default='*.bpl',
        options={'HIDDEN'}
    )

    @classmethod
    def poll(cls, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        return True

    def execute(self, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        pose_file = self.properties.filepath
        cc_poses = {}
        try:
            namespace = {}
            exec(open(pose_file, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("There was a problem reading your pose file, the following trace might give a clue what happened")
            print(traceback.format_exc())
            return {'FINISHED'}

        try:
            cc_poses.update(namespace['poses'])
        except:
            print("I couldn't find the pose library in the file")
            popup("No pose library found", "Library Error", "ERROR")
            return {'FINISHED'}

        for p in cc_poses:
            pose_matrix = cc_poses[p]['pose_matrix']
            prefix = get_data_prefix(pose_matrix)
            
            cc_poses[p]['pose_prefix'] = prefix

        ccl['poses_stored'] = cc_poses

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class CharacterConverterSavePoseLib(bpy.types.Operator, ExportHelper):
    """Save the current pose library to a file"""
    bl_idname = "bb_converter.save_pose_library"
    bl_label = "Save Pose Library"

    filename_ext = ".bpl"

    filter_glob : bpy.props.StringProperty(
        default='*.bpl',
        options={'HIDDEN'}
    )

    @classmethod
    def poll(cls, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        if ccl.get('poses_stored') == None:
            return False

        if len(ccl['poses_stored']) == 0:
            return False
        return True

    def execute(self, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        poses = ccl['poses_stored'].to_dict()

        formatted_poses = "# Pose library auto-generated by Onigiri \n\n"
        formatted_poses += "poses = {\n"

        for pose in poses:
            formatted_poses += '    "' + pose + '": {' + "\n"

            formatted_poses += "        " + '"pose_matrix": {' + "\n"
            for bone in poses[pose]['pose_matrix']:
                
                matrix_basis = matrix_to_tuples(poses[pose]['pose_matrix'][bone])
                formatted_poses += '            "' + bone + '": ' + str(matrix_basis) + ",\n"
            formatted_poses += "            },\n"
            formatted_poses += "        },\n"
        formatted_poses += "    }\n"

        pose_file = self.properties.filepath
        output = open(pose_file, 'w', encoding='UTF8')
        output.write(formatted_poses)
        output.close()
        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class CharacterConverterResetPoseLib(bpy.types.Operator):
    """Reset the current pose library"""
    bl_idname = "bb_converter.reset_pose_library"
    bl_label = "reset_pose_library"

    @classmethod
    def poll(cls, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        if ccl.get('poses_stored') == None:
            return False

        if len(ccl['poses_stored']) == 0:
            return False
        return True

    def execute(self, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects
        
        ccl['poses_stored'] = dict()
        return {'FINISHED'}

class CharacterConverterMergePoseLib(bpy.types.Operator, ImportHelper):
    """Merge a pose library with the loaded one in the panel"""
    bl_idname = "bb_converter.merge_pose_library"
    bl_label = "Merge Pose Library"

    filename_ext = ".bpl"

    filter_glob : bpy.props.StringProperty(
        default='*.bpl',
        options={'HIDDEN'}
    )

    @classmethod
    def poll(cls, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        return True

    def execute(self, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        pose_file = self.properties.filepath
        cc_poses = {}
        try:
            namespace = {}
            exec(open(pose_file, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("There was a problem reading your pose file, the following trace might give a clue what happened")
            print(traceback.format_exc())
            return {'FINISHED'}

        try:
            cc_poses.update(namespace['poses'])
        except:
            print("I couldn't find the pose library in the file")
            popup("No pose library found", "Library Error", "ERROR")
            return {'FINISHED'}

        new_poses = ccl['poses_stored'].to_dict()
        for pose in cc_poses:
            new_pose = pose
            if pose in ccl['poses_stored']:
                
                ext = get_unique_name_short()
                new_pose = pose + "." + ext
                if new_pose in ccl['poses_stored']:
                    txt = "Internal renaming error when attempting to generate a unique pose name, " + new_pose
                    print(txt)
                    popup("Internal naming error, fix your pose names, check console for details", "Pose Name Error", "ERROR")
                    
                    ext = get_unique_name()
                    new_pose = pose + "." + ext
                    if new_pose in ccl['poses_stored']:
                        txt = "Last ditch attempt to rename failed, you have serious library issues: " + new_pose
                        print (txt)
                        return {'FINISHED'}
            new_poses[new_pose] = cc_poses[pose]

        for p in new_poses:
            pose_matrix = new_poses[p]['pose_matrix']
            prefix = get_data_prefix(pose_matrix)
            
            new_poses[p]['pose_prefix'] = prefix

        ccl['poses_stored'] = new_poses

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class CharacterConverterSetKey(bpy.types.Operator):
    """Set a key on selected pose bones.  Note that scale animations do not work in Second Life
You must be in pose mode to set keys

Set keys: for rotation, location and scale
INS: move keys to the right, inserting blank space to work with
"""

    bl_idname = "bb_converter.set_key"
    bl_label = "set animation key"

    key_type : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        obsel = bpy.context.selected_objects
        if len(obsel) == 0:
            return False
        for o in obsel:
            if o.type != 'ARMATURE':
                return False
        if bpy.context.mode == 'POSE':
            return True

        return False

    def execute(self, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        bpy.context.view_layer.update()

        if self.key_type == "move":
            arm = bpy.context.selected_objects[0].name
            frame_now = bpy.context.scene.frame_current
            shifter.move_keys(arm=arm, start=frame_now, range=1)
            return {'FINISHED'}

        bone_key_types = {"rotation": "rotation_quaternion", "location": "location", "scale": "scale"}
        key_set = bone_key_types[self.key_type]

        current_frame = bpy.context.scene.frame_current

        for pbone in bpy.context.selected_pose_bones:
            
            rotation_mode = pbone.rotation_mode
            
            pbone.keyframe_insert(data_path=key_set, frame=current_frame)
            
            pbone.rotation_mode = rotation_mode
            print("REMINDER: static message")
            print(" - CharacterConverterSetKey reports:")
            print(" -")
            print(" - rotation mode saved and restored but wasn't set")
            print(" - Useless use of container or did you forget to set the rotation mode to QUATERNION?")
            print(" - INFO: keyframe_insert seems to have an internal set feature.")

        return {'FINISHED'}

class CharacterConverterApplyPose(bpy.types.Operator):
    """Apply this pose to the selected rig"""
    bl_idname = "bb_converter.apply_pose"
    bl_label = "apply_pose"

    pose : bpy.props.StringProperty(name="pose",default="")

    @classmethod
    def poll(cls, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False

        selected = bpy.context.selected_objects[0]

        if selected.type != 'ARMATURE':
            return False

        return True

    def execute(self, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        armObj = bpy.context.selected_objects[0] 

        if context.mode == 'EDIT_ARMATURE':
            
                old_mode = 'EDIT'
        else:
            old_mode = context.mode

        pose = dict()
        bpy.ops.object.mode_set(mode='POSE')

        selected_pose_bones = set()
        for boneObj in bpy.context.selected_pose_bones:
            selected_pose_bones.add(boneObj.name)

        bpy.ops.pose.select_all(action = 'DESELECT')

        poses_stored = ccl['poses_stored'][self.pose]['pose_matrix'].to_dict()

        for bone in poses_stored:
            if bone not in armObj.data.bones:
                continue
            if ccl.pose_apply_to_selected == True:
                
                if bone not in selected_pose_bones:
                    continue
            
            old_rotation_mode = armObj.pose.bones[bone].rotation_mode
            armObj.pose.bones[bone].rotation_mode = 'QUATERNION'
            armObj.pose.bones[bone].matrix_basis = mathutils.Matrix(poses_stored[bone])
            armObj.pose.bones[bone].rotation_mode = old_rotation_mode
            
        bpy.ops.pose.select_all(action = 'DESELECT')
        for bone in selected_pose_bones:
            armObj.data.bones[bone].select = True
        bpy.ops.object.mode_set(mode=old_mode)

        return {'FINISHED'}

class CharacterConverterAddPose(bpy.types.Operator):
    """Add pose from selected rig to the current library"""
    bl_idname = "bb_converter.add_pose"
    bl_label = "add_pose"

    @classmethod
    def poll(cls, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False

        selected = bpy.context.selected_objects[0]

        if selected.type != 'ARMATURE':
            return False

        return True

    def execute(self, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        armObj = bpy.context.selected_objects[0] 

        selected_bones = list()
        if bpy.context.selected_pose_bones is not None:
            for bone in bpy.context.selected_pose_bones:
                selected_bones.append(bone.name)

        if context.mode == 'EDIT_ARMATURE':
            
                old_mode = 'EDIT'
        else:
            old_mode = context.mode

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action = 'DESELECT')

        if ccl.pose_name == "" or ccl.pose_name.isspace() or ccl.pose_name in ccl['poses_stored']:
            pose_name = get_unique_name_short()
            if pose_name in ccl['poses_stored']:
                
                txt = "Name generator failed, please type in a unique name for your pose."
                print(txt)
                popup(txt, "Internal Error 503", "ERROR")
                return {'FINISHED'}
        else:
            pose_name = ccl.pose_name

        ccl['poses_stored'][pose_name] = dict()

        ccl.pose_name = ""

        pose = dict()
        pose['pose_matrix'] = {}

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action = 'DESELECT')

        for boneObj in armObj.pose.bones:
            bone = boneObj.name

            old_rotation_mode = boneObj.rotation_mode
            boneObj.rotation_mode = 'QUATERNION'
            
            pose['pose_matrix'][bone] = boneObj.matrix_basis.copy()
            boneObj.rotation_mode = old_rotation_mode
            
        pose_matrix = pose['pose_matrix']
        prefix = get_data_prefix(pose_matrix)
        pose['pose_prefix'] = prefix

        ccl['poses_stored'][pose_name] = pose.copy()

        bpy.ops.pose.select_all(action = 'DESELECT')
        for bone in selected_bones:
            armObj.data.bones[bone].select = True
        bpy.ops.object.mode_set(mode=old_mode)

        return {'FINISHED'}

class CharacterConverterRemovePosePrefix(bpy.types.Operator):
    """This indicates that there's a bone prefix associated with this pose.  Click to remove it"""

    bl_idname = "bb_converter.remove_pose_prefix"
    bl_label = "remove_pose_prefix"

    pose : bpy.props.StringProperty(name="pose",default="")

    @classmethod
    def description(cls, context, properties):
        ccl = bpy.context.window_manager.cc_libs
        return "Prefix is: " + ccl['poses_stored'][properties.pose]['pose_prefix'] + "\n" 

    def execute(self, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        pose_matrix = ccl['poses_stored'][self.pose]['pose_matrix'].to_dict()
        pose_prefix = ccl['poses_stored'][self.pose]['pose_prefix']
        ccl['poses_stored'][self.pose]['pose_matrix'] = remove_data_prefix(container=pose_matrix, prefix=pose_prefix)
        ccl['poses_stored'][self.pose]['pose_prefix'] = ""

        return {'FINISHED'}

class CharacterConverterDeletePose(bpy.types.Operator):
    """Remove pose from the current library"""
    bl_idname = "bb_converter.delete_pose"
    bl_label = "delete_pose"

    pose : bpy.props.StringProperty(name="pose",default="")

    def execute(self, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects
        del ccl['poses_stored'][self.pose]
        return {'FINISHED'}

class CharacterConverterEditPose(bpy.types.Operator):
    """Change the name of this pose"""
    bl_idname = "bb_converter.edit_pose"
    bl_label = "edit_pose"

    pose : bpy.props.StringProperty(name="pose",default="")

    @classmethod
    def poll(cls, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects
        return True

    def execute(self, context):
        ccl = bpy.context.window_manager.cc_libs
        obj = bpy.data.objects

        ccl.pose_edit_name_backup = self.pose

        bb_settings['terminate'] = True
        ccl.pose_edit_name = self.pose

        ccl.pose_edit_trigger = True
        return {'FINISHED'}

class CharacterConverterLibProperties(bpy.types.PropertyGroup):

    def pose_blank(self, context):
        self["pose_blank"] = False
    pose_blank : bpy.props.BoolProperty(
        name = "",
        description = "",
        default = False,
        update = pose_blank
        )

    def update_pose_enable_library(self, context):
        ccl = bpy.context.window_manager.cc_libs
        
        if ccl.get('poses_stored') is None:
            ccl["poses_stored"] = dict()
        return

    pose_enable_library : bpy.props.BoolProperty(
        name = "ccl enable pose library",
        description =            "Expand pose tools.  You can save, load, alter poses for this particular rig.",
        default = False,
        update = update_pose_enable_library
        )
    
    pose_lib_filename : bpy.props.StringProperty(
        name = "cc pose lib filename",
        description = "",
        default = ""
        )

    pose_name : bpy.props.StringProperty(
        name = "cc pose name",
        description =            "You cannot have duplicate names in the same library.  Put a unique name here.  "            "For the protection of your data, if you leave this blank or repeat an old name, "            "a unique identifier will be created for you. If you want to overwrite an old pose "            "you must delete it first.",
        default = ""
        )
    
    def update_pose_edit_name(self, context):
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        
        ccl = bpy.context.window_manager.cc_libs

        if ccl.pose_edit_name == ccl.pose_edit_name_backup:
            
            ccl.pose_edit_trigger = False
            return
        
        if ccl.pose_edit_name == "" or ccl.pose_edit_name.isspace():
            print("update_pose_edit_name reports empty name")
            ccl.pose_edit_name_backup = ""
            bb_settings['terminate'] = True
            ccl.pose_edit_name = ""
            ccl.pose_edit_trigger = False
            return
        if ccl.pose_edit_name in ccl['poses_stored']:
            print("update_pose_edit reports duplicate name, aborting name change")
            popup("That name is already taken, try another")
            ccl.pose_edit_name_backup = ""
            bb_settings['terminate'] = True
            ccl.pose_edit_name = ""
        else:
            
            ccl['poses_stored'][ccl.pose_edit_name] = ccl['poses_stored'][ccl.pose_edit_name_backup]
            del ccl['poses_stored'][ccl.pose_edit_name_backup]
        ccl.pose_edit_name_backup = ""
        bb_settings['terminate'] = True
        ccl.pose_edit_name = ""
        ccl.pose_edit_trigger = False
        return
    
    pose_edit_trigger : bpy.props.BoolProperty(
        name = "pose edit trigger",
        description = "",
        default = False
        )
    
    pose_edit_name : bpy.props.StringProperty(
        name = "ccl pose edit name",
        description = "Edit the name of your pose",
        default = "",
        update = update_pose_edit_name
        )
    
    pose_edit_name_backup : bpy.props.StringProperty(
        name = "cc pose edit name backup",
        description = "",
        default = ""
        )
    pose_apply_to_selected : bpy.props.BoolProperty(
        name = "cc pose apply to selection",
        description = "With this enabled any pose you apply back to the rig will only alter the selected bones on that rig.",
        default = False
        )

class CharacterConverterProperties(bpy.types.PropertyGroup):

    cc_advanced_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Expand advanced options",
        default = False
        )

    use_ccm : bpy.props.BoolProperty(
        name="load map",
        description = "Use the loaded CCM, Character Converter Map file as a starting template for your character of the same"            "target system.",
        default = False
        )
    
    cc_remove_unmatched_groups : bpy.props.BoolProperty(
        name = "",
        description = ""            "Remove groups that don't have a matching bone.  This happens often when a rig is complex with many controllers "            "and sometimes with shape tweakers, these tweakers are not compatible with SL so you may want to assign these "            "to something else if they are important, they cannot automatically be pulled in.",
        default = True
        )

    cc_weight_unmapped_groups : bpy.props.BoolProperty(
        name = "cc_weight_unmapped_groups",
        description = ""            "The default is enabled.  This tells Character Converter to follow bone chaines of those bones that were not mapped "            "and attempt to determine an anchor bone weight for each unmapped bone.  This usually works great.  An example would be "            "if you are mapping an arbitrary mesh where hair bones vary in each rig, Character Converter can find those bone ends and "            "map those weights to the head, which is usually the proper target.  This can fail if the unmapped bones do not end in a "            "single child and, instead, some how wrap around to another bone or meet up with an already mapped bone.  It's safe to "            "disable this of all of your bones are mapped to something. ",
        default = True
        )
    cc_connect_links : bpy.props.BoolProperty(
        name = "cc_connect_links",
        description =            "This connects bones to close the gap made when other bones have been removed.  Leaving the gaps can be unsightly "            "but not harmful.  Closing those gaps will definitely destroy an auto-mapped character.  Enable this only for testing.  "            "\n\n"            "You may want to enable this for testing.  It used to be enabled by default but now we can convert auto-mapped "            "characters directly into SL with a map generated from the auto-mapper.  Absolutely keep this disabled if you are "            "converting an auto-mapped character.",
        default = False
        )
    cc_rename_to_targets : bpy.props.BoolProperty(
        name = "cc_rename_to_targets",
        description = "Disable this default for debugging.  This can be helpful when debugging or creating a new Character "            "Converter Map.  The bones won't be renamed to the targets indicated in your map, so that you can see what's going "            "on with the left over and removed bones.",
        default = True
        )
    cc_remove_unused_bones : bpy.props.BoolProperty(
        name = "cc_remove_unused_bones",
        description = "This default enables the removal of unused bones after mapping.  Disabling it allows you to get a better "            "look at what's happening if you experience difficulties creating or editing a map file.  Please note that "            "this puts the armature into an unusable state and must be completed before upload.  Once you're done testing "            "then enable this feature to get a completed rig.",
        default = True
        )
    cc_add_missing_groups : bpy.props.BoolProperty(
        name = "cc_add_missing_groups",
        description = "In the skin section there might be a target, often times the root or pelvis, that had no weight group in "            "any of the mesh.  If this doesn't have a group then there's nothing to target for those remapped weights.  This "            "feature makes sure that those targets will exist for the mapping.  It shouldn't cause a problem.",
        default = True
        )
    
    def update_bake_map_pose(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        ccp = bpy.context.window_manager.cc_props
        if ccp.cc_bake_map_pose == True:
            
            ccp.cc_bake_pose_type = "map"

            bb_settings['terminate'] = True
            ccp.cc_bake_current_pose = False
        return
    def update_bake_current_pose(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        ccp = bpy.context.window_manager.cc_props
        if ccp.cc_bake_current_pose == True:
            
            ccp.cc_bake_pose_type = "current"

            bb_settings['terminate'] = True
            ccp.cc_bake_map_pose = False
        return

    cc_bake_map_pose : bpy.props.BoolProperty(
        name = "cc bake map pose",
        description =            "Apply the included pose from your map file to the source rig.  This applies when you load a map file either from "            "the converter panel or the expanded Custom Mapping Tools panel.  In the converter it's an automated single button "            "process so the pose is applied during conversion.  In the mapper the pose is applied immediately so that you can "            "change it if you want and re-save it.\n\n"            "WARNING:  This is a destructive process!  "            "But you must choose one if you are exporting for Second Life or Opensim.  "            "Don't be alarmed, just save your file beforehand.  But this is typically what you want, either to bake your pose from "            "the map file or bake it from the current pose.  It is essential to have the proper pose for SL.",
        default = False,
        update = update_bake_map_pose
        )
    cc_bake_current_pose : bpy.props.BoolProperty(
        name = "cc bake current pose",
        description =            "Apply the existing pose to your rig during conversion.  This is typically set in the Onigiri pose library but "            "you can set any pose you want and it will keep it.\n\n"            "WARNING:  This is a destructive process!  "            "But you must choose one if you are exporting for Second Life or Opensim.  "            "Don't be alarmed, just save your file beforehand.  But this is typically what you want, either to bake your pose from "            "the map file or bake it from the current pose.  It is essential to have the proper pose for SL.",
        default = True,
        update = update_bake_current_pose
        )
    cc_bake_pose_type : bpy.props.StringProperty(
        name = "cc bake pose type",
        description = "internal - the updater will set this to either current or map",
        default = ""
        )
    cc_integrity_check : bpy.props.BoolProperty(
        name = "cc integrity check",
        description =            "Fix the bone hierarchy.  This is probably best left disabled, only enable it if you experience deformities."            "\n\n"            "This can only work if (Rename bones to target) is enabled.\n\n"            "Unfortunately some rigs are broken and the bones might not be parented as you would expect.  This integrity check will "            "examine the hierarchy after the conversion and make the appropriate changes to the rig in order to fix it.  "            "If this results in a broken conversion you'll want to disable this and run the conversion on a clean rig to see what "            "went wrong and possibly fix it yourself.  Often times it's pretty easy, just find a bone that's not parented properly and "            "parent it yourself before conversion and after that you can leave this feature disabled.",
        default = False
        )
    cc_apply_bone_roll : bpy.props.BoolProperty(
        name = "",
        description =            "This applies a consistent bone roll to your mapped bones.  It usually matches the BB rig well enough for most things "            "like retargeting and motion mixing but the advancement of these tools has made this feature superfluous.  However, "            "you may find it useful in order to have a consistent bone angle outcome when working with multiple rigs that you need "            "compliant with some target.  The roll angles cannot be changed here but you can do it manually after conversion.",
        default = False
        )

    cc_full_rig : bpy.props.BoolProperty(
        name = "Convert to full rig",
        description =            "Convert to a full BB rig"            "\n\n"            "Usually your skeleton structure is as described in the map file.  With this enabled "            "the converted Second Life compatible character will have a complete rig which will work exactly the "            "same except you'll be able to modify how your character functions after conversion, for instance if you want to "            "skin part of your mesh to alternate bones that can be adjusted with sliders.  If you already converted your rig "            "with this disabled and changed your mind just expand the (Rig Tools) panel, choose your rig and click the button "            "(Convert partial rig to full rig) which accepts multiple rigs at a time."            "\n\n"            "Because of the folded spine bones it's very likely that you'll need a deformer even when uploading with joint "            "positions.  If you find yourself needing this, either because of the spine bones or because you chose to use other "            "non-sl-animated bones, like face bones, then it's best to upload without joint positions ticked and use your deformer "            "to bring the entire rig into compliance",
        )
    cc_apply_transforms : bpy.props.BoolProperty(
        name = "",
        description =            "Apply transforms before conversion",
        )
    cc_map_filename : bpy.props.StringProperty(
        name = "cc filename",
        description = "Character Converter Filename",
        default = ""
        )

    def populate_custom_map_ui(self, context):
        
        if bpy.context.window_manager.cc_props.cc_custom_mapping == True:
            print("Mapping Enabled")
            
        if bpy.context.window_manager.cc_props.cc_custom_mapping == False:
            print("Mapping Disabled")
            
        return

    cc_custom_mapping : bpy.props.BoolProperty(
        name = "cc_custom_mapping",
        description =            "CAUTION!: This is a fully functional mapping system to convert any foreign character for use with Second Life, BUT..."            "this mapper was difficult to manage and bug fix, please try your hand at the new, replacement, mapper provided under "            "(Template Creator / Editor - Hybrid Mapper), it's much more fun and a lot easier to understand."            "\n\n"            "This enables a mapper which allows you to click and choose bones, "            "that can't be used in the target platform, and map them to an anchor bone that can be used.",
        default = False,
        update = populate_custom_map_ui
        )

    def update_record_source_rig(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        if ccp.record_source_rig == True:
            if len(bpy.context.selected_objects) == 0:
                ccp.ccm_message = "No object selected"
                bb_settings['terminate'] = True
                ccp.record_source_rig = False
                return
            if len(bpy.context.selected_objects) > 1:
                ccp.ccm_message = "Only one object at a time can be chosen"
                bb_settings['terminate'] = True
                ccp.record_source_rig = False
                return
            
            armObj = bpy.context.selected_objects[0]
            
            if armObj.name == ccp.target_rig_name and ccp.target_rig_name != "":
                ccp.ccm_message = "Source and target cannot be the same rigs"
                print(ccp.ccm_message)
                ccp.target_rig_name = ""
                ccp.source_rig_name = armObj.name
                bb_settings['terminate'] = True
                ccp.record_target_rig = False
                return
            
            if armObj.type != 'ARMATURE':
                ccp.ccm_message = "Both objects must be armatures"
                bb_settings['terminate'] = True
                
                ccp.record_source_rig = False
                return

            if armObj.get('onigiri') != None:
                print("This is a Onigiri rig so it's in the wrong slot, swap your rig choices.")
                ccp.ccm_message = "Onigiri rig in wrong slot!"
                bb_settings['terminate'] = True
                ccp.record_source_rig = False
                return

            for bone in armObj.data.bones:
                bone.hide_select = False
            old_mode = bpy.context.mode
            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.select_all(action = 'SELECT')
            bpy.ops.pose.group_unassign()
            bpy.ops.pose.select_all(action = 'DESELECT')

            create_bone_group(armObj.name, cc_rename_group, cc_rename_theme)
            create_bone_group(armObj.name, cc_reskin_group, cc_reskin_theme)
            bpy.ops.object.mode_set(mode=old_mode)
            armObj.select_set(True)

            ccp.ccm_message = "Awesome sauces! \o/"
            
            ccp.source_rig_name = armObj.name

            print("Source rig recorded:", armObj.name)

        elif ccp.record_source_rig == False:
            
            ccp.load_map_info = "Load a map file"
            ccp.icon_thumb = "load"

            clean_rig_mapper(ccp.source_rig_name)
            
            if ccp.target_rig_name != "":
                clean_rig_mapper(ccp.target_rig_name)
            
            ccp.source_rig_name = ""
            return
        return

    def update_record_target_rig(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        if ccp.record_target_rig == True:
            if ccp.source_rig_name == ccp.target_rig_name and ccp.source_rig_name != "":
                ccp.ccm_message = "Source and target cannot be the same rigs"
                bb_settings['terminate'] = True
                ccp.record_source_rig = False
                return
            if len(bpy.context.selected_objects) == 0:
                ccp.ccm_message = "No object selected"
                bb_settings['terminate'] = True
                ccp.record_target_rig = False
                return
            if len(bpy.context.selected_objects) > 1:
                ccp.ccm_message = "Only one object at a time can be chosen"
                bb_settings['terminate'] = True
                ccp.record_target_rig = False
                return
            
            armObj = bpy.context.selected_objects[0]
            
            if armObj.name == ccp.source_rig_name and ccp.source_rig_name != "":
                ccp.ccm_message = "Source and target cannot be the same rigs"
                print(ccp.ccm_message)
                ccp.source_rig_name = ""
                ccp.target_rig_name = armObj.name
                bb_settings['terminate'] = True
                ccp.record_source_rig = False
                return
            
            if armObj.type != 'ARMATURE':
                ccp.ccm_message = "Both objects must be armatures"
                bb_settings['terminate'] = True
                
                ccp.record_target_rig = False
                return

            old_mode = bpy.context.mode
            
            for bone in armObj.data.bones:
                bone.hide_select = False
            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.select_all(action = 'SELECT')
            bpy.ops.pose.group_unassign()
            bpy.ops.pose.select_all(action = 'DESELECT')

            create_bone_group(armObj.name, cc_rename_group, cc_rename_theme)
            bpy.ops.object.mode_set(mode=old_mode)
            armObj.select_set(True)

            ccp.ccm_message = "Awesome sauces! \o/"
            
            ccp.target_rig_name = armObj.name

            print("Target rig recorded:", armObj.name)
        elif ccp.record_target_rig == False:
            
            ccp.load_map_info = "Load a map file"
            ccp.icon_thumb = "load"

            clean_rig_mapper(ccp.target_rig_name)
            if ccp.source_rig_name != "":
                clean_rig_mapper(ccp.source_rig_name)
            ccp.target_rig_name = ""
            return
        return

    record_source_rig : bpy.props.BoolProperty(
        name = "record_source_rig",
        description =            "WARNING! If you get an error message about (prefix) use the template tools in the (Template Workshop) before trying again.  "            "This is different than the other map tools in that the (source) is your character rig and the (target) "            "will be the armature with the bone names that are properly named, for your target system.",
        default = False,
        update = update_record_source_rig
        )
    record_target_rig : bpy.props.BoolProperty(
        name = "record_target_rig",
        description = "This is a rig from the target system that contains the proper bone names for that target.  These names will "            "be used on your source rig to rename the bones on the source and adjust weight groups according to your (Rename) and "            "(Reskin) selections",
        default = False,
        update = update_record_target_rig
        )
    disable_map_pose : bpy.props.BoolProperty(
        name = "load_map_pose",
        description =            "This feature is helpful when you've saved a CCM when the rig was in a strange pose since any pose that the rig is "            "currently in will save along with the CCM.  This allows you to start with a clean CCM with mapping only, and no pose.  "            "With this (disable) button pushed the pose contained in the map file will not be loaded along with the mapping.  "            "This also means that the current pose will be saved with the map file and the pose in the new, saved, CCM will not "            "contain the pose from the loaded CCM.  If the CCM files are the same then of course the pose in the CCM will be "            "overwritten.  Make sure you know what's going on, it's safe to just use a different name when saving.",
        default = False,
        )
    disable_map_code : bpy.props.BoolProperty(
        name = "",
        description =            "Code Loading"            "\n\n"            "In some newer versions of Onigiri we'll start using macros to help process difficult characters.  This code is "            "embedded in the map file and is only used where indicated and is always defaulted to OFF.  If the code is indicated "            "you should probably use it.  This feature allows you to disable overwrite of previously loaded code if you know that "            "a previously loaded map has usable code and you don't want to replace it.  This feature works just like the pose loader.",
        default = True,
        )

    def check_selection(self, context):
        ccp = bpy.context.window_manager.cc_props
        ccc = bpy.context.window_manager.cc_containers
        obj = bpy.data.objects
        if ccp.source_rig_name != "" and ccp.target_rig_name != "":
            
            ccp['reskin_mapper'] = dict()
            ccp['remap_stored'] = dict()
            ccp['remap_stored']['reskin'] = dict()
            ccp['remap_stored']['rename'] = dict()

            ccp['map_editor'] = dict()
            
            ccp['map_editor']['last_selected'] = ""
            
            ccp['map_editor']['hidden'] = dict()
            
            ccp['map_editor']['isolated'] = dict()

            ccp['map_editor']['hide_mapped_state'] = dict()

            ccp['map_editor']['active_anchor'] = ""

            obj[ccp.source_rig_name].show_in_front = True

            ccp.ccm_message = "Bone mapping stage"
            ccp.enable_retargeting = True
        else:
            
            ccp.enable_retargeting = False
            ccp.set_rename_parent = ""
            ccp.set_reskin_children = ""
            ccp.set_rename_target = ""
            ccp.reset_mapper = ""
            
            ccp.save_ready = ""
            ccp.last_anchor = ""

            ccp.mapper_ready = ""
            
            if ccp.get('reskin_mapper') != None:
                del ccp['reskin_mapper']
            if ccp.get('remap_stored') != None:
                del ccp['remap_stored']

        return

    source_rig_name : bpy.props.StringProperty(
        name = "source_rig_name",
        description = "internal - source rig name",
        default = "",
        update = check_selection
        )
    target_rig_name : bpy.props.StringProperty(
        name = "target_rig_name",
        description = "internal - target rig name",
        default = "",
        update = check_selection
        )

    def update_backup_source_rig_name(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        clean_rig_mapper(ccp.backup_source_rig_name)
        clean_rig_mapper(ccp.backup_target_rig_name)
        print("update_backup_target_rig_name ran")
        return
    def update_backup_target_rig_name(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        clean_rig_mapper(ccp.backup_target_rig_name)
        clean_rig_mapper(ccp.backup_source_rig_name)
        print("update_babckup_target_rig_name ran")
        return

    backup_source_rig_name : bpy.props.StringProperty(
        name = "trn backup",
        description = "internal - trn backup",
        default = "",
        update = update_backup_target_rig_name
        )
    backup_target_rig_name : bpy.props.StringProperty(
        name = "srn backup",
        description = "internal - srn backup",
        default = "",
        update = update_backup_target_rig_name
        )

    ccm_message : bpy.props.StringProperty(
        name = "ccm_message",
        description = "internal - message update",
        default = "-- Look here for messages --"
        )

    def update_enable_retargeting(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects
        bpy.context.view_layer.update()
        if ccp.enable_retargeting == True:
            
            if obj[ccp.source_rig_name].type != 'ARMATURE' or obj[ccp.target_rig_name].type != 'ARMATURE':
                return
            armObj = obj[ccp.source_rig_name]
            bpy.ops.object.select_all(action='DESELECT')
            armObj.select_set(True)
            bpy.context.view_layer.objects.active = armObj
            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.select_all(action = 'DESELECT')
            return
        
        if bpy.context.mode != 'OBJECT' and len(bpy.context.selected_objects) == 1:
            bpy.ops.object.mode_set(mode='OBJECT')
        ccp.enable_retargeting_label = ""
        return

    def update_enable_retargeting_label(self, context):
        pass
        return
        
    enable_retargeting : bpy.props.BoolProperty(
        name = "enable_retargeting",
        description = "",
        default = False,
        update = update_enable_retargeting
        )
    enable_retargeting_label : bpy.props.StringProperty(
        name = "enable_retargeting_label",
        description = "test for the call-back operator to put it to use",
        default = "",
        update = update_enable_retargeting_label
        )

    cc_check_rigs_label : bpy.props.StringProperty(
        name = "enable_retargeting_label",
        description = "test for the call-back operator to put it to use",
        default = "",
        update = update_enable_retargeting_label
        )

    def update_set_rename(self, context):
        print("set_rename enabled")
        return
    def update_set_reskin(self, context):
        print("set_reskin enabled")
        return

    set_rename_parent : bpy.props.StringProperty(name="source anchor bone", description="",default="")
    
    set_reskin_children : bpy.props.StringProperty(name="source child bones", description="",default="")

    last_anchor : bpy.props.StringProperty(default = "")

    set_rename_target : bpy.props.StringProperty(name="target parent bone", description="",default="")

    reset_mapper : bpy.props.StringProperty(name="reset mapper", description = "", default = "")

    save_ready : bpy.props.StringProperty(name="reset mapper", description = "", default = "")

    load_map_info : bpy.props.StringProperty(name="cc load map name", description = "", default = "Load a map file")

    icon_thumb : bpy.props.StringProperty(name="cc icon thumbs", description = "", default = "load")

    def update_edit_mode(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        print("edit_mode:", ccp.edit_mode)

        if ccp.edit_mode == True:
            print("edit_mode: True")
            
            select_map_mode(type="edit")

            val = set_obj_mode(mode="pose", objects=[ccp.source_rig_name, ccp.target_rig_name])
            if val == False:
                print("update_edit_mode returns error from set_obj_mode with ccp.edit_mode =", ccp.edit_mode)
                return
            
            print("CharacterConverterProperties reports: edit_mode enabled - attempting to add handler - edit.auto_weight_on_select")
            try:
                bpy.app.handlers.depsgraph_update_post.append(edit.auto_weight_on_select)
            except:
                print("CharacterConverterProperties reports: handler error, is it enabled already?")

        else:
            
            last_selected = ccp['map_editor']['last_selected']
            
            if last_selected != "":
                
                if last_selected in ccp['remap_stored']['rename']:
                    
                    edit.auto_weight_colors(bone=last_selected, state="reset")
                ccp['map_editor']['last_selected'] = ""

            print("CharacterConverterProperties reports: edit_mode disabled - attempting to remove handler - edit.auto_weight_on_select")

            try:
                bpy.app.handlers.depsgraph_update_post.remove(edit.auto_weight_on_select)
            except:
                print("CharacterConverterProperties reports: handler error, is it disabled already?")

            select_map_mode(type="map")

            val = set_obj_mode(mode="pose", objects=[ccp.source_rig_name])
            if val == False:
                print("update_edit_mode returns error from set_obj_mode with ccp.edit_mode =", ccp.edit_mode)
                return
            
        return

    def update_hide_mapped_bones(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        source = ccp.source_rig_name

        if ccp.hide_mapped_bones == True:
            
            for boneObj in obj[source].data.bones:
                ccp['map_editor']['hide_mapped_state'][boneObj.name] = boneObj.hide

            for bone in ccp['remap_stored']['rename']:
                obj[source].data.bones[bone].hide = True
            for anchor in ccp['remap_stored']['reskin']:
                for bone in ccp['remap_stored']['reskin'][anchor] :
                    obj[source].data.bones[bone].hide = True
            return
        for bone in ccp['map_editor']['hide_mapped_state']:
            obj[source].data.bones[bone].hide = ccp['map_editor']['hide_mapped_state'][bone]
        ccp['map_editor']['hide_mapped_state'] = dict()

        return 

    def update_isolation_mode(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects
        source = ccp.source_rig_name

        if ccp.isolation_mode == True:
            
            if bpy.context.active_object.name != source:
                bb_settings['terminate'] = False
                ccp.isolation_mode = False
                return
            
            if len(bpy.context.selected_pose_bones) != 1:
                bb_settings['terminate'] = False
                ccp.isolation_mode = False
                return
            
            bone = bpy.context.selected_pose_bones[0].name
            if bone not in ccp['remap_stored']['rename']:
                bb_settings['terminate'] = False
                ccp.isolation_mode = False
                return
            
            for boneObj in bpy.context.active_object.data.bones:
                ccp['map_editor']['isolated'][boneObj.name] = boneObj.hide
            
            excluded_bones = list()
            excluded_bones.append(bone)
            
            if bone in ccp['remap_stored']['reskin']:
                for child in ccp['remap_stored']['reskin'][bone]:
                    excluded_bones.append(child)
            
            for boneObj in obj[source].data.bones:
                if boneObj.name not in excluded_bones:
                    boneObj.hide = True
            return

        bpy.context.view_layer.objects.active = obj[source]
        for bone in ccp['map_editor']['isolated']:
            if bone in obj[source].data.bones:
                obj[source].data.bones[bone].hide = ccp['map_editor']['isolated'][bone]
        
        ccp['map_editor']['isolated'] = dict()
        return

    def update_add_reskin_bone(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects
        source = ccp.source_rig_name

        if ccp.add_reskin_bone == True:
            
            if bpy.context.active_object.name != source:
                bb_settings['terminate'] = False
                ccp.add_reskin_bone = False
                return
            
            if len(bpy.context.selected_pose_bones) > 1:
                bb_settings['terminate'] = False
                ccp.add_reskin_bone = False
                return
            boneObj = bpy.context.selected_pose_bones[0]
            bone = boneObj.name
            
            if bone not in ccp['remap_stored']['rename']:
                bb_settings['terminate'] = False
                ccp.add_reskin_bone = False
                return
            
            ccp['map_editor']['active_anchor'] = bone
            return
        
        if ccp.add_reskin_bone == False:
            
            if bpy.context.active_object.name != source:
                ccp['map_editor']['active_anchor'] = ""
                return
            
            if len(bpy.context.selected_pose_bones) == 0:
                ccp['map_editor']['active_anchor'] = ""
                return

            anchor = ccp['map_editor']['active_anchor']
            reskin_bones = list()

            if ccp['remap_stored']['reskin'].get(anchor) != None:
                reskin_bones = ccp['remap_stored']['reskin'][anchor].copy()

            reskin_selected = list()
            for boneObj in bpy.context.selected_pose_bones:
                reskin_selected.append(boneObj.name)

            reskin_candidates = list()

            for bone in reskin_selected:
                
                if bone in ccp['remap_stored']['rename']:
                    continue
                
                if bone in reskin_bones:
                    continue
                if bone not in obj[source].data.bones:
                    continue
                
                reskin_candidates.append(bone)
            if len(reskin_candidates) > 0:
                
                reskin_bones.extend(reskin_candidates)
                ccp['remap_stored']['reskin'][anchor] = reskin_bones
                
                for bone in reskin_candidates:
                    obj[source].pose.bones[bone].bone_group =                        bpy.data.objects[source].pose.bone_groups[cc_reskin_group]

            ccp['map_editor']['active_anchor'] = ""

        return

    show_full_map_enabled : bpy.props.BoolProperty(
        description =            "Enable this to see a complete map for bones that will be renamed",
        default = False,
        )
    isolation_mode : bpy.props.BoolProperty(
        name = "isolation_mode",
        description =            "Choose an anchor bone and then click this and you will isolate the branch making everything else hidden.",
        default = False,
        update = update_isolation_mode
        )
    hide_mapped_bones : bpy.props.BoolProperty(
        name = "hide_mapped_bones",
        description =            "Enabling this will cause all of the mapped bones to be hidden.  This can be helpful when working with a complex rig.  "            "Simply click it again to disable it in order to view the mapped bones again.",
        default = False,
        update = update_hide_mapped_bones
        )
    add_reskin_bone : bpy.props.BoolProperty(
        name = "Add reskin bones",
        description =            "Click this while an anchor is selected and then select one or more bones to add to the reskin set and unclick "            "this to add those reskin bones to the branch.",
        default = False,
        update = update_add_reskin_bone
        )
    
    edit_mode : bpy.props.BoolProperty(
        name = "edit_mode",
        description =                "Edit maps / Isolate Anchor Branches / Hide Mapped Anchor Bones etc."                "\n\n"                "This option must be enabled to use its associated features, some of which are indicated above."                "\n\n"                "When enabled all of the bones will be selectable and you can remove maps from the source by selecting them "                "and clicking the remove (X) button.  If an anchor is selected at the time then the entire tree is removed.",
        default = False,
        update = update_edit_mode
        )
    process_volume_bones : bpy.props.BoolProperty(
        name = "Process Volume Bones",
        description =            "Export with Fitted Mesh properties\n"            "\n"            "When enabled the volume bone properties will be adjusted for SL.  If they are already meeting the "            "requirements for Second Life then this will break it.  Fortunately it makes a copy of your items before "            "operating on it so that your original is untouched.  If something goes wrong just try it again with this disabled.  "            "If your rig is facing +X there's a good chance that you need to disable this and use the rotate feature to bring "            "it back to -Y, by adding an X value of -90, for consistency.  See (Rig Tools) for easy adjustment.",
        default = True,
        )

    apply_modifiers : bpy.props.BoolProperty(
        name = "Apply Modifiers",
        description =            "Export with modifiers applied non-destructively to a copy of the mesh(s)\n"            "\n",
        default = False,
        )
    rotate_for_sl : bpy.props.BoolProperty(
        name = "Rotate for SL 90 deg cw",
        description =            "If your rig is facing -y you'll want this enabled.  If it's facing +x disable it.  If it's facing any other way "            "then use the rotate rig tool in the Rig Tools section, that tool does more than just rotate it checks sanity."            "\n",
        default = True,
        )

    apply_pose : bpy.props.BoolProperty(
        name = "Apply New Rest Post",
        description =            "Export with the current pose as the new rest pose.  This is non-destructive and uses a copy of the mesh(s).\n"            "\n",
        default = False,
        )

    preserve_animation : bpy.props.BoolProperty(
        name = "Preserve animation",
        description = "With this enabled all efforts to preserve usable animation of the converted character will be attempted. "            "This does not mean it will work, it only means that nothing else can be done to make it work, if it doesn't, "            "With additional effort you may be able to do this yourself.  This overrides the following properties - \n"            " - Connect bone links\n"            " - Bake Pose From:\n"            "      Map File\n"            "      Current Pose\n",
        default = False
        )

class CharacterConverterCheckRigs(bpy.types.Operator):
    """Watch here for messages

This button does nothing, it's to hop over a Blender bug"""

    bl_idname = "onigiri.cc_check_rigs"
    bl_label = "cc_check_rigs"

    @classmethod
    def poll(cls, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        if ccp.source_rig_name != "":
            if obj.get(ccp.source_rig_name) == None:
                bb_settings['terminate'] = True
                ccp.record_source_rig = False

                ccp.backup_source_rig_name = ccp.source_rig_name

                bb_settings['terminate'] = True
                ccp.source_rig_name = ""

                ccp.cc_check_rigs_label = "Select your rigs"
                return True

        if ccp.target_rig_name != "":
            if obj.get(ccp.target_rig_name) == None:
                bb_settings['terminate'] = True
                ccp.record_target_rig = False

                ccp.backup_target_rig_name = ccp.target_rig_name

                bb_settings['terminate'] = True
                ccp.target_rig_name = ""

                ccp.cc_check_rigs_label = "Select rigs"
                return True

        if ccp.source_rig_name == "" and ccp.target_rig_name == "":
            ccp.cc_check_rigs_label = "Select target and source"
            return True

        return True

    def execute(self, context):
        pass
        return {'FINISHED'}

class CharacterConverterExpandMapper(bpy.types.Operator):
    """Watch here for messages

This button does nothing.  It's to hop over a Blender bug"""

    bl_idname = "onigiri.enable_retargeting"
    bl_label = "Enable bone retargeting properties"

    @classmethod
    def poll(cls, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        if ccp.save_ready != "":
            if ccp.edit_mode == True:
                ccp.enable_retargeting_label = "Remove map bones"
                return {'FINISHED'}

        if ccp.source_rig_name not in obj or ccp.target_rig_name not in obj:

            ccp.backup_source_rig_name = ccp.source_rig_name

            ccp.backup_target_rig_name = ccp.target_rig_name

            bb_settings['terminate'] = True
            ccp.record_source_rig = False

            bb_settings['terminate'] = True
            ccp.source_rig_name = ""

            bb_settings['terminate'] = True
            ccp.record_target_rig = False

            bb_settings['terminate'] = True
            ccp.target_rig_name = ""

            ccp.enable_retargeting_label = ""

            if bpy.context.mode != 'OBJECT' and len(bpy.context.selected_objects) == 1:
                bpy.ops.object.mode_set(mode='OBJECT')
            bb_settings['terminate'] = True
            ccp.enable_retargeting = False
            ccp.set_rename_parent = ""
            ccp.set_reskin_children = ""
            ccp.set_rename_target = ""
            
            return False

        mode = context.mode
        if mode != 'POSE':
            ccp.enable_retargeting_label = "Must be in Pose Mode"
            return True
        if len(bpy.context.selected_pose_bones) == 0 and ccp.set_rename_parent == "":
            ccp.enable_retargeting_label = "Select a bone to rename"
            return True
        if len(bpy.context.selected_pose_bones) > 1 and ccp.set_rename_parent == "":
            
            if ccp.set_rename_parent == "":
                ccp.enable_retargeting_label = "Select only 1 bone for now"
            return True

        if len(bpy.context.selected_pose_bones) > 0 and ccp.set_rename_parent != "" and ccp.set_reskin_children == "":
            ccp.enable_retargeting_label = "Click the (Set Reskin) button"
            return True

        if ccp.set_rename_parent != "" and ccp.set_reskin_children == "":
            ccp.enable_retargeting_label = "Select 0 or more child bones"
            return True

        if ccp.set_rename_parent != "" and ccp.set_reskin_children != "" and ccp.set_rename_target != "":
            ccp.enable_retargeting_label = "Click here to accept"
            return True

        if ccp.set_rename_parent != "" and ccp.set_reskin_children != "" and ccp.set_rename_target == "":
            if len(bpy.context.selected_pose_bones) > 1:
                ccp.enable_retargeting_label = "Select only one target bone"
            
            elif len(bpy.context.selected_pose_bones) == 1:
                ccp.enable_retargeting_label = "Click the (Set Target) button"
            else:
                ccp.enable_retargeting_label = "Select a target bone"
            return True

        ccp.enable_retargeting_label = "Click the (Set Rename) button"
        return True

    def execute(self, context):
        
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        if ccp.set_rename_parent != "" and ccp.set_reskin_children != "" and ccp.set_rename_target != "":

            ccp['remap_stored']['rename'].update({ccp.set_rename_parent: ccp.set_rename_target})

            reskin_children = ccp['reskin_mapper'].to_dict()

            remap_stored = ccp['remap_stored'].to_dict()

            if len(reskin_children[ccp.set_rename_parent]) > 0:
                ccp['remap_stored']['reskin'].update({ccp.set_rename_parent: reskin_children[ccp.set_rename_parent]})

            ccp.save_ready = "Save map to file"

            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.select_all(action='DESELECT')

            obj[ccp.source_rig_name].hide_select = False
            obj[ccp.source_rig_name].select_set(True)
            bpy.context.view_layer.objects.active = obj[ccp.source_rig_name]
            bpy.ops.object.mode_set(mode='POSE')

            ccp.set_rename_parent = ""
            ccp.set_reskin_children = ""
            ccp.set_rename_target = ""
            
            ccp.last_anchor = ""

            ccp['reskin_mapper'] = dict()

            ccp.reset_mapper = ""

            return {'FINISHED'}

        return {'FINISHED'}

class CharacterConverterSetRename(bpy.types.Operator):
    """Pick bones for mapping"""
    bl_idname = "onigiri.set_rename"
    bl_label = "Set Rename"

    @classmethod
    def poll(cls, context):
        ccp = bpy.context.window_manager.cc_props
        ccc = bpy.context.window_manager.cc_containers
        obj = bpy.data.objects
        mode = context.mode

        if ccp.set_reskin_children != "":
            return False

        if mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        if len(bpy.context.selected_pose_bones) > 1:
            return False
        return True

    def execute(self, context):

        ccp = bpy.context.window_manager.cc_props
        ccc = bpy.context.window_manager.cc_containers
        obj = bpy.data.objects
        armObj = bpy.context.selected_objects[0]
        
        boneObj = bpy.context.selected_pose_bones[0]
        ccp.set_rename_parent = boneObj.name

        bpy.ops.pose.group_unassign()

        obj[armObj.name].pose.bones[boneObj.name].bone_group =            obj[armObj.name].pose.bone_groups[cc_rename_group]

        obj[armObj.name].data.bones[boneObj.name].select = False

        obj[armObj.name].data.bones[boneObj.name].hide_select = True

        if ccp.last_anchor != "" and ccp.last_anchor != ccp.set_rename_parent:
            print("moving anchor anchor from", ccp.last_anchor)

            obj[armObj.name].data.bones[ccp.last_anchor].hide_select = False

            obj[armObj.name].data.bones[ccp.last_anchor].select = True
            bpy.ops.pose.group_unassign()
            obj[armObj.name].data.bones[ccp.last_anchor].select = False

            child_list = ccp['reskin_mapper'][ccp.last_anchor]
            
            if len(child_list) > 0:
                
                ccp['reskin_mapper'].update({ccp.set_rename_parent: child_list})
            else:
                
                ccp['reskin_mapper'] = {ccp.set_rename_parent: []}

        else:
            
            ccp['reskin_mapper'] = {ccp.set_rename_parent : []}

        ccp.last_anchor = ccp.set_rename_parent

        return {'FINISHED'}

class CharacterConverterSetReskin(bpy.types.Operator):
    """Set child bones for reskin"""
    bl_idname = "onigiri.set_reskin"
    bl_label = "Set Reskin"

    @classmethod
    def poll(cls, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects
        
        if ccp.set_rename_parent == "":
            return False
        
        if ccp.set_reskin_children != "":
            return False
        return True

    def execute(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        armObj = bpy.context.selected_objects[0]

        child_list = []
        for boneObj in bpy.context.selected_pose_bones:

            child_list.append(boneObj.name)

            obj[armObj.name].pose.bones[boneObj.name].bone_group =                obj[armObj.name].pose.bone_groups[cc_reskin_group]

            obj[armObj.name].data.bones[boneObj.name].hide_select = True

        ccp['reskin_mapper'].update({ccp.set_rename_parent : child_list})

        ccp.set_reskin_children = "Remove: " + str(len(child_list))

        ccp.reset_mapper = "Reset Mapper"

        bpy.ops.pose.select_all(action = 'DESELECT')
        bpy.ops.object.mode_set(mode='OBJECT')
        obj[ccp.source_rig_name].select_set(True)
        obj[ccp.target_rig_name].select_set(True)
        obj[ccp.source_rig_name].hide_select = True
        bpy.ops.object.mode_set(mode='POSE')
        
        bpy.ops.pose.select_all(action = 'DESELECT')

        return {'FINISHED'}

class CharacterConverterSetTarget(bpy.types.Operator):
    """Choose the target bone for your set"""

    bl_idname = "onigiri.set_target"
    bl_label = "Set Target"

    @classmethod
    def poll(cls, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        if len(bpy.context.selected_objects) == 0:
            return False
        
        if bpy.context.mode != 'POSE':
            return False

        if len(bpy.context.selected_pose_bones) > 1:
            return False
        
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        
        if ccp.set_rename_parent == "" or ccp.set_reskin_children == "":
            return False
        
        if ccp.set_rename_target != "":
            return False

        return True

    def execute(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects
        armObj = obj[ccp.target_rig_name]
        
        boneObj = bpy.context.selected_pose_bones[0]
        obj[armObj.name].pose.bones[boneObj.name].bone_group =            obj[armObj.name].pose.bone_groups[cc_rename_group]
        obj[armObj.name].data.bones[boneObj.name].select = False
        ccp.set_rename_target = boneObj.name

        return {'FINISHED'}

class CharacterConverterLoadMap(bpy.types.Operator, ImportHelper):
    """Load an existing map into the mapper, it will be checked for validity and the icon will change."""

    bl_idname = "onigiri.cc_load_map"
    bl_label = "Load Map"

    filename_ext = ".bbm"

    filter_glob : bpy.props.StringProperty(
        default='*.ccm;*.bbm',
        options={'HIDDEN'}
    )

    def execute(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        map_file = self.properties.filepath

        cc_rename = {}
        cc_reskin = {}
        cc_pose = {}

        try:
            namespace = {}
            exec(open(map_file, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())

        try:
            cc_rename.update(namespace['rename'])
        except:
            print("no rename, nothing to do")
            ccp.icon_thumb = "thumb_down"
            ccp.load_map_info = "Damaged map file!"
            return {'FINISHED'}

        try:
            cc_reskin.update(namespace['reskin'])
        except:
            print("no reskin, skipping")

        activate(ccp.target_rig_name)
        for bone in obj[ccp.target_rig_name].data.bones:
            bone.hide_select = False
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action = 'SELECT')
        bpy.ops.pose.group_unassign()
        bpy.ops.pose.select_all(action = 'DESELECT')
        bpy.ops.object.mode_set(mode='OBJECT')

        activate(ccp.source_rig_name)
        for bone in obj[ccp.source_rig_name].data.bones:
            bone.hide_select = False
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action = 'SELECT')
        bpy.ops.pose.group_unassign()
        bpy.ops.pose.select_all(action = 'DESELECT')
        bpy.ops.object.mode_set(mode='OBJECT')

        if ccp.disable_map_pose == False:
            try:
                cc_pose.update(namespace['pose'])
            except:
                print("no pose, skipping")

        ccm_errors = list()
        ccm_ghosts = list()

        for sbone in cc_rename:
            
            for rbone in cc_reskin:
                if sbone in cc_reskin[rbone]:
                    
                    ccm_errors.append(rbone)

        ghost_empty = False 
        if len(ccm_errors) > 0:
            for b in ccm_errors:
                if b == "":
                    ghost_empty = True
                if b in cc_reskin:
                    ccm_ghosts.append(cc_reskin.pop(b))
                else:
                    print("Missing reskin bone:", b)

            if ghost_empty == True and len(ccm_errors) == 1:
                print("DEBUG:__INIT__::CharacterConverterLoadMap reports: ghost key is empty")
                popup("A workflow inconsistency produced an empty ghost key and was repaired", "Ghost", "INFO")
                ccp.load_map_info = "CCM Ghost Empty, see console !"
                print(
                    "A key found in the rename list was empty, this transient workflow inconsistency can",
                    "produce a repeating unique empty key that destroys prior data.  Save your work often",
                    "and to new file names until you have a finished product.")
            else:
                ccp.icon_thumb = "thumb_down"
                ccp.load_map_info = "CCM Error Repaired !"
                print("CCM Error, the following reskin bones were removed because they match a rename bone:")
                print(ccm_errors)
                print("The bones that were pointed to should be listed below:")
                print(ccm_ghosts)
                print("Re-save your map now to affect the changes and make sure to check those bones for proper mapping")
                popup("CCM reskin overlap, repaired, see console for details", "Anchor / Reskin Error", "INFO")

        temp_rename = {}
        temp_reskin = {}

        for sbone in cc_rename:
            mbone = cc_rename[sbone]
            if sbone not in obj[ccp.source_rig_name].data.bones:
            
                print("skipping non matching bone:", sbone)
                continue
            temp_rename[sbone] = cc_rename[sbone]
        
        if len(temp_rename) == 0:
            ccp.icon_thumb = "thumb_down"
            ccp.load_map_info = "No matching bones, prefix error?"
            return {'FINISHED'}
        else:
            ccp.icon_thumb = "thumb_up"

        children = list()
        for anchor in cc_reskin:
            if anchor in obj[ccp.source_rig_name].data.bones:
                for child in cc_reskin[anchor]:
                    if child in obj[ccp.source_rig_name].data.bones:
                    
                        children.append(child)
                if len(children) > 0:
                    temp_reskin[anchor] = children.copy()
                    children.clear()

        remove = {}
        for sbone in temp_rename:
            mbone = temp_rename[sbone]
            if mbone not in obj[ccp.target_rig_name].data.bones:
                
                remove[mbone] = temp_rename[sbone]
                
                print("Missing map bone in target", temp_rename[sbone])
                if 1 == 0:
                    ccp.icon_thumb = "thumb_down"
                    ccp.load_map_info = "Target rig not supported by map !"
                    
                    return {'FINISHED'}

        print("applying properties to bones from map file")
        arm = ccp.source_rig_name
        mode = bpy.context.mode
        if mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')
        bpy.data.objects[arm].select_set(True)
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action = 'DESELECT')
        for bone in temp_rename:
            if bone in bpy.data.objects[arm].data.bones:
                bpy.data.objects[arm].data.bones[bone].select = True
                add_bone_to_group(arm, bone, cc_rename_group)
                bpy.data.objects[arm].data.bones[bone].hide_select = True
                bpy.data.objects[arm].data.bones[bone].select = False
        
        for children in temp_reskin:
            for child in temp_reskin[children]:
                if child in bpy.data.objects[arm].data.bones:
                    bpy.data.objects[arm].data.bones[child].select = True
                    add_bone_to_group(arm, child, cc_reskin_group)
                    bpy.data.objects[arm].data.bones[child].hide_select = True
                    bpy.data.objects[arm].data.bones[child].select = False
        
        arm = ccp.target_rig_name
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')
        bpy.data.objects[arm].select_set(True)
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action = 'DESELECT')
        for bone in temp_rename:
            mbone = temp_rename[bone] 
            if mbone in bpy.data.objects[arm].data.bones:
                bpy.data.objects[arm].data.bones[mbone].select = True
                add_bone_to_group(arm, mbone, cc_rename_group)
                bpy.data.objects[arm].data.bones[mbone].hide_select = True
                bpy.data.objects[arm].data.bones[mbone].select = False
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')

        if len(cc_pose) > 0:
            arm = ccp.source_rig_name
            for bone in cc_pose:
                
                if bone not in bpy.data.objects[arm].data.bones:
                    continue
                
                old_rotation_mode = bpy.data.objects[arm].pose.bones[bone].rotation_mode
                bpy.data.objects[arm].pose.bones[bone].rotation_mode = 'QUATERNION'
                bpy.data.objects[arm].pose.bones[bone].matrix_basis = mathutils.Matrix(cc_pose[bone])
                bpy.data.objects[arm].pose.bones[bone].rotation_mode = old_rotation_mode

        ccp['remap_stored']['rename'] = temp_rename.copy()
        ccp['remap_stored']['reskin'] = temp_reskin.copy()

        ccp.save_ready = "Save To File"

        arm = ccp.source_rig_name
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')
        bpy.data.objects[arm].select_set(True)
        bpy.context.view_layer.objects.active = bpy.data.objects[arm]
        bpy.ops.object.mode_set(mode='POSE')

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class CharacterConverterSaveMap(bpy.types.Operator, ExportHelper):
    """Save the currently committed maps to a file"""

    bl_idname = "onigiri.cc_save_map"
    bl_label = "Save Map"

    filename_ext = ".bbm"

    filter_glob : bpy.props.StringProperty(
        default='*.bbm',
        options={'HIDDEN'}
    )

    def execute(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        formatted_maps = "# Auto generated by Onigiri - Character Converter\n\n"
        rename_maps = ""
        reskin_maps = ""

        remap_stored = ccp['remap_stored'].to_dict()

        for hash in remap_stored:
            if hash == "rename":
                rename_maps += "rename = {\n";
                for tbone in remap_stored[hash]:
                    rename_maps += "    " + '"' + tbone + '": ' + '"' + remap_stored[hash][tbone] + '"' + ",\n"
                rename_maps += "    }\n"

            elif hash == "reskin":
                reskin_maps += "reskin = {\n";
                for anchor in remap_stored[hash]:
                    reskin_maps += "    " + '"' + anchor + '": [' + "\n"
                    for reskin in remap_stored[hash][anchor]:
                        reskin_maps += "        " + '"' + reskin + '"' + ",\n"
                    reskin_maps += "        ],\n"
                reskin_maps += "    }\n"

            else:
                txt = "Internal Data Error, unknown storage type [" + hash + "]"
                popup(txt, "Internal Error 504", "ERROR")
                print(txt)
                return {'FINISHED'}

        arm = ccp.source_rig_name
        pose_map = "pose = {\n"
        for boneObj in obj[arm].pose.bones[:]:

            old_rotation_mode = boneObj.rotation_mode
            boneObj.rotation_mode = 'QUATERNION'
            matrix_basis = matrix_to_tuples(boneObj.matrix_basis.copy())
            pose_map += '    "' + boneObj.name + '": ' + str(matrix_basis) + ",\n"
            boneObj.rotation_mode = old_rotation_mode

        pose_map += "    }\n"

        formatted_maps += rename_maps + reskin_maps + pose_map

        map_file = self.properties.filepath
        output = open(map_file, 'w', encoding='UTF8')
        output.write(formatted_maps)
        output.close()
        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class CharacterConverterResetMapper(bpy.types.Operator):
    """Reset this particular map, it will not destroy your previous picks."""

    bl_idname = "onigiri.reset_mapper"
    bl_label = "Reset Mapper"

    @classmethod
    def poll(cls, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects
        return True

    def execute(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')

        if ccp.set_rename_target != "":
            
            obj[ccp.target_rig_name].select_set(True)
            bpy.context.view_layer.objects.active = obj[ccp.target_rig_name]
            bpy.ops.object.mode_set(mode='POSE')
            obj[ccp.target_rig_name].data.bones[ccp.set_rename_target].select = True
            
            bpy.ops.pose.group_unassign()
            obj[ccp.target_rig_name].data.bones[ccp.set_rename_target].hide_select = False

        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')
        
        obj[ccp.source_rig_name].hide_select = False
        obj[ccp.source_rig_name].select_set(True)
        bpy.context.view_layer.objects.active = obj[ccp.source_rig_name]
        bpy.ops.object.mode_set(mode='POSE')

        child_list = ccp['reskin_mapper'][ccp.set_rename_parent]

        obj[ccp.source_rig_name].data.bones[ccp.set_rename_parent].hide_select = False

        for bone in child_list:
            
            obj[ccp.source_rig_name].data.bones[bone].hide_select = False
            
            obj[ccp.source_rig_name].data.bones[bone].select = True

        obj[ccp.source_rig_name].data.bones[ccp.set_rename_parent].select = True
        bpy.ops.pose.group_unassign()

        bpy.ops.pose.select_all(action = 'DESELECT')

        ccp.set_rename_parent = ""
        ccp.set_reskin_children = ""
        ccp.set_rename_target = ""
        ccp.last_anchor = ""

        ccp['reskin_mapper'] = dict()

        ccp.reset_mapper = ""

        return {'FINISHED'}

class CharacterConverterHideAnchorBranch(bpy.types.Operator):
    """Hide the selected anchor branch.  Select an anchor (red) and click this."""

    bl_idname = "onigiri.hide_anchor_branch_bones"
    bl_label = "Hide anchor branch"

    @classmethod
    def poll(cls, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects
        
        if bpy.context.active_object.name != ccp.source_rig_name:
            return False
        
        if len(bpy.context.selected_pose_bones) > 1:
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        
        bone = bpy.context.selected_pose_bones[0].name
        
        if bone not in ccp['remap_stored']['rename']:
            return False
        return True

    def execute(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        bone = bpy.context.selected_pose_bones[0].name
        ccp['map_editor']['hidden'][bone] = "" 

        if bone in ccp['remap_stored']['rename']:
            obj[ccp.source_rig_name].data.bones[bone].hide = True
            if bone in ccp['remap_stored']['reskin']:
                for child in ccp['remap_stored']['reskin'][bone]:
                    obj[ccp.source_rig_name].data.bones[child].hide = True

        return {'FINISHED'}

class CharacterConverterUnhideAnchorBranch(bpy.types.Operator):
    """Click this button to remove the anchor branch set from the hidden list so that
you can see it again."""

    bl_idname = "onigiri.unhide_anchor_branch_bones"
    bl_label = "Unhide anchor branch"

    bone : bpy.props.StringProperty()

    @classmethod
    def poll(cls, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        if ccp.source_rig_name not in bpy.data.objects:
            return False

        return True

    def execute(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        obj[ccp.source_rig_name].data.bones[self.bone].hide = False
        del ccp['map_editor']['hidden'][self.bone]
        if self.bone in ccp['remap_stored']['reskin']:
            for child in ccp['remap_stored']['reskin'][self.bone]:
                obj[ccp.source_rig_name].data.bones[child].hide = False

        return {'FINISHED'}

class CharacterConverterEditMap(bpy.types.Operator):
    """Remove the selected bones from the map"""

    bl_idname = "onigiri.remove_map_bone"
    bl_label = "Remove Bone"

    @classmethod
    def poll(cls, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects
        if ccp.edit_mode != True:
            return False
        
        source = ccp.source_rig_name
        if bpy.context.active_object.name != source:
            return False
        
        if len(bpy.context.selected_pose_bones) == 0:
            return False

        return True

    def execute(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects
        source = ccp.source_rig_name

        try:
            bpy.app.handlers.depsgraph_update_post.remove(edit.auto_weight_on_select)
        except:
            pass

        for boneObj in bpy.context.selected_pose_bones:
            if obj[source].data.bones[boneObj.name].hide == True:
                obj[source].data.bones[boneObj.name].select = False

        boneObjs = bpy.context.selected_pose_bones
        if len(boneObjs) < 1:
            ccp.enable_retargeting_lable = "Select at least one bone"
            print("no bones selected")
            return {'FINISHED'}

        selected_bones = list()
        for bone in boneObjs:
            selected_bones.append(bone.name)

        bpy.ops.pose.select_all(action = 'DESELECT')

        rename = ccp['remap_stored']['rename'].to_dict()
        reskin = ccp['remap_stored']['reskin'].to_dict()

        source_bones = list()
        target_bones = list()

        for bone in selected_bones:
            if bone in rename:
                source_bones.append(bone)
                target_bones.append(rename[bone])
                
                if bone in reskin:
                    children = reskin[bone]
                    for child in children:
                        source_bones.append(child)
                    del reskin[bone]
                del rename[bone]
            
            for parent in reskin:
                children = reskin[parent]
                if bone in children:

                    print("found rename bone in reskin children", bone)

                    source_bones.append(bone)
                    children.remove(bone)
                    reskin[parent] = children

                    break

        activate(ccp.source_rig_name)

        for bone in source_bones:
            if bone in obj[ccp.source_rig_name].data.bones:
                obj[ccp.source_rig_name].data.bones[bone].select = True
        bpy.ops.pose.group_unassign()
        bpy.ops.pose.select_all(action = 'DESELECT')

        activate(ccp.target_rig_name)

        for bone in target_bones:
            if bone in obj[ccp.target_rig_name].data.bones:
                obj[ccp.target_rig_name].data.bones[bone].select = True
        bpy.ops.pose.group_unassign()
        bpy.ops.pose.select_all(action = 'DESELECT')

        activate(ccp.source_rig_name)

        print("target_bones", target_bones)

        ccp['remap_stored']['rename'] = rename
        ccp['remap_stored']['reskin'] = reskin

        try:
            bpy.app.handlers.depsgraph_update_post.append(edit.auto_weight_on_select)
        except:
            pass

        return {'FINISHED'}

class CharacterConverterResetBone(bpy.types.Operator):
    """Reset this specific bone"""

    bl_idname = "onigiri.reset_bone"
    bl_label = "Reset Bone"

    bone : bpy.props.StringProperty(name="bone",default="")

    @classmethod
    def poll(cls, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        return True

    def execute(self, context):
        ccp = bpy.context.window_manager.cc_props
        obj = bpy.data.objects

        remap_stored = ccp['remap_stored'].to_dict()

        mbone = remap_stored['rename'][self.bone]

        if self.bone in ccp['remap_stored']['reskin'].keys():
            del ccp['remap_stored']['reskin'][self.bone]
        
        del ccp['remap_stored']['rename'][self.bone]

        if bpy.context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')
        obj[ccp.target_rig_name].hide_select = False 
        obj[ccp.target_rig_name].select_set(True)
        bpy.context.view_layer.objects.active = obj[ccp.target_rig_name] 
        bpy.ops.object.mode_set(mode='POSE')

        obj[ccp.target_rig_name].data.bones[mbone].hide_select = False
        
        bpy.ops.pose.select_all(action = 'DESELECT')
        obj[ccp.target_rig_name].data.bones[mbone].select = True
        
        bpy.ops.pose.group_unassign()

        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')

        obj[ccp.source_rig_name].hide_select = False
        obj[ccp.source_rig_name].select_set(True)
        bpy.context.view_layer.objects.active = obj[ccp.source_rig_name]
        bpy.ops.object.mode_set(mode='POSE')
        obj[ccp.source_rig_name].data.bones[self.bone].hide_select = False
        
        bpy.ops.pose.select_all(action = 'DESELECT')

        obj[ccp.source_rig_name].data.bones[self.bone].select = True
        
        if self.bone in remap_stored['reskin'].keys():
            map = remap_stored['reskin']
            child_list = map[self.bone]
            for bone in child_list:
                obj[ccp.source_rig_name].data.bones[bone].hide_select = False
                obj[ccp.source_rig_name].data.bones[bone].select = True
        
        bpy.ops.pose.group_unassign()

        bpy.ops.pose.select_all(action = 'DESELECT')

        ccp.set_rename_parent = ""
        ccp.set_reskin_children = ""
        ccp.set_rename_target = ""
        
        ccp.last_anchor = ""

        ccp['reskin_mapper'] = dict()

        if len(ccp['remap_stored']['rename']) == 0:
            ccp.save_ready = ""

        ccp.reset_mapper = ""

        return {'FINISHED'}

class CharacterConverterContainers(bpy.types.PropertyGroup):

    name : bpy.props.StringProperty(name="container name", default="empty")
    value : bpy.props.BoolProperty(name="container value", default=False)

class CharacterConverterMap(bpy.types.Operator, ImportHelper):
    """Load a map file for Character Converter"""

    bl_idname = "onigiri.load_character_converter_map"
    bl_label = "Load CC Map"

    @classmethod
    def poll(cls, context):
        pass
        return True

    filename_ext = ".bbm"
    filter_glob : bpy.props.StringProperty(
        default='*.ccm;*bbm',
        options={'HIDDEN'}
    )

    def execute(self, context):
        bpy.context.window_manager.cc_props.cc_map_filename = self.properties.filepath

        return {'FINISHED'}

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriMeshProperties(bpy.types.PropertyGroup):

    project_rig : bpy.props.BoolProperty(
        name = "",
        description =            "With custom rigs, as is the case with almost every conversion, you'll want the projection of "            "a full rig in order to determine joint locations when uploading with (Joint Postitions).  You "            "probably always want this enabled in this panel.  There's a similar feature in the (Export Mesh) "            "area that does the same thing, and this toggle is actually a proxy to it but they can be set "            "independantly, so keep that in mind when you're over there.  You probably don't need this switch "            "when processing devkit material",
        default = False,
        )

    def update_blank(self, context):
        self["blank"] = False
    blank : bpy.props.BoolProperty(default = False, update = update_blank)

    edit_mesh_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description = "Some tools to smooth normals between objects and split parts so that there's no seam",
        default = False,
        )
    smooth_normals_precision : bpy.props.IntProperty(
        name = "",
        description =            "Precision (rounding)"            "\n\n"            "This is a simple conversion by rounding the input location data to determine the relative distance between "            "vertex locations.  This is how it's determined if a vertex is close enough to another one to average normals "            "between them.",
        min=1,
        default = 6,
        )
    smooth_normals_angle : bpy.props.FloatProperty(
        name = "",
        description =            "Some angles you may want to preserve, like hard edges at 45 degrees.  This will preserve those normal angles that "            "fall outside the tolerance range in degrees",
        default = 30.0,
        )
    smooth_normals_selected : bpy.props.BoolProperty(
        name = "",
        description = "If enabled the smoothing will be applied only to the selected vertices",
        default = False,
        )

    def update_smooth_normals_simple(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_mesh = bpy.context.scene.bb_mesh
        if bb_mesh.smooth_normals_simple == True:
            bb_settings['terminate'] = True
            bb_mesh.smooth_normals_advanced = False
    def update_smooth_normals_advanced(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_mesh = bpy.context.scene.bb_mesh
        if bb_mesh.smooth_normals_simple == True:
            bb_settings['terminate'] = True
            bb_mesh.smooth_normals_simple = False

    smooth_normals_simple : bpy.props.BoolProperty(
        name = "",
        description = "A simple face average",
        default = False,
        update = update_smooth_normals_simple
        )
    smooth_normals_advanced : bpy.props.BoolProperty(
        name = "",
        description = "If enabled the options you set will be used with regard to precision and selection",
        default = True,
        update = update_smooth_normals_advanced
        )

    def update_pose_data_safe(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        if bb_mesh.use_safe_settings == True:
            bb_mesh['use_rig_data'] = True
            bb_mesh['use_bind_data'] = False
            
            bb_mesh['use_sl_compatible_data'] = False
            bb_mesh['use_app_compatible_data'] = False
    def update_pose_data_rig(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_mesh = bpy.context.scene.bb_mesh
        if bb_mesh.use_rig_data == True:
            bb_settings['terminate'] = True
            bb_mesh.use_bind_data = False
            
            bb_mesh['use_sl_compatible_data'] = False
            bb_mesh['use_app_compatible_data'] = False
        if bb_mesh.use_rig_data == False:
            bb_settings['terminate'] = True
            bb_mesh.use_rig_data = True
        return
    def update_pose_data_bind(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_mesh = bpy.context.scene.bb_mesh
        if bb_mesh.use_bind_data == True:
            bb_settings['terminate'] = True
            bb_mesh.use_rig_data = False
            
            bb_mesh['use_sl_compatible_data'] = False
            bb_mesh['use_app_compatible_data'] = False
        if bb_mesh.use_bind_data == False:
            bb_settings['terminate'] = True
            bb_mesh.use_rig_data = True
        return
    def update_pose_data_sl_compatible(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_mesh = bpy.context.scene.bb_mesh
        
        if bb_mesh.use_sl_compatible_data == True:
            bb_settings['terminate'] = True
            bb_mesh.use_rig_data = False
            bb_settings['terminate'] = True
            bb_mesh.use_bind_data = False
            bb_mesh['use_app_compatible_data'] = False
        
        if bb_mesh.use_sl_compatible_data == False:
            bb_settings['terminate'] = True
            bb_mesh.use_rig_data = True
        return
    
    def update_pose_data_app_compatible(self, context):
        if bb_mesh.use_app_compatible_data == True:
            bb_mesh['use_rig_data'] = False
            bb_mesh['use_bind_data'] = False
            bb_mesh['use_app_compatible_data'] = False
            
        if bb_mesh.use_app_compatible_data == False:
            bb_settings['terminate'] = True
            bb_mesh.use_rig_data = True
        return

    pose_export_menu_enabled : bpy.props.BoolProperty(
        description =
        "Click to expand more specific export options, including bind pose, rig and Avastar."        "You are cautioned not to use these options unless dealing with an existing dev kit.  "        "If you're starting a new project use the Second Life Safe option",
        default = False,
        )

    use_universal_data : bpy.props.BoolProperty(
        description = ""            "This overrides everything and should be used predominantly.  Unfortunately there are some kit types that cannot "            "benefit from this tool.  DAE sourced material aught to use the (Bind Pose) option and some rigs like Tonic and possibly "            "male rig derived kits may be able to benefit from (Use Avastar Data).  All of the exporters are now able to generate a "            "DAE/Collada file that is compatible with other applications.",
        default = False,
        
        )

    use_safe_settings : bpy.props.BoolProperty(
        description = ""            "Safe settings for rig pose"            "\n"            "This is the same as (Use Rig Data), it's a way to internally set default values that are known to work properly.  If you "            "want to move away from the craziness and find a solid and understandable way to generate mesh characters and their products "            "then this is the way to go.  This currently enables offsets for position and rotation so that you can have a normal bind pose "            "and be able to use and distribute your item across 3d applications to widen the creator pool for your product (devkit).",
        
        default = False,
        
        update = update_pose_data_safe
        )

    use_rig_data : bpy.props.BoolProperty(
        description = ""            "Use Rig Data (Onigiri / Avastar) "            "\n"            "Use with Converted Characters, Animesh and normal DAE.  This is your (go to) export option."            "\n"            "If you have an altered bind pose with an Avastar rig then try the Avatar Pose.",
        default = True,
        update = update_pose_data_rig
        )
    use_bind_data : bpy.props.BoolProperty(
        description = ""            "Use Bind Data"            "\n\n"            "If you imported a dae file, possibly one identified as a devkit, then it's also assumed that you enabled (Keep Bind Info) "            "which is required for this feature to work.  If you did not include that option then this feature cannot be used with your "            "mesh.  If you are starting new and imported a mesh, possibly even skinned, just to have a starting point to generate a new "            "character or to use one as a reference then you'll want to use the export option (Use Rig Data) from now on and enable all "            "calculate options for volume, location, rotation and scale for best versatility.",
        default = False,
        update = update_pose_data_bind
        )

    use_sl_compatible_data : bpy.props.BoolProperty(
        name = "",
        description =            "Export for SL"            "\n\n"            "If you were able to import your devkit as dae file, and if that dae file is actually functional in SL, then this will "            "produce a perfect result.  This is only as good as the kit you have, a lot of kits are broken so don't blame Onigiri "            "for that other tool's problems, please.",
        default = False,
        update = update_pose_data_sl_compatible
        )
    use_app_compatible_data : bpy.props.BoolProperty(
        name = "",
        description =            "Export for other applications"            "\n\n"            "Many devkits have incorrect data as a result of the exporter that was used to produce the dae files, as well as the "            "joint configurations in their corresponding Blender kits.  This exporter option will allow you to export the correct "            "data for use with other 3d applications.  This type of export can also be used in Second Life."            "\n\n"            "If you're a devkit creator (Mesh Body Maker) and you've used Onigiri for your creations you don't need a specific "            "export.  Just hit the (Reset All) button and that's the safe state to export with."            "\n\n"            "If you're a devkit creator and if you didn't start your project using Onigiri there may be a snag.  If you're going "            "to re-work a kit to fix something but you're already established and items have been made for your kit be careful... "            "the story you're about to hear is true, the names have been changed to protect the guilty... If your stable item was "
            "derived from AvaBurp and you uploaded with joint positions you're in a pickle, those joint positions are wrong but you're "            "stuck now so use our (Use SL Data) export switch, this preserves the AvaBurp errors so that you get what you have always "            "gotten, broken but expected behavior.",

        default = False,
        update = update_pose_data_app_compatible
        )

    mesh_export_text : bpy.props.StringProperty(
        name = "The type of mesh that was last exported",
        default = "Look here for messages",
        )
    process_volume_bones : bpy.props.BoolProperty(
        name = "Process SL specific bone properties",
        description = ""            "Sometimes this is not what you want.  If your rig is facing the X direction then there's a good chance that it "            "contains bind information that you don't want to change. If you're unsure just uncheck it and give it a try.  If "            "your resulting mesh looks like a flattened mosquito in Second Life then this feature needs to be enabled. ",
        default = True,
        )
    volume_bone_location : bpy.props.BoolProperty(
        name = "",
        description = ""            "This should be disabled for mapped mesh when you don't want the volume bones relocated."            "\n\n"            "Volume bones have special properties of location, rotation and scale.  With custom mapped mesh the location and "            "rotation values should not be included and, instead, taken from the rig.  The scale option should be enabled.",
        default = True,
        )
    volume_bone_rotation : bpy.props.BoolProperty(
        name = "",
        description = ""            "This should be disabled for mapped mesh when you don't want the volume bones relocated."            "\n\n"            "Volume bones have special properties of location, rotation and scale.  With custom mapped mesh the location and "            "rotation values should not be included and, instead, taken from the rig.  The scale option should be enabled.",
        default = True,
        )
    volume_bone_scale : bpy.props.BoolProperty(
        name = "",
        description = ""            "This should be ENABLED for mapped mesh if using volume bones in order to prevent deformations."            "\n\n"            "Volume bones have special properties of location, rotation and scale.  With custom mapped mesh the location and "            "rotation values should not be included and, instead, taken from the rig.  The scale option should be enabled",
        default = True,
        )
    rotate_for_sl : bpy.props.BoolProperty(
        name = "X facing for SL",
        description = ""            "If your rig is facing -Y right now, this is what you want.  You won't see anything happen but it's required.",
        default = True,
        )
    
    def update_choose_base_rig(self, context):
        bpy.context.scene.bb_mesh.property_unset("choose_base_rig")
    choose_base_rig : bpy.props.BoolProperty(
        name = "", 
        description =            "- Calculate Offsets -"
            "\n\n"            "This button is informative only"            "\n\n"            "You shouldn't have to alter these and mostly they are not implemented as an option except for specific conditions. "            "They are placed here to test individual transform offsets for bind poses with various rig classes and types.  What it "            "does is enable or disable bind pose data with respect to the current rig associated with the mesh you're about to export "            "for that particular bone property or transform.  Internally these are usually set to (enabled) depending on the situation.",
        default = False,
        update = update_choose_base_rig
        )

    base_rig_items = [
        ("default", "Default", '', 0),
        ("neutral", "Neutral", '', 1),
        ("male_default", "Male Default", '', 2),
        ("male_neutral", "Male Neutral", '', 0),
        ]
    base_rig : bpy.props.EnumProperty(
        name = "", 
        description = "Choose a base rig for your bind pose calculation",
        items = base_rig_items,
        )
    
    def update_export_full_rig(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        if bb_mesh.export_full_rig == True:
            bb_mesh.export_path_to_pelvis = False
        else:
            return
    def update_export_path_to_pelvis(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        if bb_mesh.export_path_to_pelvis == True:
            bb_mesh.export_full_rig = False
        else:
            return
    export_full_rig : bpy.props.BoolProperty(
        name = "",
        description =            "Export Full Rig"            "\n\n"            "Exporting a full rig will prevent your mesh from being weight driven in Second Life, the option will not be available."            "This tool is to help deliver your complete kit to another platform with all bones included, a full rig, for better "            "versatility and manipulation.",
        default = False,
        update = update_export_full_rig
        )
    export_path_to_pelvis : bpy.props.BoolProperty(
        name = "",
        description =            "Export path to pelvis (1)"            "\n\n"            "This option will tell the exporter to include all bones that are missing on the way from an influencing bone to the pelvis.  "            "I put this in to help generate a mesh deformer as an alternative to the animation/pose deformer.  If you find that there are too "            "many bones in your mesh as a result of using this you will have to either use a mesh deformer found under (Mesh Tools),  split up "            "your mesh into multiple parts or use a corrective pose (deformer) in the animation panel.",
        default = True,
        update = update_export_path_to_pelvis
        )

    use_offset_volume : bpy.props.BoolProperty(
        description = "Calculate Volume Bone Offsets"            "\n\n"            "This is a normal feature that should be available for Second Life but it will not work with Avastar rigs.  "            "If you are committed to using Onigiri to generate your character, bind pose and kit, turn this feature on "            "to get the most flexibility without future glitches.  If you are converting from an Avastar rig to a Onigiri rig "            "leave this feature off unless you plan to release it as a new character/avatar."            "\n\n"            "What does it do?"            "\n"            "It calculates a difference from when you generated your rig to what you did with it before binding the "            "character mesh to the rig.  It allows for those changes to be incorporated into your avatar shape in SL, effectively like sliders "            "but without the slider confusion.  This is specifically for volume bones since they are treated a bit differently than the "            "typical deform bones but it allows you to manipulate those bones just as you would the normal deform bones and get the results "            "that you expect.  It's safe to keep this off in any case.",
        default = False,
        )
    
    use_offset_location : bpy.props.BoolProperty(
        description = "Calculate location offsets"            "\n\n"            "This calculates any changes in location to bones on the rig used to export the mesh.",
        default = False,
        )
    
    use_offset_rotation : bpy.props.BoolProperty(
        description = "Calculate rotation offsets"            "\n\n"            "This calculates any changes in rotations to bones on the rig used to export the mesh.",
        default = False,
        )
    
    use_offset_scale : bpy.props.BoolProperty(
        description = "Calculate scale offsets"            "\n\n"            "This calculates scale directly from bones on the rig used to export the mesh.  "            "This is how the real world does it but Blender doesn't export this property and, at the time of this writing, we're "            "unsure if bone scale can even be used as a reference but the option is here in case Blender improves in the future.  "            "It's very safe to leave this off, it's very NOT safe to turn it on.",
       default = False,
        )
    guess_offset_scale : bpy.props.BoolProperty(
        description = "Guess and then calculate scale offsets"            "\n\n"            "This will attempt to guess the applied scale but it can fail if you have a custom bind pose.  The best thing to do is "            "try to revert back to the original size, apply your scales there, and then scale your rig up but do not apply that scale.  "            "That is, of course, if you actually wanted your avatar to be a different default size in-world.",
        default = False,
        )
    scale_factor : bpy.props.FloatVectorProperty(
        name = "- internal -",
        description = "float property for the original rig's scale to be applied to the dae file",
        default = (1.0,1.0,1.0),
        subtype = 'XYZ'
        )

    fix_broken_bones : bpy.props.BoolProperty(
        description = "Fix use_deform property"            "\n\n"            "Blender bones have a global setting that tells the exporter if they have some influence on their weighted mesh.  This setting "            "is wrong on some kits produced using Avastar an can benefit from the use of this setting so keep this enabled to fix that.  If "            "your rig is not SL compliant this could break it.",
       default = False,
        )
    remove_empty_groups : bpy.props.BoolProperty(
        name = "",
        description = "Remove empty groups"            "\n\n"            "Pre-processing to remove empty weight groups.  The default behavior is to remove only groups that have no mirror counterpart.  "            "This test can only be specific to Second Life so if your mesh is not intended for SL then you may encounter unexpected results "            "if you enable (preserve counterparts)",
       default = True,
        )
    preserve_empty_counterparts : bpy.props.BoolProperty(
        name = "",
        description =            "Preserve Empty Counterparts"            "\n\n"            "If you enabled (Remove Empty Groups) then you can utilize this (on/enabled) to preserve the mirrored group counterparts that have "            "no data just yet thus preventing them from being included in the pruning.",
       default = True,
        )

    apply_scale : bpy.props.BoolProperty(
        name = "Apply scale before export",
        description = ""            "This applies the scale to your items to be exported before it saves"            "\n\n"            "This is usually want you want, it's permanent, save save save!",
        default = False,
        )
    
    apply_rotation : bpy.props.BoolProperty(
        name = "Apply rotation before export",
        description = ""            "This applies the rotation to your items to be exported before it saves"            "\n\n"            "This is usually want you want, it's permanent, save save save!",
        default = True,
        )
    apply_location : bpy.props.BoolProperty(
        name = "Apply location before export",
        description = ""            "This applies the location to your items to be exported before it saves"            "\n\n"            "This is usually want you want, it's permanent, save save save!",
        default = False,
        )
    export_advanced : bpy.props.BoolProperty(
        description = "Show advanced dae (collada) export features",
        default = False,
        )
    export_apply_modifiers : bpy.props.BoolProperty(
        name = "DAE / Collada export option",
        description = ""            "This is a dae export option, it will not effect you Blender items but it will freeze your posed mesh, "            "if that's what you want, inside the DAE file, which will show up in SL or other apps.",
        default = False,
        )
    
    export_apply_modifiers : bpy.props.BoolProperty(default=False)
    export_selected : bpy.props.BoolProperty(default=True)
    export_include_children : bpy.props.BoolProperty(default=False)
    export_include_armatures : bpy.props.BoolProperty(default=True)
    export_include_shapekeys : bpy.props.BoolProperty(default=False)
    export_include_animations : bpy.props.BoolProperty(default=False)
    export_deform_bones_only : bpy.props.BoolProperty(default=True)
    export_triangulate : bpy.props.BoolProperty(default=False)
    export_use_object_instantiation : bpy.props.BoolProperty(default=False)
    export_use_blender_profile : bpy.props.BoolProperty(default=False)
    export_sort_by_name : bpy.props.BoolProperty(default=True)
    export_open_sim : bpy.props.BoolProperty(default=True)

    def update_export_reset(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_mesh = bpy.context.scene.bb_mesh
        if bb_mesh.export_reset == True:
            for export_option in bb_settings['dae_export_options']:
                bpy.context.scene.bb_mesh.property_unset(export_option)
        bb_settings['terminate'] = True
        bb_mesh.export_reset = False
        return

    export_reset : bpy.props.BoolProperty(
        description = "Use this to reset your buttons to Second Life and Opensim compatible options",
        default=False,
        update=update_export_reset
        )

class OnigiriDevkitProperties(bpy.types.PropertyGroup):

    def update_preset(context):
        armObj = utils.has_armature()
        
        preset = devkit.get_properties()
        
        if armObj == False:
            print("No armature found, updating preset for defaults...")
            for prop in preset:
                
                devkit.defaults['onigiri'][prop] = preset[prop]
        else:
            if armObj.get('bb_devkit_preset') == None:
                print("Associated armature contains no preset, applying...")
            else:
                print("Armature preset updating...")
            armObj['bb_devkit_preset'] = preset.copy()

        return True
    def update_preset_trigger(self, context):
        
        self.update_preset()
        return

    def update_blank(self, context):
        self["blank"] = False
    blank : bpy.props.BoolProperty(
        default = False,
        update = update_blank
        )

    def update_use_rig_data(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        use_rig_data = getattr(self, "use_rig_data")
        if use_rig_data == True:
            self["use_bind_data"] = False
            self["use_sl_compatible_data"] = False
            self["use_app_compatible_data"] = False
        else:
            self["use_rig_data"] = True
        bb_mesh["use_rig_data"] = getattr(self, "use_rig_data")
        bb_mesh["use_bind_data"] = getattr(self, "use_bind_data")
        
        self.update_preset()

    def update_use_bind_data(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        use_bind_data = getattr(self, "use_bind_data")
        if use_bind_data == True:
            self["use_rig_data"] = False
            self["use_sl_compatible_data"] = False
            self["use_app_compatible_data"] = False
        else:
            self["use_rig_data"] = True
        bb_mesh["use_rig_data"] = getattr(self, "use_rig_data")
        bb_mesh["use_bind_data"] = getattr(self, "use_bind_data")
        self.update_preset()

    def update_use_app_compatible_data(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        use_app_compatible_data = getattr(self, "use_app_compatible_data")
        if use_app_compatible_data == True:
            self["use_rig_data"] = False
            self["use_bind_data"] = False
            self["use_sl_compatible_data"] = False
            
        else:
            self["use_rig_data"] = True
        self.update_preset()
    def update_use_sl_compatible_data(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        use_sl_compatible_data = getattr(self, "use_sl_compatible_data")
        if use_sl_compatible_data == True:
            self["use_rig_data"] = False
            self["use_bind_data"] = False
            self["use_app_compatible_data"] = False
        else:
            self["use_rig_data"] = True
        self.update_preset()

    use_rig_data : bpy.props.BoolProperty(
        description = ""            "Use Rig Data (Onigiri / Avastar) "            "\n"            "Use with Converted Characters, Animesh and normal DAE.  This is your (go to) export option."            "\n"            "If you have an altered bind pose with an Avastar rig then try the Avatar Pose.",
        default = True,
        update = update_use_rig_data
        )
    use_bind_data : bpy.props.BoolProperty(
        description = ""            "Use Bind Data"            "\n\n"            "If you imported a dae file, possibly one identified as a devkit, then it's also assumed that you enabled (Keep Bind Info) "            "which is required for this feature to work.  If you did not include that option then this feature cannot be used with your "            "mesh.  If you are starting new and imported a mesh, possibly even skinned, just to have a starting point to generate a new "            "character or to use one as a reference then you'll want to use the export option (Use Rig Data) from now on and enable all "            "calculate options for volume, location, rotation and scale for best versatility.",
        default = False,
        update = update_use_bind_data
        )

    use_sl_compatible_data : bpy.props.BoolProperty(
        name = "",
        description =            "Export for SL"            "\n\n"            "If you were able to import your devkit as dae file, and if that dae file is actually functional in SL, then this will "            "produce a perfect result.  This is only as good as the kit you have, a lot of kits are broken so don't blame Onigiri "            "for that other tool's problems, please.",
        default = False,
        update = update_use_sl_compatible_data
        )
    use_app_compatible_data : bpy.props.BoolProperty(
        name = "",
        description =            "Export for other applications"            "\n\n"            "This feature is the default for devkit material because it produces a compatible DAE file that you can often times use "            "with other 3d applcations.  In addition you can convert a devkit produced using the Avastar tool into a compatible set "            "for use with other 3d applications, something that Avastar was not capable of at the time of this writing - 1/3/2022",
        default = False,
        update = update_use_app_compatible_data
        )

    def update_rotate_for_sl(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        bb_mesh["rotate_for_sl"] = getattr(self, "rotate_for_sl")
        self.update_preset()
    rotate_for_sl : bpy.props.BoolProperty(
        name = "X facing for SL",
        description = ""            "If your rig is facing -Y right now, this is what you want.  You won't see anything happen but it's required.",
        default = True,
        update = update_rotate_for_sl
        )

    def update_remove_empty_groups(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        bb_mesh["remove_empty_groups"] = getattr(self, "remove_empty_groups")
        self.update_preset()
    remove_empty_groups : bpy.props.BoolProperty(
        name = "",
        description = "Remove empty groups"            "\n\n"            "Pre-processing to remove empty weight groups.  The default behavior is to remove only groups that have no mirror counterpart.  "            "This test can only be specific to Second Life so if your mesh is not intended for SL then you may encounter unexpected results "            "if you enable (preserve counterparts)",
        default = True,
        update = update_remove_empty_groups
        )
    preserve_empty_counterparts : bpy.props.BoolProperty(
        name = "",
        description =            "Preserve Empty Counterparts"            "\n\n"            "If you enabled (Remove Empty Groups) then you can utilize this (on/enabled) to preserve the mirrored group counterparts that have "            "no data just yet thus preventing them from being included in the pruning.",
        default = True,
       )

    def update_limit_groups(self, context):
        self["limit_groups"] = False
        
        self.update_preset()

    limit_groups : bpy.props.BoolProperty(
        name = "",
        description =            "This feature is disabled and no longer needed"            "\n\n"            "Pre-processing to limit weight groups per vertex.  This is always assumed to be 4 for Second Life so if the targetis otherwise "            "then disable this and use the manualy tool found in (Skinning / Weights).  Note that this is applied after (Remove Empty Groups) "            "since this is the logical order, the reverse would produce unexpected results, so if you are doing this manually do so in this order",
        default = False,
        update = update_limit_groups
        )

    def update_export_copies(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        self.update_preset()
    export_copies : bpy.props.BoolProperty(
        name = "",
        description =            "Export copies instead of originals"            "\n\n"            "This will duplicate the selected mesh and perform any indicated cleanup options on those copies instead of your original mesh.  "            "This is now the default in order to preserve your existing work.  Techically nothing wrong should happen to your mesh, just "            "some logical cleanup, if you disable this feature, but you may be in the middle of a testing work-flow and, for instance, "            "want to preserve any empty vertex groups.  You can disable this to test the facility to make sure it's doing what it is "            "supposed to do.  If the export process fails with an unhandled exception then you will be left with junk in your scene which "            "you aught to try to find and remove",
        default = True,
        update = update_export_copies
        )

    def update_apply_rig_scale(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        self.update_preset()

    apply_rig_scale : bpy.props.BoolProperty(
        name = "",
        description = "Apply rig scale"            "\n\n"            "These things aught to be done by the user but many creators have been following a broken hand-holding process for so long that it has "            "become a (thing) that may have introduced more disfuntional methods.  It's here to do the job and do it permanently, not just on export.  "            "This will modify your rig and if you did the right thing you can expect it to be fine.  Unfortunately any number of combinations of "            "settings in this export UI can introduce confusion if you didn't process your set correctly.  Always make sure to apply transforms beforehand",
        default = True,
        update = update_apply_rig_scale
        )

    def update_apply_scale(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        bb_mesh["apply_scale"] = getattr(self, "apply_scale")
        self.update_preset()
    apply_scale : bpy.props.BoolProperty(
        name = "Apply scale before export",
        description = ""            "This applies the scale to your items to be exported before it saves"            "\n\n"            "This is usually want you want, it's permanent, save save save!",
        default = False,
        update = update_apply_scale
        )
    def update_apply_rotation(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        bb_mesh["apply_rotation"] = getattr(self, "apply_rotation")
        self.update_preset()
    
    apply_rotation : bpy.props.BoolProperty(
        name = "Apply rotation before export",
        description = ""            "This applies the rotation to your items to be exported before it saves"            "\n\n"            "This is usually want you want, it's permanent, save save save!",
        default = True,
        update = update_apply_rotation
        )
    def update_apply_location(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        bb_mesh["apply_location"] = getattr(self, "apply_location")
        self.update_preset()
    apply_location : bpy.props.BoolProperty(
        name = "Apply location before export",
        description = ""            "This applies the location to your items to be exported before it saves"            "\n\n"            "This is usually want you want, it's permanent, save save save!",
        default = False,
        update = update_apply_location
        )

    use_bind_pose : bpy.props.BoolProperty(
        name = "",
        description = ""            "Retain the shape of your character in SL without using joint positions"            "\n\n"            "As stated, you retain the shape of your avatar appearance without the need to upload with joint positions.  "            "If your avatar is not in a common T pose then this is probably what you want, for humanoid characters.  "            "For those characters that required custom joint positions, for instance very tiny or large, you'll be "            "wanting to upload those with joint positions.",
        default = False,
        )

    def update_use_offset(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        bb_mesh["use_offset_location"] = getattr(self, "use_offset_location")
        bb_mesh["use_offset_rotation"] = getattr(self, "use_offset_rotation")
        bb_mesh["use_offset_scale"] = getattr(self, "use_offset_scale")
        self.update_preset()

    use_offset_location : bpy.props.BoolProperty(
        description = "Calculate location offsets"            "\n\n"            "This preserves the difference between the expected zero (default) pose with respect to the existing pose.  "            "This feature allows you to have a custom bind pose, although not supported by Second Life, and will translate "            "correctly to other 3d applications.  When in doubt turn this off.",
        default = False,
        update = update_use_offset
        )
    use_offset_rotation : bpy.props.BoolProperty(
        description = "Calculate rotation offsets"            "\n\n"            "This allows you to export a custom bind pose, for instance an (A) pose, while still maintaining compatibility "            "with Second Life's default rig.  This only works with rotations, if you have custom bone positions (location) "            "you can keep your bind pose for use with other applications by choosing this feature as well, Second Life does not "            "directly support this but.",
        default = False,
        update = update_use_offset
        )
    use_offset_scale : bpy.props.BoolProperty(
        description = "Calculate scale offsets"            "\n\n"            "This calculates scale directly from bones on the rig used to export the mesh.  "            "This is how the real world does it but Blender doesn't export this property and, at the time of this writing, we're "            "unsure if bone scale can even be used as a reference but the option is here in case Blender improves in the future.  "            "It's very safe to leave this off, it's very NOT safe to turn it on.",
        default = False,
        update = update_use_offset
        )
    def update_export_full_rig(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        bb_mesh["export_full_rig"] = getattr(self, "export_full_rig")
        if self.export_full_rig == True:
            self["export_path_to_pelvis"] = False
        self.update_preset()
    export_full_rig : bpy.props.BoolProperty(
        name = "",
        description =            "Export Full Rig"            "\n\n"            "Exporting a full rig will prevent your mesh from being weight driven in Second Life, the option will not be available."            "This tool is to help deliver your complete kit to another platform with all bones included, a full rig, for better "            "versatility and manipulation.",
        default = False,
        update = update_export_full_rig
        )
    def update_export_path_to_pelvis(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        bb_mesh["export_path_to_pelvis"] = getattr(self, "export_path_to_pelvis")
        if self.export_path_to_pelvis == True:
            self["export_full_rig"] = False
        self.update_preset()
    export_path_to_pelvis : bpy.props.BoolProperty(
        name = "",
        description =            "Export path to pelvis (2)"            "\n\n"            "This option will tell the exporter to include all bones that are missing on the way from an influencing bone to the pelvis.  "            "I put this in to help generate a mesh deformer as an alternative to the animation/pose deformer.  If you find that there are too "            "many bones in your mesh as a result of using this you will have to either use a mesh deformer found under (Mesh Tools),  split up "            "your mesh into multiple parts or use a corrective pose (deformer) in the animation panel.",
        default = True,
        update = update_export_path_to_pelvis
        )
    def update_export_joints(self, context):
        self.update_preset()
    export_joints : bpy.props.BoolProperty(
        name = "",
        description =            "Export Joints"            "\n\n"            "Export the joints that have been set to (export) under the (Bone Control) section of the (Character Tools) panel.  These bones will "            "retain their expected positions in Second Life if uploaded with joint positions enabled.  This includes any bones that have been set "            "with this property, including mSkull, where previously this setting was specificaly for that bone it is now for all bones that have "            "been set to be exported in this way.  This is useful when you want to control a bones location without defining it in mesh.  A good "            "use of this is with a modulare set of items that are attached to Animesh and you'll want to keep their expected positions in tact",
        default = True,
        update = update_export_joints
        )

    def update_project_rig(self, context):
        self.update_preset()
    project_rig : bpy.props.BoolProperty(
        name = "",
        description =            "Project Rig"            "\n\n"            "Sometimes spine bones that are in odd locations will cause a distortion in the chain.  This can be avoided by enabling this option, "            "which builds a temporary full rig relative to your existing rig in order to repair these chain errors",
        default = False,
        update = update_project_rig
        )

    def update_normalize_bones(self, context):
        self.update_preset()
    normalize_bones : bpy.props.BoolProperty(
        name = "",
        description =            "Normalize Bones (disabled, not active yet)"            "\n\n"            "This effects the content that is exported only, it won't damage your product in Blender.  It corrects some obvious errors in bone properties, "            "one notable is scale on mBones",
        default = False,
        update = update_normalize_bones
        )

    def update_export_real_shape(self, context):
        self.update_preset()
    export_real_shape : bpy.props.BoolProperty(
        name = "",
        description =            "Export Real Shape (disabled, not active yet)"            "\n\n"            "Shape correction for Avastar devkit material",
        default = True,
        update = update_export_real_shape
        )
    def update_export_normalized_weights(self, context):
        self.update_preset()
    export_normalized_weights : bpy.props.BoolProperty(
        name = "",
        description =            "Normalize Weights (report bugs please)"            "\n\n"            "This replicates the method that Avastar used when exporting weighted mesh (skinned mesh).  Despite that many "            "mesh items were seriously damaged by weight distribution, among other things, Avastar pruned and limited this "            "data so that the imported item would have at least some value in Second Life(r).  This tool does exactly the same "            "thing and produces the same vertex weight data with floating point accuracy",
        default = False,
        update = update_export_normalized_weights
        )

    export_advanced : bpy.props.BoolProperty(
        description = "Show advanced dae (collada) export features",
        default = False,
        )
    
    export_apply_modifiers : bpy.props.BoolProperty(
        name = "DAE / Collada export option",
        description = ""            "This is a dae export option, it will not effect you Blender items but it will freeze your posed mesh, "            "if that's what you want, inside the DAE file, which will show up in SL or other apps.",
        default = False,
        )
    
    def update_dae_export_settings(self, context):
        
        bb_mesh = bpy.context.scene.bb_mesh
        bb_mesh["export_apply_modifiers"] = self.dae_apply_modifiers
        bb_mesh["export_selected"] = self.dae_selected
        bb_mesh["export_include_children"] = self.dae_include_children
        bb_mesh["export_include_armatures"] = self.dae_include_armatures
        bb_mesh["export_include_shapekeys"] = self.dae_include_shapekeys
        bb_mesh["export_include_animations"] = self.dae_include_animations
        bb_mesh["export_deform_bones_only"] = self.dae_deform_bones_only
        bb_mesh["export_triangulate"] = self.dae_triangulate
        bb_mesh["export_include_armatures"] = self.dae_include_armatures
        bb_mesh["export_use_object_instances"] = self.dae_use_object_instantiation
        bb_mesh["export_use_blender_profile"] = self.dae_use_blender_profile
        bb_mesh["export_sort_by_name"] = self.dae_sort_by_name
        bb_mesh["export_open_sim"] = self.dae_open_sim
        self.update_preset()

    dae_apply_modifiers : bpy.props.BoolProperty(default=False, update=update_dae_export_settings)
    dae_selected : bpy.props.BoolProperty(default=True, update=update_dae_export_settings)
    dae_include_children : bpy.props.BoolProperty(default=False, update=update_dae_export_settings)
    dae_include_armatures : bpy.props.BoolProperty(default=True, update=update_dae_export_settings)
    dae_include_shapekeys : bpy.props.BoolProperty(default=False, update=update_dae_export_settings)
    dae_include_animations : bpy.props.BoolProperty(default=False, update=update_dae_export_settings)
    dae_deform_bones_only : bpy.props.BoolProperty(default=True, update=update_dae_export_settings)
    dae_triangulate : bpy.props.BoolProperty(default=False, update=update_dae_export_settings)
    dae_use_object_instantiation : bpy.props.BoolProperty(default=False, update=update_dae_export_settings)
    dae_use_blender_profile : bpy.props.BoolProperty(default=False, update=update_dae_export_settings)
    dae_sort_by_name : bpy.props.BoolProperty(default=True, update=update_dae_export_settings)
    dae_open_sim : bpy.props.BoolProperty(default=True, update=update_dae_export_settings)

    def update_export_reset(self, context):
        bb_mesh = bpy.context.scene.bb_mesh
        if bb_mesh.export_reset == True:
            for export_option in bb_settings['dae_export_options']:
                bpy.context.scene.bb_mesh.property_unset(export_option)
        bb_settings['terminate'] = True
        bb_mesh.export_reset = False
        return
    
    export_reset : bpy.props.BoolProperty(
        description = "Use this to reset your buttons to Second Life and Opensim compatible options",
        default=False,
        update=update_export_reset
        )
    
    def update_devkit_poll(context):
        bb_devkit = bpy.context.scene.bb_devkit

        if len(devkit.defaults['onigiri']) == 0:
            print("Loading presets, you should only see this message once per session")
            devkit.defaults['defaults'] = devkit.load_defaults(file="defaults")
            devkit.defaults['avastar'] = devkit.load_defaults(file="avastar")
            devkit.defaults['onigiri'] = devkit.load_defaults(file="onigiri")
            
            devkit.props['last_source'] = None

        armObj = utils.has_armature()

        if devkit.props['last_source'] == armObj:
            return True 

        if armObj == False:
            print("No armature, using defaults")
            
            presets = devkit.defaults['onigiri']

        else:
            print("Got armature", armObj.name)
            if armObj.get('bb_devkit_preset') != None:
                print("Got presets from armature")
                presets = armObj['bb_devkit_preset'].to_dict()
            else:
                
                if armObj.get('onigiri_converted') != None:
                    print("Character Converted, using defaults")
                    presets = devkit.defaults['defaults']
                
                elif armObj.get('bb_collada_matrices') == None:
                    print("No presets on armature, using default assuming Onigiri")
                    presets = devkit.defaults['onigiri']
                else:
                    print("No presets on armature, using default assuming Devkit (Avastar Joints)")
                    presets = devkit.defaults['avastar']

        if len(presets) == 0:
            print("Default presets are zero length.  If you see this message more than once")
            print("per Blender session you have missing data.  This is not an error until then.")
            
            devkit.defaults['defaults'] = devkit.load_defaults(file="defaults")
            devkit.defaults['avastar'] = devkit.load_defaults(file="avastar")
            devkit.defaults['onigiri'] = devkit.load_defaults(file="onigiri")

            devkit.props['last_source'] = False

        devkit.props['last_source'] = armObj  
        
        properties = set(bb_devkit.__annotations__.keys())
        
        for prop in properties:
            
            if prop in presets:
                
                try:
                    bb_devkit[prop] = presets[prop]
                    
                except:
                    pass
                    
        bb_devkit.export_menu_enabled = True

        return True

    devkit_poll : bpy.props.IntProperty(
        default=0,
        get = update_devkit_poll
        )

    def update_devkit_state(self, context):
        self["devkit_state"] = False
    devkit_state : bpy.props.BoolProperty(
        name = "",
        description = ""            "If there is a message here it will indicate the status below.  This data is loaded when you load a preset or use the "            "dae or devkit import tool.  You'll recall (Devkit Manager) if you've used Avastar and this is the same thing except "            "it's just two steps and there's nothing else to fill out or know about the kit or armature."            "\n"            " - Unsaved Devkit -\n"            "   * Save your data or lose it on the next preset load or Blender restart\n"            "   * Data can be used during export but is unsaved for future use\n"            "   * The red X removes the data, if you want to, it's not required\n"            "\n"            " - Data Ready -\n"            "   * Devkit data has been saved\n"            "   * Data can be used during export\n"            "\n"            "NOTE: A blank notice means that the associated armature has no devkit data.  This is not a bad thing.\n"            "Blender devkits derived from Avastar Blender files will not have this data but if there's a known preset "            "for it just load it and you're ready to fun.",
        default = False,
        update = update_devkit_state
        )

    devkit_rotate : bpy.props.BoolProperty(
        name = "",
        description = ""            "If your DAE file works in SL then enable this to get a more functional representation of the imported item. "            "This could break it if the dae was not targeted for SL.  For instance, maybe you're importing a kit that was "            "exported from Maya and not preparted for SL but only for distribution and use for products associated with that "            "kit, then it could be facing -Y and would not need this enabled.",
        default = True,
        )

    devkit_resize : bpy.props.BoolProperty(
        name = "",
        description = ""            "Adjust bone relationship transforms to the Z height of the imported set."            "\n\n"            "With this enabled the bone transforms are adjusted to match what's expected from the size of the incoming "            "rig, this is usually what you want.  Make sure you save before any conversion.",
        default = True,
        )
    devkit_connect : bpy.props.BoolProperty(
        name = "",
        description = ""            "Known bones for SL can be connected where indicated and should be safe to do so.  Unfortunately many devkits were "            "damaged and these damages were recorded by exporting and then uploading to SL.  If items were made for these products "            "then enabling this could potentially damage your exports for that particular kit.  Use this for testing only, it's "            "absolutely not required.  When enabled this will link the head of one bone to its parent if the connect feature is "            "indicated for SL.  This can be most useful when (fix) and (match) are also used, which is really all you need instead "            "of this.  For those that understand what (use_connect) does then, of course, have at it, you may have a specific use case.",
        default = False,
        )
    devkit_strip : bpy.props.BoolProperty(
        name = "",
        description = ""            "When an imported kit has uknown bones this is useful for removing those.  Why would it have known bones?  Maybe you exported "            "a dae file using Avastar and enabled the (all bones) feature thinking that it would be compatible with something.  This will "            "probably fix it.",
        default = True,
        )
    devkit_align : bpy.props.BoolProperty(
        name = "",
        description = ""            "The Onigiri Second Life rig is a perfect representation of that which is considered most compatible with standard SL shapes, "            "with an allowable tweak here and there to conform with animations produced by Avastar.  This is the tweaker.  However, this can "            "also be a huge (fixer) if your imported bone angles are way off.  Why would they be (way off)?  Because Avastar does not export "            "your skeleton definitions in its entirety and doesn't need to for compatibility with Second Life.  The bone angles are most useful "            "when using your kit in another application and when re-exporting a kit to that end or if using this imported kit as an animation rig."            "This is probably safe for imported DAE but this feature is also present when migrating a partial rig to a full rig so you will see "            "this there as well.  With that in mind this is NOT entirely safe for Blender sourced devkits that you've converted from Avastar",
        default = False,
        )
    devkit_fix : bpy.props.BoolProperty(
        name = "",
        description = ""            "This prepares your imported bones for best alignment with SL bones.  It will analyze the rig and determine if the tail of a parent "            "bone can be placed to the head of its only child.  This is usually safe, and should be done with imported DAE files but not always "            "when creating a full rig from a partial rig.  This preparation is almost always required if using (match) as well since the angle of "            "the existing bones determine where and how the new bones will be arranged.",
        default = True,
        )
    devkit_match : bpy.props.BoolProperty(
        name = "",
        description = ""            "This enables or disables the alignment of generated bones"            "\n\n"            "If you have an ugly rig after the process then this may be for you.  During the import process, the rig is converted "            "from partial to full rig.  During that stage it's necessary for the tool to generate a known good rig for reference. "            "This known rig is a proxy rig (Onigiri Rig) and is adjusted in order to have the best match for your target rig. "            "After all of the work is done the target rig assumes the angles and locations of the adjusted proxy, making an almost "            "perfect match.  This should not cause usues with bones that already exist, since the match would be perfect, but for "            "those bones that did NOT exist prior to using this tool then this (match) options forces those into alignment with "
            "known SL definitions which can pose a problem, especially for Blender devkits.  You probably want this enabled if you're "            "importing a devkit dae.",
        default = True,
        )
    def update_mesh_export_blank(self, context):
        self["export_blank"] = False
    export_blank : bpy.props.BoolProperty(default = False, update = update_mesh_export_blank)

    export_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Expand the export options for this rig/kit",
        default = False,
        )
    def update_process_volume_bones(self, context):
        bpy.context.scene.bb_mesh["process_volume_bones"] = self["process_volume_bones"]
        self.update_preset()
    process_volume_bones : bpy.props.BoolProperty(
        name = "Process SL specific bone properties",
        description = ""            "Sometimes this is not what you want.  If your rig is facing the X direction then there's a good chance that it "            "contains bind information that you don't want to change. If you're unsure just uncheck it and give it a try.  If "            "your resulting mesh looks like a flattened mosquito in Second Life then this feature needs to be enabled. ",
        default = True,
        update = update_process_volume_bones,
        )
    
    volume_bone_location : bpy.props.BoolProperty(
        name = "",
        description = ""            "This should be disabled for mapped mesh when you don't want the volume bones relocated."            "\n\n"            "Volume bones have special properties of location, rotation and scale.  With custom mapped mesh the location and "            "rotation values should not be included and, instead, taken from the rig.  The scale option should be enabled.",
        default = True,
        update = update_preset_trigger
        )

    volume_bone_rotation : bpy.props.BoolProperty(
        name = "",
        description = ""            "This should be disabled for mapped mesh when you don't want the volume bones relocated."            "\n\n"            "Volume bones have special properties of location, rotation and scale.  With custom mapped mesh the location and "            "rotation values should not be included and, instead, taken from the rig.  The scale option should be enabled.",
        default = True,
        update = update_preset_trigger
        )
    volume_bone_scale : bpy.props.BoolProperty(
        name = "",
        description = ""            "This should be ENABLED for mapped mesh if using volume bones in order to prevent deformations."            "\n\n"            "Volume bones have special properties of location, rotation and scale.  With custom mapped mesh the location and "            "rotation values should not be included and, instead, taken from the rig.  The scale option should be enabled",
        default = True,
        update = update_preset_trigger
        )

    def update_process_attachment_bones(self, context):
        if self.process_attachment_bones == False:
            self["process_unsupported_bones"] = False
            armObj = utils.has_armature()
            if armObj != False:
                for boneObj in armObj.data.bones:
                    bone = boneObj.name
                    if " " not in bone:
                        continue
                    if bone in skel.avatar_skeleton:
                        if skel.avatar_skeleton[bone]['type'] == 'attachment':
                            boneObj.use_deform = False
        self.update_preset_trigger(context)
    
    process_attachment_bones : bpy.props.BoolProperty(
        name = "",
        description =            "Export Attachment Joints"            "\n\n"            "This will export attachment bones that are compatible with SL's uploader.",
        default = False,
        update = update_process_attachment_bones
        )
    
    def update_process_unsupported_bones(self, context):
        
        if self.process_attachment_bones == False:
            self["process_unsupported_bones"] = False
            
            armObj = utils.has_armature()
            if armObj != False:
                for boneObj in armObj.data.bones:
                    bone = boneObj.name
                    if " " not in bone:
                        continue
                    if bone in skel.avatar_skeleton:
                        if skel.avatar_skeleton[bone]['type'] == 'attachment':
                            boneObj.use_deform = False
            return
        
        if self.process_unsupported_bones == True:
            
            armObj = utils.has_armature()
            if armObj != False:
                for boneObj in armObj.data.bones:
                    bone = boneObj.name
                    if bone in skel.avatar_skeleton:
                        if skel.avatar_skeleton[bone]['type'] == 'attachment':
                            boneObj.use_deform = True
        
        if self.process_unsupported_bones == False:
            armObj = utils.has_armature()
            if armObj != False:
                for boneObj in armObj.data.bones:
                    bone = boneObj.name
                    if " " not in bone:
                        continue
                    if bone in skel.avatar_skeleton:
                        if skel.avatar_skeleton[bone]['type'] == 'attachment':
                            boneObj.use_deform = False
        
        self.update_preset_trigger(context)

    process_unsupported_bones : bpy.props.BoolProperty(
        name = "",
        description =            "Process Unsupported Points"            "\n\n"            "This only works with (Use Attach Points).  These particular joints are not compatible with SL skinning because they "            "have spaces in their names.  However, if you are using the Firestorm Viewer you can still use these bones form "            "mesh deformation like any other bone.  Things could get very strange but if you're into motion fun, enjoy!",
        default = False,
        update = update_process_unsupported_bones
        )

    fix_broken_bones : bpy.props.BoolProperty(
        name = "",
        description = "",
        default = False,
        update = update_preset_trigger
        )

    def update_rig_class_default(self, context):
        self.update_rig_class_name_proxy("default", self.rig_class_default)
        self.update_preset()
    def update_rig_class_neutral(self, context):
        self.update_rig_class_name_proxy("neutral", self.rig_class_neutral)
        self.update_preset()
    def update_rig_class_male_default(self, context):
        self.update_rig_class_name_proxy("male_default", self.rig_class_male_default)
        self.update_preset()
    def update_rig_class_male_neutral(self, context):
        self.update_rig_class_name_proxy("male_neutral", self.rig_class_male_neutral)
        self.update_preset()
    def update_rig_class_name_proxy(self, name, state):
        
        classes = {"default", "neutral", "male_default", "male_neutral"}
        rc = "rig_class_"
        if state == True:
            self.rig_class_name = name
            classes.remove(name)
            for c in classes:
                self[rc + c] = False
        self.update_preset()

    rig_class_default : bpy.props.BoolProperty(
        name = "",
        description =            "Default"            "\n\n"            "Devkits have a class that they are based on.  Sometimes their existing rig configuration IS their class but "            "to make sure you get the proper export it's nice to know the class.  If you are unsure you can try default or "            "leave it blank to take the data directly from the rig.  If the rig has a custom pose, like an (A) pose, you "            "need to know what the original rig configuration was.  In this case try default first if you don't know.",
        default = False,
        update = update_rig_class_default
        )
    rig_class_neutral : bpy.props.BoolProperty(
        name = "",
        description =            "Neutral"            "\n\n"            "Devkits have a class that they are based on.  Sometimes their existing rig configuration IS their class but "            "to make sure you get the proper export it's nice to know the class.  If you are unsure you can try default or "            "leave it blank to take the data directly from the rig.  If the rig has a custom pose, like an (A) pose, you "            "need to know what the original rig configuration was.  In this case try default first if you don't know.",
        default = False,
        update = update_rig_class_neutral
        )
    rig_class_male_default : bpy.props.BoolProperty(
        name = "",
        description =            "Default Male"            "\n\n"            "Devkits have a class that they are based on.  Sometimes their existing rig configuration IS their class but "            "to make sure you get the proper export it's nice to know the class.  If you are unsure you can try default or "            "leave it blank to take the data directly from the rig.  If the rig has a custom pose, like an (A) pose, you "            "need to know what the original rig configuration was.  In this case try default first if you don't know.",
        default = False,
        update = update_rig_class_male_default
        )
    rig_class_male_neutral : bpy.props.BoolProperty(
        name = "",
        description =            "Neutral Male"            "\n\n"            "Devkits have a class that they are based on.  Sometimes their existing rig configuration IS their class but "            "to make sure you get the proper export it's nice to know the class.  If you are unsure you can try default or "            "leave it blank to take the data directly from the rig.  If the rig has a custom pose, like an (A) pose, you "            "need to know what the original rig configuration was.  In this case try default first if you don't know.",
        default = False,
        update = update_rig_class_male_neutral
        )
    
    rig_class_name : bpy.props.StringProperty(
        name = "",
        description = "-- internal",
        default = "default",
        )

class OnigiriDevKitPresetLoad(bpy.types.Operator, ImportHelper):
    """Presets are devkit properties loaded onto an associated rig of the selected mesh.
Only one preset needs to be loaded for all associated mesh of that rig.  These presets
are context sensitive, allowing you to have a preset for each devkit"""

    bl_idname = "onigiri.devkit_preset_load"
    bl_label = "Load Settings"

    filename_ext = ".dkp"
    filter_glob : bpy.props.StringProperty(
        default='*.dkp',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        load_path = script_dir + devkit_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        armObj = utils.has_armature()
        if armObj == False:
            return False
        return True

    def execute(self, context):
        preset_file = self.properties.filepath

        path, name = os.path.split(self.properties.filepath)
        file_prefix = name.split(".")[0]
        ext = name.split(".")[-1]
        devkit.props['preset_name'] = file_prefix

        try:
            namespace = {}
            exec(open(preset_file, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        presets = {}

        try:
            presets.update(namespace['presets'])
        except:
            print("New preset format not present, trying old...")
            try:
                presets.update(namespace['devkit_presets'])
            
            except:
                print("Old preset not present, there's nothing to do.")
                popup("No presets exist", "Error", "ERROR")
                return {'FINISHED'}

        armObj = utils.has_armature()

        armObj['bb_devkit_preset'] = presets
        devkit.props['last_source'] = False

        matrices = {}
        try:
            matrices.update(namespace['matrices'])
            print("Found matrices")
        except:
            print("No matrices")

        armObj['bb_collada_matrices'] = matrices

        bb_devkit = bpy.context.scene.bb_devkit

        export_advanced = bb_devkit.export_advanced
        devkit.set_defaults(all=True)

        remove = []
        for p in presets:
            try:
                
                bb_devkit[p] = presets[p]
            except:
                remove.append(p)
                print("Read only property:", p)
        for p in remove:
            presets.pop(p, "")

        bb_devkit.export_advanced = export_advanced
        bb_devkit.export_menu_enabled = True

        print("Preset loaded onto armature:", armObj.name)
        bb = bpy.context.scene.onigiri
        if bb.devkit_run_code == True:
            code = {}
            if namespace.get('code') != None:
                code.update(namespace['code'])
                print("Code loaded, running...")
                
                code_file = script_dir + code_path + code['file']
                try:
                    f = open(code_file, 'r')
                    run_script = f.read()
                    f.close()
                    exec(run_script)
                except Exception as e:
                    print(traceback.format_exc())
                    return {'FINISHED'}
            
                print("Run finished!")

        return {'FINISHED'}

class OnigiriDevKitPresetSave(bpy.types.Operator, ExportHelper):
    """Presets are devkit properties.  It's expected that you have mesh selected but
an armature is ok as well since presets are store onto the armature of that
character.  You must have a selection to use this"""

    bl_idname = "onigiri.devkit_preset_save"
    bl_label = "Save Preset"

    filename_ext = ".dkp"
    filter_glob : bpy.props.StringProperty(
        default='*.dkp',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = script_dir + devkit_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        armObj = utils.has_armature()
        if armObj == False:
            return False
        
        return True

    def execute(self, context):
        bb_devkit = bpy.context.scene.bb_devkit

        path, name = os.path.split(self.properties.filepath)
        file_prefix = name.split(".")[0]
        ext = name.split(".")[-1]
        devkit.props['preset_name'] = file_prefix

        armObj = utils.has_armature()

        if armObj == False:
            print("This is a Blender bug, your UI selection caused an inconsistancy with Blender, please try again.")
            popup("A Blender bug hit you, make your selection again and re-export")
            return {'FINISHED'}

        if armObj.get('bb_devkit_preset') != None:
            print("Found preset on armature")
            presets = armObj['bb_devkit_preset'].to_dict()
        else:
            print("No preset on armature, using default")
            presets = devkit.defaults['avastar']
            
        formatted = "# Preset data auto-generated by Bento Budddy\n\n"
        formatted += "presets = "
        formatted += pprint.pformat(presets)
        formatted += "\n"

        if armObj.get('bb_collada_matrices') != None:
            matrices = armObj['bb_collada_matrices'].to_dict()
            formatted += "matrices = "
            formatted += pprint.pformat(matrices)
            formatted += "\n"
            armObj.pop('bb_collada_unsaved', "")
        output = open(self.properties.filepath, 'w', encoding='UTF8')
        output.write(formatted)
        output.close()

        armObj['bb_devkit_prefix'] = presets

        print("Preset saved for armature:", armObj.name)

        return {'FINISHED'}

class OnigiriDevKitPresetSaveDefaults(bpy.types.Operator, ExportHelper):
    """This saves the UI elements, allowing you to save a base set of presets for
the configuring your devkits and dea exports.  This data is automatically
loaded when needed so make sure it's what you want"""

    bl_idname = "onigiri.devkit_preset_save_defaults"
    bl_label = "Save Defaults"

    filename_ext = ".dkp"
    filter_glob : bpy.props.StringProperty(
        default='*.dkp',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = script_dir + devkit_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_devkit = bpy.context.scene.bb_devkit

        presets = {}
        for prop in bb_devkit.__annotations__.keys():
            presets[prop] = getattr(bb_devkit, prop)

        formatted = "# Preset data auto-generated by Bento Budddy\n\n"
        formatted += "presets = "
        formatted += pprint.pformat(presets)
        formatted += "\n"

        output = open(self.properties.filepath, 'w', encoding='UTF8')
        output.write(formatted)
        output.close()

        print("Presets saved:", self.properties.filepath)

        return {'FINISHED'}

class OnigiriDevKitResetAll(bpy.types.Operator):
    """This resets all devkit options to default"""

    bl_idname = "onigiri.devkit_reset_all"
    bl_label = "Reset All"

    def execute(self, context):
        bb_devkit = bpy.context.scene.bb_devkit

        export_advanced = bb_devkit.export_advanced

        devkit.set_defaults(all=True)

        bb_devkit.export_advanced = export_advanced
        bb_devkit.export_menu_enabled = True

        return {'FINISHED'}

class OnigiriDevKitResetCollada(bpy.types.Operator):
    """This resets only the dae export options"""

    bl_idname = "onigiri.devkit_reset_collada"
    bl_label = "Reset DAE"

    def execute(self, context):
        bb_devkit = bpy.context.scene.bb_devkit

        export_advanced = bb_devkit.export_advanced

        devkit.set_defaults(all=False, area="dae")
        
        devkit.update_preset_source()

        bb_devkit.export_advanced = export_advanced
        bb_devkit.export_menu_enabled = True

        return {'FINISHED'}

class OnigiriColladaExporter(bpy.types.Operator, ExportHelper):
    """Export a rigged / fitted mesh for SL, including Character Converter,
Dev Kits (even from Avastar), standard DAE exports with bind
information (the stuff that\'s usually missing from Blender)"""

    bl_idname = "onigiri.collada_export"
    bl_label = "DAE / Collada Exporter"

    filename_ext = ".dae"
    filter_glob : bpy.props.StringProperty(
        default='*.dae',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        
        if len(bpy.context.selected_objects) == 0:
            return False
        
        for mesh in bpy.context.selected_objects:
            if mesh.type == 'MESH':
                return True
        return False

    def execute(self, context):

        def delete_exported_copies(exported_copies, state=None):
            if len(exported_copies) == 0:
                return False
            utils.get_state() 
            for o in exported_copies:
                
                if utils.is_valid(o) == False:
                    continue
                o.select_set(True)
                utils.activate(o)
            bpy.ops.object.delete()
            if state != None:
                utils.set_state(state) 
            return True

        if os.path.isdir(self.filepath) == True:
            txt = "The path below does not contain a filename, it is a directory/path only...\n"
            txt += self.filepath
            txt += "\n"
            txt += "Make sure to add a filename before saving or choose a file in the export window.\n"
            print(txt)
            utils.popup(txt, "Missing filename", "ERROR")
            return {'FINISHED'}

        obj = bpy.data.objects
        ccp = bpy.context.window_manager.cc_props

        bb_mesh = bpy.context.scene.bb_mesh
        bb_devkit = bpy.context.scene.bb_devkit
        project_rig = bb_devkit.project_rig

        export_copies = bb_devkit.export_copies
        
        state = utils.get_state()
        utils.set_state(state)

        txt = ""
        armObj = utils.has_armature(report=True)
        if armObj == False:
            txt = "There is an armature issue, please check the console for more details.\n"
            txt += "This can happen if an armature is missing, the items are not parented,\n"
            txt += "or there are too many armatures associated with the selected mesh.\n"
        if txt != "":
            print(txt)
            utils.popup(txt, "Error", "ERROR")
            return {'FINISHED'}
        if armObj.get('onigiri_converted'):
            print("Found converted character, using the alternate project_rig proxy switch")
            project_rig = bb_mesh.project_rig

        select_state = armObj.select_get()
        armObj.select_set(True)
        if armObj.select_get() == False:
            txt = "INIT: The armature object associated with the mesh that you're attempting to export cannot be examined because it is\n"
            txt += "not selectable.  Make sure that the armature is visible in the scene and that you can select it before you proceed."
            print(txt)
            utils.popup(txt, "No Armature Available", "ERROR")
            return {'FINISHED'}
        armObj.select_set(select_state)

        selected_mesh = []
        selected_armatures = []
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                selected_mesh.append(o)
            elif o.type == 'ARMATURE':
                selected_armatures.append(o)
        if len(selected_mesh) == 0:
            print("There are no mesh in your selected")
            popup("There are no mesh in your selected", "Error", "ERROR")
            return {'FINISHED'}
        
        no_groups = []
        qualified_mesh = []
        for meshObj in selected_mesh:
            if len(meshObj.vertex_groups) == 0:
                no_groups.append(meshObj.name)
            else:
                qualified_mesh.append(meshObj)
        if len(qualified_mesh) == 0:
            print("There are no qualified mesh in your selection.")
            print("The following mesh were selected but have no vertex groups")
            print(no_groups)
            popup("There are no qualified mesh in your selection, see console", "Error", "ERROR")
            return {'FINISHED'}
        print("Qualified mesh:")
        for o in qualified_mesh:
            print(" -", o.name)
        print("Unqualified mesh:")
        for oname in no_groups:
            print(" -", oname)

        utils.get_state()

        for o in selected_armatures:
            o.select_set(True)
        for o in qualified_mesh:
            o.select_set(True)
        utils.activate(qualified_mesh[0])

        print("selected:")
        for o in bpy.context.selected_objects:
            print(" -", o.name)

        exported_copies = []
        if export_copies == True:
            bpy.ops.object.duplicate()
            
            for o in bpy.context.selected_objects:
                exported_copies.append(o)
                
                if o.type == 'ARMATURE':
                    armObj = o

        zero_matrix = mathutils.Matrix()
        for boneObj in armObj.pose.bones:
            boneObj.matrix_basis = zero_matrix

        if bb_devkit.remove_empty_groups == True:
            
            bpy.ops.onigiri.remove_unused_groups(method="best")

        if 1 == 0:
            if bb_devkit.limit_groups == True:
                for o in bpy.context.selected_objects:
                    if o.type != 'MESH':
                        continue
                    print("limit groups per vertex of", o.name)
                    
                    limit_weights(mesh=o.name, limit=4)

        if bb_devkit.apply_rig_scale == True:
            print("Applying scale to rig, this could damage everything, do this manually!")
            temp_state = utils.get_state()
            armObj.select_set(True)
            utils.activate(armObj)

            bpy.ops.object.mode_set(mode='OBJECT')

            bpy.ops.object.transform_apply(location=False, rotation=False, scale=True)
            utils.set_state(temp_state)

        if 1 == 1:

            if bb_devkit.use_rig_data == True:
                print("Running rig data export...")

                if bb_devkit.rig_class_default == True:
                    base = "female_default"
                elif bb_devkit.rig_class_neutral == True:
                    base = "female_neutral"
                elif bb_devkit.rig_class_male_default == True:
                    base = "male_default"
                elif bb_devkit.rig_class_male_neutral == True:
                    base = "male_neutral"
                else:
                    base = None

                txt = ""
                armObj = utils.has_armature()
                if armObj == False:
                    txt = "No armature is associated with the mesh.\n"
                    txt += "Make sure your mesh are skinned and that there's\n"
                    txt += "an armature modifier, along with an intended target,\n"
                    txt += "associated with the mesh."
                if txt != "":
                    delete_exported_copies(exported_copies, state=state)
                    print(txt)
                    utils.popup(txt, "Error", "ERROR")
                    return {'FINISHED'}

                use_bind_pose = bb_devkit.use_bind_pose

                print("The following states are being sent to devkit.get_matrices")
                print(" - use_bind_pose:", use_bind_pose)
                print(" - project_rig  :", project_rig)

                if project_rig == True:
                    print("project_rig is enabled, this will duplicate the rig, complete it, record matrices and then delete it")
                    
                    fake_state = utils.get_state()
                    
                    armObj.select_set(True)
                    utils.activate(armObj)
                    bpy.ops.object.duplicate()
                    fakeObj = bpy.context.object
                    
                    result = rigutils.make_complete(
                        armature=fakeObj, rotate=True,
                        resize=False, connect=False,
                        strip=False, align=False,
                        fix=False, match=False,)
                    if result == False:
                        print("The project_rig option failed when attempting to complete the rig, the process will continue but may suffer")
                    matrices = devkit.get_matrices(armature=fakeObj, base=base, use_bind_pose=use_bind_pose, report=True)
                    for o in bpy.context.selected_objects:
                        o.select_set(False)
                    fakeObj.select_set(True)
                    utils.activate(fakeObj)
                    bpy.ops.object.delete()
                    utils.set_state(fake_state)
                else:
                    matrices = devkit.get_matrices(armature=armObj, base=base, use_bind_pose=use_bind_pose, report=True)

                print("Exporting from rig data")
                result = devkit.export_dae(matrices=matrices, joint='real_data', file=self.filepath,)
                if result == False:
                    print("Export seems to have failed")
                    popup("Export failed", "Error", "ERROR")
                else:
                    print("Export completed successfully")
                delete_exported_copies(exported_copies, state=state)
                return {'FINISHED'}

            elif bb_devkit.use_bind_data == True:
                txt = ""
                armObj = utils.has_armature()
                if armObj == False:
                    txt = "No armature is associated with the mesh.\n"
                    txt += "Make sure your mesh are skinned and that there's\n"
                    txt += "an armature modifier, along with an intended target,\n"
                    txt += "associated with the mesh."
                if txt != "":
                    print(txt)
                    utils.popup(txt, "Error", "ERROR")
                    delete_exported_copies(exported_copies, state=state)
                    return {'FINISHED'}

                matrices = devkit.get_bind_info(armObj)
                if matrices == False:
                    print("get_bind_info returned False")
                    popup("Incompatible data type, try using a different bind data source", "Error", "ERROR")
                    delete_exported_copies(exported_copies, state=state)
                    return {'FINISHED'}

                result = devkit.export_dae(matrices=matrices, joint='bone_data', file=self.filepath,)

                if result == False:
                    print("Export seems to have failed")
                    popup("Export failed", "Error", "ERROR")
                else:
                    print("Export completed successfully")

                delete_exported_copies(exported_copies, state=state)
                return {'FINISHED'}

        if bb_devkit.use_sl_compatible_data == True or bb_devkit.use_app_compatible_data == True:
            print("Running compatible data export...")
            armObj = utils.has_armature()
            if armObj == False:
                txt = "No armature is associated with the mesh.\n"
                txt += "Make sure your mesh are skinned and that there's\n"
                txt += "an armature modifier, along with an intended target,\n"
                txt += "associated with the mesh."
                print(txt)
                utils.popup(txt, "Error", "ERROR")

                delete_exported_copies(exported_copies, state=state)
                return {'FINISHED'}

            if bb_devkit.use_sl_compatible_data == True:
                joint = "bone_data"
            elif bb_devkit.use_app_compatible_data == True:
                joint = "real_data"
            print("Devkit branch running...")
            
            matrices = armObj.get('bb_collada_matrices')
            if matrices == None:
                print("OnigiriColladaExporter : No devkit bone definitions were loaded, try a different method")
                popup("The mesh set does not contain any bone definitions, try a different export option", "Error", "ERROR")
                delete_exported_copies(exported_copies, state=state)
                return {'FINISHED'}

            missing = []
            for bone in skel.avatar_skeleton:
                if bone not in matrices['bone_data']:
                    missing.append(bone)
            if len(missing) > 0:
                txt = "There are " + str(len(missing)) + " missing joint definitions in your devkit preset.\n"
                txt += "The exporter cannot utilize this type of export without all of the joints present.\n"
                txt += "If you imported this using a dae file you'll need to do it again and save your,\n"
                txt += "preset for later use.  If you loaded a preset that's not identified as (preset only)\n"
                txt += "then the loaded preset is damaged in some way.  Find another bind source solution.\n"
                txt += "Maybe you meant to use (Use Rig Data) and possibly include (Use Bind Pose).\n"
                utils.popup(txt, "Error", "ERROR")
                delete_exported_copies(exported_copies, state=state)
                return {'FINISHED'}

            result = devkit.export_dae(matrices=matrices, joint=joint, file=self.filepath,)
            print("Devkit banch returned")
            if result == False:
                print("Devkit branch returned an error")
            else:
                print("Devkit branch succeeded!")
            delete_exported_copies(exported_copies, state=state)
            return {'FINISHED'}

        print("collada_export : fall through, the old data is defunct and should not be used, find out what triggered this.")
        txt = "A setting you used or triggered caused a logic error in the collada exporter.\n"
        txt += "Please report this error, take a screen shot if you can, thank you."
        utils.popup(txt, "Error", "ERROR")
        delete_exported_copies(exported_copies, state=state)
        return {'FINISHED'}

        old_mode = bpy.context.mode
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'

        selected = [o for o in bpy.context.selected_objects]
        active = bpy.context.active_object

        active_selection = []

        export_path_to_pelvis = bb_devkit.export_path_to_pelvis
        export_full_rig = bb_devkit.export_full_rig

        use_rig_data = bb_devkit.use_rig_data
        use_bind_data = bb_devkit.use_bind_data
        
        use_app_compatible_data = bb_devkit.use_app_compatible_data
        
        if use_app_compatible_data == True:
            if armObj.get('bb_devkit_transforms') == None:
                use_app_compatible_data = False
                use_rig_data = True
                setattr(bb_devkit, "export_path_to_pelvis", False)
                setattr(bb_devkit, "export_full_rig", False)
                export_path_to_pelvis = False
                export_full_rig = False
                print("collada_export : use_app_compatible_data was enabled but there's no transforms available to use so we fall back to use_rig_data")
        
        if use_bind_data == True:
            has_bind_data = False
            
            armObj = utils.has_armature()
            if armObj == False:
                print("collada_export : Attempting to find an armature for use with bind data failed.")
                popup("collada_export : Armature Failure, no associated armature", "Error", "ERROR")
                return {'FINISHED'}
            for boneObj in armObj.data.bones:
                if boneObj.get('bind_mat') != None:
                    has_bind_data = True
                    setattr(bb_devkit, "export_path_to_pelvis", False)
                    setattr(bb_devkit, "export_full_rig", False)
                    export_path_to_pelvis = False
                    export_full_rig = False
                    print("collada_export : use_bind_data is enabled and we found the required data on the rig")
                    break
            if has_bind_data == False:
                print("collada_export : use_bind_data was enabled but there's no bind data on the rig, falling back to use_rig_data")
                use_bind_data = False
                use_rig_data = True

        bpy.context.view_layer.update()

        new_state = utils.get_state()
        new_kit = meshutils.get_exportable_mesh(objects=selected, report=True)
        if new_kit == False:
            
            print("onigiri.collada_exporter reports: first pass return from meshutils::get_exportable_mesh is False")
            return {'FINISHED'}
        
        for o in bpy.context.selected_objects:
            o.select_set(False)
        arm = new_kit['armature']
        utils.set_state(new_state)

        if obj[arm].get('bb_dae_devkit') != None or obj[arm].get('bb_dae_bind') != None:
            
            bb_mesh.export_path_to_pelvis = False
            bb_mesh.export_full_rig = False
            
            bb_mesh["export_path_to_pelvis"] = False
            bb_mesh["export_full_rig"] = False
            
        if export_path_to_pelvis or export_full_rig:
            print("Adding deformer...")
            new_kit = meshutils.get_exportable_mesh(objects=selected, report=True)
            if new_kit == False:
                
                print("onigiri.collada_exporter reports: return from meshutils::get_exportable_mesh is False")
                return {'FINISHED'}
            
            for o in bpy.context.selected_objects:
                o.select_set(False)
            arm = new_kit['armature']
            new_mesh = new_kit['mesh']
            for o in new_mesh:
                o.select_set(True)
            obj[arm].select_set(True)
            bpy.context.view_layer.objects.active = obj[arm]

            bpy.ops.object.mode_set(mode='OBJECT')

            bpy.ops.object.duplicate()
            
            duplicates = [o for o in bpy.context.selected_objects]

            print("Calling build_rig with static class (pos) which is probably not the best idea...")

            proxyObj = rigutils.build_rig(rig_class="pos", rotate=True)

            print("Export path to pelvis requires a clean rig, check for data transfer.")
            print("Export proxy object receiving properties from source:")
            for k in obj[arm].keys():
                proxyObj[k] = obj[arm][k]
                print(" *", k)

            duplicates.append(proxyObj)
            
            rigutils.snap_to(source=proxyObj.name, target=arm)

            for o in duplicates:
                if o.type == 'MESH':
                    o.parent = proxyObj
                    for modObj in o.modifiers:
                        if modObj.type == 'ARMATURE':
                            modObj.object = proxyObj

            for o in bpy.context.selected_objects:
                o.select_set(False)
            for o in duplicates:
                if o.type == 'MESH':
                    o.select_set(True)
            bpy.context.view_layer.objects.active = duplicates[0]

        active_selection = [o for o in bpy.context.selected_objects]

        if bb_mesh.remove_empty_groups == True:
            
            bpy.ops.onigiri.remove_unused_groups(method="best")
        
        if bb_devkit.limit_groups == True:
            for m in selected_mesh:
                print("limit groups per vertex of", m)
                
                limit_weights(mesh=m, limit=4)
        if bb_devkit.apply_rig_scale == True:
            print("Applying scale to rig, this could damage everything, do this manually!")
            temp_state = utils.get_state()
            armObj.select_set(True)
            utils.activate(armObj)
            bpy.ops.object.transform_apply(location=False, rotation=False, scale=True)
            utils.set_state(temp_state)

        bad_mesh_groups = {}
        bad_mesh_groups_trigger = False

        bpy.context.view_layer.update()

        for o in active_selection:
            if o.type != 'MESH':
                continue
            bad_mesh_groups[o.name] = list()
            for g in o.vertex_groups:
                if g.name not in skel.avatar_skeleton:
                    bad_mesh_groups[o.name].append(g.name)
                    bad_mesh_groups_trigger = True
        if bad_mesh_groups_trigger == True:
            print("-----------------------------------------------------------------------------------------------")
            print("At least one of the objects you attempted to export is not SL compliant and cannot be exported")
            print("using this method.  If you are exporting mapped Onigiri mesh from the Character Tools use")
            print("the (mapped mesh) option instead.  if you see animation bones listed from Avastar use the")
            print("(Move weights from control rig) feature under (Mesh Tools).  The mesh names with associated")
            print("vertex groups follows:")
            print("-----------------------------------------------------------------------------------------------")
            for mesh in bad_mesh_groups:
                print("mesh:", mesh)
                for vgroup in bad_mesh_groups[mesh]:
                    print("  -", vgroup)
            print("-----------------------------------------------------------------------------------------------")
            popup("There was an export error, wrong weight groups, see console", "Error", "ERROR")

            if 1 == 1:
                proxyObj.select_set(True)
                for o in duplicates:
                    o.select_set(True)
                bpy.ops.object.delete()
                return {'FINISHED'}

        rotate_for_sl = bb_devkit.rotate_for_sl
        apply_scale = bb_devkit.apply_scale
        apply_location = bb_devkit.apply_location
        apply_rotation = bb_devkit.apply_rotation

        fix_broken_bones = bb_devkit.fix_broken_bones
        export_deform_bones_only = bb_devkit.dae_deform_bones_only

        use_safe_settings = bb_mesh.use_safe_settings

        use_universal_data = bb_mesh.use_universal_data
        
        if bpy.context.active_object == None:
            active_object = active_selection[0] 
            bpy.context.view_layer.objects.active = active_object
            print("no active object, fixed:", active_object.name)
        else:
            active_object = bpy.context.active_object

        bpy.ops.object.mode_set(mode='OBJECT')
        
        bpy.ops.object.select_all(action='DESELECT')

        for o in bpy.context.selected_objects:
            o.select_set(False)
        for o in active_selection:
            o.select_set(True)

        mesh_arms = {}
        
        arm_objects = list()
        
        for meshObj in bpy.context.selected_objects:
            if meshObj.type != 'MESH':
                continue
            for mod in meshObj.modifiers:
                if mod.type == 'ARMATURE':
                    try:
                        if mod.object.name != None:
                            pass
                    except:
                        print("no target for armature modifier")
                        popup("your armature modifier has no target object", "Error", "ERROR")
                        return {'FINISHED'}
                    if mod.object.name not in arm_objects:
                        arm_objects.append(mod.object.name)
                    
                    print("Export skinned mesh is checking if there's already an ARMATURE modifier for", meshObj.name)
                    if meshObj.name in mesh_arms:
                        txt = "One of your selected mesh objects has more than one armature modifier: " + meshObj.name
                        print(txt)
                        popup(txt, "Error", "ERROR")
                        return {'FINISHED'}

                    mesh_arms[meshObj.name] = meshObj.modifiers[mod.name].object.name

        print("armatures found:", arm_objects)
        if len(arm_objects) > 1:
            print("Onigiri can only handle one armature at a time at the moment, you can export as many objects as you like however.")
            popup("Too many armatures, choose just one, see console for details", "Error", "ERROR")
            return {'FINISHED'}
        if len(arm_objects) == 0:
            txt = "Please skin/rig your mesh before exporting, if you want to export static mesh use blenders exporter"
            print(txt)
            popup(txt, "Error", "ERROR")
            return {'FINISHED'}

        armature = arm_objects[0]
        armObj = bpy.data.objects[armature]

        if fix_broken_bones == True:
            print("Fixing use_deform...")
            for dBone in armObj.data.bones:
                if dBone.name not in skel.avatar_skeleton:
                    dBone.use_deform = False
                else:
                    dBone.use_deform = True

        if (
        apply_scale == True or
        apply_rotation == True or
        apply_location == True
        ):
            print("active_selection:", active_selection)
            print("Pre-processing requested, this is a destructive process but should not hurt your mesh")
            for o in bpy.context.selected_objects:
                o.select_set(False)
            for o in active_selection:
                if o.type == 'MESH':
                    o.select_set(True)
                utils.activate(o)
            armObj.select_set(True)
            
            if armObj.select_get() == False:
                print("Could not select armature, this may not go well.")
                print("Make sure the armature is visible and selectable.")
                popup("The armature could not be transform processed, see System Console", "Error", "ERROR")
            bpy.ops.object.transform_apply(scale=apply_scale, rotation=apply_rotation, location=apply_location)
            
            for o in bpy.context.selected_objects:
                o.select_set(False)
            for o in active_selection:
                o.select_set(True)
            
        file_path = tempfile.gettempdir() + "/onigiri_" + get_unique_name_short() + ".dae"

        if rotate_for_sl == True:
            global_forward = '-X'
        else:
            global_forward = 'Y'

        if 1 == 0:
            state = utils.get_state()
            kludge_select = []
            kludge_active = bpy.context.active_object
            for o in bpy.context.selected_objects:
                kludge_select.append(o)
                o.select_set(False)
            armObj.select_set(True)
            utils.activate(armObj)
            
            bba = bpy.context.scene.bb_anim_props
            xrot = bba.x_rotate_value
            yrot = bba.y_rotate_value
            zrot = bba.z_rotate_value
            bba.x_rotate_value = 0.0
            bba.y_rotate_value = 0.0
            bba.z_rotate_value = 90.0
            bpy.ops.onigiri.rotate_rig()
            bba.x_rotate_value = xrot
            bba.y_rotate_value = yrot
            bba.z_rotate_value = zrot
            global_forward = 'Y'
            rotate_for_sl = False
            utils.set_state(state)
        
        bpy.ops.wm.collada_export(
            filepath = file_path,
            check_existing = True,
            apply_modifiers = bb_devkit.dae_apply_modifiers,
            selected = bb_devkit.dae_selected,
            include_children = bb_devkit.dae_include_children,
            include_armatures = bb_devkit.dae_include_armatures,
            include_shapekeys = bb_devkit.dae_include_shapekeys,
            include_animations = bb_devkit.dae_include_animations,
            deform_bones_only = bb_devkit.dae_deform_bones_only,

            triangulate = bb_devkit.dae_triangulate,
            use_object_instantiation = bb_devkit.dae_use_object_instantiation,
            use_blender_profile = bb_devkit.dae_use_blender_profile,
            sort_by_name = bb_devkit.dae_sort_by_name,
            open_sim = bb_devkit.dae_open_sim,
            export_object_transformation_type_selection = 'matrix',
            export_global_forward_selection=global_forward,
            export_global_up_selection='Z',
            apply_global_orientation=rotate_for_sl,
            )

        file_in = file_path
        file_out = self.properties.filepath

        if armObj.get('onigiri_converted') != None:
            print("OnigiriColladaExporter reports: converted rig detected, deferring to collada::write_collada")
            
            bb_mesh.property_unset("use_universal_data")
            bb_devkit.property_unset("use_rig_data")
            
            bb_devkit.property_unset("use_bind_data")

        if use_universal_data == True:
            print("universal retired, deferring to updated use_rig_data")
            bb_mesh.property_unset("use_universal_data")
            bb_devkit.property_unset("use_rig_data")
            
            bb_devkit.property_unset("use_bind_data")
            if 1 == 0:
                print("Converting using universal data...")
                collada_universal.write_collada(armature=armature, write=True, file_in=file_in, file_out=file_out)

                try:
                    os.remove(file_path)
                    print("BB dae cleanup")
                except:
                    print("BB Warning: unable to remove temporary file:", file_path)

        if use_safe_settings == True:
            print("use_safe_settings is being obsoleted")
            if 1 == 0:
                print("Observing safe settings, will use the rig for joint data and allow offset position and rotation data")
                print("UPDATE: offset settings appear to be ignored")
                use_rig_data = True
                use_offset_rotation = True
                use_offset_location = True

        print("Converting dae file:", file_in)
        collada.write_collada(
            armature=armature, real_armature = arm, write=True, file_in=file_in, file_out=file_out)

        if 1 == 1:
            try:
                os.remove(file_path)
                print("BB dae cleanup")
            except:
                print("BB Warning: unable to remove temporary file:", file_path)

        too_many = list()
        for mesh in mesh_arms:
            if len(obj[mesh].vertex_groups) > 110:
                too_many.append(mesh)
        if len(too_many) > 0:
            print("The following mesh have more than 110 vertex groups and cannot be uploaded to SL, split your mesh.")
            [print(a) for a in too_many]
            popup("At least one of your exported mesh have too many vertex groups, > 110, see console", "Info", "INFO")

        if export_path_to_pelvis or export_full_rig:
            for o in bpy.context.selected_objects:
                o.select_set(False)
            for o in duplicates:
                o.select_set(True)
            bpy.context.view_layer.objects.active = o
            bpy.ops.object.delete()
        
        for o in bpy.context.selected_objects:
            o.select_set(False)
        for o in selected:
            o.select_set(True)
        if active != None:
            bpy.context.view_layer.objects.active = active

        return {'FINISHED'}

class OnigiriImportProperties(bpy.types.PropertyGroup):

    dae_import_menu_enabled: bpy.props.BoolProperty(
        name = "",
        description =            "Expand the dae import menu",
        default = False,
        )
    
    dae_keep_bind_info : bpy.props.BoolProperty(
        description =            "Onigiri can utilize the bind information in dae files where there are skinned mesh.  "            "When exporting this you'll use the (Use Bind Data) option or you can convert the rig beforehand "            "and use the safer and more consistent route.",
        default = True,
        )
    
    dae_find_bone_chains : bpy.props.BoolProperty(
        description =            "The importer will attempt to align bones to each other, which is visually much better and often times easier "            "to work with but should not break your rig.",
        default = True,
        )

    dae_build_missing_bones : bpy.props.BoolProperty(
        name = "",
        description =            "This is what fixes your broken devkit.  If your kit is NOT broken then this entire tool is likely to break it for you.  "            "If you're running into problems don't use this, use the dae importer with (Bind Info) enabled or use Blenders importer "            "with that same option enabled.",
        default = True
        )
    dae_rotate_collada : bpy.props.BoolProperty(
        name = "",
        description =            "This is more of a convenience but probably what you expect.  A properly configured dae kit will have its armature, "            "and subsequently its mesh, facing +X direction for compatibility with other 3d applications and Second Life.  This switch "            "rotates the kit so that it's facing -Y, since that is an expected behavior and easier to work with since some Blender tools "            "require this orientation for intended work-flow.",
        default = True
        )
    dae_fix_scale : bpy.props.BoolProperty(
        name = "",
        description =            "There's a very good chance that youre dae kit will be scaled differently than you'd expect.  This will set it to a "            "1 which is not always what you want, you may want to do this yourself manually.",
        default = True
        )

class OnigiriColladaImporter(bpy.types.Operator, ImportHelper):
    """This is a dae importer with a fix.  Some dae files cannot be imported using
Blenders default importer and silently fails without an error to be found anywhere.
This is the fix for that"""

    bl_idname = "onigiri.collada_import"
    bl_label = "Import dae file"

    filename_ext = ".dae"
    filter_glob : bpy.props.StringProperty(
        default='*.dae',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_import = bpy.context.scene.bb_import

        file_name = bpy.path.basename(self.properties.filepath)
        suffix_name = os.path.splitext(file_name)[0]

        file_in = self.properties.filepath
        file_out = tempfile.gettempdir() + "/" + suffix_name + "_" + utils.get_temp_name() + ".dae"

        file_out = tempfile.gettempdir() + "/" + suffix_name + "_" + "bb" + ".dae"

        URI = globals.collada['URI']
        n = globals.collada['namespace']
        ET.register_namespace('', URI)
        tree = ET.parse(file_in)
        root = tree.getroot()

        print("Fixing dae file")
        itl = []
        for item in root.iter(f'{n}diffuse'):
            itl.append(item)
        for i in itl:
            print(i)
            i.clear()

        tree.write(file_out,
            xml_declaration = True,
            encoding = 'utf-8',
            method = 'xml'
            )
        
        bpy.ops.wm.collada_import(
            filepath=file_out,
            
            keep_bind_info=True,
            
            find_chains=bb_import.dae_find_bone_chains,
            )

        selected = bpy.context.selected_objects
        active = bpy.context.active_object

        has_armature = False
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                armObj = o
                has_armature = True

        if has_armature == False:
            print("No detectable armature was found in the imported items")
            txt = "\n"
            txt += "There was no detectable armature in the imported dae file\n"
            txt += "This tool serves only one particular purpose, to import dae\n"
            txt += "files to condition for use with Second Life.  It cannot do\n"
            txt += "anything else.\n"
            utils.popup(txt, "Error", "ERROR")
            return {'FINISHED'}

        for o in selected:
            o.select_set(False)
        armObj.select_set(True)
        utils.activate(armObj)

        if bb_import.dae_rotate_collada == True:
            bba = bpy.context.scene.bb_anim_props
            xrot = bba.x_rotate_value
            yrot = bba.y_rotate_value
            zrot = bba.z_rotate_value

            bba.x_rotate_value = 0.0
            bba.y_rotate_value = 0.0
            bba.z_rotate_value = -90.0

            bpy.ops.onigiri.rotate_rig()

            bba.x_rotate_value = xrot
            bba.y_rotate_value = yrot
            bba.z_rotate_value = zrot
        if bb_import.dae_fix_scale == True:
            armObj.scale.x = 1
            armObj.scale.y = 1
            armObj.scale.z = 1

        matrices = collada.get_matrices(file=file_in)

        armObj['bb_collada_matrices'] = matrices

        try:
            os.remove(file_out)
            print("BB dae cleanup")
        except:
            print("BB Warning: unable to remove temporary file:", file_out)

        for o in selected:
            o.select_set(True)
        utils.activate(active)

        return {'FINISHED'}

class OnigiriDevkitImporter(bpy.types.Operator, ImportHelper):
    """For versatility a devkit creator may export their finished mesh body as a
dae file, using the same tool they processed it with.  If this is the case, and
it actually works in SL, use this tool for a perfect match"""

    bl_idname = "onigiri.devkit_import"
    bl_label = "Import dae/devkit file"

    filename_ext = ".dae"
    filter_glob : bpy.props.StringProperty(
        default='*.dae',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_import = bpy.context.scene.bb_import
        bb_devkit = bpy.context.scene.bb_devkit

        rotate = bb_import.dae_rotate_collada

        resize = bb_devkit.devkit_resize
        connect = bb_devkit.devkit_connect
        strip = bb_devkit.devkit_strip
        align = bb_devkit.devkit_align
        fix = bb_devkit.devkit_fix
        match = bb_devkit.devkit_match

        state = utils.get_state()

        file_name = bpy.path.basename(self.properties.filepath)
        suffix_name = os.path.splitext(file_name)[0]

        file_in = self.properties.filepath
        file_out = tempfile.gettempdir() + "/" + suffix_name + "_" + utils.get_temp_name() + ".dae"

        file_out = tempfile.gettempdir() + "/" + suffix_name + "_" + "bb" + ".dae"

        URI = globals.collada['URI']
        n = globals.collada['namespace']
        ET.register_namespace('', URI)
        tree = ET.parse(file_in)
        root = tree.getroot()

        if 1 == 1:
            print("Fixing dae file")
            itl = []
            for item in root.iter(f'{n}diffuse'):
                itl.append(item)
            for i in itl:
                print(i)
                i.clear()
        else:
            print("collada_import : skipping material error discovery, add this in later")
 
        tree.write(file_out,
            xml_declaration = True,
            encoding = 'utf-8',
            method = 'xml'
            )
        
        bpy.ops.wm.collada_import(
            filepath=file_out,
            
            keep_bind_info=True,
            
            )

        try:
            os.remove(file_out)
            print("BB dae cleanup")
        except:
            print("BB Warning: unable to remove temporary file:", file_out)

        selected = bpy.context.selected_objects

        has_armature = False
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                armObj = o
                has_armature = True

        if has_armature == False:
            
            bpy.ops.object.delete()
            utils.set_state(state)
            print("No detectable armature was found in the imported items")
            txt = "\n"
            txt += "There was no detectable armature in the imported dae file\n"
            txt += "This tool serves only one particular purpose, to import dae\n"
            txt += "files to condition for use with Second Life.  It cannot do\n"
            txt += "anything else.\n"
            utils.popup(txt, "Error", "ERROR")
            return {'FINISHED'}

        for o in selected:
            o.select_set(False)
        armObj.select_set(True)
        utils.activate(armObj)

        utils.apply_transforms(armObj)

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in armObj.data.edit_bones:
            if boneObj.name not in skel.avatar_skeleton:
                armObj.data.edit_bones.remove(boneObj)
        bpy.ops.object.mode_set(mode='OBJECT')

        if bb_import.dae_rotate_collada == True:
            bba = bpy.context.scene.bb_anim_props
            xrot = bba.x_rotate_value
            yrot = bba.y_rotate_value
            zrot = bba.z_rotate_value

            bba.x_rotate_value = 0.0
            bba.y_rotate_value = 0.0
            bba.z_rotate_value = -90.0

            bpy.ops.onigiri.rotate_rig()

            bba.x_rotate_value = xrot
            bba.y_rotate_value = yrot
            bba.z_rotate_value = zrot

        if bb_import.dae_fix_scale == True:
            armObj.scale.x = 1
            armObj.scale.y = 1
            armObj.scale.z = 1

        result = rigutils.make_complete(
            armature=armObj, rotate=rotate,
            resize=resize, connect=connect,
            strip=strip, align=align,
            fix=fix, match=match,)

        if result == False:
            for o in selected:
                o.select_set(True)
            armObj.select_set(True)
            utils.activate(armObj)
            bpy.ops.object.delete()
            utils.set_state(state)
            popup("Rig regeneration failed", "Error", "ERROR")
            return {'FINISHED'}

        matrices = collada.get_matrices(file=file_in, armature=armObj)

        armObj['bb_collada_matrices'] = matrices

        mesh = []
        for o in selected:
            if o.type == 'MESH':
                mesh.append(o)

        skin_data = set()
        for meshObj in mesh:
            for v in meshObj.data.vertices:
                for g in v.groups:
                    name = meshObj.vertex_groups[g.group].name
                    skin_data.add(name)
        armObj['bb_collada_matrices']['skin_data'] = list(skin_data)
        
        armObj['onigiri'] = globals.version

        armObj.show_in_front = True

        armObj['bb_collada_unsaved'] = 1

        for o in selected:
            o.select_set(True)
        utils.activate(armObj)

        return {'FINISHED'}

class OnigiriColladaDataRemove(bpy.types.Operator):
    """This will remove the collada data from the rig associated with the mesh"""

    bl_idname = "onigiri.collada_data_remove"
    bl_label = "Remove Collada Data"

    @classmethod
    def poll(cls, context):
        armObj = utils.has_armature()
        if armObj == False:
            return False
        if armObj.get('bb_collada_matrices') == None:
            return False
        return True

    def execute(self, context):
        bb_import = bpy.context.scene.bb_import
        armObj = utils.has_armature()
        
        armObj.pop('bb_collada_matrices', "")
        armObj.pop('bb_collada_unsaved', "")
        print("Removed collada data from", armObj.name)

        return {'FINISHED'}

class OnigiriAnimEditProperties(bpy.types.PropertyGroup):

    def update_anim_blank(self, context):
        bpy.context.window_manager.bb_anim_edit["anim_blank"] = False
    anim_blank : bpy.props.BoolProperty(
        name = "",
        description =            "blank",
        default = False,
        update = update_anim_blank
        )

    anim_loop_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "something",
        default = True,
        )
    anim_loop_in : bpy.props.FloatProperty(
        name = "",
        description =            "something",
        default = 0,
        )
    anim_loop_out : bpy.props.FloatProperty(
        name = "",
        description =            "something",
        default = 0,
        )
    anim_ease_in : bpy.props.FloatProperty(
        name = "",
        description =            "something",
        default = 0.82,
        )
    anim_ease_out : bpy.props.FloatProperty(
        name = "",
        description =            "something",
        default = 0.82,
        )
    anim_menu_enabled: bpy.props.BoolProperty(
        name = "",
        description =            "Expand the menu to enable loading, editing and saving of anim files",
        default = False,
        )
    anim_show_joints_menu_enabled: bpy.props.BoolProperty(
        name = "",
        description =            "Show / HIde joint data",
        default = False,
        )
    anim_last_loaded : bpy.props.StringProperty(
        name = "",
        description = "--internal",
        default = "",
        )

    def update_anim_all(self, context):
        bpy.ops.onigiri.update_anim()

    anim_base_priority : bpy.props.IntProperty(
        min = -1,
        max = 6,
        default=2,
        
        update = update_anim_all
        )
    anim_loop_in_point : bpy.props.FloatProperty(
        name = "",
        description = "",
        default = 1.0,
        
        update = update_anim_all
        )
    anim_loop_out_point : bpy.props.FloatProperty(
        default = 0,
        
        update = update_anim_all
        )
    anim_loop : bpy.props.BoolProperty(
        default = False,
        
        update = update_anim_all
        )
    anim_ease_in_duration : bpy.props.FloatProperty(
        default = 0,
        
        update = update_anim_all
        )
    anim_ease_out_duration : bpy.props.FloatProperty(
        default = 0,
        
        update = update_anim_all
        )

    anim_hand_pose_enabled : bpy.props.BoolProperty(
        name = "hand pose enabled",
        description =            "This button must be pressed in for the feature to work"            "\n\n"            "A hand pose that becomes active during your animation.  This is pretty much obsoleted by Bento.  "            "This only works with the classic avatar, not mesh, because it's done with morphs, not bones.",
        default = False,
        )
    anim_hand_poses_menu = [
        ('0',"Spread",'',0),
        ('1',"Relaxed",'',1),
        ('2',"Point",'',2),
        ('3',"Fist",'',3),
        ('4',"Relaxed Left",'',4),
        ('5',"Point Left",'',5),
        ('6',"Fist Left",'',6),
        ('7',"Relaxed Right",'',7),
        ('8',"Point Right",'',8),
        ('9',"Fist Right",'',9),
        ('10',"Salute Right",'',10),
        ('11',"Typing",'',11),
        ('12',"Peace Right",'',12),
        ('13',"Palm Right",'',13),
        ]
    anim_hand_pose : bpy.props.EnumProperty(
        name = "Optional Hand Pose",
        description = "Optional hand pose during animation.",
        items = anim_hand_poses_menu,
        
        update = update_anim_all
        )

    def update_anim_joint_priority(self, context):
        bb_anim_edit = bpy.context.window_manager.bb_anim_edit
        bone = bb_anim_edit.anim_joint_name
        priority = bb_anim_edit.anim_joint_priority
        anim.props['anim_data']['joints'][bone]['joint_priority'] = priority
        bb_anim_edit["anim_joint_name"] = ""

    anim_joint_priority : bpy.props.IntProperty(
        name = "",
        description = "Alter priority for this joint",
        min = -1,
        max = 6,
        default = 0,
        update = update_anim_joint_priority
        )

    anim_joint_name : bpy.props.StringProperty(
        name = "",
        description = "--internal",
        default = "",
        )

class OnigiriAnimLoad(bpy.types.Operator, ImportHelper):
    """Make basic changes to your already saved anim file.  You can turn loop on
and off, change the loop range in/out, change ease in/out, change base priority
and all of the per-joint priorities"""

    bl_idname = "onigiri.load_anim"
    bl_label = "Load anim file"

    filename_ext = ".anim"
    filter_glob : bpy.props.StringProperty(
        default='*.anim',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        load_path = bpy.path.abspath("//")
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_anim_edit = bpy.context.window_manager.bb_anim_edit

        file_name = bpy.path.basename(self.properties.filepath)
        suffix_name = os.path.splitext(file_name)[0]
        file_in = self.properties.filepath

        anim.props['anim_data'] = anim.load_anim(file=file_in)

        print("file_name:", file_name)
        print("suffix_name:", suffix_name)
        print("file_in:", file_in)
       
        bb_anim_edit.anim_last_loaded = file_name

        bb_anim_edit["anim_base_priority"] = anim.props['anim_data']['header']['base_priority']
        bb_anim_edit["anim_loop_in_point"] = anim.props['anim_data']['header']['loop_in_point']
        bb_anim_edit["anim_loop_out_point"] = anim.props['anim_data']['header']['loop_out_point']
        bb_anim_edit["anim_loop"] = anim.props['anim_data']['header']['loop']
        bb_anim_edit["anim_ease_in_duration"] = anim.props['anim_data']['header']['ease_in_duration']
        bb_anim_edit["anim_ease_out_duration"] = anim.props['anim_data']['header']['ease_out_duration']
        bb_anim_edit["anim_hand_pose"] = anim.props['anim_data']['header']['hand_pose']

        return {'FINISHED'}

class OnigiriAnimSave(bpy.types.Operator, ExportHelper):
    """Save your altered anim file for use in Second Life"""

    bl_idname = "onigiri.save_anim"
    bl_label = "Save anim file"

    filename_ext = ".anim"
    filter_glob : bpy.props.StringProperty(
        default='*.anim',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_anim_edit = bpy.context.window_manager.bb_anim_edit

        if len(anim.props['anim_data']) == 0:
            print("No data to save")
            popup("No data to save, load a file first", "No data", "INFO")
            return {'FINISHED'}

        file_name = bpy.path.basename(self.properties.filepath)
        suffix_name = os.path.splitext(file_name)[0]
        file_out = self.properties.filepath

        print("file_name:", file_name)
        print("suffix_name:", suffix_name)
        print("file_out:", file_out)

        anim.save_anim(data=anim.props['anim_data'], file=file_out)

        return {'FINISHED'}

class OnigiriAnimReset(bpy.types.Operator):
    """Reset the buffer that contains the anim file.  The file is completely contained
inside ram and, while it's not very large, it stays until you restart blender, load
a new anim or reset it.  This is useful for cleaning up the UI when finished"""

    bl_idname = "onigiri.reset_anim"
    bl_label = "Reset anim file"

    @classmethod
    def poll(cls, context):
        if len(anim.props['anim_data']) == 0:
            return False
        return True

    def execute(self, context):
        bb_anim_edit = bpy.context.window_manager.bb_anim_edit

        anim.props['anim_data'] = {}
        bb_anim_edit.anim_last_loaded = ""

        return {'FINISHED'}

class OnigiriAnimUpdate(bpy.types.Operator):
    """--internal"""

    bl_idname = "onigiri.update_anim"
    bl_label = "Edit anim"

    def execute(self, context):
        bb_anim_edit = bpy.context.window_manager.bb_anim_edit

        anim.props['anim_data']['header']['base_priority'] = bb_anim_edit.anim_base_priority
        anim.props['anim_data']['header']['loop_in_point'] = bb_anim_edit.anim_loop_in_point
        anim.props['anim_data']['header']['loop_out_point'] = bb_anim_edit.anim_loop_out_point
        
        anim.props['anim_data']['header']['loop'] = bb_anim_edit.anim_loop
        anim.props['anim_data']['header']['ease_in_duration'] = bb_anim_edit.anim_ease_in_duration
        anim.props['anim_data']['header']['ease_out_duration'] = bb_anim_edit.anim_ease_out_duration
        anim.props['anim_data']['header']['hand_pose'] = bb_anim_edit.anim_hand_pose

        return {'FINISHED'}

class OnigiriAnimJointPriorityEdit(bpy.types.Operator):
    """Click this to enable editing the priority for this joint"""

    bl_idname = "onigiri.anim_joint_priority_edit"
    bl_label = "Reset anim file"

    bone : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(anim.props['anim_data']) == 0:
            return False
        return True

    def execute(self, context):
        bb_anim_edit = bpy.context.window_manager.bb_anim_edit

        bb_anim_edit.anim_joint_name = self.bone

        priority = anim.props['anim_data']['joints'][self.bone]['joint_priority']
        bb_anim_edit["anim_joint_priority"] = priority

        return {'FINISHED'}

class OnigiriAnimJointPriorityReset(bpy.types.Operator):
    """Click to reset all joint priorities to the base priority"""

    bl_idname = "onigiri.anim_reset_joint_priority"
    bl_label = "Reset to base"

    bone : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(anim.props['anim_data']) == 0:
            return False
        return True

    def execute(self, context):
        bb_anim_edit = bpy.context.window_manager.bb_anim_edit

        base_priority = anim.props['anim_data']['header']['base_priority']
        for bone in anim.props['anim_data']['joints']:
            anim.props['anim_data']['joints'][bone]['joint_priority'] = base_priority

        return {'FINISHED'}

class OnigiriPanelImport(bpy.types.Panel):
    """Import Tools"""
    bl_idname = "OBJECT_PT_bento_buddy_import"
    bl_label = "Import"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        row = self.layout.row(align=True)

        bb_import = bpy.context.scene.bb_import
        bb_devkit = bpy.context.scene.bb_devkit

        if bb_import.dae_import_menu_enabled == True:
            dae_import_menu_enabled_icon = "menu_opened"
        else:
            dae_import_menu_enabled_icon = "menu_closed"
        row.prop(
            bb_import,
            "dae_import_menu_enabled",
            toggle = True,
            text = "Dae Import",
            icon_value = ico.custom_icons[dae_import_menu_enabled_icon].icon_id
            )
        if bb_import.dae_import_menu_enabled == True:

            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.devkit_import",
                text="Import DAE DevKit",
                icon_value = ico.custom_icons["load"].icon_id
                )
            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.collada_import",
                text="Import DAE File",
                icon_value = ico.custom_icons["load"].icon_id
                )
            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bpy.context.scene.bb_import,
                "dae_rotate_collada",
                text="Rotate",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bpy.context.scene.bb_import,
                "dae_fix_scale",
                text="Fix Scale",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bpy.context.scene.bb_import,
                "dae_find_bone_chains",
                text="Find Chains",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )

            row = col.row(align=True)
            row.prop(
                bpy.context.scene.bb_devkit,
                "devkit_resize",
                text="Resize",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bpy.context.scene.bb_devkit,
                "devkit_connect",
                text="Connect",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bpy.context.scene.bb_devkit,
                "devkit_strip",
                text="Strip",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bpy.context.scene.bb_devkit,
                "devkit_align",
                text="Align",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bpy.context.scene.bb_devkit,
                "devkit_fix",
                text="Fix",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bpy.context.scene.bb_devkit,
                "devkit_match",
                text="Match",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )

        row = self.layout.row(align=True)
        bb_anim_edit = bpy.context.window_manager.bb_anim_edit
 
        if bb_anim_edit.anim_menu_enabled == True:
            anim_menu_enabled_icon = "menu_opened"
        else:
            anim_menu_enabled_icon = "menu_closed"

        row.prop(
            bb_anim_edit,
            "anim_menu_enabled",
            toggle = True,
            text = "Anim Editor",
            icon_value = ico.custom_icons[anim_menu_enabled_icon].icon_id
            )
        if bb_anim_edit.anim_menu_enabled == True:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)

            row.operator(
                "onigiri.load_anim",
                text="Load anim File",
                icon_value = ico.custom_icons["load"].icon_id
                )
            row.operator(
                "onigiri.save_anim",
                text="Save anim File",
                icon_value = ico.custom_icons["save"].icon_id
                )
            row.operator(
                "onigiri.reset_anim",
                text="Unload anim File",
                icon_value = ico.custom_icons["reset"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)

            if bb_anim_edit.anim_show_joints_menu_enabled == True:
                anim_show_joints_menu_enabled_icon = "menu_opened"
            else:
                anim_show_joints_menu_enabled_icon = "menu_closed"

            if len(anim.props['anim_data']) > 0:
                version = anim.props['anim_data']['header']['version']
                sub_version = anim.props['anim_data']['header']['sub_version']
                base_priority = anim.props['anim_data']['header']['base_priority']
                duration = anim.props['anim_data']['header']['duration']
                emote_name = anim.props['anim_data']['header']['emote_name']
                loop_in_point = anim.props['anim_data']['header']['loop_in_point']
                loop_out_point = anim.props['anim_data']['header']['loop_out_point']
                loop = anim.props['anim_data']['header']['loop']
                ease_in_duration = anim.props['anim_data']['header']['ease_in_duration']
                ease_out_duration = anim.props['anim_data']['header']['ease_out_duration']
                hand_pose = anim.props['anim_data']['header']['hand_pose']
                num_joints = anim.props['anim_data']['header']['num_joints']

                if emote_name == "": emote_name ="None"

                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = "Version:",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = str(version),
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                
                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = "Sub-Version:",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = str(sub_version),
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                
                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = "Base Priority:",
                    toggle = True,
                    icon_value = ico.custom_icons["edit"].icon_id
                    )
                row.prop(
                    bb_anim_edit,
                    "anim_base_priority",
                    text = " ",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                
                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = "Duration:",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = str(round(duration, 4)),
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                
                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = "Emote Name:",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = str(emote_name),
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                
                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = "Loop in point:",
                    toggle = True,
                    icon_value = ico.custom_icons["edit"].icon_id
                    )
                row.prop(
                    bb_anim_edit,
                    "anim_loop_in_point",
                    text = " ",
                    )
                
                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = "Loop out point:",
                    toggle = True,
                    icon_value = ico.custom_icons["edit"].icon_id
                    )
                row.prop(
                    bb_anim_edit,
                    "anim_loop_out_point",
                    text = " ",
                    )
                
                if loop: loop_enabled = "Yes"
                else: loop_enabled = "No"
                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = "Loop enabled:",
                    toggle = True,
                    icon_value = ico.custom_icons["edit"].icon_id
                    )
                row.prop(
                    bb_anim_edit,
                    "anim_loop",
                    text = loop_enabled,
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                
                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = "Ease in duration:",
                    toggle = True,
                    icon_value = ico.custom_icons["edit"].icon_id
                    )
                row.prop(
                    bb_anim_edit,
                    "anim_ease_in_duration",
                    text = " ",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                
                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    toggle = True,
                    text = "Ease out duration:",
                    icon_value = ico.custom_icons["edit"].icon_id
                    )
                row.prop(
                    bb_anim_edit,
                    "anim_ease_out_duration",
                    text = " ",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                
                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_hand_pose_enabled",
                    text = "Hand Pose:",
                    toggle = True,
                    icon_value = ico.custom_icons["edit"].icon_id
                    )
                
                row.prop(
                    bb_anim_edit,
                    "anim_hand_pose",
                    text = "",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                
                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = "Animated Joints:",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    text = str(num_joints),
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )

            if bb_anim_edit.anim_last_loaded != "":
                row = col.row(align=True)
                row.prop(
                    bb_anim_edit,
                    "anim_blank",
                    toggle = True,
                    text = bb_anim_edit.anim_last_loaded,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                col = box.column(align = True)

            row = col.row(align=True)
            row.prop(
                bb_anim_edit,
                "anim_show_joints_menu_enabled",
                toggle = True,
                text = "Edit Joints",
                icon_value = ico.custom_icons[anim_show_joints_menu_enabled_icon].icon_id
                )
            if bb_anim_edit.anim_show_joints_menu_enabled == True:
                row = col.row(align=True)
                row.operator(
                    "onigiri.anim_reset_joint_priority",
                    text="Reset all priorities to base",
                    icon_value = ico.custom_icons["reset"].icon_id
                    )
                
                if anim.props.get('anim_data') != None:
                    if anim.props['anim_data'].get('joints') != None:
                        for anim_joint in anim.props['anim_data']['joints']:
                            anim_joint_priority = anim.props['anim_data']['joints'][anim_joint]['joint_priority']
                            row = col.row(align=True)
                            row.prop(
                                bb_anim_edit,
                                "anim_blank",
                                toggle = True,
                                text = anim_joint,
                                icon_value = ico.custom_icons["edit"].icon_id
                                )
                            if anim_joint == bb_anim_edit.anim_joint_name:
                                row.prop(
                                    bb_anim_edit,
                                    "anim_joint_priority",
                                    text = " ",
                                    toggle = True,
                                    )
                            else:
                                row.operator(
                                    "onigiri.anim_joint_priority_edit",
                                    text = str(anim_joint_priority),
                                    icon_value = ico.custom_icons["blank"].icon_id
                                    ).bone = anim_joint

class OnigiriPanelDevKitTools(bpy.types.Panel):
    """Devkit DeGreaser"""

    bl_idname = "OBJECT_PT_bento_buddy_devkit_tools"
    bl_label = "Devkit Tools"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        bb_devkit = bpy.context.scene.bb_devkit

        layout = self.layout
        box = layout.box()

        col = box.column(align = True)
        row = col.row(align=True)

        row.operator("wm.url_open", text="Devkit Tools Help (website)").url = "http://critters.xyz/help/onigiri/devkit_tools.html"

        col = box.column(align = True)
        row = col.row(align=True)

        devkit_master_text = devkit.props['master_text']
        devkit_master_icon = devkit.props['master_icon']
        row.operator(
            "onigiri.devkit_master_set",
            text = devkit_master_text,
            icon_value = ico.custom_icons[devkit_master_icon].icon_id
            )
        row.operator(
            "onigiri.devkit_master_clear",
            text="",
            icon_value = ico.custom_icons["x_red"].icon_id
            )
        row = col.row(align=True)
        row.operator(
            "onigiri.devkit_combine",
            text="Combine Selected",
            icon_value = ico.custom_icons["blank"].icon_id
            )

        col = box.column(align = True)
        row = col.row(align=True)
        row.operator(
            "onigiri.devkit_reshape",
            text="Reshape Devkit",
            icon_value = ico.custom_icons["blank"].icon_id
            )

class OnigiriDevKitReshape(bpy.types.Operator):
    """This is a fix tool for Avastar rigs.  This is destructive and may not be compatible
with your existing content.  See (Mesh Export/Export Real Shape) for a full
description"""

    bl_idname = "onigiri.devkit_reshape"
    bl_label = "Reshape Devkit"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            return False

        armObj = utils.has_armature()
        if armObj == False:
            return False
        if armObj.get('bb_collada_matrices') == None:
            return False

        return True

    def execute(self, context):
        
        armObj = utils.has_armature()

        transforms = armObj.get('bb_collada_matrices')
        if transforms == None:
            print("INIT: OnigiriDevkitReshape reports : no matrices on the armature object")
        else:
            matrices = {}
            for bone in transforms['bind_data']:
                mat = mathutils.Matrix(transforms['bind_data'][bone]).inverted()
                matrices[bone] = mat

        print("Reshaping devkit armature...")
        result = devkit.reshape(armObj, matrices=matrices, rotate=True, copy=True, delete=False, report=True)
        if result == False:
            popup("Devkit repair failed")

        return {'FINISHED'}

class OnigiriDevKitMasterSet(bpy.types.Operator):
    """Each devkit has a set of rules for export.  Some hands are separate and require
a different set of rules.  This tool makes its own rules.  Put your hands back where
they belong.  The master is almost always the body, choose one and click"""

    bl_idname = "onigiri.devkit_master_set"
    bl_label = "Set Devkit Master"

    @classmethod
    def poll(cls, context):
        devkit.props['master_text'] = "Set Master"
        devkit.props['master_icon'] = "dot_black"
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            return False
        armObj = utils.has_armature()
        if armObj == False:
            return False
        if armObj.get('bb_collada_matrices') == None:
            return False
        if armObj.get('bb_devkit_master') != None:
            devkit.props['master_icon'] = "dot_green"
            devkit.props['master_text'] = "Master: " + armObj.name
            return False
        return True

    def execute(self, context):
        
        armObj = utils.has_armature()
        armObj['bb_devkit_master'] = True
        print("Set", armObj.name, "as devkit master.")
        return {'FINISHED'}

class OnigiriDevKitMasterClear(bpy.types.Operator):
    """Clear out the "master" bit for the selected kit"""

    bl_idname = "onigiri.devkit_master_clear"
    bl_label = "Clear Devkit Master"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        return True

    def execute(self, context):
        removed = set()
        for o in bpy.context.selected_objects:
            armObj = utils.has_armature(object=o)
            if armObj != False:
                if armObj.get('bb_devkit_master'):
                    del armObj['bb_devkit_master']
                    removed.add(armObj.name)
        if len(removed) > 0:
            print("Removed the following as masters:")
            for m in removed:
                print(" -", m)
        else:
            print("None of the selected objects were masters")

        return {'FINISHED'}

class OnigiriDevKitCombine(bpy.types.Operator):
    """After choosing a master and enabling it select all the other kits associated
with it, hands/feet etc., as well as the master and then click this.  This is
destructive, save your work!  This can fail badly!"""

    bl_idname = "onigiri.devkit_combine"
    bl_label = "Combine Devkits"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) < 2:
            return False
        return True

    def execute(self, context):
        
        arms = set()
        selected = bpy.context.selected_objects
        for o in selected:
            if o.type == 'ARMATURE':
                arms.add(o)

        for o in bpy.context.selected_objects:
            o.select_set(False)

        master_count = 0
        for o in arms:
            if o.get('bb_devkit_master'):
                master_count += 1
                
                masterObj = o
        if master_count > 1:
            print("Too many devkit masters, we want one but got", master_count)
            popup("Too many devkit masters", "Error", "ERROR")
            return {'FINISHED'}

        all_mesh = [] 
        rig_to_mesh = {}
        for o in arms:
            m = rigutils.get_associated_mesh(o)
            mesh = [n.name for n in m] 
            all_mesh.extend(mesh)
            rig_to_mesh[o.name] = set(mesh)

        print("Master rig:", masterObj.name)
        print("Qualified mesh:")
        for m in all_mesh:
            print(" -", m)

        result = rigutils.make_complete(
            armature=masterObj, connect=False,
            rotate=True, fix=True,
            strip=False, resize=True)

        for mesh in all_mesh:
            meshObj = bpy.data.objects[mesh]
            meshObj.select_set(True)
            utils.activate(meshObj)
            utils.remove_empty_groups(mesh)
            meshObj.select_set(False)

        mesh_groups = {}
        for arm in rig_to_mesh:
            armObj = bpy.data.objects[arm]
            for mesh in rig_to_mesh[arm]:
                meshObj = bpy.data.objects[mesh]
                vGroups = meshObj.vertex_groups
                groups = set()
                
                for G in vGroups:
                    if G.name in armObj.data.bones:
                        groups.add(G.name)
                if len(groups) == 0:
                    print("No qualified vertex groups for", mesh)
                else:
                    mesh_groups[mesh] = groups

        template_map = {}
        for arm in rig_to_mesh:
            if arm == masterObj.name:
                continue
            mesh = rig_to_mesh[arm]
            print("mesh:", mesh)
            for m in mesh:
                groups = mesh_groups[m]
                print("groups:", groups)
                for g in groups:
                    if g in masterObj.data.bones:
                        template_map[g] = arm

        print("The following armature bones will be altered in the master:")
        for bone in template_map:
            print("bone:", bone, "- armature:", template_map[bone])

        bad_devkits = []
        master_matrices = masterObj['bb_collada_matrices'].to_dict()
        for arm in rig_to_mesh:
            if arm == masterObj.name:
                continue
            armObj = bpy.data.objects[arm]
            if armObj.get('bb_collada_matrices') == None:
                bad_devkits.append(arm)
                continue
            
            matrices = armObj['bb_collada_matrices'].to_dict()
            for bone in matrices['bind_data']:
                if bone in template_map:
                    master_matrices['bind_data'][bone] = matrices['bind_data'][bone]
            for bone in matrices['bone_data']:
                if bone in template_map:
                    master_matrices['bone_data'][bone] = matrices['bone_data'][bone]
            for bone in matrices['real_data']:
                if bone in template_map:
                    master_matrices['real_data'][bone] = matrices['real_data'][bone]
        if len(bad_devkits) > 0:
            print("Some devkit parts did not have corrective data associated with them.")
            print("To fix this make sure you've applied a devkit preset while it is selected")
            print("or make sure you've imported a DAE devkit and you may wish to save that")
            print("devkit preset for later in the (Mesh Export) section.  The following")
            print("armatures associated with your devkits contained no corrective data:")
            for d in bad_devkits:
                print(" -", d)

        masterObj.select_set(True)
        utils.activate(masterObj)
        bpy.ops.object.mode_set(mode='EDIT')
        for bone in template_map:
            arm = template_map[bone]
            tarmObj = bpy.data.objects[arm]
            if bone not in masterObj.data.bones:
                continue
            boneObj = masterObj.data.edit_bones[bone]
            tmw = tarmObj.matrix_world
            head = tarmObj.data.bones[bone].head_local.copy()
            tail = tarmObj.data.bones[bone].tail_local.copy()
            
            boneObj.head = head
            boneObj.tail = tail
        bpy.ops.object.mode_set(mode='OBJECT')
        del masterObj['bb_devkit_master']

        masterObj.select_set(False)
        for arm in rig_to_mesh:
            if arm == masterObj.name:
                continue
            for mesh in rig_to_mesh[arm]:
                meshObj = bpy.data.objects[mesh]
                meshObj.select_set(True)
                utils.activate(meshObj)
                bpy.ops.object.parent_clear(type='CLEAR_KEEP_TRANSFORM')
                meshObj.select_set(False)
                for modObj in meshObj.modifiers:
                    if modObj.type == 'ARMATURE':
                        modObj.object = masterObj

        armObj = None
        for arm in rig_to_mesh:
            armObj = bpy.data.objects[arm]
            if arm == masterObj.name:
                continue
            armObj.select_set(True)
        utils.activate(armObj)
        bpy.ops.object.delete()

        masterObj.select_set(True)
        utils.activate(masterObj)

        print("Devkit Composer Finished!")

        return {'FINISHED'}

class CharacterConverterExport(bpy.types.Operator, ExportHelper):
    """Export your custom mesh for use in Second Life and Opensim.  You may want to
try the "Mesh Export" panel with "Rig Pose" enabled, if you discover deformities in
your mesh.  This exporter will be discontinued soon.
"""

    bl_idname = "onigiri.character_converter_export"
    bl_label = "Character Converter Exporter"

    filename_ext = ".dae"
    filter_glob : bpy.props.StringProperty(
        default='*.dae',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        
        if len(bpy.context.selected_objects) == 0:
            return False
        
        for mesh in bpy.context.selected_objects:
            if mesh.type == 'MESH':
                return True
        return False

    def execute(self, context):
        ccp = bpy.context.window_manager.cc_props
        bb_mesh = bpy.context.scene.bb_mesh

        original_selection = list(bpy.context.selected_objects)
        
        active_object = bpy.context.active_object

        print("original_selection", original_selection)

        for Obj in bpy.context.selected_objects:
            Obj.select_set(False)
        
        if bpy.context.mode == 'POSE':
            print("=================================================")
            print("found sticky armature in pose mode")
            print("=================================================")
            
            bpy.ops.object.mode_set(mode='OBJECT')
        
        for Obj in original_selection:
            Obj.select_set(True)

        selected = {}

        for meshObj in bpy.context.selected_objects:
            if meshObj.type != 'MESH':
                continue
            for mod in meshObj.modifiers:
                if mod.type == 'ARMATURE':
                    
                    print("Export skinned mesh is checking if there's already an ARMATURE modifier for", meshObj.name)
                    if meshObj.name in selected:
                        txt = "One of your selected mesh objects has more than one armature modifier: " + meshObj.name
                        print(txt)
                        popup(txt, "Error", "ERROR")
                        return {'FINISHED'}

                    selected[meshObj.name] = meshObj.modifiers[mod.name].object.name

        bpy.ops.object.select_all(action='DESELECT')

        temp_selected = {} 
        delete_list = [] 
        for mesh in selected:
            meshObj = bpy.data.objects[mesh]
            arm = selected[mesh]
            armObj = bpy.data.objects[arm]

            armObj.select_set(True)
            meshObj.select_set(True)

            bpy.ops.object.duplicate()

            if len(bpy.context.selected_objects) < 2:
                print("-------------------------------------------")
                print("I may have had trouble finding the rig associated with your armature modifier")
                print("selected count:", len(bpy.context.selected_objects))
                print("-------------------------------------------")
                print("Expected the following to be selected [arm/mesh]:", arm, mesh)

            delete_list.extend(bpy.context.selected_objects)

            obA, obB = bpy.context.selected_objects

            if obA.type == 'MESH':
                temp_selected[obA.name] = obB.name
                
                meshObj = obA
                armObj = obB
            else:
                temp_selected[obB.name] = obA.name
                meshObj = obB
                armObj = obA

            bpy.ops.object.select_all(action='DESELECT')

            armObj.select_set(True)
            bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
            bpy.ops.object.select_all(action='DESELECT')
            meshObj.select_set(True)
            bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
            bpy.ops.object.select_all(action='DESELECT')

            armObj.select_set(True)
            
            old_rotation_mode = armObj.rotation_mode

            armObj.rotation_mode = 'XYZ'
            armObj.rotation_euler = (0.0, 0.0, 1.5708)
            bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
            bpy.ops.object.select_all(action='DESELECT')
            meshObj.select_set(True)
            bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
            
            armObj.rotation_mode = old_rotation_mode

            bpy.ops.object.select_all(action='DESELECT')

        mesh_problems = dict()

        for mesh in temp_selected:
            meshObj = bpy.data.objects[mesh]
            meshObj.select_set(True)

            bpy.context.view_layer.objects.active = meshObj

            joint_count = len(meshObj.vertex_groups)
            if joint_count > bb_settings['sl_joint_total']: 
                txt = "Mesh error: " + "[" + meshObj.name + "]"                + "total bones exceeded, wanted " + str(bb_settings['sl_joint_total']) + " but got " + str(joint_count)
                mesh_problems.update({meshObj.name : txt})

        file_path = tempfile.gettempdir() + "/onigiri_" + get_unique_name_short() + ".dae"

        bb_mesh = bpy.context.scene.bb_mesh

        bpy.ops.wm.collada_export(
            filepath = file_path,
            check_existing = True,
            apply_modifiers = bb_mesh.export_apply_modifiers,
            selected = True,
            include_children = False,
            include_armatures = True,
            include_shapekeys = False,
            include_animations=False,
            deform_bones_only = True,
            triangulate = False,
            use_object_instantiation = False,
            use_blender_profile = True,
            sort_by_name = True,
            export_object_transformation_type_selection = 'matrix',
            open_sim = True,
            )

        bpy.ops.object.select_all(action='DESELECT')
        for obj in delete_list:
            obj.select_set(True)
        bpy.ops.object.delete()

        bpy.ops.object.select_all(action='DESELECT')

        for obj in original_selection:
            obj.select_set(True)
        
        bpy.context.view_layer.objects.active = active_object

        file_in = file_path
        file_out = self.properties.filepath

        if bb_mesh.process_volume_bones == 1:

            ET.register_namespace('',"http://www.collada.org/2005/11/COLLADASchema")
            tree = ET.parse(file_in)
            root = tree.getroot()

            print("Converting dae file:", file_in)
            controllers = fix_bind_matrices(root, transform=1)
            
            condition_matrices(controllers)

            print("BB finished adjusting matrices, writing dae file:", file_out)
            tree.write(file_out,
                xml_declaration = True,
                encoding = 'utf-8',
                method = 'xml'
                )
            try:
                os.remove(file_path)
                print("BB dae cleanup")
            except:
                print("BB Warning: unable to remove temporary file:", file_path)
        else:
            
            shutil.copyfile(file_in, file_out)

        return {'FINISHED'}

class OnigiriRemoveConstraintsOperator(bpy.types.Operator):
    """Remove constraints from the selected bones if you're in pose mode or from
all bones if you're NOT in pose mode"""

    bl_idname = "onigiri.remove_constraints_operator"
    bl_label = "Remove Constraints"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        armObj = bpy.context.selected_objects[0]
        utils.activate(armObj)
        if bpy.context.mode == 'POSE':
            for boneObj in bpy.context.selected_pose_bones:
                
                for pbC in boneObj.constraints:
                    boneObj.constraints.remove(pbC)
        else:
            for boneObj in armObj.pose.bones:
                
                for pbC in boneObj.constraints:
                    boneObj.constraints.remove(pbC)
        return {'FINISHED'}

class OnigiriRemoveControlRigOperator(bpy.types.Operator):
    """Remove the control rig from the selected / active armature.  This is a legacy
feature and is still present to allow you to clean up old rigs but it will vanish
eventually"""

    bl_idname = "onigiri.remove_control_rig"
    bl_label = "Remove Control Rig"

    @classmethod
    def poll(cls, context):
        amount_sel = len(bpy.context.selected_objects)
        if amount_sel > 1:
            return False
        if amount_sel == 0:
            return False
        obj = bpy.context.selected_objects[0]
        if obj.get('onigiri_control_rig') != 1:
            return False
        if obj.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):

        armObj = bpy.context.active_object
        armObj.select_set(True)

        if armObj.get('onigiri_control_rig') != 1:
            return False

        bpy.context.object.data.layers[bb_vbones_layer] = True
        bpy.context.object.data.layers[bb_mbones_layer] = True
        bpy.context.object.data.layers[bb_base_layer] = True

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action = 'SELECT')
        bpy.ops.pose.constraints_clear()
        bpy.ops.pose.select_all(action = 'DESELECT')

        bpy.ops.object.mode_set(mode='EDIT')
        for bone in armObj.data.edit_bones:
            if bone.name in cr_bones_hash:
                armObj.data.edit_bones.remove(bone)
        bpy.ops.object.mode_set(mode='OBJECT')
        
        print("Removing (onigiri_control_rig) property, do I actually need to do this or set to 0 ?")
        del bpy.context.active_object['onigiri_control_rig']
        print("Removed control rig from:", bpy.context.active_object.name)

        return {'FINISHED'}

class OnigiriLoadReferenceMap(bpy.types.Operator, ImportHelper):
    """You only need to load a template if source armature bones do not match those of
the target.  A map is typically used when the target rig/character has not been converted
yet and is useful for retargeting"""

    bl_idname = "onigiri.load_reference_map"
    bl_label = "Load reference map"

    filter_glob : bpy.props.StringProperty(
        default='*.ctm',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        bbp = bpy.context.scene.bb_anim_props
        if bbp.get('source_armature') == None:
            return False
        if bbp.get('target_armature') == None:
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb_anim = bpy.context.scene.bb_anim_props
        sarm = bb_anim['source_armature']
        tarm = bb_anim['target_armature']

        file = self.properties.filepath
        template_map = {}
        try:
            namespace = {}
            exec(open(file, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("There was a problem reading your CTM file, the following trace might give a clue what happened")
            print(traceback.format_exc())
            return {'FINISHED'}

        try:
            template_map.update(namespace['template_map'])
        except:
            print("the template map is missing in the ctl, did you load the correct file?")
            popup("Missing template map", "No Template", "ERROR")
            return {'FINISHED'}

        targets = {}
        for sbone in template_map:
            (tarm, tbone), = template_map[sbone].items()
            targets[tarm] = ""
        tlen = len(targets)
        if tlen == 0:
            print("template_map", template_map)
            print("There's no targets in the template_map")
            popup("Missing target, see console", "Error", "ERROR")
            return {'FINISHED'}
        if tlen > 1:
            print("template_map", template_map)
            print("There are mutlple targets in the template_map.  While the CTM format supports this the tool you")
            print("are using does not and adding that feature would be more complicated than it's worth.  Your solution")
            print("is to split this map up into as many targets using the template tools and match one at a time")
            popup("Multiple targets are not supported with this tool, see console", "Error", "ERROR")
            return {'FINISHED'}

        bb_anim['template_map'] = template_map

        return {'FINISHED'}

class OnigiriMatchPose(bpy.types.Operator):
    """Match the chosen rig to the SL source for better alignment, in-world existing
animations and retargeting.  This is restricted to SL matching since a custom target
would have to be mapped or present but I can update this later to include that"""

    bl_idname = "onigiri.match_pose"
    bl_label = "Match Pose To Source"

    @classmethod
    def poll(cls, context):
        bbp = bpy.context.scene.bb_anim_props
        if bbp.get('source_armature') == None:
            return False
        if bbp.get('target_armature') == None:
            return False
        return True

    def execute(self, context):
        bb_anim = bpy.context.scene.bb_anim_props
        obj = bpy.data.objects
        sarm = bb_anim['source_armature']
        tarm = bb_anim['target_armature']

        if bpy.context.mode == 'EDIT_ARMATURE':
                old_mode = 'EDIT'
        else:
            old_mode = bpy.context.mode
        
        bone_map = {}
        selected_pose_bones = list()

        if bpy.context.mode == 'POSE':
            selected_pose_bones = [a.name for a in bpy.context.selected_pose_bones]

        bpy.ops.object.mode_set(mode='OBJECT')
        obj[tarm].select_set(True)
        bpy.context.view_layer.objects.active = obj[tarm]
        bpy.ops.object.mode_set(mode='POSE')
        for boneObj in obj[tarm].data.bones:
            boneObj.select = True
        bpy.ops.pose.transforms_clear()
        for boneObj in obj[tarm].data.bones:
            boneObj.select = False

        if bb_anim.get('template_map') != None:

            template_map = bb_anim['template_map'].to_dict()
            for sbone in template_map:
                (trig, tbone), = template_map[sbone].items()
                
                if tbone not in obj[tarm].data.bones:
                    continue
                if sbone not in obj[sarm].data.bones:
                    continue
                if bb_anim.match_pose_selected == True:
                    if tbone in selected_pose_bones:
                        bone_map[sbone] = tbone
                else:
                    bone_map[sbone] = tbone
        else:
            
            for boneObj in obj[tarm].data.bones:
                if boneObj.name in obj[sarm].data.bones:
                    if bb_anim.match_pose_selected == True:
                        if boneObj.name in selected_pose_bones:
                            bone_map[boneObj.name] = boneObj.name
                    else:
                        bone_map[boneObj.name] = boneObj.name

        roots = list()
        for boneObj in obj[sarm].data.bones:
            if boneObj.parent:
                continue
            roots.append(boneObj.name)

        for sbone in bone_map:
            
            if bb_anim.match_root_bones == False:
                if sbone in roots:
                    continue
            tbone = bone_map[sbone]

            obj[tarm].data.bones.active = obj[tarm].data.bones[tbone]
            bc = bpy.data.objects[tarm].pose.bones[tbone].constraints
            bc.new('COPY_ROTATION')
            bc['Copy Rotation'].target = obj[sarm]
            bc['Copy Rotation'].subtarget = sbone
            bc['Copy Rotation'].target_space = 'WORLD'
            bc['Copy Rotation'].owner_space = 'WORLD'
            bc['Copy Rotation'].influence = 1
            if bb_anim.match_x_axis == False:
                bc['Copy Rotation'].use_x = False
            if bb_anim.match_y_axis == False:
                bc['Copy Rotation'].use_y = False
            if bb_anim.match_z_axis == False:
                bc['Copy Rotation'].use_z = False
            bc['Copy Rotation'].name = "BB Copy Rot"

        bpy.context.view_layer.update()

        pose_mats = dict()
        for boneObj in obj[tarm].pose.bones:

            pose_mats[boneObj.name] = boneObj.matrix.copy()

        for boneObj in obj[tarm].pose.bones:
            for cObj in boneObj.constraints:
                if cObj.name == 'BB Copy Rot':
                    boneObj.constraints.remove(cObj)

        bpy.context.view_layer.update()

        for sbone in bone_map:
            
            if bb_anim.match_root_bones == False:
                if sbone in roots:
                    continue
            tbone = bone_map[sbone]
            obj[tarm].pose.bones[tbone].matrix = pose_mats[tbone]
            bpy.context.view_layer.update()

        del pose_mats

        bpy.ops.pose.select_all(action = 'DESELECT')
        for bone in selected_pose_bones:
            obj[tarm].data.bones[bone].select = True

        bpy.ops.object.mode_set(mode=old_mode)

        return {'FINISHED'}

class OnigiriMatchPoseReset(bpy.types.Operator):
    """Reset the pose matcher.
"""

    bl_idname = "onigiri.match_pose_reset"
    bl_label = "Reset loaded template"

    def execute(self, context):
        bbp = bpy.context.scene.bb_anim_props

        bbp.property_unset("lock_source_armature")
        bbp.property_unset("lock_target_armature")

        if bbp.get('source_armature') != None:
            del bbp['source_armature']
        if bbp.get('target_armature') != None:
            del bbp['target_armature']
        if bbp.get('tempmlate_map'):
            del bbp['template_map']
        return {'FINISHED'}

class OnigiriCreateReferencePoseOperator(bpy.types.Operator):
    """Create a reference pose on the start frame of your animation or, if there
is no animation, on the start frame of the scene"""

    bl_idname = "onigiri.create_reference_pose"
    bl_label = "Create reference pose"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        
        if o.animation_data == None:
            return True
        if o.animation_data.action == None:
            return True
        
        if o.get('reference') != None:
            return False
        return True

    def execute(self, context):
        bb_anim = bpy.context.scene.bb_anim_props
        armObj = bpy.context.selected_objects[0]

        if armObj.get('reference') != None:
            print("A reference pose has already been set, use (restore) before trying again")
            popup("A reference pose has already been set, use (restore) then try again", "Error", "ERROR")
            return {'FINISHED'}

        bpy.context.view_layer.objects.active = armObj
        obj = bpy.data.objects
        tarm = armObj.name

        bpy.context.view_layer.update()
        current_frame = bpy.context.scene.frame_current

        if bpy.context.mode == 'EDIT_ARMATURE':
            
                old_mode = 'EDIT'
        else:
            old_mode = bpy.context.mode

        bpy.ops.object.mode_set(mode='POSE')

        selected_pose_bones = [a.name for a in bpy.context.selected_pose_bones]

        pose_mats = {}
        for boneObj in armObj.pose.bones:
            
            pose_mats[boneObj.name] = boneObj.matrix.copy()

        armObj['reference'] = pose_mats

        if 1 == 0:
            
            bpy.context.scene.frame_set(bpy.context.scene.frame_start)
            
            start_frame = bpy.context.scene.frame_start
        else:
            start_frame, end_frame = animutils.get_frame_range(armObj, start=True, end=False)
            print("Create reference frame picks up start frame as", start_frame)

        if armObj.animation_data != None:

            anim = armObj.animation_data
            
            move_to = (start_frame + 1)

            if anim.action != None:
                print("moving animation")
                for fcurve in anim.action.fcurves:
                    for point in fcurve.keyframe_points:
                        
                        point.co.x += 1 

        if bb_anim.reference_from_pose == True:

            print("from current pose")

            for bone in pose_mats:
                armObj.pose.bones[bone].matrix = pose_mats[bone]
                bpy.context.view_layer.update()

            print("Klude for broken matrix update - see notes")
            for boneObj in armObj.pose.bones:
                if boneObj.name in pose_mats:
                    boneObj.matrix = pose_mats[boneObj.name]
                    bpy.context.view_layer.update()

        else:
            
            print("from custom pose properties")

            if bb_anim.pose_clear_location == True:
                for boneObj in armObj.data.bones:
                    if boneObj.parent:
                        boneObj.select = True
                    else:
                        boneObj.select = False
                bpy.ops.pose.loc_clear()
            
            if bb_anim.pose_clear_location_root == True:
                for boneObj in armObj.data.bones:
                    if boneObj.parent:
                        boneObj.select = False
                    else:
                        boneObj.select = True
            
            for boneObj in armObj.data.bones:
                boneObj.select = True
            bpy.ops.pose.rot_clear()
            
        for boneObj in armObj.pose.bones:
            if 1 == 0:
                if armObj.animation_data != None:
                    print("MARK: Animation should have been moved at this point")
                    boneObj.keyframe_insert(data_path="rotation_quaternion", frame=start_frame)
                    boneObj.keyframe_insert(data_path="rotation_euler", frame=start_frame)
                    boneObj.keyframe_insert(data_path="location", frame=start_frame)
                else:
                    boneObj.keyframe_insert(data_path="rotation_quaternion", frame=bpy.context.scene.frame_start)
                    boneObj.keyframe_insert(data_path="rotation_euler", frame=bpy.context.scene.frame_start)
                    boneObj.keyframe_insert(data_path="location", frame=bpy.context.scene.frame_start)
            else:
                boneObj.keyframe_insert(data_path="rotation_quaternion", frame=start_frame)
                boneObj.keyframe_insert(data_path="rotation_euler", frame=start_frame)
                boneObj.keyframe_insert(data_path="location", frame=start_frame)

        bpy.context.view_layer.update()
        
        del pose_mats

        bpy.ops.pose.select_all(action = 'DESELECT')
        for bone in selected_pose_bones:
            armObj.data.bones[bone].select = True

        bpy.ops.object.mode_set(mode=old_mode)

        armObj['bb_reference_frame'] = (start_frame + 1)

        return {'FINISHED'}

class OnigiriRestoreReferencePoseOperator(bpy.types.Operator):
    """If you've created a reference pose using this interface then you can restore to where
you were before that using this button.  You will have to do this before attempting to create
another reference pose using this method"""

    bl_idname = "onigiri.restore_reference_pose"
    bl_label = "Restore reference pose"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        if bpy.context.selected_objects[0].get('reference') == None:
            return False
        return True

    def execute(self, context):
        bb_anim = bpy.context.scene.bb_anim_props
        armObj = bpy.context.selected_objects[0]

        if armObj.get('reference') == None:
            print("A reference pose has not been set so cannot be restored")
            popup("A reference pose has not been set, so cannot be restored", "Error", "ERROR")
            return {'FINISHED'}

        if armObj.animation_data == None:
            print("There is animation data associated with the chosen object, so nothing to do")
            armObj.pop('reference', "")
            popup("A reference pose is an animation but there is no animation on the object")
            return {'FINISHED'}
        if armObj.animation_data.action == None:
            print("There is acton associated with the chosen object, so nothing to do")
            armObj.pop('reference', "")
            popup("A reference pose is an animation but there is no action on the object")
            return {'FINISHED'}

        bpy.context.view_layer.objects.active = armObj
        obj = bpy.data.objects
        tarm = armObj.name

        bpy.context.view_layer.update()
        current_frame = bpy.context.scene.frame_current

        if context.mode == 'EDIT_ARMATURE':
            
                old_mode = 'EDIT'
        else:
            old_mode = context.mode

        start_frame, stop_frame = armObj.animation_data.action.frame_range
        
        if start_frame == None:
            start_frame = 1
        bpy.context.scene.frame_set(start_frame)

        bpy.ops.object.mode_set(mode='POSE')

        selected_pose_bones = [a.name for a in bpy.context.selected_pose_bones]

        if armObj.get('bb_reference_frame') != None:
            start_frame = armObj['bb_reference_frame']

        for boneObj in armObj.pose.bones:
            dBone = boneObj.bone
            dBone.select = True
            try:
                boneObj.keyframe_delete(data_path="location", frame=start_frame)
            except:
                print("No action or no location data, moving on...")
            try:
                boneObj.keyframe_delete(data_path="rotation_euler", frame=start_frame)
            except:
                print("No action or no Euler data, moving on...")
            try:
                boneObj.keyframe_delete(data_path="rotation_quaternion", frame=start_frame)
            except:
                print("No action or no quaternion data, moving on...")
            try:
                boneObj.keyframe_delete(data_path="scale", frame=start_frame)
            except:
                print("No action or no scale data, moving on...")
            dBone.select = False

        has_curves = False
        anim = armObj.animation_data
        if anim != None:
            if anim.action != None:
                if anim.action.fcurves:
                    has_curves = True
        if has_curves == True:
            move_to = start_frame - 1
            print("moving animation back")
            for fcurve in anim.action.fcurves:
                for point in fcurve.keyframe_points:
                    point.co.x += move_to

        bpy.ops.pose.select_all(action = 'DESELECT')
        for bone in selected_pose_bones:
            armObj.data.bones[bone].select = True

        bpy.ops.object.mode_set(mode=old_mode)

        del armObj['reference']
        armObj.pop('bb_reference_frame', '')

        return {'FINISHED'}

class OnigiriFixFlags(bpy.types.Operator):
    """During debug mode the flags can become corrupted.  This will load them back
    from the module in order to continue testing, at least for a while
    """
    bl_idname = "onigiri.fix_flags"
    bl_label = "Fix Onigiri Flags"

    def execute(self, context):
        importlib.reload(mod_flags)
        return {'FINISHED'}

class OnigiriCopykeyFrame(bpy.types.Operator):
    @classmethod
    def poll(cls, context):
        
        active = bpy.context.active_object
        if active == None:
            return False
        if active.type != 'ARMATURE':
            return False
        action = getattr(active.animation_data, "action", None)

        if action is None:
            return False
        
        if len(bpy.context.selected_objects) != 1:
            return False

        return True

    def execute(self, context):
        armObj = bpy.context.active_object
        action = armObj.animation_data.action.name
        start_frame, end_frame = armObj.animation_data.action.frame_range

        if context.mode == 'EDIT_ARMATURE':
            
                old_mode = 'EDIT'
        else:
            old_mode = context.mode

        bpy.ops.object.mode_set(mode='POSE')

        return {'FINISHED'}

class OnigiriScaleAnimationOperator(bpy.types.Operator):
    """ Scale your current animation to fit between the time line indicated above """
    bl_idname = "onigiri.scale_animation"
    bl_label = "Scale Animation"

    @classmethod
    def poll(cls, context):
        
        active = bpy.context.active_object
        if active == None:
            return False
        if active.type != 'ARMATURE':
            return False
        action = getattr(active.animation_data, "action", None)

        if action is None:
            return False
        
        sel_len = len(bpy.context.selected_objects)
        if sel_len != 1:
            return False
        getattr(bpy.context.scene.bb_anim_props, "trigger_scale_frames_access", False)
        return True

    def execute(self, context):
        arm = bpy.context.active_object.name
        current_first_frame, current_last_frame = bpy.data.objects[arm].animation_data.action.frame_range
        current_total = current_last_frame - current_first_frame

        scale_first_frame = bpy.context.scene.bb_anim_props.scale_first_frame
        scale_last_frame = bpy.context.scene.bb_anim_props.scale_last_frame
        scale_total = scale_last_frame - scale_first_frame

        if scale_total == current_total:
            print("Same total for both, no scale required.")
            popup("Same number of frames, no scale required")
            return {'FINISHED'}

        if current_total > scale_total:
            scale_by = scale_total / current_total
        else:
            scale_by = current_total / scale_total

        if context.mode == 'EDIT_ARMATURE':
            
                old_mode = 'EDIT'
        else:
            old_mode = context.mode

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action = 'SELECT')

        bpy.context.view_layer.update()

        for channel in bpy.data.objects[arm].animation_data.action.fcurves:
            for key in channel.keyframe_points:
                key.select_control_point = True
                key.select_left_handle = True
                key.select_right_handle = True

        old_type = bpy.context.area.type
        bpy.context.area.type = 'GRAPH_EDITOR'

        bpy.ops.graph.interpolation_type(type='BEZIER')
        bpy.context.scene.frame_current = current_first_frame
        bpy.ops.transform.resize(value=(scale_by, 1, 1))
        bpy.context.area.type = old_type

        current_first_frame = bpy.data.objects[arm].animation_data.action.frame_range[0]
        frame_offset = scale_first_frame - current_first_frame

        for fcurve in bpy.data.objects[arm].animation_data.action.fcurves:
            for point in fcurve.keyframe_points:
                
                point.co.x += frame_offset

        bpy.ops.object.mode_set(mode=old_mode)
        return {'FINISHED'}

class OnigiriAnimationProperties(bpy.types.PropertyGroup):

    rebind_keep_animation : bpy.props.BoolProperty(
        name = "",
        description =            "Keep the associated animation after rebinding.  This can cuase an issue but you can prepare your mesh and rig "            "beforehand in order to prevent distorion",
        default = True,
        )

    reference_pose_menu_enabled : bpy.props.BoolProperty(
        description =            "Expand the reference pose options",
        default = False,
        )

    pose_clear_location : bpy.props.BoolProperty(
        name = "Clear location data",
        description =        "\n"        "This is almost never what you want but custom characters with animated bone locations (translations) can benefit from this "        "being reset."        "\n",
        default = False,
        )
    pose_clear_location_root : bpy.props.BoolProperty(
        name = "Clear location data from root bones",
        description =        "\n"        "This is even more unusual and could break your rig, make sure you save first.  This will clear the location data from "        "all root bones, pelvis and hip(s) are usually root."        "\n",
        default = False,
        )

    reference_from_pose : bpy.props.BoolProperty(
        name = "From current pose",
        description =        "\n"        "Create your reference pose from the current pose instead of the rest pose, which gives you more control, "        "basically what you see is what you get so give your character a pose, save it for later as well in the pose "        "library, enable this feature and hit the button."        "\n",
        default = False,
        )
    def update_lock_source_armature(self, context):
        bbp = bpy.context.scene.bb_anim_props
        if bbp.lock_source_armature == True:
            if len(bpy.context.selected_objects) == 0 or len(bpy.context.selected_objects) > 1:
                print("Only 1 object can be selected to use this feature")
                
                bbp.property_unset("lock_source_armature")
                return
            if bpy.context.selected_objects[0].type != 'ARMATURE':
                print("Must be an armature")
                bbp.property_unset("lock_source_armature")
                return
            target = bbp.get('target_armature', None)
            if bpy.context.selected_objects[0].name == target:
                print("Source cannot be the same as the target")
                bbp.property_unset("lock_source_armature")
                return
            bbp['source_armature'] = bpy.context.selected_objects[0].name
            print("Source Locked!", bbp['source_armature'])
        else:
            if bbp.get('source_armature') != None:
                print("Un-Locked!", bbp['source_armature'])
                del bbp['source_armature']
    def update_lock_target_armature(self, context):
        bbp = bpy.context.scene.bb_anim_props
        if bbp.lock_target_armature == True:
            if len(bpy.context.selected_objects) == 0 or len(bpy.context.selected_objects) > 1:
                print("Only 1 object can be selected to use this feature")
                bbp.property_unset("lock_target_armature")
                return
            if bpy.context.selected_objects[0].type != 'ARMATURE':
                print("Must be an armature")
                bbp.property_unset("lock_target_armature")
                return
            source = bbp.get('source_armature', None)
            if bpy.context.selected_objects[0].name == source:
                print("Target cannot be the same as the source")
                bbp.property_unset("lock_target_armature")
                return
            bbp['target_armature'] = bpy.context.selected_objects[0].name
            print("Target Locked!", bbp['target_armature'])
        else:
            if bbp.get('target_armature') != None:
                print("Un-Locked!", bbp['target_armature'])
                del bbp['target_armature']

    lock_source_armature : bpy.props.BoolProperty(
        description =            "A source for the bone orientation has to be determined.  This will be the same source armature that "            "you'll be using as an animation receiver for your retargeting.  Often times this will be a Onigiri rig "            "but you can use any armature.  The map loader is used only if you are working with a non-converted source "            "so that the matcher can determine which bones are associated.  If your source and target skeleton have the "            "same bone names then you do not need to load a map and should not unless you are scrambling bones in some "            "unique way which could very well have a practical use.",
        default = False,
        update = update_lock_source_armature
        )
    lock_target_armature : bpy.props.BoolProperty(
        description =            "This is the armature that will have to have its pose altered to match the source.  The result after posing "            "may not be ideal, visually, but that's not usually relevant.",
        default = False,
        update = update_lock_target_armature
        )
    match_root_bones : bpy.props.BoolProperty(
        name = "Match root bones",
        description =            "Root bone orientation can be a problem if re-adjusted.  Usually you're fine just leaving this feature alone but "            "this  process is non-descructive so you can give it a try and see how things look.  This feature, when disabled, "            "will skip over pelvis / hip, those kind of bones, and any root bones which are bones without parents.",
        default = False
        )
    match_pose_selected : bpy.props.BoolProperty(
        name = "Match to selected",
        description =            "This feature cannot work globally for each rig.  You will have to experiment to see which bones can be adjusted "            "and using this (selection only) setting will be helpful to that end.  From experimentation I have learned that "            "that finger joints will probably benefit the most.  It is unlikely that face bones will be affected positively "            "by this",
        default = False
        )
    match_x_axis : bpy.props.BoolProperty(
        name = "Match X Axis",
        description =            "Match the source bone X axis.  This is usually what you want.",
        default = True
        )
    match_y_axis : bpy.props.BoolProperty(
        name = "Match Y Axis",
        description =            "Match the source bone Y axis.  This is usually NOT what you want because it is a base bone orientation but "            "the entire process is non-destructive so try whatever you like",
        default = False
        )
    match_z_axis : bpy.props.BoolProperty(
        name = "Match Z Axis",
        description =            "Match the source bone Z axis.  This is usually what you want.",
        default = True
        )

    def get_scale_first_frame(self):
        start_frame = bpy.context.active_object.animation_data.action.frame_range[0]
        return start_frame
    def get_scale_second_frame(self):
        end_frame = bpy.context.active_object.animation_data.action.frame_range[1]
        return end_frame
    def get_scale_total_frames(self):
        start_frame, end_frame = bpy.context.active_object.animation_data.action.frame_range
        return end_frame - start_frame + 1

    def trigger_scale_frames_access(self):
        
        start_frame, end_frame = bpy.context.active_object.animation_data.action.frame_range
        
        bpy.context.scene.bb_anim_props.scale_total_frames = end_frame - start_frame
        return True

    def get_scale_total_frames(self):
        start_frame, end_frame = bpy.context.active_object.animation_data.action.frame_range
        frames_total = end_frame - start_frame + 1
        return frames_total

    scale_animation_menu : bpy.props.BoolProperty(
        description =            "Click to expand the animation compressor"            "\n\n"            "Here you can compress your animation into the desired frame range.  This can be helpful when "            "needing to adjust time, speed and size of animation for upload to Second Life",
        default=False
        )
    
    trigger_scale_frames_access : bpy.props.IntProperty(
        name = "trigger", 
        description = "Trigger for scale frames access, used internally",
        default = 0, 
        get = trigger_scale_frames_access
        )
    scale_first_frame : bpy.props.IntProperty(
        name = "scale first:", 
        description = "The frame where you want your animation to start, 1 or 2 is good for typical use.",
        default = 1,
        )
    scale_last_frame : bpy.props.IntProperty(
        name = "scale last:", 
        description = "This is where you would like for your animation to end.  Start frame and end frame adjusts the total frames.",
        default = 250,
        )
    scale_total_frames : bpy.props.IntProperty(
        name = "scale total:", 
        description = "total frames desired",
        default = 0, 
        )

    x_rotate_value : bpy.props.FloatProperty(
        name = "X:",
        description = "x rotation in degrees",
        min = -360,
        max = 360,
        default = 0.0,
        )
    y_rotate_value : bpy.props.FloatProperty(
        name = "Y:",
        description = "y rotation in degrees",
        min = -360,
        max = 360,
        default = 0.0,
        )
    z_rotate_value : bpy.props.FloatProperty(
        name = "Z:",
        description = "z rotation in degrees",
        min = -360,
        max = 360,
        default = 90.0,
        )

    enum_menu_items = [
        ('XYZ','XYZ Euler','',1),
        ('QUATERNION','Quaternion (WXYZ)','',2),
        ('XZY','XZY Euler','',3),
        ('YXZ','YXZ Euler','',4),
        ('YZX','YZX Euler','',5),
        ('ZXY','ZXY Euler','',6),
        ('ZYX','ZYX Euler','',7),
        ]
    rotation_mode : bpy.props.EnumProperty(
        name = "Rotation mode values",
        description = "Common types used with Blender are probably XYZ and Quaternion",
        items = enum_menu_items
        )

    exclude_pelvis : bpy.props.BoolProperty(
        name = "mPelvis animation",
        description =            "The pelvis bone (mPelvis) can cause problems when animated.  Often times you can get away with this, for "            "repositioning the avatar in-world for instance.  But if you experience glitches, odd quick snapping, or even "            "the entire avatar seems twisted in some way, enable this and try again.",
        default = False
        )

    disable_pelvis_location_animation : bpy.props.BoolProperty(
        name = "",
        description =            "Disable location/position animations on the root bone, mPelvis and other variants like hip, Hips etc."            "\n\n"            "WARNING: This feature is switched off when using the (High Fidelity) options (Use Source/Target keys) and the options "            "provided with that feature are used instead.  Note that the High Fidelity feature is only useful for anim format so "            "if you are exporting BVH you can ignore this warning.",
        default = False,
        )
    disable_location_offsets : bpy.props.BoolProperty(
        name = "Disable Joint Location Offsets",
        description =            "This is an animation export feature.  It prevents offset location data from being exported with the animation.  "            "\n\n"            "WARNING: This feature is switched off when using the (High Fidelity) options (Use Source/Target keys) and the options "            "provided with that feature are used instead.  Note that the High Fidelity feature is only useful for anim format so "            "if you are exporting BVH you can ignore this warning."            "\n\n"            "This feature disables the export of location animations, except for the entire avatar, which is ROOT, or HIP, mPelvis.  "            "If you are not relocating bones to do something neat, then disabling location data will save a lot of space for more keys."            "You can still animate the movement (location), of your avatar by selecting the pelvis and key framing that.",
        default = False
        )
    remove_isolated_keys : bpy.props.BoolProperty(
        name = "",
        description =            "Remove isolated keys"            "\n\n"            "CAUTION! This will alter your animation directly but it's probably not a bad thing since you don't need these keys.  "            "This is probably something you should never disable but those experts out there may want to keep free floating keys around "            "for some reason.  Blender does this automatically when you save your file, but only in the saved file.  If you want the "            "data that Blender saves you'll need to load/open that saved file, but you can leave this enabled to save the hassle",
        default = True
        )
    fill_missing_keys : bpy.props.BoolProperty(
        name = "",
        description =            "Fill Missing Keys"            "\n\n"            "Keep this enabled unless you are sure of what it does"            "\n\n"            "This adds two additional keys to each animated bone to accommodate your frame range of start and end.  This is necessary "            "in order to get normal expected behavior but the option is here in order to disable it if you are more comfortable "            "with the non-standard, and less accurate, way that some other tool provides.",
        default = True
        )

    export_sl_bvh_label : bpy.props.StringProperty(default="Export BVH for SL")
    export_sl_bvh_label_short : bpy.props.StringProperty(default="Export SL BVH")
    export_sl_bvh_label_busy : bpy.props.StringProperty(default="Saving: please wait...")

    export_sl_bvh_alert : bpy.props.BoolProperty(default=False)
    
    export_standard_bvh_label : bpy.props.StringProperty(default="Export BVH Retargeted")
    export_standard_bvh_label_busy : bpy.props.StringProperty(default="Please wait...")
    export_standard_bvh_alert : bpy.props.BoolProperty(default=False)

class OnigiriRunProperties(bpy.types.PropertyGroup):

    def trigger_update(self, context):
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_settings['terminate'] = True
        bpy.context.scene.bb_run.running = "no"
        return

    def trigger_get(self):
        print("Triggered get")
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return True
        bpy.context.scene.bb_run.running = False
        return True

    def trigger_set(self, value):
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_settings['terminate'] = True
        bpy.context.scene.bb_run.running = False
        return

    action : bpy.props.StringProperty(
        name = "bb_action",
        description = "current action",
        default = ""
        )
    
    last : bpy.props.StringProperty(
        name = "bb_last",
        description = "last object processed",
        default = ""
        )
    
    selected : bpy.props.StringProperty(
        name = "bb_selected",
        description = "selected / active object",
        default = ""
        )
   
    running : bpy.props.BoolProperty(
        name = "bb_running",
        description = "actively running",

        set = trigger_set,
        default = False

        )

class OnigiriTargetProperties(bpy.types.PropertyGroup):

    name : bpy.props.StringProperty(name="target name", default="empty")
    value : bpy.props.BoolProperty(name="target value", default=False)

class OnigiriBoneProperties(bpy.types.PropertyGroup):

    name : bpy.props.StringProperty(name="bone property", default="empty")
    value : bpy.props.BoolProperty(name="Test Prop", default=False)

class OnigiriArmatureProperties(bpy.types.PropertyGroup):

    def rp_use_connect_all(self, context):
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return

        bb = bpy.context.scene.bb_arm_props
        obj = bpy.context.active_object

        if context.mode == 'EDIT_ARMATURE':
            
                old_mode = 'EDIT'
        else:
            old_mode = context.mode

        bpy.ops.object.mode_set(mode='EDIT')

        if getattr(bb, "use_connect_all", None) == True:
            
            if getattr(obj, 'bb_bone_props', None) == None:
                print("Missing property bb_bone_props on True")
                popup("Missing essential property (bb_bone_props) on True, this is a bug", "Missing data", "ERROR")
                return

            obj['disable_use_connect'] = True 
            
            for bone in obj.data.edit_bones:
                
                if bone.name not in bpy.context.active_object.bb_bone_props.keys():
                    bone_con = bpy.context.active_object.bb_bone_props.add()
                    bone_con.name = bone.name
                bpy.context.active_object.bb_bone_props[bone.name]['value'] = bone.use_connect
                bone.use_connect = False
        else:
            
            if getattr(obj, 'bb_bone_props', None) == None:
                print("Missing property bb_bone_props on False")
                popup("Missing essential property (bb_bone_props) on False, this is a bug", "Missing data", "ERROR")
                return

            obj['disable_use_connect'] = False 
            for bone in obj.data.edit_bones:
                if bone.name not in bpy.context.active_object.bb_bone_props.keys():
                    continue
                bone.use_connect = bpy.context.active_object.bb_bone_props[bone.name].value

        bpy.ops.object.mode_set(mode=old_mode)

        return
    
    use_connect_enabled : bpy.props.BoolProperty(
        name = "use connect all enabled or disabled",
        description = "sanity_check",
        default = False
        )
    
    use_connect_all : bpy.props.BoolProperty(
        name = "Unlock All Bones",
        description =            "Unlock all of the bones so that you can move them and, if you like, animate their positions.\n"            "NOTE: Volume bones can be animated if using the .anim exporter.  BVH export may cause problems.  "            "I'll have a look later to see if I can beat BVH into compliance as well.",
        update = rp_use_connect_all,
        default = False
        )

class OnigiriMiscProperties(bpy.types.PropertyGroup):

    def update_blank(self, context):
        self["blank"] = False
        self["misc_blank"] = False
    blank : bpy.props.BoolProperty(default=False, update=update_blank)
    
    misc_blank : bpy.props.BoolProperty(default=False, update=update_blank)

    object_props_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Enable view, copy, paste, of object and bone properties",
        default = False,
        )

    show_object_props : bpy.props.BoolProperty(
        name = "",
        description =            "Show Object Properties"            "\n\n"            "Enable this if you want to see a list of the object properties.  Please note that this could cause errors in the "            "background and also slow down blender quite a bit so use it only temporarily to get an idea of what's contained within "            "the object and also note that the list could be extensive.  If the object is a rig and you are in pose mode with bones "            "selected then you will see the properties of those bones as well"            "\n\n"            "If it's a rig you must be in edit mode or pose mode to see its bone properties and a bone must be selected",
        default = False,
        )
    split_mesh_keep_originals : bpy.props.BoolProperty(
        name = "",
        description =            "Keep Originals"            "\n\n"            "After splitting the mesh you have the option to keep the original mesh objects of those that were split.  "            "The objects that were not split are never deleted since those are part of your set for upload but this feature "            "is provided for testing in case something gets confusing if there's an actual bug.  By default the splitter will "            "remove the original objects of those that needed splitting.  It's assumed that you have disposable objects and/or "            "you've saved your data before this, this is be a destructive process so be careful.",
        default = False,
        )
    mesh_deformer_separate : bpy.props.BoolProperty(
        name = "",
        description =            "Keep Separate"            "\n\n"            "Enabling this will prevent the deformer process from combining the resulting mesh which can make it easier to track down "            "problems.  The result of this type of product can still be uploaded to SL, and there are functional applications for it, but "            "it is heftier and usually unnecessary.",
        default = False,
        )

    split_mesh_for_sl : bpy.props.BoolProperty(
        name = "",
        description =            "After the process is complete split the mesh, if necessary, to comply with Second Life's requirement "            "that no single mesh has more than 110 bone definitions.  This allows you to upload the resulting mesh right away.",
        default = True,
        )
    
    group_count_limit : bpy.props.IntProperty(
        name = "",
        description =            "The total number of vertex groups allowed per mesh.  For Second Life this is 110",
        default = 55
        )

    mesh_from_attachment_bones : bpy.props.BoolProperty(
        name = "",
        description =            "Allow attachment bones to be used in this mesh creation.",
        default = True
        )

    mesh_from_mapped_bones : bpy.props.BoolProperty(
        name = "",
        description =            "If there's a map on your rig it will be used to determine which bones are excluded from meshifying. "            "This helps keep your mesh complaint with the target system and uploads to SL.  It's safe to leave this on.",
        default = False
        )
    mesh_to_middle : bpy.props.BoolProperty(
        name = "",
        description =            "The default location for the mesh is at the joint, which is the head of the bone.  With this enabled the mesh "            "will be located between the head and the tail, which is the middle of the path.",
        default = False
        )

    overwrite_rig_data_backup : bpy.props.BoolProperty(
        description =            "With this enabled each additional save will backup the old rig data first.  You probably don't want to do this.",
        default = False,
        )

    rig_rotate : bpy.props.BoolProperty(
        name = "",
        description = ""            "Enable this if your rig/character faces -Y"            "\n\n"            "Rotate the reference rig before the conversion.  The reference rig is the proxy rig used as a reference for your "            "bone properties.  Enable this if your rig and/or character orientation looks right.",
        default = True,
        )

    rig_resize : bpy.props.BoolProperty(
        name = "",
        description = ""            "Adjust bone relationship transforms to the Z height of the selected armature."            "\n\n"            "With this enabled the bone transforms are adjusted to match what's expected from the size of the kits "            "rig, this is usually what you want.  Make sure you save before any conversion.",
        default = False,
        )
    rig_connect : bpy.props.BoolProperty(
        name = "",
        description = ""            "Known bones for SL can be connected where indicated and should be safe to do so.  Unfortunately many devkits were "            "damaged and these damages were recorded by exporting and then uploading to SL.  If items were made for these products "            "then enabling this could potentially damage your exports for that particular kit.  Use this for testing only, it's "            "absolutely not required.  When enabled this will link the head of one bone to its parent if the connect feature is "            "indicated for SL.  This can be most useful when (fix) and (match) are also used, which is really all you need instead "            "of this.  For those that understand what (use_connect) does then, of course, have at it, you may have a specific use case.",
        default = False,
        )
    rig_strip : bpy.props.BoolProperty(
        name = "",
        description = ""            "When a kit has uknown bones this is useful for removing those.  Why would it have unknown bones?  Maybe you haven't converted "            "it yet from Avastar?  Maybe it has controllers that you want to remove?  If a bone is unknown this will remove it during "            "the conversion.",
        default = True,
        )
    rig_align : bpy.props.BoolProperty(
        name = "",
        description = ""            "The Onigiri Second Life rig is a perfect representation of that which is considered most compatible with standard SL shapes, "            "with an allowable tweak here and there to conform with animations produced by Avastar.  This is the tweaker.  However, this can "            "also be a huge (fixer) if your devkit bone angles are way off",
        default = False,
        )
    rig_fix : bpy.props.BoolProperty(
        name = "",
        description = ""            "This prepares your imported bones for best alignment with SL bones.  It will analyze the rig and determine if the tail of a parent "            "bone can be placed to the head of its only child.  This is usually safe, and should be done with imported DAE files but not always "            "when creating a full rig from a partial rig.  This preparation is almost always required if using (match) as well since the angle of "            "the existing bones determine where and how the new bones will be arranged.",
        default = True,
        )
    rig_match : bpy.props.BoolProperty(
        name = "",
        description = ""            "This enables or disables the alignment of generated bones"            "\n\n"            "If you have an ugly rig after the process then this may be for you.  During the conversion process, from partial to "            "full rigs, a proxy rig is generated and adjusted in order to have the best match for your target rig.  After all "            "of the work is done the target rig assumes the angles and locations of the adjusted proxy, making a perfect match. "            "This should not cause usues with bones that already exist, since the match would be perfect, but for those bones that did "            "NOT exist prior to using this tool then this (match) options forces those into alignment with known SL definitions which "            "can pose a problem, especially for Blender devkits.  You probably want this enabled if you didn't use Avastar.",
        default = True,
        )

    def update_select_bone_shape(self, context):
        bb_misc = bpy.context.window_manager.bb_misc
        if bb_misc.select_bone_shape == True:
            if len(bpy.context.selected_objects) > 1:
                bb_misc["select_bone_shape"] = False
                return
            armObj = bpy.context.selected_objects[0]
            if armObj.type != 'ARMATURE':
                bb_misc["select_bone_shape"] = False
                return
            if bpy.context.mode != 'POSE':
                bb_misc["select_bone_shape"] = False
                return
            if len(bpy.context.selected_pose_bones) == 0:
                bb_misc["select_bone_shape"] = False
                return
            bb_misc.select_bone_shape_rig_name = bpy.context.selected_objects[0].name
            pb = []
            for boneObj in bpy.context.selected_pose_bones:
                pb.append(boneObj.name)
            bb_misc['selected_pose_bones'] = []
            bb_misc['selected_pose_bones'] = pb
            bpy.ops.object.mode_set(mode='OBJECT')
        else:
            if len(bpy.context.selected_objects) != 1:
                return
            o = bpy.context.selected_objects[0]
            if o.type != 'MESH':
                return
            shapeObj = o
            for o in bpy.context.selected_objects:
                o.select_set(False)
            if bb_misc.select_bone_shape_rig_name not in bpy.data.objects:
                print("Object is missing:", bb_misc.select_bone_shape_rig_name)
                return
            obj = bpy.data.objects
            armObj = obj[bb_misc.select_bone_shape_rig_name]
            armObj.select_set(True)
            bpy.context.view_layer.objects.active = armObj
            bpy.ops.object.mode_set(mode='POSE')
            
            pose_bones = bb_misc['selected_pose_bones']
            for bone in pose_bones:
                if bone in armObj.data.bones:
                    armObj.pose.bones[bone].custom_shape = shapeObj
                    armObj.pose.bones[bone].use_custom_shape_bone_size = True

    select_bone_shape : bpy.props.BoolProperty(
        description =            "Select 1 or more pose bones then enable this and then choose a mesh to shape your selected pose bones. "            "Once you've chosen your single mesh disable this to accept it as your shape.",
        default = False,
        update = update_select_bone_shape
        )
    select_bone_shape_rig_name : bpy.props.StringProperty(
        name = "",
        description = "--internal",
        default = ""
        )
    
    from_default_class : bpy.props.BoolProperty(
        description =            "Some tools require that the rig type flag be set to a specific name.  This uses a base of (default) if enabled.  "            "If you've already converted your rig you can use the tools below this to just set the flag but keep in mind that "            "the flag tool does not give you the bone positions of that flag.",
        default = False,
        )
    to_full_rig : bpy.props.BoolProperty(
        description =            "Durring the process also convert this to a full Onigiri rig.",
        default = False,
        )
    existing_bones_only : bpy.props.BoolProperty(
        name = "", 
        description =            "Convert to a result that includes only the bones that exist in the source rig, no additional bones will be present, so it "            "may not be a full rig that is generated as a result of this process.",
        default = True
        )
    
    convert_with_animation : bpy.props.BoolProperty(
        name = "", 
        description =            "Attempt to carry the animation with the converted rig.  You're best bet is to retarget the animation and bake it in instead "            "because there are controllers that might be animated and those animations will not carry over",
        default = True
        )
    
    use_old_rig : bpy.props.BoolProperty(
        name = "",
        description =            "Convert to old rig"            "\n\n"            "Don't be fooled by the use of face and finger bones in your rig.  To be sure that your kit uses the old method check for "            "spine bones.  We have mPelvis, mTorso, mChest in the old rig and mSpine01 to mSpine04 interweaved with those in the new rig.  "            "Onigiri will attempt to determine which to use but it will not remove bones that don't exist unless you tick this button, "            "except for the very strange mSpine? bones that will definitely break your mesh if you convert.  How will you know if it works?  "            "Just convert and upload your mesh, if it's broken then try this button.",
            default = False,
        )

    def update_info_onigiri_bind_info(self, context):
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        
        bb_settings['terminate'] = True
        bpy.context.window_manager.bb_misc.info_onigiri_bind_info = False
        return

    info_onigiri_bind_info : bpy.props.BoolProperty(
        name = "Bind Information",
        description =            "\n"            "This feature allows you to manipulate bind information.  This is an advanced feature and was "            "initially placed here for testing."            "\n",
        default = False,
        update = update_info_onigiri_bind_info,
    )
    
    enable_bind_data : bpy.props.BoolProperty(
        name = "Bind Data Manipulation",
        description =            "\n"            "Utilize various features associated with the skeleton's bind information."            "\n",
        default = False,
    )

    right_blank : bpy.props.BoolProperty(
        name = "right_blank",
        description =            "An intentionally blank page or vacant page (from Latin: vacare for \"being empty\"\) "            "is a page that is devoid of content and may be unexpected. Such pages may serve purposes "            "ranging from place-holding to space-filling and content separation. Sometimes, these pages "            "carry a notice such as \"This page [is] intentionally left blank.\" Such notices typically "            "appear in printed works, such as legal documents, manuals, and exam papers, in which the "            "reader might otherwise suspect that the blank pages are due to a printing error and where "            "missing pages might have serious consequences."            "\n\n"            "But that's not the case here.  I'm just goofy.",
        default = False,
        )

    def update_rig_class_to_default(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbm = bpy.context.window_manager.bb_misc
        
        if bbm.rig_class_to_default == False:
            
            bb_settings['terminate'] = True
            bbm.rig_class_to_default = True
            return
        if len(bpy.context.selected_objects) != 1:
            return
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return
        print("set rig_class to Default")
        rigutils.convert_rig_to_class(armature=o.name, rig_class="default")
        o['rig_class'] = "default"
        bb_settings['terminate'] = True
        bbm.rig_class_to_neutral = False
        bb_settings['terminate'] = True
        bbm.rig_class_to_pivot = False
        bb_settings['terminate'] = True
        bbm.rig_class_to_pos = False
        return
    def update_rig_class_to_neutral(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbm = bpy.context.window_manager.bb_misc
        
        if bbm.rig_class_to_neutral == False:
            
            bb_settings['terminate'] = True
            bbm.rig_class_to_neutral = True
            return
        if len(bpy.context.selected_objects) != 1:
            return
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return
        print("set rig_class to Neutral")
        rigutils.convert_rig_to_class(armature=o.name, rig_class="neutral")
        o['rig_class'] = "neutral"
        bb_settings['terminate'] = True
        bbm.rig_class_to_default = False
        bb_settings['terminate'] = True
        bbm.rig_class_to_pivot = False
        bb_settings['terminate'] = True
        bbm.rig_class_to_pos = False
        return
    def update_rig_class_to_pivot(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbm = bpy.context.window_manager.bb_misc
        
        if bbm.rig_class_to_pivot == False:
            
            bb_settings['terminate'] = True
            bbm.rig_class_to_pivot = True
            return
        if len(bpy.context.selected_objects) != 1:
            return
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return
        rigutils.convert_rig_to_class(armature=o.name, rig_class="pivot")
        o['rig_class'] = "pivot"
        bb_settings['terminate'] = True
        bbm.rig_class_to_pos = False
        bb_settings['terminate'] = True
        bbm.rig_class_to_neutral = False
        bb_settings['terminate'] = True
        bbm.rig_class_to_default = False
        return
    def update_rig_class_to_pos(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbm = bpy.context.window_manager.bb_misc
        
        if bbm.rig_class_to_pos == False:
            
            bb_settings['terminate'] = True
            bbm.rig_class_to_pos = True
            return
        if len(bpy.context.selected_objects) != 1:
            return
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return
        rigutils.convert_rig_to_class(armature=o.name, rig_class="pos")
        o['rig_class'] = "pos"
        bb_settings['terminate'] = True
        bbm.rig_class_to_pivot = False
        bb_settings['terminate'] = True
        bbm.rig_class_to_neutral = False
        bb_settings['terminate'] = True
        bbm.rig_class_to_default = False
        return

    rig_class_to_default : bpy.props.BoolProperty(
        name = "",
        description = ""            "Convert class to default"            "\n\n"            "The rig selection for starting a new devkit for your brand new Second Life avatar, for which you will eventually "            "make clothing and, possibly, distribute as a devkit, is a very important matter.  I suggest using a POS rig right off "            "the bat, this will avoid many errors that typically creep into the creation process and also allow for old, and very old, "            "animations to work without so many glitches.  However, this (default) option is provided because many devkits were made "            "using this Avastar style of joint positions and you may need to do the same, especially when making animations for that type",
        default = False,
        update = update_rig_class_to_default
        )
    rig_class_to_neutral : bpy.props.BoolProperty(
        name = "Convert class to neutral",
        description = ""        "Convert class to neutral"        "\n\n"        "Read the description under the button that converts your rig to a (default) rig, this gives you exactly the same information ",
        default = False,
        update = update_rig_class_to_neutral
        )
    rig_class_to_pivot : bpy.props.BoolProperty(
        name = "",
        description =            "Convert to pivot"            "\n\n"            "There are some devkits that use this, the neutral and default rig types used in Avastar had a type as well as a shape, or class, "            "of rig.  There was some misudnerstanding on what these terms meant and what the rig types were used for but it was only that, "            "confusion.  This feature is not implemented anymore because there's no need for it so if you see it tell someone please",
        default = False,
        update = update_rig_class_to_pivot
        )
    rig_class_to_pos : bpy.props.BoolProperty(
        name = "",
        description =            "Convert this rig to a POS rig"            "\n\n"            "Another discontinued feature that had no real use.  If you see it please tell someone",
        default = False,
        update = update_rig_class_to_pos
        )

    def update_enable_base_bones(self, context):
        armObj = rigutils.is_armature()
        if armObj == False:
            print("armature is False")
            self["enable_base_bones"] = False
            return
        state = self.enable_base_bones
        group = "base"
        rigutils.show_bones(armature=armObj, group=group, state=state)
        if armObj.get('bb_bone_groups') != None:
            armObj['bb_bone_groups'][group] = state
    def update_enable_volume_bones(self, context):
        armObj = rigutils.is_armature()
        if armObj == False:
            self["enable_volume_bones"] = False
            return
        state = self.enable_volume_bones
        group = "volume"
        rigutils.show_bones(armature=armObj, group=group, state=state)
        if armObj.get('bb_bone_groups') != None:
            armObj['bb_bone_groups'][group] = state
    def update_enable_attach_bones(self, context):
        armObj = rigutils.is_armature()
        if armObj == False:
            self["enable_attach_bones"] = False
            return
        state = self.enable_attach_bones
        group = "attach"
        rigutils.show_bones(armature=armObj, group=group, state=state)
        if armObj.get('bb_bone_groups') != None:
            armObj['bb_bone_groups'][group] = state
    def update_enable_attach2_bones(self, context):
        armObj = rigutils.is_armature()
        if armObj == False:
            self["enable_attach2_bones"] = False
            return
        state = self.enable_attach2_bones
        group = "attach2"
        rigutils.show_bones(armature=armObj, group=group, state=state)
        if armObj.get('bb_bone_groups') != None:
            armObj['bb_bone_groups'][group] = state
    def update_enable_hind_bones(self, context):
        armObj = rigutils.is_armature()
        if armObj == False:
            self["enable_hind_bones"] = False
            return
        state = self.enable_hind_bones
        group = "hind"
        rigutils.show_bones(armature=armObj, group=group, state=state)
        if armObj.get('bb_bone_groups') != None:
            armObj['bb_bone_groups'][group] = state
    def update_enable_face_bones(self, context):
        armObj = rigutils.is_armature()
        if armObj == False:
            self["enable_face_bones"] = False
            return
        state = self.enable_face_bones
        group = "face"
        rigutils.show_bones(armature=armObj, group=group, state=state)
        if armObj.get('bb_bone_groups') != None:
            armObj['bb_bone_groups'][group] = state
    def update_enable_wing_bones(self, context):
        armObj = rigutils.is_armature()
        if armObj == False:
            self["enable_wing_bones"] = False
            return
        state = self.enable_wing_bones
        group = "wing"
        rigutils.show_bones(armature=armObj, group=group, state=state)
        if armObj.get('bb_bone_groups') != None:
            armObj['bb_bone_groups'][group] = state
    def update_enable_tail_bones(self, context):
        armObj = rigutils.is_armature()
        if armObj == False:
            self["enable_tail_bones"] = False
            return
        state = self.enable_tail_bones
        group = "tail"
        rigutils.show_bones(armature=armObj, group=group, state=state)
        if armObj.get('bb_bone_groups') != None:
            armObj['bb_bone_groups'][group] = state
    def update_enable_hand_bones(self, context):
        armObj = rigutils.is_armature()
        if armObj == False:
            self["enable_hand_bones"] = False
            return
        state = self.enable_hand_bones
        group = "hand"
        rigutils.show_bones(armature=armObj, group=group, state=state)
        if armObj.get('bb_bone_groups') != None:
            armObj['bb_bone_groups'][group] = state
    def update_enable_spine_bones(self, context):
        armObj = rigutils.is_armature()
        if armObj == False:
            self["enable_spine_bones"] = False
            return
        state = self.enable_spine_bones
        group = "spine"
        rigutils.show_bones(armature=armObj, group=group, state=state)
        if armObj.get('bb_bone_groups') != None:
            armObj['bb_bone_groups'][group] = state

    def poll_enable_bones(self):
        
        armObj = rigutils.is_armature()
        if armObj == False:
            for group in visible.layers:
                prop = "enable_" + group + "_bones"
                self[prop] = False
            return False

        if armObj.get('bb_bone_groups') == None:
            bone_groups = {}
            
            for group in visible.layers:
                bone_groups[group] = True
            armObj['bb_bone_groups'] = bone_groups
        bone_groups = armObj['bb_bone_groups'].to_dict()
        for group in bone_groups:
            state = bone_groups[group]
            prop = "enable_" + group + "_bones"
            self[prop] = state
        return True

    poll_enable_bones : bpy.props.IntProperty(
        name = "",
        description = "- internal",
        default = False,
        get = poll_enable_bones
        )

    enable_base_bones : bpy.props.BoolProperty(
        name = "",
        description = "View and hide the normal deform volumes",
        default = False,
        update = update_enable_base_bones
        )
    enable_volume_bones : bpy.props.BoolProperty(
        name = "",
        description = "View and hide the collision volumes",
        default = False,
        update = update_enable_volume_bones
        )
    enable_attach_bones : bpy.props.BoolProperty(
        name = "",
        description = "View and hide the attachment bones used for deforming / skinning and animation",
        default = False,
        update = update_enable_attach_bones
        )
    enable_attach2_bones : bpy.props.BoolProperty(
        name = "",
        description =            "View and hide the attachment bones with spaces in their names, previously you couldn't skin using these bones "            "but we've updated it to allow for this.",
        default = False,
        update = update_enable_attach2_bones
        )
    enable_hind_bones : bpy.props.BoolProperty(
        name = "",
        description = "View and hide the hind bones.",
        default = False,
        update = update_enable_hind_bones
        )
    enable_face_bones : bpy.props.BoolProperty(
        name = "",
        description = "View and hide the face bones.",
        default = False,
        update = update_enable_face_bones
        )
    enable_wing_bones : bpy.props.BoolProperty(
        name = "",
        description = "View and hide the wing bones.",
        default = False,
        update = update_enable_wing_bones
        )
    enable_tail_bones : bpy.props.BoolProperty(
        name = "",
        description = "View and hide the tail bones.",
        default = False,
        update = update_enable_tail_bones
        )
    enable_hand_bones : bpy.props.BoolProperty(
        name = "",
        description = "View and hide the hand bones.",
        default = False,
        update = update_enable_hand_bones
        )
    enable_spine_bones : bpy.props.BoolProperty(
        name = "",
        description = "View and hide the hand bones.",
        default = False,
        update = update_enable_spine_bones
        )

    limit_weights : bpy.props.IntProperty(
        name = "limit weights", 
        description = "Number of bone influences per vertex",
        default = 4,
        )
    limit_weights_message : bpy.props.StringProperty(default="[look here]")

    def update_refit_lock_garment_source(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        obj = bpy.data.objects
        bbm = bpy.context.window_manager.bb_misc
        if bbm.refit_lock_garment_source == True:
            if len(bpy.context.selected_objects) == 0:
                bb_settings['terminate'] = True
                bbm.refit_lock_garment_source = False
                return
            if len(bpy.context.selected_objects) > 1:
                
                txt = "Error: one object only"
                print(txt)
                bbm.refit_message = txt
                bb_settings['terminate'] = True
                bbm.refit_lock_garment_source = False
                return
            
            meshObj = bpy.context.selected_objects[0]
            if meshObj.type != 'MESH':
                
                txt = "Error: mesh objects only"
                print(txt)
                bbm.refit_message = txt
                bb_settings['terminate'] = True
                bbm.refit_lock_garment_source = False
                return
            bbm.refit_garment_source_name = meshObj.name
            bbm.refit_message = "Garment Locked"
        else:
            bbm.refit_lock_avatar_targets = False
            bbm.refit_lock_avatar_source = False
            bbm.refit_garment_source_name = ""
            bbm.refit_message = "[Look here for messages]"
        return
    
    def update_refit_lock_avatar_source(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        obj = bpy.data.objects
        bbm = bpy.context.window_manager.bb_misc
        if bbm.refit_lock_avatar_source == True:
            if len(bpy.context.selected_objects) == 0:
                bb_settings['terminate'] = True
                bbm.refit_lock_avatar_source = False
                return
            if len(bpy.context.selected_objects) > 1:
                
                txt = "Error: one object only"
                print(txt)
                bbm.refit_message = txt
                bb_settings['terminate'] = True
                bbm.refit_lock_avatar_source = False
                return
            
            meshObj = bpy.context.selected_objects[0]
            if meshObj.type != 'MESH':
                
                txt = "Error: mesh objects only"
                print(txt)
                bbm.refit_message = txt
                bb_settings['terminate'] = True
                bbm.refit_lock_avatar_source = False
                return
            
            if meshObj.name == bbm.refit_garment_source_name:

                txt = "Error: source and targets are the same!"
                print(txt)
                bbm.refit_message = txt
                bb_settings['terminate'] = True
                bbm.refit_lock_avatar_source = False
                return
            bbm.refit_avatar_source_name = meshObj.name
            bbm.refit_message = "Avatar Locked"
        else:
            bbm.refit_lock_avatar_targets = False
            bbm.refit_avatar_source_name = ""
            bbm.refit_message = "[Look here for messages]"
        return

    def update_refit_lock_avatar_targets(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        
        obj = bpy.data.objects
        bbm = bpy.context.window_manager.bb_misc
        if bbm.refit_lock_avatar_targets == True:
            if len(bpy.context.selected_objects) == 0:
                
                txt = "Error: select one or more objects"
                print(txt)
                bbm.refit_message = txt
                bb_settings['terminate'] = True
                bbm.refit_lock_avatar_targets = False
                return
            qualified_mesh = list()
            for o in bpy.context.selected_objects:
                if o.type != 'MESH':
                    continue
                
                if o.name == bbm.refit_avatar_source_name or o.name == bbm.refit_garment_source_name:
                    print("Found locked mesh in targets:", o.name)
                    continue
                
                source_vcount = len(obj[bbm.refit_avatar_source_name].data.vertices)
                target_vcount = len(o.data.vertices)

                if source_vcount != target_vcount:
                    print("Found incompatible vertex count in target:", o.name)
                    print("source vertex count:", source_vcount)
                    print("target vertex count:", target_vcount)
                    bbm.refit_message = "Incompatible: " + o.name
                    bb_settings['terminate'] = True
                    bbm.refit_lock_avatar_targets = False
                    return
                
                print("Found qualified mesh:", o.name)
                qualified_mesh.append(o.name)
            if len(qualified_mesh) == 0:
                
                txt = "There are no qualified meshes in your targets.  Check console for details."
                print(txt)
                bbm.refit_message = "Error: no qualified meshes"
                bb_settings['terminate'] = True
                bbm.refit_lock_avatar_targets = False
                return
            
            bbm['refit_targets'] = qualified_mesh
            bbm.refit_avatar_target_name = "FILLED"
            bbm.refit_message = "Refit ready!"
            return
        else:
            
            if bbm.get('refit_targets') != None:
                del bbm['refit_targets']
            bbm.refit_avatar_target_name = ""
            bbm.refit_message = "[Look here for messages]"
            return
        return

    def update_refit_check(self, context):
        obj = bpy.data.objects
        bbm = bpy.context.window_manager.bb_misc
        return

    refit_enabled : bpy.props.BoolProperty(
        name = "bb_enable_mesh_refit",
        description =            "Expand the mesh refit menu.  You can refit your garments or other attachments, even weighted items, to"            "other targets/avatars of the same type.  If it is just a shape difference it just needs a fit.",
        default = False,
        )
    refit_lock_avatar_source : bpy.props.BoolProperty(
        description =            "This is the object that wraps to your avatar mesh in order for the garment to fit.  This object can be temporary and "            "usually is.  An exception would be if you were refitting your garment to multiple shapes of the same avatar like Makehuman "            "or other object that has the same vertex order.  This wrap object can be created in Marvelous Designer but, with some "            "careful planning, can be done with Blender instead but not recommended for non-experts.",
        default = False,
        update = update_refit_lock_avatar_source
        )
    refit_avatar_source_name : bpy.props.StringProperty(
        description =            "This is the the object the garment is currently fitted to.",
        default = "",
        update = update_refit_check
        )
    refit_lock_garment_source : bpy.props.BoolProperty(
        description =            "This is the the object, attachment or garment you want to duplicate and refit.",
        default = False,
        update = update_refit_lock_garment_source
        )
    refit_garment_source_name : bpy.props.StringProperty(
        default="",
        update = update_refit_check
        )
    
    refit_lock_avatar_targets : bpy.props.BoolProperty(
        description =            "Select your target avatars, or some qualified mesh object or objects, and click this.",
        default = False,
        update = update_refit_lock_avatar_targets
        )
    
    refit_avatar_target_name : bpy.props.StringProperty(
        default="",
        update = update_refit_check
        )
    
    refit_assume_pose : bpy.props.BoolProperty(
        description =            "This can only work if your wrap object has an armature and armature modifier.  The targets must have both while the "            "original, source, can get away with just the modifier.  If the vertex groups don't match this will fail.  "            "This will attempt to mimic the pose of the target.  Often times you'll have an avatar that is posed in some form "            "that does not match the rest pose.  You might see an armature in (A) pose but its rest pose is T-Pose.  With this "            "feature enabled the refitter will attempt to conform your garment to the current pose, and then freeze it.  A frozen "            "mesh in this instance is exactly what you are wanting and what is expected in Second Life when using these particular "            "kits.",
        default = False,
        update = update_refit_lock_avatar_targets
        )
    refit_falloff : bpy.props.FloatProperty(
        description =            "Deformation smoothness (falloff).  This can help fit some garments with difficult layers.  Try different values",
        min = 2,
        max = 16,
        default = 4,
        )

    refit_message : bpy.props.StringProperty(default="[Look here for messages]")

    def update_test_angle_pos_x(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbm = bpy.context.window_manager.bb_misc
        if bbm.test_angle_pos_x == True:
            bb_settings['terminate'] = True
            bbm.test_angle_neg_x = False
    def update_test_angle_pos_y(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbm = bpy.context.window_manager.bb_misc
        if bbm.test_angle_pos_y == True:
            bb_settings['terminate'] = True
            bbm.test_angle_neg_y = False
    def update_test_angle_pos_z(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbm = bpy.context.window_manager.bb_misc
        if bbm.test_angle_pos_z == True:
            bb_settings['terminate'] = True
            bbm.test_angle_neg_z = False
    
    def update_test_angle_neg_x(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbm = bpy.context.window_manager.bb_misc
        if bbm.test_angle_neg_x == True:
            bb_settings['terminate'] = True
            bbm.test_angle_pos_x = False
    def update_test_angle_neg_y(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbm = bpy.context.window_manager.bb_misc
        if bbm.test_angle_neg_y == True:
            bb_settings['terminate'] = True
            bbm.test_angle_pos_y = False
    def update_test_angle_neg_z(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbm = bpy.context.window_manager.bb_misc
        if bbm.test_angle_neg_z == True:
            bb_settings['terminate'] = True
            bbm.test_angle_pos_z = False

    test_angles_enabled : bpy.props.BoolProperty(
        description =            "Test x,y,z angles, these are temporary buttons for testing only.  If there are floats they are overriden by any toggle buttons "            "that you see.  The toggles are a quick 90 degree angle, for larger angles use the floats instead and make sure all buttons are "            "disabled.",
        default = False,
        )
    test_angle_pos_x : bpy.props.BoolProperty(default = False, update = update_test_angle_pos_x)
    test_angle_pos_y : bpy.props.BoolProperty(default = False, update = update_test_angle_pos_y)
    test_angle_pos_z : bpy.props.BoolProperty(default = False, update = update_test_angle_pos_z)
    test_angle_neg_x : bpy.props.BoolProperty(default = False, update = update_test_angle_neg_x)
    test_angle_neg_y : bpy.props.BoolProperty(default = False, update = update_test_angle_neg_y)
    test_angle_neg_z : bpy.props.BoolProperty(default = False, update = update_test_angle_neg_z)

    test_angle_x : bpy.props.FloatProperty(
        name = "X",
        description = "",
        default = 0.0,
        )
    test_angle_y : bpy.props.FloatProperty(
        name = "Y",
        description = "",
        default = 0.0,
        )
    test_angle_z : bpy.props.FloatProperty(
        name = "Z",
        description = "",
        default = 0.0,
        )

class OnigiriProperties(bpy.types.PropertyGroup):

    def update_blank(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb = bpy.context.scene.onigiri
        bb_settings['terminate'] = True
        bb.blank = False
    blank : bpy.props.BoolProperty(
        name = "",
        description = "",
        default = False,
        update = update_blank
        )
    devkit_run_code : bpy.props.BoolProperty(
        name = "",
        description = ""            "Some unique processes may be required when loading a devkit preset and code may have been added for that "            "specific kit.  If that's the case then this feature will run that required code, if enabled.  The feature "            "is allowed to be turned on and off because devkit creators may update their kit in the future making this "            "option, for that particular kit, obsolete, or damaging",
        default = True,
        )

    def set_map_type_mbones(self, value):
        bb = bpy.context.scene.onigiri
        global bb_settings 
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        
        if getattr(bb, 'map_to_mbones') == True:
            
            bb_settings['terminate'] = True
            setattr(bb, "map_to_template", False)
            setattr(bb, "template_enabled", False)
            return
        else:
            
            pass
        return

    def set_map_type_template(self, value):
        bb = bpy.context.scene.onigiri
        global bb_settings 
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        
        if getattr(bb, 'map_to_template') == True:
            
            bb_settings['terminate'] = True
            setattr(bb, "map_to_mbones", False)
            setattr(bb, "template_enabled", True)
        else:
            
            setattr(bb, "template_enabled", False)
        return

    for flag in bb_flags:
        if flag in bb_notes.keys():
            desc = bb_notes[flag]
        
        flag_string  = flag + " : bpy.props.BoolProperty("
        flag_string += "name = \"" + flag + "\","
        flag_string += "description = \"" + desc + "\","
        flag_string += "default = " + str(bb_flags[flag])
        flag_string += ")"

        if bb_flags['debug'] == 1:
            print("================")
            print("EXEC FLAG:")
            print("===============================================================")
            print(flag_string)
            print("===============================================================")

        exec(flag_string)

    map_to_mbones : bpy.props.BoolProperty(
        name = "map source to mbones",
        description = ""            "If your rig's bones are name compatible with Second Life but, for some reason, it doesn't seam "            "to upload or, if so, doesn't work properly in Second Life, then this button might be for you, "            "give it a try.  This will move the source bones into the positions of your existing rig's "            "properly named bones allowing you to transfer your animations and mesh data to the source rig "            "so that they can be exported and then imported into SL properly.",
        update = set_map_type_mbones,
        default = False
        )
    map_to_template : bpy.props.BoolProperty(
        name = "map source to template",
        description =            "You can load a text file into the panel and the converter will use that file as the mapping template, where the "            "file content is a list, each line containing 3 items.  An armature name, mBone name (must be SL bone) and target "            "bone on your rig.",
        update = set_map_type_template,
        default = False
        )
    
    template_enabled : bpy.props.BoolProperty(
        name = "template_enabled",
        description = "toggle enable",
        default = False
        )
    enforce_settings : bpy.props.BoolProperty(
        name = "enforce_settings",
        description =            "When using an alternative mapping there are some settings that are automatically altered to give expected results.  "            "The switches for this alternative mapping is on either side of the big Map and Retarget button.  If you prefer to use "            "the existing settings, without them being over-ridden by the alternative mapping feature, then enable this switch.  "            "Note that you may experience unexpected and unpredictable results.  You will want to disable (Enable use_connect).",
        default = False
        )

    custom_bone_list : bpy.props.BoolProperty(
        name = "use a custom bone order list",
        description =            "Enable this button if you want to use a loaded list containing the bone order that you prefer.  Internally the "            "bone order that is used should be enough to get you started but a custom order will get you even closer to making "            "your completed template for later.",
        default = False
        )
    
    def get_tpf(self):
        return bpy.context.scene.render.fps_base / bpy.context.scene.render.fps
    def set_tpf(self):
        bpy.context.scene.render.fps = bpy.context.scene.onigiri.animation_fps
        return

    def get_animation_time(self):
        bb = bpy.context.scene.onigiri
        bba = bpy.context.scene.bb_anim_props
        
        if bb.animation_fps == 0:
            return 0
        
        return (bb.animation_end_frame - bb.animation_start_frame) / bb.animation_fps

    def set_fps(self, context):
        bpy.context.scene.render.fps = bpy.context.scene.onigiri.animation_fps

        return

    animation_time : bpy.props.FloatProperty(
        name = "time sec:",
        description =            "This is the total amount of time the animation takes, with respect to actual start and end frames,"            "not the ones you set.  This is (total frames - 1 / fames per second)",
        precision = 4,
        default = 0.0,
        get = get_animation_time,

        )

    animation_fps : bpy.props.FloatProperty(
        name = "fps:", 
        description = "frames per second",
        min=0.0,
        precision = 2,
        default = 24.0,
        update=set_fps
        )

    animation_tpf : bpy.props.FloatProperty(
        name = "tpf:",
        description = "time per frame",
        default = 1.0,
        get = get_tpf
        )
    animation_start_frame : bpy.props.IntProperty(
        name = "Start Frame:", 
        description = "starting frame",
        default=1
        )
    animation_end_frame : bpy.props.IntProperty(
        name = "End Frame:", 
        description = "ending frame",
        default=100
        )
    
    pos_rig : bpy.props.BoolProperty(
        name = "generate POS rig",
        description =            "Generate a POS rig instead of a Pivot rig.",
        default = False
        )

    add_control_rig : bpy.props.BoolProperty(
        name = "Add a control rig with rig creation",
        description =            "This is becoming obsoleted by (Add Onigiri Rig), use at your own risk.\n"            "A new animation rig will replace this with full features, if not already installed.\n\n"            "If this is enabled then the Onigiri rig creations will have a control rig attached.  This can make it easier "            "to animate and sometimes fixes problems with auto-map targets.  The animations created with this can also be exported "            "and sometimes turn out better.  The export will take a little longer so be aware of that before trying to upload.",
        default = False,
        )
    
    add_animation_rig : bpy.props.BoolProperty(
        name = "Add animation controllers to the created rig",
        description =            "\n"            "This doesn't work at the moment, coming soon."            "\n"            "\n"            "This creates some controller that allow your rig / character to simulate natural responsive motion, which is referred to "            "as IK, or Inverse Kinematics.  For instance, if you move a foot bone the entire leg should move in some natural way.",
        default = False,
        )

    def add_selected_reference_rig(self, value):
        bb = bpy.context.scene.onigiri
        global bb_settings 
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        if getattr(bb, 'selected_reference') == True:
            
            bb_settings["terminate"] = True
            setattr(bb, "neutral_reference", False)
        return;
    def add_neutral_reference_rig(self, value):
        bb = bpy.context.scene.onigiri
        global bb_settings 
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        if getattr(bb, 'neutral_reference') == True:
            
            bb_settings["terminate"] = True
            setattr(bb, "selected_reference", False)
        return;

    selected_reference : bpy.props.BoolProperty(
        name = "selected reference rig",
        description =            "Make sure you are on the correct layer where (Choose bone source rig) is.\n\n"            "When this switch is disabled the button on the right will create a rig that is the suggested proportions for "            "making human characters and animations compatible with Second Life. \n\n"            "With this switch enabled Onigiri expects that there's a reference rig in the scene and is present in the "            "(Bone Source Rig) drop-down list.  Onigiri will then copy the positions of the bones creating a skeleton "            "from that.  This allows you to make adjustments to the reference rig and, in the case of MB-LAB or others, using the "            "controls associated with that system, and Onigiri will mimic  the proportions, positions, rotations and scale "            "after clicking the button on the right.  Each click of that button adds an additional rig.",
        update = add_selected_reference_rig,
        default = False
        )
    neutral_reference : bpy.props.BoolProperty(
        name = "neutral reference rig",
        description =        "This is the default skeleton in SL without shape sliders adjusted.  Animations have a starting point, when the animation "        "includes location data for specific bones then you may see some discrepancy with where the bone should be and where it "        "starts in the animation.  Technically animations are not transferable between different avatar shapes with differing slider "        "values but it's close enough to use generically.  Keep this in mind when making animations for a character that is far beyond "        "the generic type.",
        update = add_neutral_reference_rig,
        default = False
        )

    bvh_menu_enabled : bpy.props.BoolProperty(
        name = "enable bvh features",
        description =            "BVH Export Features",
        default = False
        )

    bvh_to_sl : bpy.props.BoolProperty(
        name = "Animation Export to SL / BVH standard",
        description =            "BVH compliant.  Use this option to make bvh joint names compatible with SL animations, it probably works without this but "            "most of these are standard BVH names and you may want to use this feature if you are going to alter the animation with "            "a different tool.",
        default = False
        )
    extended_animation_options : bpy.props.BoolProperty(
        description =            "Some additional options that you rarely need, good for testing though.",
        default=False
        )

    export_onigiri_disabled : bpy.props.BoolProperty(
        name = "",
        description =            "Disable check for Onigiri rig"            "\n\n"            "It can be confusing, and annoying, when your animation does absolutely nothing in SL.  This can happen when the animation source "            "is chosen while exporting the animation, instead of the Onigiri rig.  This check is enabled by default.  The button disableds "            "it in case you want to try exporting a different source, it probably won't work but it's here if you want to test it.",
        default = False
        )

    export_avastar_disabled : bpy.props.BoolProperty(
        name = "",
        description =            "Disable check for Avastar rig"            "\n\n"            "Avastar rigs are detected so that you can export your existing animations properly from a previous work-flow.  Unfortunately there "            "can be some confusion about which bones to animate and, thus, which keys to utilize.  If an Avastar rig is detected then a translation "            "has to be performed if keys are detected on the control bones, which you can change using (Export Avastar Deform Bones).  The default "            "behavior is to attempt to asertain if the selected rig is an avastar rig and, if so, we'll process this translated data into a usable "            "animation. "            "\n\n"            "When should you enable this (disable) feature? -- If your deform (mBone) bones were animated instead of the control (Bone) bones and "            "you want to use the extended Onigiri animation export features, you want to enable this (disable) feature and then, if you have "            "static poses on any bones, you need to enable (Use Source Keys).",
        default = False
        )

    export_sl_limitations_check_disabled : bpy.props.BoolProperty(
        name = "Disable check for SL and OS limitations",
        description =            "\n"            "This will disable the checking for time and file size.  The file size limit can only work on .anim format.  If you "            "export BVH this check will not be usable but the SL BVH importer will tell you if it's too large.  This also checks the time "            "to make sure that the animation will be usable in SL/OS.  Currently the limitation is 60 seconds per clip.",
        default = False
        )

    export_volume_motion : bpy.props.BoolProperty(
        name = "Export animated collision volumes",
        description =            "If you've animated the collision volumes then you probably want to see those animations in Second Life.  This button allows "            "you to disable the export of those specific animated bones.  This feature is provided as a debug option to see where your "            "animations may be going wrong",
        default = True
        )
    export_attachment_motion : bpy.props.BoolProperty(
        name = "",
        description =            "Disable export of attachment bone animations"            "\n\n"            "Attachment bone animations have a less useful purpose so this is disabled by default.  If you're exporting a static pose this is "            "probably best left disabled.",
        default = False
        )

    export_avastar_deform_bones : bpy.props.BoolProperty(
        name = "",
        description =            "Export animation from the deform bones only"            "\n\n"            "Onigiri will prioritize exporting animation from control bones, which is expected.  However, if there are no keys present on "            "any control bones then any deform bones that have keys will be acknowledged as being the animation set for your export.  If you don't "            "want this method of detection, and are sure you want to export from the less popular deform bones (with respect to Avastar), then enable "            "this feature.  The default behavior (off) is for Onigiri to examine the rig to determin which bones are animated and globally "            "overwrite any mBone data (deform bones) with the control bone data, if even a single control bone has a key, then all deform bone "            "data will be ignored.  Motion detection is still enabled.",
        default = False
        )

    export_keys_only : bpy.props.BoolProperty(
        name = "",
        description =            "Export the animation keys from the selected rig"            "\n\n"            "WARNING: This overrides (Use Source Keys) and (Use Target Keys) which can only be used with a High Fidelity Bake (motion detection).  The "            "selected rig must be the animation source (key framed)."            "\n\n"            "Onigiri goes through a series of prioritized methods before it even reaches this check.  If those methods result in no-acation, even a "            "failure, then this one is checked to see if this convenient method can be empolyed, otherwise it's business as usual for motion detection.  "            "What this feature does is to examine keys only, no motion detection is observed, and those keys will be used in your export.  This is useful "            "for a quick export when you know that the rig you're using is compatible, it has animation keys, and no controllers need to be exmained for "            "keys.  If you're using this with a control rig you'll need to key the underlying bones",
        default = False
        )

    export_translations : bpy.props.BoolProperty(
        name = "Prevent export of bone translations",
        description =            "This doesn't work yet, it's here as a reminder to finish it.  It will be part of the new BVH exporter."            "\n\n"            "Translation is just another term for motion that is not rotation or scale.  It's the forward, back, up, down, diagonal etc. "            "If you want your bones to move out of sync with its hierarchy, then you want translations.  It's almost "            "always safe to keep translations, unless you've animated a volume bone location, then there are other considerations.  "            "If you've animated volume bones",
        default = False
        )
    
    bake_animation : bpy.props.BoolProperty(
        name = "Bake animation",
        description =            "\n"            "This property is no longer functional.  If you see it there's probably an operator button somewhere to do the same thing.",
        default = False
        )

    animation_file_name : bpy.props.StringProperty(default="")

    def initialize_onigiri(self):
        global dynamic_properties
        print("Triggered!", dynamic_properties)
        if 'trigger_start' not in dynamic_properties.keys():
            return False
        dynamic_properties['trigger_start'] = False
        return False
    trigger_start : bpy.props.BoolProperty(
        name = "trigger start",
        get = initialize_onigiri,
        default = True
        )

class OnigiriRetargetProps(bpy.types.PropertyGroup):

    def update_retarget_enabled(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget
        if bbr.retarget_enabled == True:
            print("adding retarget_mode handler")
            bbr.retarget_text = "Select a source bone"

            bbr.retarget_rig = bbr.retarget_source_name
            
            bpy.app.handlers.depsgraph_update_post.append(retarget_mode)
        else:
            print("removing retarget_mode handler")
            bpy.app.handlers.depsgraph_update_post.remove(retarget_mode)
            bbr.retarget_text = ""
        return

    def update_retarget_set_source(self, context):
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget

        if bbr.retarget_set_source == False:
            bbr.retarget_source_name = ""
            return

        armObj = get_armature()
        if armObj is None:
            bb_settings['terminate'] = True
            bbr.retarget_set_source = False
            return

        if armObj.name == bbr.retarget_target_name:
            print("selected source is same as target, swapping")
            bbr.retarget_target_name = ""
            bb_settings['terminate'] = True
            bbr.retarget_set_target = False

        bbr.retarget_source_name_backup = armObj.name
        bbr.retarget_source_name = armObj.name
        return

    def update_retarget_set_target(self, context):
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget

        if bbr.retarget_set_target == False:
            bbr.retarget_target_name = ""
            return

        armObj = get_armature()
        if armObj is None:
            bb_settings['terminate'] = True
            bbr.retarget_set_target = False
            return

        if armObj.name == bbr.retarget_source_name:
            print("selected target is same as source, swapping")
            bbr.retarget_source_name = ""
            bb_settings['terminate'] = True
            bbr.retarget_set_source = False

        bbr.retarget_target_name_backup = armObj.name
        bbr.retarget_target_name = armObj.name
        return

    retarget_enabled : bpy.props.BoolProperty(
        name = "bbr enable retarget",
        description =            "-- internal",
        default = False,
        update = update_retarget_enabled
        )
    retarget_set_source : bpy.props.BoolProperty(
        name = "bbr add source",
        description =            "Select a rig then click this.  Transfer animation from this rig.",
        default = False,
        update = update_retarget_set_source
        )
    retarget_set_target : bpy.props.BoolProperty(
        name = "bbr set target",
        description =            "Select a rig then click this.  Transfer animation to this rig.",
        default = False,
        update = update_retarget_set_target
        )

    def update_retarget_suspend(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget
        
        if bbr.retarget_enabled == True:
            
            if bbr.retarget_suspend == True:
                    
                    bpy.ops.object.mode_set(mode='OBJECT')
                    return
            
            else:
                
                if bpy.context.mode != 'OBJECT':
                    bpy.ops.object.mode_set(mode='OBJECT')
                for o in bpy.data.objects:
                    o.select_set(False)
                obj[bbr.retarget_source_name].select_set(True)
                obj[bbr.retarget_target_name].select_set(True)
                
                activate(bbr.retarget_source_name)
                bpy.ops.object.mode_set(mode='POSE')

                bbr.retarget_text = "Retargeting Resumed"
                
                bpy.app.handlers.depsgraph_update_post.append(retarget_mode)
                return

        print("retarget is not enabled so suspend can't be used")
        bb_settings['terminate'] = True
        bbr.retarget_suspend = False
        return

    retarget_suspend : bpy.props.BoolProperty(
        name = "bbr retarget suspend",
        description =            "This button, or getting out of pose mode, when enabled, will allow you to move your rigs without losing your data.  "            "When you've finished click this button so that it's disabled (out) and you will be returned to your mapping stage.",
        default = False,
        update = update_retarget_suspend
        )
    def update_retarget_reset(self, context):
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        
        bbr.retarget_set_source = False
        bbr.retarget_set_target = False
        bb_settings['terminate'] = True
        bbr.retarget_reset = False
        
        return
    retarget_reset : bpy.props.BoolProperty(
        name = "bbr reterget reset",
        description =            "This resets the retargeting and turns it off.  Save your work and then click this button to get a stable state "            "so that you can continue doing other things in Blender without the stale data and a possible crash.",
        default = False,
        update = update_retarget_reset
        )

    def update_retarget_check(self, context):
        if bb_flags['debug'] == 1:
            print("bbr - update_retarget_check - triggered")
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget

        if (bbr.retarget_source_name == "" or bbr.retarget_target_name == "") and bbr.retarget_enabled == False:
            
            return
        
        elif (bbr.retarget_source_name == "" or bbr.retarget_target_name == "") and bbr.retarget_enabled == True:
            
            print("disabling animation mapper")
            animation_retarget()
            return
        else:
            
            print("enabling animation mapper")
            print("source orig", bbr.retarget_source_name)
            print("source back", bbr.retarget_source_name_backup)
            print("target orig", bbr.retarget_target_name)
            print("target back", bbr.retarget_target_name_backup)

            animation_retarget()

        return

    retarget_source_name : bpy.props.StringProperty(
        name = "retarget source name",
        description = "",
        default = "",
        update = update_retarget_check
        )
    retarget_target_name : bpy.props.StringProperty(
        name = "retarget target name",
        description = "",
        default = "",
        update = update_retarget_check
        )
    retarget_filename : bpy.props.StringProperty(
        name = "retarget filename",
        description = "",
        default = ""
        )

    retarget_source_name_backup : bpy.props.StringProperty(default = "")
    retarget_target_name_backup : bpy.props.StringProperty(default = "")

    retarget_source_bone : bpy.props.StringProperty(default = "")
    retarget_target_bone : bpy.props.StringProperty(default = "")

    retarget_text : bpy.props.StringProperty(default = "")

    retarget_rig : bpy.props.StringProperty(default = "")

class OnigiriRetargetApply(bpy.types.Operator):
    """Apply retargeting map to selected rig"""
    bl_idname = "onigiri.retarget_apply"
    bl_label = "apply retarget map"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget
        if bbr.retarget_set_source == False:
            return False
        if bbr.retarget_set_target == False:
            return False
        if len(obj[bbr.retarget_source_name]['bone_map']) == 0:
            return False
        if bpy.context.mode != 'POSE':
            return False
        return True

    def execute(self, context):
 
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget

        bpy.app.handlers.depsgraph_update_post.remove(retarget_mode)

        source_location = obj[bbr.retarget_source_name].matrix_world.to_translation().copy()
        target_location = obj[bbr.retarget_target_name].matrix_world.to_translation().copy()

        scale = obj[bbr.retarget_source_name].scale

        transformed_location = target_location - source_location

        scaled_location = scale_transforms(transformed_location, scale)

        bone_map = obj[bbr.retarget_source_name]['bone_map'].to_dict()

        bpy.ops.object.mode_set(mode='EDIT')

        for sbone in bone_map:
            tbone = bone_map[sbone]

            head = obj[bbr.retarget_target_name]['bone_data'][tbone]['pose']['head']
            tail = obj[bbr.retarget_target_name]['bone_data'][tbone]['pose']['tail']
            roll = obj[bbr.retarget_target_name]['bone_data'][tbone]['edit']['roll']

            scale_factor_head = scale_transforms(head, scale)
            scale_factor_tail = scale_transforms(tail, scale)

            if 1 == 1:
                obj[bbr.retarget_source_name].data.edit_bones[sbone].head =                    mathutils.Vector(scaled_location) + mathutils.Vector(scale_factor_head)
                obj[bbr.retarget_source_name].data.edit_bones[sbone].tail =                    mathutils.Vector(scaled_location) + mathutils.Vector(scale_factor_tail)
                
            if 1 == 0:
                obj[bbr.retarget_source_name].data.edit_bones[sbone].head =                    transformed_location + mathutils.Vector(obj[bbr.retarget_target_name]['bone_data'][tbone]['pose']['head'])
                obj[bbr.retarget_source_name].data.edit_bones[sbone].tail =                    transformed_location + mathutils.Vector(obj[bbr.retarget_target_name]['bone_data'][tbone]['pose']['tail'])

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action = 'DESELECT')

        bpy.app.handlers.depsgraph_update_post.append(retarget_mode)

        return {'FINISHED'}

class OnigiriRetargetRestore(bpy.types.Operator):
    """Restore the bones to their original locations, this will not delete your work."""
    bl_idname = "onigiri.retarget_restore"
    bl_label = "restore rig"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget
        if bbr.retarget_set_source == False:
            return False
        if bbr.retarget_set_target == False:
            return False
        if len(obj[bbr.retarget_source_name]['bone_map']) == 0:
            return False
        if bpy.context.mode != 'POSE':
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget

        bpy.app.handlers.depsgraph_update_post.remove(retarget_mode)

        restore_sources("edit")

        bpy.app.handlers.depsgraph_update_post.append(retarget_mode)

        return {'FINISHED'}

class OnigiriRetargetSave(bpy.types.Operator, ExportHelper):
    """Save your retarget map to a file"""
    bl_idname = "onigiri.retarget_save"
    bl_label = "Save Retarget Map"

    filename_ext = ".bbr"
    filter_glob : bpy.props.StringProperty(
        default='*.bbr',
        options={'HIDDEN'}
        )

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget

        if bbr.retarget_enabled == False:
            return False
        
        if len(obj[bbr.retarget_source_name]['bone_map']) == 0:
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget

        bone_map = obj[bbr.retarget_source_name]['bone_map'].to_dict()

        retarget_map = "# Animation retargeting map auto-generated by Onigiri\n";
        retarget_map += "retarget_map = {\n"
        for sbone in bone_map:
            mbone = bone_map[sbone]
            retarget_map += "    " + '"' + sbone + '": ' + '"' + mbone + '",' + "\n"
        retarget_map += "    }\n"

        output = open(self.properties.filepath, 'w', encoding='UTF8')
        output.write(retarget_map)
        output.close()

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriRetargetBake(bpy.types.Operator):
    """Bake the animation to the target rig"""
    bl_idname = "onigiri.retarget_bake"

    bl_label = "retarget bake"
    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget

        if bbr.retarget_set_source == False:
            return False
        if bbr.retarget_set_target == False:
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(obj[bbr.retarget_source_name]['bone_map']) == 0:
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget

        bpy.ops.onigiri.retarget_apply()

        bpy.app.handlers.depsgraph_update_post.remove(retarget_mode)

        activate(bbr.retarget_target_name)
        bone_map = obj[bbr.retarget_target_name]['bone_map'].to_dict()
        s_rig = bbr.retarget_source_name
        t_rig = bbr.retarget_target_name

        for target_bone in bone_map:
            source_bone = bone_map[target_bone]
            
            for con in bb_const["constraint_types"]:
                add_constraint(t_rig, target_bone, s_rig, source_bone, con, bb_const['constraint_influence'])

        print("ALERT!: handler is disabled for testing, be careful!")

        return {'FINISHED'}

class OnigiriRetargetLoad(bpy.types.Operator, ImportHelper):
    """Load a previously saved retarget map into the set to continue work on it or to apply it to your rigs"""
    bl_idname = "onigiri.retarget_load"
    bl_label = "Retarget Load"

    filename_ext = ".bbr"
    filter_glob : bpy.props.StringProperty(
        default='*.bbr',
        options={'HIDDEN'}
        )

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget
        if bbr.retarget_enabled == False:
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget

        filename = self.properties.filepath
        retarget_map = {}
        try:
            namespace = {}
            exec(open(filename, 'r', encoding='UTF8').read(), namespace)
            retarget_map.update(namespace['retarget_map'])
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        missing = []
        mappable = {}
        for sbone in retarget_map:
            tbone = retarget_map[sbone]
            if sbone in obj[bbr.retarget_source_name].data.bones:

                if obj[bbr.retarget_target_name].get('onigiri_control_rig') == 1:
                    
                    if tbone in cr_bones_map:
                        tbone = cr_bones_map[tbone]

                if tbone in obj[bbr.retarget_target_name].data.bones:
                    
                    mappable.update({sbone: tbone})
                continue
            
            missing.append(sbone)
        if len(mappable) == 0:
            
            print("Bad map, no matching bones in source rig -", missing)
            popup("No mappable bones, see console for details", "Wrong Map?", "ERROR")
            bbr.retarget_text = "No matching bones in loaded map"
            return {'FINISHED'}

        print("retarget map - loaded without errors")

        bpy.app.handlers.depsgraph_update_post.remove(retarget_mode)

        bpy.ops.pose.select_all(action = 'DESELECT')

        smap = {}
        tmap = {}
        activate(bbr.retarget_source_name)
        for sbone in retarget_map:
            tbone = retarget_map[sbone]

            if obj[bbr.retarget_target_name].get('onigiri_control_rig') == 1:
                
                if tbone in cr_bones_map:
                    tbone = cr_bones_map[tbone]
                else:
                    txt = "Onigiri control rig found as target but control bone is missing, this is a fatal error: " + tbone
                    print(txt)
                    popup(txt, "Fatal Error!", "ERROR")
                    return {'FINISHED'}

            if sbone not in obj[bbr.retarget_source_name].data.bones:
                print("Missing target for source:", sbone, tbone)
                continue

            smap.update({sbone: tbone})
            tmap.update({tbone: sbone})

            obj[bbr.retarget_source_name].data.bones[sbone].select = True
            obj[bbr.retarget_source_name].pose.bones[sbone].bone_group =                bpy.data.objects[bbr.retarget_source_name].pose.bone_groups[bb_source_group]

        bpy.ops.pose.select_all(action = 'DESELECT')

        activate(bbr.retarget_target_name)
        for tbone in tmap:
            obj[bbr.retarget_target_name].data.bones[tbone].select = True
            obj[bbr.retarget_target_name].pose.bones[tbone].bone_group =                bpy.data.objects[bbr.retarget_target_name].pose.bone_groups[bb_target_group]

        if len(smap) == 0:
            txt = "There were no matching bones in your loaded map, nothing to do"
            print(txt)
            popup(txt, "Map Mismatch", "ERROR")
        else:
            obj[bbr.retarget_source_name]['bone_map'] = smap
            obj[bbr.retarget_target_name]['bone_map'] = tmap

        bpy.ops.pose.select_all(action = 'DESELECT')

        bpy.app.handlers.depsgraph_update_post.append(retarget_mode)

        return {'FINISHED'}

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriRetargetRemoveMap(bpy.types.Operator):
    """Remove this specific bone map from your set, this will NOT delete all of your work, only the associated bone map."""
    bl_idname = "onigiri.retarget_remove_map"
    bl_label = "remove retarget map"

    bone : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget

        if bpy.context.mode != 'POSE':
            return False
        
        if bbr.retarget_suspend == True:
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bbr = bpy.context.window_manager.bb_retarget

        bpy.app.handlers.depsgraph_update_post.remove(retarget_mode)

        target_bone_value = obj[bbr.retarget_source_name]['bone_map'][self.bone]

        active_obj = bpy.context.active_object.name

        activate(bbr.retarget_source_name)

        bpy.ops.object.mode_set(mode='EDIT')
        restore_source_bone(self.bone, "edit")
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action = 'DESELECT')
        obj[bbr.retarget_source_name].data.bones[self.bone].select = True
        bpy.ops.pose.group_unassign()
        obj[bbr.retarget_source_name].data.bones[self.bone].select = False

        activate(bbr.retarget_target_name)

        bpy.ops.pose.select_all(action = 'DESELECT')
        obj[bbr.retarget_target_name].data.bones[target_bone_value].select = True
        bpy.ops.pose.group_unassign()
        obj[bbr.retarget_target_name].data.bones[target_bone_value].select = False

        del obj[bbr.retarget_source_name]['bone_map'][self.bone]
        del obj[bbr.retarget_target_name]['bone_map'][target_bone_value]

        activate(active_obj)

        bpy.app.handlers.depsgraph_update_post.append(retarget_mode)

        return {'FINISHED'}

class OnigiriRigProperties(bpy.types.PropertyGroup):

    rig_rotate : bpy.props.BoolProperty(
        name = "",
        description =            "Second life rigs face the X direction.  It's difficult, and may be impossible, to use some blender tools "            "with the rig in this orientation so most of the time you probably see the rig facing -Y instead.  That's what "            "this button is for but you can disable it and have a correct facing rig, if you really need that for something.",
        default = True
        )
    rig_clean : bpy.props.BoolProperty(
        name = "",
        description =            "This is an expected process, it will clean the original rig so that there's no influences that will interfere with "            "the new controllers as a result of attaching a proxy rig.  This is necessary in order to get clean motion.  Your "            "original rig is copied first, retaining all drivers, controllers and other influences, then the original rig is cleaned "            "so that it's prepared properly for this symmetry.",
        default = True
        )

    def update_lock_selected(self, context):
        
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_rig = bpy.context.window_manager.bb_rig
        if bb_rig.lock_selected == False:
            bb_rig.lock_engaged = False
            bb_rig.rig_selected = ""
            bb_rig.bone_selected = ""
        else:
            if bpy.context.mode == 'POSE':
                if len(bpy.context.selected_pose_bones) == 1:
                    
                    pBone = bpy.context.selected_pose_bones[0]
                    bb_rig.bone_selected = pBone.name
                    bb_rig.rig_selected = pBone.id_data.name 
                    bb_rig.lock_engaged = True

            if bb_rig.lock_engaged == False:
                bb_rig.property_unset("lock_selected")
                bb_rig.rig_selected = ""
                bb_rig.bone_selected = ""

        return 

    lock_selected : bpy.props.BoolProperty(
        name = "",
        description =            "Lock the selection"            "\n\n"            "Use this to continue to view the bone transforms even when the rig is not selected.  This was useful for me when testing "            "various aspects of Blender and how it interprets transform relations.  Disable it to lose the connection.",
        default = False,
        update = update_lock_selected
        )
    lock_engaged : bpy.props.BoolProperty(
        name = "",
        description = "-- internal, the first lock is a trigger, this one holds the lock.  This is disabled when the lock is removed",
        default = False
        )
    rig_selected : bpy.props.StringProperty(
        name = "",
        description =            "-- internal base property used to identify a target rig",
        default = ""
        )
    bone_selected : bpy.props.StringProperty(
        name = "",
        description =            "-- internal base property used to identify a bone selected in the target rig",
        default = ""
        )
    
class OnigiriRigProps(bpy.types.PropertyGroup):

    rigs_enabled : bpy.props.BoolProperty(
        description = "Use this to enable showing and usage of the old rigs, which can be useful if creating "            "characters from scratch, clothing or using a kit.  They can be directly animated and the resulting "            "animation can be uploaded to Second Life using the Onigiri animation exporter.",
        default=False
        )

    rigs_create : bpy.props.BoolProperty(
        description = "This generates a rig from internal data, it's slower.  If you have a lot of things in your "            "scene try turning this off, then the rig will be fetched from a saved library.",
        default=True
        )

    bone_prefix_name : bpy.props.StringProperty(
        description = "Set a name here, or remove it, and click the button.  Do not change the Second Life armature",
        default = "",
        )

    bone_prefix_label : bpy.props.StringProperty(default="")

    bone_prefix_last_armature : bpy.props.StringProperty(default="")

class OnigiriAddRig(bpy.types.Operator):
    """Animate

    Add a fully featured rig for animations, animesh and mesh / character creations.  If you're uncertain about
    which rig to use, this is probably the one you want.  If you're making animations, you're in the right place.
    """

    bl_idname = "onigiri.add_rig"
    bl_label = "Add a Onigiri rig to the scene for Second Life"

    rig_class : bpy.props.StringProperty(default="")

    filter_glob : bpy.props.StringProperty(
        default='*.cbl',
        options={'HIDDEN'}
    )

    def execute(self, context):
        obj = bpy.data.objects
        brp = bpy.context.window_manager.bb_rigprops

        if self.rig_glass == "":
            txt = "something strange happened when running AddRig, no rig type"
            print(txt)
            return {'FINISHED'}

        if brp.rigs_create == True:
            print("Creating fresh rig from mapper")
            
            armObj = create_bento_buddy_rig()
            
            armObj['rig_class'] = "neutral"
            
            armObj["onigiri"] = bl_info['version']

            return {'FINISHED'}

        else:
            path = script_dir + presets_path
            file = bb_settings['files']['rigs']['lib']
            object = bb_settings['files']['rigs']['types'][self.rig_class]

            full_path = path + file

            filepath = path + file + "/Object/" + object + "/"
            directory = full_path + "/Object/"
            filename = object

            if os.path.exists(full_path) == False:
                print("OnigiriAddRig reports: missing data", full_path)
                popup("External rig data is missing, your installation might be damaged")
                return {'FINISHED'}

            bpy.ops.wm.append(
                filepath = filepath,
                directory = directory,
                filename = filename,
                )

            for o in bpy.context.selected_objects:
                obj_name = o.name
                if obj_name.startswith("Onigiri"):
                    bpy.context.view_layer.objects.active = o
                    
                    obj[obj_name].name = "Onigiri" 
                    break
                return {'FINISHED'}

        return {'FINISHED'}

def scoobiedoo_create_bento_buddy_rig():

    for flag in bb_flags:
        bb_flags[flag] = getattr(bpy.context.scene.onigiri, flag)

    bb = bpy.context.scene.onigiri

    if getattr(bpy.context.scene.onigiri, 'pos_rig') == True:
        bb_rig = create_rig(skel_type="pos", add_control_rig=bb.add_control_rig)
    else:
        bb_rig = create_rig(skel_type="pivot", add_control_rig=bb.add_control_rig)

    bpy.data.objects[bb_rig.name]["onigiri_control_rig"] = bpy.context.scene.onigiri.add_control_rig
    
    bpy.data.objects[bb_rig.name]["onigiri"] = bl_info['version']
    setattr(bpy.context.scene, "bone_source", bb_rig.name)

    return bb_rig

    obj = bpy.data.objects

    filename = script_dir + presets_path + "neutral_reference.py"

    nr = {} 
    try:
        namespace = {}
        exec(open(filename, 'r', encoding='UTF8').read(), namespace)
        nr.update(namespace['neutral_reference'])
    except Exception as e:
        print(traceback.format_exc())
        return False

    armObj = create_rig()
    armObj["onigiri"] = bl_info['version']

    return armObj

class OnigiriExpireProperties(bpy.types.PropertyGroup):

    expire_ready : bpy.props.BoolProperty(
        name = "expire ready",
        description =            "does nothing",
        default = False,
        
        )
    
class OnigiriMapperProps(bpy.types.PropertyGroup):

    bone_control_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "This section is for  manipulating bone locations so that you get a better visual representation "            "in Second Life as well as the ability to control these bones better.  This is a bone packer "            "and stabilizer mesh to control where your bones end up in SL.  The mesh is required to be "            "uploaded to SL with joint positions enabled and attached to the same object as your Animesh "            "or attached to your avatar if that's the target you're going for.",
        default = False,
        )

    mapper_attach_from_start : bpy.props.BoolProperty(
        description =            "This makes sure your time slider is moved to the start frame where it belongs before attaching.  "            "If the controllers are attached while your subjects(s) are in a non-reference pose then your animation transfer "            "will not work properly.  There is no easy way to determine your start frame, it's left up to you to make sure that "            "your (Start) on the (Timeline) window is correct and is on or before your reference pose.",
        default = True
        )

    def update_mapper_lock_source(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        if bmp.mapper_lock_source == True:
            
            if len(bpy.context.selected_objects) == 0:
                popup("Choose a source rig")
                bmp.mapper_message = "Choose 1 rig for source"
                bmp.mapper_lock_source = False
                bb_settings['terminate'] = True
                return
            
            for o in bpy.context.selected_objects:
                if o.type != 'ARMATURE':
                    o.select_set(False)
            
            if len(bpy.context.selected_objects) > 1:
                popup("Choose only one 1 rig for source")
                bmp.mapper_message = "Choose 1 rig for source"
                bmp.mapper_lock_source = False
                bb_settings['terminate'] = True
                return
            armObj = bpy.context.selected_objects[0]
            if armObj.type != 'ARMATURE':
                print("Mapper expected an armature but this one didn't pass:", armObj.name)
                bmp.mapper_lock_source = False
                bb_settings['terminate'] = True
                return
            
            if 'targets' in bmp.keys() and armObj.name in bmp['targets']:
                print("source rig in target")
                bmp.mapper_message = "Can't have target in source"
                bb_settings['terminate'] = True
                bmp.mapper_lock_source = False
                return

            bmp.mapper_source_name = armObj.name
            bmp.mapper_source_name_backup = armObj.name

            for bone in armObj.pose.bones:
                if bone.parent == None:
                    bmp.mapper_anchor_source_name = bone.name
            
            print("update_mapper_lock_source completed")

        elif bmp.mapper_lock_source == False:
            
            if bmp.mapper_enabled == True:
                return
            else:
                print("Mind changer! Source cleared...")
                bmp.mapper_source_name = ""
                bmp.mapper_anchor_name = ""
            return
        return 

    def update_mapper_lock_target(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        if bmp.mapper_lock_target == True:
            if len(bpy.context.selected_objects) == 0:
                popup("Select 1 or more targets")
                bmp.mapper_message = "Select target rigs"
                bmp.mapper_lock_source = False
                bb_settings['terminate'] = True
                return
            
            for o in bpy.context.selected_objects:
                if o.type != 'ARMATURE':
                    o.select_set(False)
            
            if len(bpy.context.selected_objects) == 0:
                popup("Only armatures can be targets")
                bmp.mapper_message = "Armatures Only!"
                bmp.mapper_lock_target = False
                bb_settings['terminate'] = True
                return
            
            if bmp.mapper_source_name != "" and obj[bmp.mapper_source_name] in bpy.context.selected_objects:
                obj[bmp.mapper_source_name].select_set(False)
                print("removed source from selection")

            if bmp.get('targets') == None:
                bmp['targets'] = dict()
            for o in bpy.context.selected_objects:
                if o.type != 'ARMATURE':
                    print("Mapper expected armatures but this one didn't pass:", o.name)
                    del bmp['targets']
                    bmp.mapper_lock_target = False
                    bb_settings['terminate'] = True
                    return
                bmp['targets'].update({o.name: {}})
            
            bmp.mapper_targets = len(bmp['targets'])

            shifter.morph_reset(bmp['targets'])

            bmp.mapper_target_name = "TRIGGERED!"

        elif bmp.mapper_lock_target == False:
            
            if bmp.mapper_enabled == True:
                return
            else:
                print("Mind changer! Target cleared...")
                bmp.mapper_target_name = ""
            return 

        return

    mapper_menu_enabled : bpy.props.BoolProperty(
        description =            "Enable the Character Mapper and animation Retargeter"            "\n\n"            "In here you can instantly generate a Second Life compatible character, with included animation, from an "            "arbitrary source.  You can use this for Animes of verious types or even wear the resulting character as your ow.",
        default = False
        )
    mapper_lock_source : bpy.props.BoolProperty(
        name = "anim add source",
        description =            "Select your bone source rig, this might, for instance, be a Onigiri rig designed for Second Life or Opensim.",
        default = False,
        update = update_mapper_lock_source
        )
    mapper_lock_target : bpy.props.BoolProperty(
        name = "animesh set targets",
        description =            "Select 1 or more of your character armatures.  These armatures are associated with the characters that you want to "            "bring into Second Life, Opensim or remap to another platform.  For Second Life the bone total cannot be more than 110 "            "per mesh.  The mapper will do the math for you, when source and target are enabled, and let you know if there's a problem.",
        default = False,
        update = update_mapper_lock_target
        )
    mapper_restore_pose : bpy.props.BoolProperty(
        name = "Restore Manual Pose",
        description = "\n"            "If you set a non animated pose for your start frame, so that the armatures/bones match up better, keep this enabled in order "            "to revert back to that same pose between map cycles (reset/load).  This will also snap your frame back to the first frame of "            "your animation which is the only way this can work.  If you don't like the jolt of being tossed back to your start frame then "            "disable this and use the Onigiri pose library to restore your poses where you like them.",
        default = True,
        )
    
    def update_mapper_check(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        
        if bmp.mapper_source_name == "" or bmp.mapper_target_name == "":
            return

        print("mapper engaged, storing armature data")

        trigs = list()
        for tarm in bmp['targets']:
            mapper.store_armature_data(tarm)
            trigs.append(tarm)
            obj[tarm]['role'] = "target"
        
        obj[bmp.mapper_source_name]['targets'] = trigs
        
        obj[bmp.mapper_source_name]['name'] = obj[bmp.mapper_source_name].name
        
        obj[bmp.mapper_source_name]['role'] = "source"

        bmp.mapper_enabled = True
        
        mapper_init()

        return

    mapper_source_name : bpy.props.StringProperty(
        name = "mapper source name",
        description = "",
        default = "",
        update = update_mapper_check
        )
    
    mapper_source_name_backup : bpy.props.StringProperty(
        description = "--internal mapper backup source name",
        default="",
        )
    
    mapper_target_name : bpy.props.StringProperty(
        name = "mapper target names",
        description = "",
        default = "",
        update = update_mapper_check
        )

    def update_mapper_allow_all_bones(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bmp = bpy.context.window_manager.bb_mapper
        if bmp.mapper_allow_all_bones == True:
            bb_settings['terminate'] = True
            bmp.mapper_safe_bones = False
    def update_mapper_safe_bones(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bmp = bpy.context.window_manager.bb_mapper
        if bmp.mapper_safe_bones == True:
            bb_settings['terminate'] = True
            bmp.mapper_allow_all_bones = False

    mapper_morph_pose : bpy.props.BoolProperty(
        description =            "Test tool, generates a corrective morph pose in order to use all mbones.  This is part of the Shape Shifter tools"            "\n\n"            "If you see this you probably want to use it always.  When it finally vanishes then the feature is already part of "            "the background mapper process.",
        default=False,
        )
    mapper_safe_bones : bpy.props.BoolProperty(
        description =            "This guarantees that the automapper uses only those bones that can be animated properly with arbitrarily mapped characters.  "            "That doesn't mean you are limited to this amount, it just means easier and quicker prototyping before you set on a set of bones "            "that you'll be using.  The idea of the automapper is to click a few times and see your results in Second Life, and that's just "            "what it does.  The process is non-destructive so you can continue to change bones, names, positions and bind poses to get where "            "you're going before commitng to a set.",
        default=True,
        update = update_mapper_safe_bones
        )
    mapper_allow_all_bones : bpy.props.BoolProperty(
        description =            "The mapper will use safe bones first, then the remainder of the typical deform bone, which includes what you may be referring to as "
            "bento bones.  After which volume bones will be appended to the list if they were enabled.  If you want to map all bones try it with "            "the Shape Shifter option enabled to prevent wobble and out-right bone explosions",
        default=False,
        update = update_mapper_allow_all_bones
        )
    mapper_force_pelvis_map : bpy.props.BoolProperty(
        description =            "If you're going to carry your auto-map as a ctm you'll want a heads up here.  The pelvis must be mapped for smooth "            "animation retargeting.  The very useful (Retarget Only) feature cannot be used without an anchor, this is your anchor.",
        default=False,
        )
    mapper_allow_volume_bones : bpy.props.BoolProperty(
        description =            "Include bones in your chosen set."            "\n\n"            "You can add volume bones to the list of bones to map along with your chosen set, they will be added to the end of the series "            "so that they are used last.  You're always able to make your own map, bone by bone, instead of relying on Onigiri but these "            "auto-map features are a nice addition to prototype testing and can speed up your discovery process quite a bit.",
        default=False,
        )
    mapper_retarget_only : bpy.props.BoolProperty(
        description =            "This is a primary mode of retargetting animations.  It is the suggested method for a typical setup.  This feature allows you "            "to use proxy objects, which is already set for you, to create a master and slave object in order to drive your working rig.  "            "Rotation data from the animated bones will be transmitted to the working rig's bones.  There are other options associated with "            "this type of retargetting, location data and anchor.  Typically you'll want the anchor bone to be enabled and location data "            "to be disabled.  Additionally, having this feature enabled prevents the creation, and usage, of the sticky rig (fly_paper).",
        default=False,
        )
    mapper_auto_fix_bvh : bpy.props.BoolProperty(
        name = "Auto Fix BVH / SL map",
        description = ""            "\n"            "BVH names are used in Second Life and some exporters used this map, Avastar for instance, to export your animation.  "            "This auto-fix will detect that and fix it for you if you haven't already.  There is a tool for it to do it yourself in "            "(Rig Tools / Fix SL BVH Rig) but this button does it virtually, without changing the bone names.  It's usually safe to "            "keep this enabled but if you ever run ito the odd situation where your SL bone name matches some other target system then "            "you want to disable this.  Essentially if you're expecting an SL animation then use this feature.",
        default = True,
        )

    def update_enable_pelvis_controls(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        anchor_slave = bmp['transient']['anchor_slave']

        last_start = None
        for target in bmp['targets']:
            this_start, this_stop = bpy.data.objects[target].animation_data.action.frame_range

            if last_start == None:
                last_start = this_start

            elif this_start < last_start:
                last_start = this_start

        bpy.context.view_layer.update()
        frame_now = bpy.context.scene.frame_current
        bpy.context.scene.frame_current = last_start
        
        bpy.context.scene.frame_set(last_start)

        print("frame_now:", frame_now)
        print("last_start:", last_start)

        con = bmp.constraint_name_anchor

        state = save_state()
        
        for o in bpy.context.selected_objects:
            o.select_set(False)

        obj[anchor_slave].select_set(True)
        activate(anchor_slave)

        print("con:", con)
        print("anchor_slave:", anchor_slave)
        obj[anchor_slave].constraints[con].use_rotation_x = bmp.enable_pelvis_rotation_x
        obj[anchor_slave].constraints[con].use_rotation_y = bmp.enable_pelvis_rotation_y
        obj[anchor_slave].constraints[con].use_rotation_z = bmp.enable_pelvis_rotation_z
        obj[anchor_slave].constraints[con].use_location_x = bmp.enable_pelvis_location_x
        obj[anchor_slave].constraints[con].use_location_y = bmp.enable_pelvis_location_y
        obj[anchor_slave].constraints[con].use_location_z = bmp.enable_pelvis_location_z

        context_copy = bpy.context.copy()
        context_copy["constraint"] = obj[anchor_slave].constraints[con]

        utils.set_inverse(context_copy, con)
        
        bpy.context.scene.frame_set(frame_now)

        restore_state(state)

    constraint_name_anchor : bpy.props.StringProperty(default = "BB Child Of - sticky rig anchor")

    enable_pelvis_rotation_x : bpy.props.BoolProperty(default = False, update=update_enable_pelvis_controls)
    enable_pelvis_rotation_y : bpy.props.BoolProperty(default = False, update=update_enable_pelvis_controls)
    enable_pelvis_rotation_z : bpy.props.BoolProperty(default = False, update=update_enable_pelvis_controls)
    
    enable_pelvis_location_x : bpy.props.BoolProperty(default = True, update=update_enable_pelvis_controls)
    enable_pelvis_location_y : bpy.props.BoolProperty(default = True, update=update_enable_pelvis_controls)
    enable_pelvis_location_z : bpy.props.BoolProperty(default = True, update=update_enable_pelvis_controls)

    location_data : bpy.props.BoolProperty(
        description =            "Use location data for all bones.  This is probably not practical since it will effectively give you the same results "            "as mapping without the (Retarget Only) feature but it could come in handy for debugging a difficult rig.  Note, this "            "setting overrides the anchor property.",
        default=False,
        )

    def update_mapper_anchor_enabled(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        
        if bmp.get('transient') == None:
            print("transient missing, returning")
            return
        if bmp['transient'].get('sticky') == None:
            print("sticky not active, returning")
            return
        sticky = bmp['transient']['sticky']
        if len(sticky) == 0:
            print("update_mapper_anchor_enabled reports: sticky is empty, returning")
            return
        if bmp.mapper_source_name == "" or bmp.mapper_target_name == "":
            print("update_mapper_anchor_enabled reports: sticky attempt but mapper is not complete yet, returning")
            return
        
        anchor = bmp['transient']['anchor']
        slave = bmp['transient']['source'][anchor]
        if slave not in bpy.data.objects:
            print("update_mapper_anchor_enabled reports: fatal error, missing slave object")
            return

        bpy.context.view_layer.update()
        frame_now = bpy.context.scene.frame_current
        
        bpy.context.scene.frame_set(0)
        obj[slave].constraints[sticky].mute = not bmp.mapper_anchor_enabled 
        bpy.context.scene.frame_set(frame_now)

        print("Sticky rig toggled:", bmp.mapper_anchor_enabled)
        return

    mapper_anchor_enabled : bpy.props.BoolProperty(
        name = "Enable Pelvis Anchor",
        description =            "\n"            "Having this enabled is usually what you want and will allow the working rig to follow the animated rig's location.  "            "The target rig in this case is the animated rig, which we are using as a source for our rig that's not animated.  Keep in "            "mind that the source and target definitions here are different than what you'd expect in a (retargeting) system since this "            "particular tool is designed for something a bit different but has the added benefit of being able to retarget animations.",
        default=True,
        update = update_mapper_anchor_enabled
        )
    mapper_anchor_source_name : bpy.props.StringProperty(
        description =            "This is the name of the bone that will follow along with the animated subject, this aught to be a root bone and it "            "will be location linked to its counterpart.  This is something you probably want and the default is shown as the first "            "root bone found in the skeleton.  If it's wrong change it.  It's probably not wrong.",
        default="",
        )
    mapper_proxy_objects : bpy.props.BoolProperty(
        description =            "With this enabled the (Attach) will generate proxy objects to help prevent glitches with animation transfers.  "            "Using this is the default because it's almost always what you want.  The alternative, without it, is a direct "            "bone mapping, which actually works at times, and can give you a quick view of how things look and may be helpful "            "for debugging.  The associated objects will be removed automatically when the mapper is no longer active on the "            "intended items unless you 'Disconnect Mapped Items'.",
        default=True,
        )
    mapper_edit_targets : bpy.props.BoolProperty(
        description =            "Enabling this will expand a list of mapped bones.  You can remove bones from the map to test your exported animation.  "            "This is useful for testing to see which bones are causing difficulties in your end result.  You'll want to create a new "            "map file, when you have everything working, so that you won't have to edit them again.",
        default=False,
        )

    mapper_template_path : bpy.props.StringProperty(
        name = "mapper template name",
        description = "This area is really for internal use, it stores the location of "            "template you loaded, you really shouldn't mess with it.",
        default = "",
        )
    
    mapper_template_ready : bpy.props.BoolProperty(
        name = "mapper template ready",
        description = "-- internal",
        default = False
        )

    mapper_targets : bpy.props.IntProperty(
        default = 0,

        )
    mapper_message : bpy.props.StringProperty(default="[look here for messages]")

    mapper_enabled : bpy.props.BoolProperty(default=False)

    mapper_fitted : bpy.props.BoolProperty(
        description = "This is for fitted mesh for Second Life, if you're mapping for a system other than Second Life "            "then you don't need this.  The default is on because most people will probably be using this.  Even if you are "            "not interested in using the fitted mesh (volume bones) option, it probably will not break anything leaving it "            "enabled.  In addition, if you find that you want to use volume bones, for some special purpose, then you will want this "            "feature enabled or the results in Second Life may be strange since these bones are treated differently and the mapper "            "knows how to process them for export to limit the visible weirdness that could occur.",
        default=True,
        )
    mapper_stabilize : bpy.props.BoolProperty(
        name = "Stabilize Animation Transfers",
        description =            "NOTE:  This does not apply to the (Retarget Only) feature\n\n"            "This feature may be going away, it is not performing as expected and the introduction of the .anim format "            "should be able to replace this in the future.  Until then it can provide some stability in oddly transformed rigs.  \n\n"            "The lock makes the bones stick to the targets, this ensures that your animation will transfer although the "            "quality will vary.  This feature (stabilize) goes further and secures the unused bones so that they don't move."            "This can allow a cleaner transition into Second Life.  The object created in your scene for this purpose is "            "(Fly Paper) and is a copy of your source armature.  It's removed when you reset the mapper.",
        default=True,
        )

    def update_mapper_pack_bones(self, context):
        bmp = bpy.context.window_manager.bb_mapper
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_settings['terminate'] = True
        bmp.mapper_pack_bones = False
    
    def update_mapper_custom_stabilizer(self, context):
        bmp = bpy.context.window_manager.bb_mapper
        
        if bmp.mapper_custom_stabilizer == False:
            return
        bmp.mapper_custom_stabilizer = False

    def update_mapper_visual_stabilizer(self, context):
        bmp = bpy.context.window_manager.bb_mapper
        
        if bmp.mapper_visual_stabilizer == False:
            return
        bmp.mapper_visual_stabilizer = False

    mapper_pack_bones : bpy.props.BoolProperty(
        name = "",
        description =            "Enable this toggle to expand the options:"            "\n\n"            "This will pack the unused bones into a grid, away from their default positions, ensuring that any mesh attached "            "to them can be uploaded with joint positions.  This is a feature to help stabilize your animations.  "            "This is sometimes necessary because foreign rigs do not usually end up with the same amount of usable bones after "            "conversion and the free floating bones, unused bones, can cause mesh distortions and animation wobble.  You might "            "consider using this without joint positions but with a deformer pose instead."            "\n\n"            "IMPORTANT!: Animations affecting the packed bones will cause interference with your target area.  To prevent this "            "use the (Glue Packed Bones) option which will create a duplicate of your mesh and constrain your packed bones to it",
        default=False,

        )
    mapper_rebuild_rig : bpy.props.BoolProperty(
        name = "",
        description =            "Rebuild SL Rig"            "\n\n"            "If this is an SL compatible rig you're asking the packer to rebuild it before packing the bones.  This is what you want "            "if the rig is SL compatible and there's a very good chance that the results will not be ideal if you do NOT choose this "            "option.  If your rig has been determined to be incompatible with SL this rebuild will not happen at all.",
        default=True,
        )
    mapper_rebuild_rig_attachment : bpy.props.BoolProperty(
        name = "",
        description =            "Rebuild Attachment Bones"            "\n\n"            "This may or may not be a good idea to add, I haven't tested skinning to attachment bones very well yet.  But the option is here "            "for you to enabled.  If enabled then the attachment bones, those that can be skinned to, will be generated and the resulting "            "stabilizer mesh, when generated, will have those as definitions.  Your stabilizer mesh may very well be highly deformed when "            "using this option, as well as when using volume bones.",
        default=False,
        )
    mapper_rebuild_rig_volume : bpy.props.BoolProperty(
        name = "",
        description =            "Rebuild Volume Bones"            "\n\n"            "Just like the attachment bone option this may deform your flat stabilizer mesh but it shouldn't matter really, the idea of using "            "a stabilizer is to force bones into a genera vacinity and to stay there.  But the option is here for you to enable if you choose.",
        default=False,
        )
    mapper_pack_pelvis : bpy.props.BoolProperty(
        name = "",
        description =            "Include Pelvis"            "\n\n"            "This will include the pelvis (mPelvis) if it's not already skinned to.  I have no idea if this option is useful but it seems to "            "make sense to include it at least as a test, to rule out any issues with this bone.  If this is enabled then the mPelvis bone "            "will be packed along with the other unused bones.",
        default=True,
        )
    mapper_pack_compress : bpy.props.BoolProperty(
        name = "",
        description =            "Compress to a point.  If enabled this combines (Pack) with the (Custom Stabilizer) process so you only need this."            "\n\n"            "This is an alternative to the grid pattern arrangement and is more suited for bulk manipulation and accuracy.  You will "            "sometimes want to control where an Animesh is placed, either when worn or with respect to its base/root object.  This "            "option will give you that control much easier since it places everything in a specific location in your 3d arena determined "            "by you.  If you enable (Selected) virtually anything can be used as a locator item such as selected object (mesh or rig) "            "or a selected vertex or even a selected bone.  All of the unused bones will be packed into this one location and a mesh "            "will be created to support them.  The (Length) value in the options area will be used for the bone length",
        default=False,
        )
    mapper_pack_selected : bpy.props.BoolProperty(
        name = "",
        description =            "Compress to selected.  All of your bones and a resulting mesh will appear at the designated location."            "\n\n"            "If this is enabled then your compressed set will be located at the area logically suited for the mode you are in. "            "If you are in edit mode on a mesh object then a selected vertex will be used as a locator.  If you're in edit mode or "            "pose mode on a rig then a selected bone will be used.  If you are in object mode then a selected object location "            "will be used.  Without this enabled your compressed set will be located at origin (0,0,0)",
        default=True,
        )
    mapper_pack_glue : bpy.props.BoolProperty(
        name = "",
        description =            "This stabilizes your packed bones.  You will notice a new rig in your scene if using this.  This rig is designed to tack your"            "packed bones into place so that they don't move.  This can clear up some wigglies but if your rig and animation are not "            "properly setup then the influences may be too much for SL to handle.  In that case you would have to choose which bones are "            "going to be influenced.  The reason for the pack feature is to direct Second Life to place all of your bones where you chose "            "and not where it wants them, and should be good enough even without gluing the bones down but the resulting stabilizer mesh "            "may move and be an ugly show so you would want to make that mesh invisible.",
        default=True,
        )

    def update_gap(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bmp = bpy.context.window_manager.bb_mapper
        if bmp.mapper_pack_bones_gap != 0:
            bb_settings['terminate'] = True
            bmp.mapper_pack_bones_spacing_x = 0
            bb_settings['terminate'] = True
            bmp.mapper_pack_bones_spacing_y = 0
            bb_settings['terminate'] = True
            bmp.mapper_pack_bones_spacing_z = 0
    
    def update_spacing(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bmp = bpy.context.window_manager.bb_mapper
        x = bmp.mapper_pack_bones_spacing_x
        y = bmp.mapper_pack_bones_spacing_y
        z = bmp.mapper_pack_bones_spacing_z
        if x != 0 or y != 0 or z != 0:
            bb_settings['terminate'] = True
            bmp.mapper_pack_bones_gap = 0
        return

    mapper_pack_bones_origin_x : bpy.props.FloatProperty(
        name = "origin x",
        description = "The X location of the first packed bone placed.  This is for visual readability.",
        default = -1.17,
        )
    mapper_pack_bones_origin_y : bpy.props.FloatProperty(
        name = "origin y",
        description = "The Y location of the first packed bone placed.  This is for visual readability.",
        default = 0.5,
        )
    mapper_pack_bones_origin_z : bpy.props.FloatProperty(
        name = "origin z",
        description = "The Z location of the first packed bone placed.  This is for visual readability.",
        default = 0.0,
        )
    mapper_pack_bones_spacing_x : bpy.props.FloatProperty(
        name = "spacing x",
        description =            "NOTE: Overrides Gap\n\n"            "The X spacing between bones.  This is for visual readability.",
        min = 0.0,
        default = 0.0,
        update = update_spacing
        )
    mapper_pack_bones_spacing_y : bpy.props.FloatProperty(
        name = "spacing y",
        description =            "NOTE: Overrides Gap\n\n"            "The Y spacing between bones.  This is for visual readability.",
        min = 0.0,
        default = 0.0,
        update = update_spacing
        )
    mapper_pack_bones_spacing_z : bpy.props.FloatProperty(
        name = "spacing z",
        description =            "NOTE: Overrides Gap\n\n"            "The Z spacing between bones.  This is for visual readability.",
        min = 0.0,
        default = 0.0,
        update = update_spacing
        )
    mapper_pack_bones_gap : bpy.props.FloatProperty(
        name = "gap",
        description =            "NOTE: Overrides Spacing\n\n"            "This is the gap between rows and columns.  This for visual readability.",
        min = 0.0,
        default = 0.05,
        update = update_gap
        )
    mapper_pack_bones_length : bpy.props.FloatProperty(
        name = "Length:",
        description =            "The visual length of each bone.  This is always on the Z axis.  The vertical spacing will take this into account.  "            "This is an essential property and must be more than 0 or the bone will vanish visually and internally.",
        min = 0.01,
        default = 0.1,
        )
    mapper_pack_bones_array : bpy.props.IntProperty(
        name = "Array:",
        description = "This is the number of bones per row / horizontal.  This for visual readability.",
        min = 1,
        default = 16,
        )
    
    mapper_custom_stabilizer : bpy.props.BoolProperty(
        name = "",
        description =            "This is the original stabilizer that used to be found in another area that became discontinued.  It is now "            "re-introduced because of its Animesh usefulness but you can use it for your avatar as well.  There's an "            "alternative option to pack and stabilize (Compress) if you want better accuracy instead of pretty bones."            "\n\n"            "This is probably not very useful unless you used (Pack Bones) first but you can still use it if you want, "            "your testing might reveal something interesting that I haven't run into. \n\n"            "This will create a mesh with a vertex located at every unused bone position and weighted to "            "that bone, and only that bone.  This will allow you to upload a stabilizer mesh that, when worn or attached to your "            "Animesh, will snap the bones into place where they belong, instead of where Second Life thinks they belong.",
        default=False,
        update = update_mapper_custom_stabilizer
        )
    mapper_visual_stabilizer : bpy.props.BoolProperty(
        description =            "This can do the same thing as the custom stabilizer except that this one gives you a better visual representation "            "of the stray bones that need to be worked into the mesh at the cost of more vertices, which also translates to more LI.  "            "I would suggest using this to prototype and use the custom one for the finished product.",
        default=False,
        update = update_mapper_visual_stabilizer
        )
    
    mapper_stabilizer_name : bpy.props.StringProperty(default="")

class OnigiriMapperLoad(bpy.types.Operator, ImportHelper):
    """Load a template to use in the mapper, the corresponding button (Template Map) is useful after this is loaded.
"""
    bl_idname = "onigiri.mapper_load"
    bl_label = "Load template"

    filename_ext = ".ctm"
    filter_glob : bpy.props.StringProperty(
        default='*.ctm;*.bbm',
        options={'HIDDEN'}
        )

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper

        filename = self.properties.filepath
        template_map = {}
        try:
            namespace = {}
            exec(open(filename, 'r', encoding='UTF8').read(), namespace)
            template_map.update(namespace['template_map'])
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        bpy.ops.onigiri.mapper_reset()

        bmp['template'] = template_map

        arms = {}
        for sbone in template_map:
            (tarm, tbone), = template_map[sbone].items()
            arms.setdefault(tarm, {})

        if len(arms) != 0:
            bmp['targets_waiting'] = arms
            bmp.mapper_message = "Select a target in scene, click armature button"
            bmp.mapper_template_path = self.filepath
            
            bmp['targets'] = dict()
            
        if len(bpy.context.selected_objects) > 0:
            bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]
            bpy.ops.object.mode_set(mode='OBJECT')

        bmp.mapper_target_name = "TRIGGERED!"

        return {'FINISHED'}

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriMapperReset(bpy.types.Operator):
    """Reset everything in the mapper, mapper data will be removed, your rigs cannot
be restored after this so save your map if you need to re-use it"""

    bl_idname = "onigiri.mapper_reset"
    bl_label = "bb reset mapper"

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper

        print("A method in mapper handler has been disabled, check notes if problems arise")
        print(" - source lock would reset the character template mapper")

        if bmp.mapper_enabled == True:
            print("Character Mapper was enabled removing handler")
            
            print("OnigiriMapperReset reports: calling operator mapper_restore")

        else:
            print("Character Mapper was not enabled, will attempt to remove handler anyway")
        try:
            bpy.app.handlers.depsgraph_update_post.remove(mapper_handler)
        except:
            print("Ghost handler, nothing to do")

        bpy.ops.onigiri.mapper_restore()

        if bmp.mapper_source_name != "" and bmp.mapper_source_name in obj.keys():
            
            expire_purge(trigger=bmp.mapper_source_name)

            obj[bmp.mapper_source_name].data.display_type = 'OCTAHEDRAL'

            if obj[bmp.mapper_source_name].get('location') != None:
                del obj[bmp.mapper_source_name]['location']
            if obj[bmp.mapper_source_name].get('fly_paper') != None:
                del obj[bmp.mapper_source_name]['fly_paper']

            if bmp.get('locked') != None:
                del obj[bmp.mapper_source_name]['locked']
            if obj[bmp.mapper_source_name].get('mapped') != None:
                del obj[bmp.mapper_source_name]['mapped']
            if obj[bmp.mapper_source_name].get('packed') != None:
                del obj[bmp.mapper_source_name]['packed']

            if bmp.mapper_source_name in obj.keys():
                if obj[bmp.mapper_source_name].get('bone_map') != None:
                    del obj[bmp.mapper_source_name]['bone_map']
                if obj[bmp.mapper_source_name].get('bone_data') != None:
                    del obj[bmp.mapper_source_name]['bone_data']
                
                if obj[bmp.mapper_source_name].get('targets') != None:
                    del obj[bmp.mapper_source_name]['targets']
                if obj[bmp.mapper_source_name].get('name') != None:
                    del obj[bmp.mapper_source_name]['name']
                if obj[bmp.mapper_source_name].get('role') != None:
                    del obj[bmp.mapper_source_name]['role']
                if obj[bmp.mapper_source_name].get('detached') != None:
                    del obj[bmp.mapper_source_name]['detached']

        if bmp.get('targets') != None:

            shifter.morph_reset(bmp['targets'])

            if bmp.mapper_restore_pose == True:
                bpy.context.scene.frame_set(bpy.context.scene.frame_start)

            for tarm in bmp['targets']:
                if tarm in obj.keys():
                    
                    if obj[tarm].get('bone_data') != None:

                        if bmp.mapper_enabled == True:
                            
                            if obj[tarm].get('pose_matrix') != None:
                                
                                del obj[tarm]['pose_matrix']

                        del obj[tarm]['bone_data']
                    
                    if obj[tarm].get('bone_map') != None:
                        del obj[tarm]['bone_map']
                    if obj[tarm].get('name') != None:
                        del obj[tarm]['name']
                    if obj[tarm].get('role') != None:
                        del obj[tarm]['role']
            del bmp['targets']
        
        for o in bpy.context.selected_objects:
            o.select_set(False)
        
        if bmp.get('clean'):
            if bmp['clean'].get('objects'):
                for name in bmp['clean']['objects']:
                    if name in obj:
                        obj[name].hide_set(False)
                        obj[name].select_set(True)
                        bpy.ops.object.delete()
            if bmp['clean'].get('constraints'):
                for name in bmp['clean']['constraints']:
                    if name in obj:
                        for b in obj[name].pose.bones:
                            for c in b.constraints:
                                b.constraints.remove(c)

        remove_properties = [
            "transient",
            "locked",
            "template",
            "targets_waiting",
            
            "mapper_anchor_source_name",
            "mapper_enabled",
            "mapper_lock_source",
            "mapper_lock_target",
            "mapper_message",
            "mapper_source_name",
            "mapper_target_name",
            "mapper_targets",
            "mapper_template_path",
            "mapper_template_ready"
            "clean"]
            
        for rp in remove_properties:
            if bmp.get(rp) != None:
                del bmp[rp]

        bmp.mapper_enabled = False
        bmp.mapper_source_name = ""
        bmp.mapper_target_name = ""
        bmp.mapper_template_path = ""
        bmp.mapper_template_ready = False
        bmp.mapper_targets = 0
        bmp.mapper_message = "Choose source and target rigs"
        bmp.mapper_anchor_source_name = "mPelvis"

        bb_settings['terminate'] = True
        bmp.mapper_lock_source = False
        bb_settings['terminate'] = True
        bmp.mapper_lock_target = False

        return {'FINISHED'}

class OnigiriMapperRestore(bpy.types.Operator):
    """Restore the source bones to their original positions"""

    bl_idname = "onigiri.mapper_restore"
    bl_label = "bb restore rig"

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        source = bmp.mapper_source_name

        if source == "":
            print("OnigiriMapperRestore reports: no source to reset, just returning")
            return {'FINISHED'}
        if source not in obj:
            print("OnigiriMapperRestore reports: source existed but is not in the scene.")
            bmp.mapper_source_name = ""
            return {'FINISHED'}

        if obj[bmp.mapper_source_name].get('mapped') != 1:
            txt = "Not mapped yet, nothing to restore"
            print(txt)
            
            return {'FINISHED'}

        if obj[bmp.mapper_source_name].get('mapped') != None:
            del obj[bmp.mapper_source_name]['mapped']

        restore_rig(armature=bmp.mapper_source_name, type="edit", roll=True, data="all")

        if obj[bmp.mapper_source_name].get('collection') != None:
            remove_collection(name=obj[bmp.mapper_source_name]['collection'])
            del obj[bmp.mapper_source_name]['collection']

        if obj[source].get('targets') != None:
            shifter.morph_reset(obj[source]['targets'])

        bpy.data.objects[bmp.mapper_source_name].data.display_type = 'OCTAHEDRAL'

        if obj[source].get('fly_paper') == None:
            print("Fly paper property missing from source")
            return {'FINISHED'}
        else:
            fly = obj[source]['fly_paper']
            if fly_paper == "":
                print("Sticky armature missing from source property")
                del obj[source]['fly_paper']
                return {'FINISHED'}
            if fly not in obj:
                print("Sticky armature missing from scene")
            else:
                print("==================================")
                print("fly paper name is:", fly)
                print("==================================")

                remove_object(object=fly)
            del obj[source]['fly_paper']

        return {'FINISHED'}

class OnigiriMapperDetach(bpy.types.Operator):
    """This will detach your work from the mapper so that it's not affected by it any longer
and then the mapper will be reset."""

    bl_idname = "onigiri.mapper_detach"
    bl_label = "bb detach mapper"

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper

        if bmp.mapper_enabled == True:
            print("Character Mapper was enabled removing handler")
            try:
                bpy.app.handlers.depsgraph_update_post.remove(mapper_handler)
            except:
                print("Ghost handler, nothing to do")

        if bmp.mapper_source_name != "" and bmp.mapper_source_name in obj.keys():

            obj[bmp.mapper_source_name]['detached'] = 1
            
            if obj[bmp.mapper_source_name].get('locked') != None:
                del obj[bmp.mapper_source_name]['locked']

            if obj[bmp.mapper_source_name].get('location') != None:
                del obj[bmp.mapper_source_name]['location']
            if bmp.get('locked') != None:
                del obj[bmp.mapper_source_name]['locked']
            
            if obj[bmp.mapper_source_name].get('packed') != None:
                del obj[bmp.mapper_source_name]['packed']

            if bmp.get('template') != None:
                del bmp['template']
            if bmp.get('targets_waiting') != None:
                del bmp['targets_waiting']

            if bmp.mapper_source_name in obj.keys():
                if obj[bmp.mapper_source_name].get('bone_map') != None:
                    del obj[bmp.mapper_source_name]['bone_map']
                if obj[bmp.mapper_source_name].get('bone_data') != None:
                    del obj[bmp.mapper_source_name]['bone_data']
                
                if obj[bmp.mapper_source_name].get('targets') != None:
                    del obj[bmp.mapper_source_name]['targets']
                if obj[bmp.mapper_source_name].get('name') != None:
                    del obj[bmp.mapper_source_name]['name']
                if obj[bmp.mapper_source_name].get('role') != None:
                    del obj[bmp.mapper_source_name]['role']

        if bmp.get('targets') != None:
            for tarm in bmp['targets']:
                if tarm in obj.keys():
                    
                    obj[tarm]['detached'] = 1

                    if obj[tarm].get('bone_data') != None:
                        del obj[tarm]['bone_data']
                    
                    if obj[tarm].get('bone_map') != None:
                        del obj[tarm]['bone_map']
                    if obj[tarm].get('name') != None:
                        del obj[tarm]['name']
                    if obj[tarm].get('role') != None:
                        del obj[tarm]['role']
            del bmp['targets']

        if bmp.get('transient') != None:
            del bmp['transient']

        bmp.mapper_enabled = False
        bmp.mapper_source_name = ""
        bmp.mapper_target_name = ""
        bmp.mapper_template_path = ""
        bmp.mapper_template_ready = False
        bmp.mapper_targets = 0
        bmp.mapper_message = "Choose source and target rigs"

        bb_settings['terminate'] = True
        bmp.mapper_lock_source = False
        bb_settings['terminate'] = True
        bmp.mapper_lock_target = False

        return {'FINISHED'}

class OnigiriMapperSaveTargets(bpy.types.Operator, ExportHelper):
    """Save your altered character template map to a file for specific use in this retargeter"""
    bl_idname = "onigiri.mapper_retarget_save"
    bl_label = "Save retargeted template map"

    filename_ext = ".ctm"
    filter_glob : bpy.props.StringProperty(
        default='*.ctm',
        options={'HIDDEN'}
        )

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        if bmp.mapper_template_ready == False:
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        
        source = bmp.mapper_source_name

        bone_map = obj[source]['bone_map'].to_dict()

        template_map = "# Character Template Map auto-generated by Onigiri\n";
        template_map += "template_map = {\n"
        for sbone in bone_map:
            (tarm, tbone), = bone_map[sbone].items()
            template_map += "    " + '"' + sbone + '": ' + '{' + "\n"
            template_map += "        " + '"' + tarm +'": ' + '"' + tbone + '",' + "\n" + "        },\n"
        template_map += "    }\n"

        output = open(self.properties.filepath, 'w', encoding='UTF8')
        output.write(template_map)
        output.close()

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriMapperRemoveRetargetLink(bpy.types.Operator):
    """Remove all constraints from individual bone"""

    bl_idname = "onigiri.mapper_remove_retarget_link"
    bl_label = "bb remove retarget constraints"

    bone : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        bmp = bpy.context.window_manager.bb_mapper
        if bmp.mapper_template_ready == False:
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        
        source = bmp.mapper_source_name

        bpy.context.view_layer.objects.active = obj[source]
        bpy.ops.object.mode_set(mode='OBJECT')

        for o in bpy.context.selected_objects:
            o.select_set(False)

        bpy.context.view_layer.objects.active = obj[source]
        obj[source].select_set(True)
        bpy.ops.object.mode_set(mode='POSE')

        boneObj = obj[source].pose.bones[self.bone]
        for pbC in boneObj.constraints:
            boneObj.constraints.remove(pbC)

        bpy.ops.object.mode_set(mode='OBJECT')

        (target, tbone), = obj[source]['bone_map'][self.bone].items()

        del obj[source]['bone_map'][self.bone]
        
        del obj[target]['bone_data'][tbone]
        
        print("BB: removed bone constraints and data from " + self.bone + " from target " + target)

        return {'FINISHED'}

class OnigiriMapperRemoveTarget(bpy.types.Operator):
    """Remove this target from your list.  All targets must be processed before the mapper is enabled."""
    bl_idname = "onigiri.mapper_remove_target"
    bl_label = "Remove target map"

    target : bpy.props.StringProperty(default="")

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper

        del bmp['targets_waiting'][self.target]
        if len(bmp['targets_waiting']) == 0:
            del bmp['targets_waiting']
            bmp.animesh_message = "Ready! Start picking."

        return {'FINISHED'}

class OnigiriMapperTarget(bpy.types.Operator):
    """Select an armature in the scene and click this button to establish one of your targets for this template
"""

    bl_idname = "onigiri.mapper_target"
    bl_label = "bb target mapper"

    target : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        bmp = bpy.context.window_manager.bb_mapper
        if len(bpy.context.selected_objects) == 0:
            return False
        
        if bmp.mapper_source_name == "":
            bmp.mapper_message = "Choose your source first"
            return False
        else:
            bmp.mapper_message = "Select a target then a button"
        if len(bmp['targets']) > 0 and len(bmp['targets_waiting']) != 0:
            bmp.mapper_message = "Choose another target if you want"
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper

        for o in bpy.context.selected_objects:
            if o.type != 'ARMATURE':
                o.select_set(False)

        if len(bpy.context.selected_objects) == 0:
            txt = "No armatures were selected, this can only work with skeletons"
            print(txt)
            popup(txt, "Rigs Only", "ERROR")
            return {'FINISHED'}

        if len(bpy.context.selected_objects) > 1:
            txt = "Can only target one armature at a time with this method"
            print(txt)
            popup(txt, "Too many targets", "ERROR")
            return {'FINISHED'}

        armObj = bpy.context.selected_objects[0]

        if armObj.name == bmp.mapper_source_name:
            txt = "Error: target cannot be the same as source"
            print(txt)
            popup(txt, "Circular dependency", "ERROR")
            return {'FINISHED'}

        if bmp.get('targets') != None:
            if armObj.name in bmp['targets'].keys():
                txt = "Error: already chosen as target"
                popup(txt, "Duplicate Target", "ERROR")
                return {'FINISHED'}
            bmp['targets'].update({armObj.name : {}})
        else:
            bmp['targets'] = dict()
            bmp['targets'].update({armObj.name : {}})

        store_armature_data(armObj.name)

        bmp.mapper_lock_target = True

        del bmp['targets_waiting'][self.target]
        if len(bmp['targets_waiting']) == 0:
            bmp.mapper_message = "Ready! Click [Template Map]"
            bmp.mapper_template_path = ""
        else:
            bmp.mapper_message = "Choose another target if needed"

        if obj[bmp.mapper_source_name].get('bone_map') == None:
            obj[bmp.mapper_source_name]['bone_map'] = dict()

        arm = armObj.name 
        sarm = bmp.mapper_source_name
        
        obj[arm]['bone_map'] = dict()

        for sbone in bmp['template']:
            (tarm, tbone), = bmp['template'][sbone].items()
            
            if tarm == self.target:
                obj[bmp.mapper_source_name]['bone_map'].update({sbone: {armObj.name: tbone}})

                if tbone in obj[arm].data.bones:
                    obj[arm]['bone_map'][tbone] = {}
                    obj[arm]['bone_map'][tbone][sarm] = sbone
        
        if len(obj[arm]['bone_map']) == 0:
            print("There were no matching bones from the template to the scene rig target chosen")
            popup("No matching bones, see console", "Error", "ERROR")
            return {'FINISHED'}

        bmp.mapper_template_ready = True

        return {'FINISHED'}

class OnigiriMapperAuto(bpy.types.Operator):
    """Automatically map any available source bone to match up with your custom skeletons"""

    bl_idname = "onigiri.mapper_auto"
    bl_label = "bb auto mapper"

    @classmethod
    def poll(cls, context):
        if bpy.context.window_manager.bb_mapper.get('template') != None:
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper

        if bmp.mapper_enabled == False:
            txt = "The mapper is not ready yet, have you filled in all the data?"
            print(txt)
            popup(txt, "Mapper Disabled", "ERROR")
            return {'FINISHED'}

        if obj[bmp.mapper_source_name].get('mapped') == 1:
            txt = "Already mapped, use reset or restore first"
            print(txt)
            popup(txt, "Mapped", "ERROR")
            return {'FINISHED'}

        if bmp.mapper_retarget_only == True:
            txt = "Auto Map needs location data to be useful, disable the (Retarget Only) button in order to use this feature."
            print(txt)
            popup(txt, "Location Data Required", "ERROR")
            return {'FINISHED'}

        if obj[bmp.mapper_source_name].get('onigiri') != None:
            
            if bmp.mapper_allow_all_bones == True:
                print("using all bones, this includes all mbones but not vbones unless specified")
                bone_list = mbones_only.copy()
            
            elif bmp.mapper_safe_bones == True:
                print("using safe bones")
                bone_list = safe_bones.copy()
                
            else:
                print("No option selected, using safe bones then vbones then the rest.")
                
                bone_list = []
                match_list = {}
                for bone in safe_bones:
                    match_list[bone] = None
                for bone in vbones_only:
                    match_list[bone] = None
                for bone in mbones_only:
                    if bone not in match_list:
                        match_list[bone] = None
                for bone in match_list:
                    bone_list.append(bone)

            if bmp.mapper_allow_volume_bones == True:
                if bmp.mapper_allow_all_bones == True or bmp.mapper_safe_bones == True:
                    print("adding vbones to the map")
                    bone_list.extend(vbones_only.copy())

            source_bone_count = len(bone_list)

        else:
            source_bone_count = 0
            bone_list = list()
            for boneObj in obj[bmp.mapper_source_name].data.bones:
                
                if boneObj.use_deform == True:
                    bone_list.append(boneObj.name)
                    source_bone_count +=1
        
        target_bone_count = 0
        for arm in bmp['targets']:
            for boneObj in obj[arm].data.bones:
                
                if boneObj.use_deform == True:
                    target_bone_count +=1

        if target_bone_count > source_bone_count:
            print("The amount of mapped bones required to map the target skeleton exceeds the amount in the map you chose")
            txt = "Bone count warning.  The chosen map doesn't have enough bones."
            popup(txt, "Bone Count Error", "ERROR")

        targets = dict(sorted(bmp['targets'].items(), key = lambda x:x[0]))

        obj[bmp.mapper_source_name]['bone_map'] = dict()
        for tarm in targets:
            obj[tarm]['bone_map'] = dict()

        if bmp.mapper_force_pelvis_map == True:
            bone_list.insert(0, "mPelvis") 

        count = min(source_bone_count, target_bone_count)
        c = 0
        for tarm in targets:
            if c == count:
                break
            for tBone in obj[tarm].data.bones:
                if c == count:
                    break
                
                if tBone.use_deform == True:
                    store_bone_map(source=bmp.mapper_source_name, sbone=bone_list[c], target=tarm, tbone=tBone.name)
                    c +=1

        if bpy.context.active_object != None:
            bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')
        bpy.data.objects[bmp.mapper_source_name].select_set(True)
        bpy.context.view_layer.objects.active = bpy.data.objects[bmp.mapper_source_name]

        bpy.data.objects[bmp.mapper_source_name].data.display_type = 'STICK'
        bpy.data.objects[bmp.mapper_source_name].show_in_front = True

        snap_to(source=bmp.mapper_source_name)

        return {'FINISHED'}

class OnigiriMapperMatch(bpy.types.Operator):
    """The mapper will match the target rig bone names with the source rig bone of the same name.
This is useful for transferring animations from a damaged rig, transferring from a converted
character or transferring from a similar rig"""

    bl_idname = "onigiri.mapper_match"
    bl_label = "bb match mapper"

    @classmethod
    def poll(cls, context):
        bmp = bpy.context.window_manager.bb_mapper

        if bmp.mapper_enabled == False:
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        source = bmp.mapper_source_name

        if len(bmp['targets']) > 1:
            txt = "Works only with 1 target"
            print(txt)
            popup(txt, "One Target Only!", "ERROR")
            return {'FINISHED'}

        target = list(bmp['targets'])[0] 

        if obj[source].get('mapped') == 1:
            print("Object already mapped, use restore to to start a new map")
            popup("Already mapped, use resore to start a new map", "Error", "ERROR")
            return {'FINISHED'}

        arms = list()
        arms.append(source)
        arms.append(target) 

        count = 0
        for sboneObj in obj[source].data.bones:
            if sboneObj.name not in obj[target].data.bones:
                count +=1
        if count == len(obj[source].data.bones):
            print("The source and target armatures do not appear to have any matching bones")
            
            bmp.mapper_message = "Error: no mappable bones"
            return {'FINISHED'}

        obj[source]['bone_map'] = dict()
        obj[target]['bone_map'] = dict()

        for sboneObj in obj[source].data.bones:
            
            if sboneObj.name not in obj[target].data.bones:

                if bmp.mapper_auto_fix_bvh == True:
                    if sboneObj.name not in bvh_names:
                        continue
                    
                    bvh_alt = bvh_names[sboneObj.name]
                    if bvh_alt in obj[target].data.bones:
                        
                        print("Adjusting map for bvh fix:", sboneObj.name, "<->", bvh_alt)
                        store_bone_map(source=source, sbone=sboneObj.name, target=target, tbone=bvh_alt)
                        
                continue
            
            store_bone_map(source=source, sbone=sboneObj.name, target=target, tbone=sboneObj.name)

        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')
        bpy.data.objects[bmp.mapper_source_name].select_set(True)
        bpy.context.view_layer.objects.active = bpy.data.objects[bmp.mapper_source_name]

        if bmp.mapper_retarget_only == True:
            bpy.data.objects[source].data.display_type = 'OCTAHEDRAL'
        else:
            bpy.data.objects[source].data.display_type = 'STICK'

        if obj[source].get('onigiri_control_rig') == 1:
            bpy.ops.onigiri.remove_control_rig()
            obj[source]['onigiri_control_rig'] = 0

        if obj[source].get('fly_paper') == 1:
            txt = "MapperLock reports: sticky rig exists, this is a bug, please report it (fly_paper)"
            print(txt)
            popup(txt, "Internal Error 505", "ERROR")
            return {'FINISHED'}

        snap_to(source=source)

        bmp.mapper_message = "Use (Attach) before exporting animations)"

        return {'FINISHED'}

class OnigiriMapperTemplate(bpy.types.Operator):
    """Apply the loaded template to your rigs
"""

    bl_idname = "onigiri.mapper_template"
    bl_label = "bb template mapper"

    @classmethod
    def poll(cls, context):
        bmp = bpy.context.window_manager.bb_mapper
        if bmp.mapper_template_ready == False:
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        source = bmp.mapper_source_name

        if bmp.mapper_retarget_only == True:
            if bmp.mapper_anchor_source_name != "":
                if bmp.mapper_anchor_source_name not in obj[source].data.bones:
                    print("Character mapper anchor is missing in the source rig:", bmp.mapper_anchor_source_name)
                    popup("The anchor is missing from the source armature", "ROOT MISSING", "ERROR")
                    return {'FINISHED'}
            else:
                print("Character mapper anchor is empty, the root or mPelvis has to be mapped for this to work")
                popup("Your anchor is empty, you need a mapped anchor for retargeting", "MISSING ANCHOR", "ERROR")
                return {'FINISHED'}

            if obj[source]['bone_map'].get(bmp.mapper_anchor_source_name) == None:
                print("The indicated anchor is not in the map file that was loaded")
                popup("Map your anchor before retargeting, there's no other way to do this", "ROOT MISSING", "ERROR")
                return {'FINISHED'}

            (anchor_rig, anchor_target), = obj[source]['bone_map'][bmp.mapper_anchor_source_name].items()
            if anchor_target not in obj[anchor_rig].data.bones:
                print("Anchor", anchor_target, "does not exist in the target rig", anchor_rig)
                popup("Anchor does not exist in the target rig", "Target Rig Anchor Missing", "ERROR")
                return {'FINISHED'}
            
        s_match = list()
        t_match = list()
        s_no_match = list()
        t_no_match = list()
        for sbone in obj[source]['bone_map']:
            if sbone not in obj[source].data.bones:
                s_no_match.append(sbone)
            else:
                s_match.append(sbone)
        
        for sbone in obj[source]['bone_map']:
            (tarm, tbone), = obj[source]['bone_map'][sbone].items()
            if sbone in s_match and tbone not in obj[tarm].data.bones:

                print("Missing tbone, removing:", tbone)

                t_no_match.append(tbone)

                s_no_match.append(sbone)

                s_match.remove(sbone)
            else:
                t_match.append(tbone)
        if len(s_match) == 0:
            txt = "There were no matching bones from source to target, wrong map?"
            print(txt)
            popup(txt, "Nothing to do", "ERROR")
            return {'FINISHED'}

        tarms = list(bmp['targets'])

        for bone in s_no_match:
            print("attempting to remove source bone:", bone)
            del obj[source]['bone_map'][bone]
        if len(s_no_match) > 0:
            print("There were [" + str(len(s_no_match)) + "] bones that did not match your target rig")
        if len(t_no_match) > 0:
            txt = "Your target rig contains [" + str(len(t_no_match)) + "] unmapped bones"
            bmp.mapper_message = "Warning! [" + str(len(t_no_match)) +"] unmapped targets"
            print(txt)
            
        else:
            bmp.mapper_message = "Mapped!"

        snap_to(source=source)

        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')
        bpy.data.objects[bmp.mapper_source_name].select_set(True)
        bpy.context.view_layer.objects.active = bpy.data.objects[bmp.mapper_source_name]

        if bmp.mapper_retarget_only != True:
            bpy.data.objects[bmp.mapper_source_name].data.display_type = 'STICK'

        bpy.data.objects[bmp.mapper_source_name].show_in_front = True

        return {'FINISHED'}

class OnigiriMapperAttachTEST(bpy.types.Operator):
    """This will apply constraints to the source rig bones targeting the character rigs and associated bones.
This is a final step but not always what you want.
"""

    bl_idname = "onigiri.mapper_attach_test"
    bl_label = "New Mapper Attach :test"

    @classmethod
    def poll(cls, context):
        bmp = bpy.context.window_manager.bb_mapper
        if bmp.mapper_enabled == False:
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        
        bbe = bpy.context.window_manager.bb_expire

        source = bmp.mapper_source_name

        if obj[source].get('locked') == 1:
            popup("Object is already locked, try reset or restore to start over", "Locked", "ERROR")
            print("object is locked already", source)
            return {'FINISHED'}
        if obj[source].get('mapped') != 1:
            popup("Object not mapped, use one of the map buttons first.", "No Map", "ERROR")
            print("Object is not mapped yet, there's nothing to do.", source)
            return {'FINISHED'}

        bmp['transient'] = {}
        
        bmp['transient']['anchor'] = {}         
        bmp['transient']['anchor_slave'] = ""   
        bmp['transient']['masters'] = {}        
        bmp['transient']['slaves'] = {}         
        bmp['transient']['source'] = {}         
        bmp['transient']['target'] = {}         
        
        bmp['transient']['sticky'] = {}         

        if obj[source].get('onigiri_control_rig') == 1:
            bpy.ops.onigiri.remove_control_rig()
            
            obj[source]['onigiri_control_rig'] = 0

        if obj[source].get('fly_paper') == 1:
            txt = "MapperLock reports: sticky rig exists, this is a bug, please report it (fly_paper)"
            print(txt)
            popup(txt, "Internal Error 506", "ERROR")
            return {'FINISHED'}

        fly_paper(armature=source)

        bone_map = obj[source]['bone_map']

        if bmp.mapper_retarget_only == True:

            print("Proxy objects are forced with (Retarget Only) enabled")
            bmp.mapper_proxy_objects = True
            if bmp.mapper_proxy_objects == True:

                cursor_location = bpy.context.scene.cursor.location.copy()
                bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)

                BB_col = create_collection(name="BB_Controllers")
                if BB_col == False:
                    txt = "I couldn't create a collection for some reason, it might be stated here: " + BB_col
                    print(txt)
                    popup(txt, "Collection Error", "ERROR")
                    return {'FINISHED'}

                BB_col.hide_render = True

                cname = BB_col.name
                
                obj[source]['collection'] = cname

                expires = []
                rotate_toggle(source)
                for sbone in bone_map:
                    (tarm, tbone), = bone_map[sbone].items()

                    if bb_settings['proxy_type'] == "mesh":
                        bpy.ops.mesh.primitive_ico_sphere_add(location=(0.0, 0.0, 0.0), radius=0.025)
                        oSlave = bpy.context.object
                        bpy.context.object.show_in_front = True
                        bpy.context.object.hide_render = True
                        bpy.context.object.display.show_shadows = False
                        bpy.context.object.show_wire = True
                        bpy.context.object.display_type = 'WIRE'
                        
                    else:
                        oSlave = bpy.data.objects.new( "empty", None )
                        bpy.context.scene.collection.objects.link( oSlave )
                        oSlave.empty_display_size = 0.028
                        oSlave.empty_display_type = 'SPHERE'

                    try:
                        bpy.data.collections[cname].objects.link(oSlave)
                        bpy.context.scene.collection.objects.unlink(oSlave)
                    except:
                        pass

                    controller_prefix = get_unique_name_short()

                    oSlave.name = controller_prefix + "_" + "Slave"

                    oSlave.matrix = bpy.data.objects[source].pose.bones[sarm].matrix @ bpy.data.objects[source].pose.bones[sarm].matrix

                    expires.append(oSlave.name)

                    if bb_settings['proxy_type'] == "mesh":
                        bpy.ops.mesh.primitive_cube_add(location=(0.0, 0.0, 0.0), size=0.027)
                        oMaster = bpy.context.object
                        bpy.context.object.show_in_front = True
                        bpy.context.object.hide_render = True
                        bpy.context.object.display.show_shadows = False
                        bpy.context.object.show_wire = True
                        bpy.context.object.display_type = 'WIRE'
                        
                    else:
                        
                        oMaster = bpy.data.objects.new( "empty", None )
                        bpy.context.scene.collection.objects.link( oMaster )
                        oMaster.empty_display_size = 0.03
                        oMaster.empty_display_type = 'CUBE'

                    try:
                        bpy.data.collections[cname].objects.link(oMaster)
                        bpy.context.scene.collection.objects.unlink(oMaster)
                    except:
                        pass

                    oMaster.name = controller_prefix + "_" + "Master"

                    expires.append(oMaster.name)

                    bmp['transient']['masters'][oMaster.name] = oSlave.name
                    bmp['transient']['slaves'][oSlave.name] = oMaster.name
                    bmp['transient']['source'][sbone] = oSlave.name
                    bmp['transient']['target'][tbone] = oMaster.name

                    space_type = 'WORLD'
                    oMaster.matrix_world = world_matrix(tarm, tbone)
                    oSlave.matrix_world = world_matrix(source, sbone)

                    for o in bpy.context.selected_objects:
                        o.select_set(False)
                    oMaster.select_set(True)
                    oSlave.select_set(True)
                    
                    bpy.ops.object.scale_clear()

                    oSlave.select_set(False)
                    bpy.context.view_layer.objects.active = oMaster

                    bc = oMaster.constraints

                    bc.new('COPY_ROTATION')
                    bc['Copy Rotation'].target = obj[source]
                    bc['Copy Rotation'].subtarget = sbone
                    bc['Copy Rotation'].target_space = space_type
                    bc['Copy Rotation'].owner_space = space_type
                    bc['Copy Rotation'].influence = 1
                    bc['Copy Rotation'].name = "BB Copy Rot"
                    
                    bpy.ops.object.visual_transform_apply()
                    
                    oMaster.constraints.remove(bc['BB Copy Rot'])

                    bpy.context.view_layer.objects.active = oMaster

                    bc.new('CHILD_OF')
                    bc['Child Of'].target = obj[tarm]
                    bc['Child Of'].subtarget =  tbone
                    bc['Child Of'].target_space = space_type
                    bc['Child Of'].owner_space = space_type
                    bc['Child Of'].influence = 1
                    bc['Child Of'].name = "BB Child Of"
                    context_py = bpy.context.copy()
                    context_py["constraint"] = bc.active
                    utils.set_inverse(context_py, "BB Child Of")
                    
                    slave_constraint = False
                    if slave_constraint == True:
                        
                        oMaster.select_set(False)
                        bpy.context.view_layer.objects.active = oSlave
                        bc = oSlave.constraints
                        bc.new('COPY_ROTATION')
                        bc['Copy Rotation'].target = oMaster
                        bc['Copy Rotation'].target_space = space_type
                        bc['Copy Rotation'].owner_space = space_type
                        bc['Copy Rotation'].influence = 1
                        bc['Copy Rotation'].name = "BB Copy Rot"

                        sticky_proxies = False
                        if sticky_proxies == True:
                            
                            bc.new('COPY_LOCATION')
                            bc['Copy Location'].target = obj[source]
                            bc['Copy Location'].subtarget = sbone
                            bc['Copy Location'].target_space = space_type
                            bc['Copy Location'].owner_space = space_type
                            bc['Copy Location'].influence = 1
                            bc['Copy Location'].name = "BB Copy Loc - (see warning)"

                    else:
                        
                        rot_axis = ['ROT_X', 'ROT_Y', 'ROT_Z']
                        
                        slave_driver = oSlave.driver_add('rotation_euler')
                        for axis in range(3):
                            
                            slave_driver[axis].driver.type = 'AVERAGE' 
                            slave_driver[axis].driver.variables.new()
                            slave_driver[axis].driver.variables[0].name = 'FollowMaster'
                            slave_driver[axis].driver.variables[0].type = 'TRANSFORMS'
                            slave_driver[axis].driver.variables[0].targets[0].id = oMaster
                            slave_driver[axis].driver.variables[0].targets[0].transform_type = rot_axis[axis]
                            slave_driver[axis].driver.variables[0].targets[0].transform_space = 'WORLD_SPACE'

                        sticky_proxies = False
                        if sticky_proxies == True:
                            loc_axis = ['LOC_X', 'LOC_Y', 'LOC_Z']
                            sticky_driver = oSlave.driver_add('location')
                            for axis in range(3):
                                sticky_driver[axis].driver.type = 'AVERAGE'
                                sticky_driver[axis].driver.variables.new()
                                sticky_driver[axis].driver.variables[0].name = 'Follow_BB_Rig'
                                sticky_driver[axis].driver.variables[0].type = 'TRANSFORMS'
                                sticky_driver[axis].driver.variables[0].targets[0].id = obj[source]
                                sticky_driver[axis].driver.variables[0].targets[0].bone_target = sbone
                                sticky_driver[axis].driver.variables[0].targets[0].transform_type = loc_axis[axis]
                                sticky_driver[axis].driver.variables[0].targets[0].transform_space = 'WORLD_SPACE'

                    obj[source].select_set(True)
                    bpy.context.view_layer.objects.active = obj[source]
                    
                    bpy.ops.object.mode_set(mode='POSE')
                    bpy.ops.pose.select_all(action = 'DESELECT')
                    obj[source].data.bones.active = obj[source].data.bones[sbone]

                    bc = bpy.data.objects[source].pose.bones[sbone].constraints
                    bc.new('COPY_ROTATION')
                    bc['Copy Rotation'].target = oSlave
                    bc['Copy Rotation'].target_space = space_type
                    bc['Copy Rotation'].owner_space = space_type
                    bc['Copy Rotation'].influence = 1
                    bc['Copy Rotation'].name = "BB Copy Rot"
                    bpy.ops.object.mode_set(mode='OBJECT')

                for o in bpy.context.selected_objects:
                    o.select_set(False)
                bpy.context.view_layer.objects.active = obj[source]
                obj[source].select_set(True)
                bpy.ops.object.mode_set(mode='POSE')
                bpy.ops.pose.select_all(action = 'DESELECT')
                obj[source].data.bones.active = obj[source].data.bones[sbone]

                sbone = bmp.mapper_anchor_source_name

                if sbone in bpy.data.objects[source].data.bones:
                    (tarm, tbone), = bone_map[sbone].items()

                    bmp['transient']['anchor'] = sbone

                    oSlave = obj[ bmp['transient']['source'][sbone] ]

                    bmp['transient']['anchor_slave'] = oSlave.name

                    obj[source].data.bones.active = obj[source].data.bones[sbone]
                    bc = bpy.data.objects[source].pose.bones[sbone].constraints
                    bc.new('COPY_LOCATION')
                    bc['Copy Location'].target = oSlave
                    bc['Copy Location'].target_space = 'WORLD'
                    bc['Copy Location'].owner_space = 'WORLD'
                    bc['Copy Location'].influence = 1
                    bc['Copy Location'].name = "BB Copy Loc (sticky rig)"

                    bpy.ops.object.mode_set(mode='OBJECT')
                    obj[source].select_set(False)

                    oSlave.select_set(True)
                    bpy.context.view_layer.objects.active = oSlave
                    oMaster = obj[ bmp['transient']['target'][tbone] ]
                    bc = oSlave.constraints
                    bc.new('CHILD_OF')
                    bc['Child Of'].target = oMaster

                    bc['Child Of'].target_space = space_type
                    bc['Child Of'].owner_space = space_type
                    bc['Child Of'].influence = 1
                    
                    bc['Child Of'].name = bmp.constraint_name_anchor
                    context_py = bpy.context.copy()
                    context_py["constraint"] = bc.active

                    print("Disabling xyz rotations for anchor:", sbone)
                    
                    bpy.context.object.constraints[bmp.constraint_name_anchor].use_rotation_x = False
                    bpy.context.object.constraints[bmp.constraint_name_anchor].use_rotation_y = False
                    bpy.context.object.constraints[bmp.constraint_name_anchor].use_rotation_z = False
                    utils.set_inverse(context_py, bmp.constraint_name_anchor)
                    bpy.ops.constraint.childof_set_inverse(context_py, constraint=bmp.constraint_name_anchor, owner="OBJECT")

                    bmp['transient']['sticky'] = bmp.constraint_name_anchor
                    
                    if bmp.mapper_anchor_enabled == False:
                        bpy.context.object.constraints["BB Child Of - sticky rig"].mute = True

                else:
                    txt = "Anchor bone doesn't exist in the source rig!"
                    popup(txt, "Missing Bone", "ERROR")
                    print("lock reports: anchor bone doesn't exist in source armature -", sbone)

                targets = []
                for t in bmp['targets']:
                    targets.append(t)
                
                tasks = {}
                
                eval_code = r'remove_collection(name="' + cname + r'")'
                tasks['remove_collection'] = [eval_code]
                
                expire_create(trigger=source, partners=targets, objects=expires, tasks=tasks)

                bpy.context.scene.cursor.location = cursor_location

            else:
                for sbone in bone_map:
                    (tarm, tbone), = bone_map[sbone].items()
                    add_constraint(source=source, sbone=sbone, target=tarm, tbone=tbone, type="COPY_ROTATION")
        else:
            for sbone in bone_map:
                (tarm, tbone), = bone_map[sbone].items()
                add_constraint(source=source, sbone=sbone, target=tarm, tbone=tbone, type="COPY_LOCATION")
                add_constraint(source=source, sbone=sbone, target=tarm, tbone=tbone, type="COPY_ROTATION")

        set_obj_mode(mode="object", objects=[source])

        obj[source]['locked'] = 1

        return {'FINISHED'}

class OnigiriMapperAttach(bpy.types.Operator):
    """This will apply constraints to the source rig bones targeting the character rigs and associated bones.
This is a final step but not always what you want.  This allows you to transfer and export the foreign rig
animation.
"""

    bl_idname = "onigiri.mapper_attach"
    bl_label = "Attach Mapped Controls"

    @classmethod
    def poll(cls, context):
        bmp = bpy.context.window_manager.bb_mapper
        if bmp.mapper_enabled == False:
            return False
        source = bmp.mapper_source_name
        if source != "":
            if source in bpy.data.objects:
                if bpy.data.objects[source].get('mapped', None) != 1:
                    return False
                if bpy.data.objects[source].get('detached', None) == 1:
                    bmp.mapper_message = "Your set was detached, reset the mapper first!"
                    return False
                if bpy.data.objects[source].get('locked', None) == 1:
                    bmp.mapper_message = "Locked!"
                    return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        
        bbe = bpy.context.window_manager.bb_expire
        source = bmp.mapper_source_name

        if obj[source].get('locked') == 1:
            popup("Object is already locked, try reset or restore to start over", "Locked", "ERROR")
            print("object is locked already", source)
            return {'FINISHED'}
        if obj[source].get('mapped') != 1:
            popup("Object not mapped, use one of the map buttons first.", "No Map", "ERROR")
            print("Object is not mapped yet, there's nothing to do.", source)
            return {'FINISHED'}

        bpy.context.view_layer.update()
        frame_current = bpy.context.scene.frame_current

        if bmp.mapper_attach_from_start == True:
            frame_start = bpy.context.scene.frame_start
            bpy.context.scene.frame_set(frame_start)

        if bmp.mapper_morph_pose == True and bmp.mapper_retarget_only == False:
            print("morph pose requested, setting up additional frames...")
            
            state = shifter.snap(
                sarm=bmp.mapper_source_name,
                tarms=obj[bmp.mapper_source_name]['targets'],
                type="map")
            if state == False:
                
                print("shifter::snap returned False, resetting your mapper is probably a good idea")
                popup("snap failed, see console", "Error", "ERROR")
            else:
                obj[source]['locked'] = 1
            return {'FINISHED'}

        bmp['transient'] = {}
        
        bmp['transient']['anchor'] = {}         
        bmp['transient']['anchor_slave'] = ""   
        bmp['transient']['masters'] = {}        
        bmp['transient']['slaves'] = {}         
        bmp['transient']['source'] = {}         
        bmp['transient']['target'] = {}         
        
        bmp['transient']['sticky'] = {}         

        if obj[source].get('onigiri_control_rig') == 1:
            bpy.ops.onigiri.remove_control_rig()
            
            obj[source]['onigiri_control_rig'] = 0

        if bmp.mapper_stabilize == True:
            fly_paper(armature=source)

        bone_map = obj[source]['bone_map']

        if bmp.mapper_retarget_only == True:

            print("OnigiriMapperAttach reports: Proxy Objects are forced with (Retarget Only) enabled")
            bmp.mapper_proxy_objects = True
            
            if bmp.mapper_proxy_objects == True:

                cursor_location = bpy.context.scene.cursor.location.copy()
                bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)

                BB_col = create_collection(name="BB_Controllers")
                if BB_col == False:
                    txt = "I couldn't create a collection for some reason, it might be stated here: " + BB_col
                    print(txt)
                    popup(txt, "Collection Error", "ERROR")
                    return {'FINISHED'}

                BB_col.hide_render = True

                cname = BB_col.name
                
                obj[source]['collection'] = cname

                expires = []

                print("WARNING: rotate_toggle disabled for new BVH exporter")

                for sbone in bone_map:
                    (tarm, tbone), = bone_map[sbone].items()

                    if bb_settings['proxy_type'] == "mesh":
                        
                        bpy.ops.mesh.primitive_ico_sphere_add(location=(0.0, 0.0, 0.0), radius=0.025)
                        oSlave = bpy.context.object
                        bpy.context.object.show_in_front = True
                        bpy.context.object.hide_render = True
                        bpy.context.object.display.show_shadows = False
                        bpy.context.object.show_wire = True
                        bpy.context.object.display_type = 'WIRE'
                        
                    else:
                        
                        oSlave = bpy.data.objects.new( "empty", None )
                        bpy.context.scene.collection.objects.link( oSlave )
                        oSlave.empty_display_size = 0.028
                        oSlave.empty_display_type = 'SPHERE'

                    try:
                        bpy.data.collections[cname].objects.link(oSlave)
                        bpy.context.scene.collection.objects.unlink(oSlave)
                    except:
                        pass

                    controller_prefix = get_unique_name_short()

                    oSlave.name = controller_prefix + "_" + "Slave"

                    expires.append(oSlave.name)

                    if bb_settings['proxy_type'] == "mesh":
                        
                        bpy.ops.mesh.primitive_cube_add(location=(0.0, 0.0, 0.0), size=0.027)
                        oMaster = bpy.context.object
                        bpy.context.object.show_in_front = True
                        bpy.context.object.hide_render = True
                        bpy.context.object.display.show_shadows = False
                        bpy.context.object.show_wire = True
                        bpy.context.object.display_type = 'WIRE'
                        
                    else:
                        
                        oMaster = bpy.data.objects.new( "empty", None )
                        bpy.context.scene.collection.objects.link( oMaster )
                        oMaster.empty_display_size = 0.03
                        oMaster.empty_display_type = 'CUBE'

                    try:
                        bpy.data.collections[cname].objects.link(oMaster)
                        bpy.context.scene.collection.objects.unlink(oMaster)
                    except:
                        pass

                    oMaster.name = controller_prefix + "_" + "Master"

                    expires.append(oMaster.name)

                    bmp['transient']['masters'][oMaster.name] = oSlave.name
                    bmp['transient']['slaves'][oSlave.name] = oMaster.name
                    bmp['transient']['source'][sbone] = oSlave.name
                    bmp['transient']['target'][tbone] = oMaster.name

                    space_type = 'WORLD'
                    oMaster.matrix_world = world_matrix(tarm, tbone)
                    oSlave.matrix_world = world_matrix(source, sbone)

                    for o in bpy.context.selected_objects:
                        o.select_set(False)
                    oMaster.select_set(True)
                    oSlave.select_set(True)
                    
                    bpy.ops.object.scale_clear()

                    oSlave.select_set(False)
                    bpy.context.view_layer.objects.active = oMaster

                    bc = oMaster.constraints

                    bc.new('COPY_ROTATION')
                    bc['Copy Rotation'].target = obj[source]
                    bc['Copy Rotation'].subtarget = sbone
                    bc['Copy Rotation'].target_space = space_type
                    bc['Copy Rotation'].owner_space = space_type
                    bc['Copy Rotation'].influence = 1
                    bc['Copy Rotation'].name = "BB Copy Rot"
                    
                    bpy.ops.object.visual_transform_apply()

                    oMaster.constraints.remove(bc['BB Copy Rot'])

                    bpy.context.view_layer.objects.active = oMaster

                    bc.new('CHILD_OF')
                    bc['Child Of'].target = obj[tarm]
                    bc['Child Of'].subtarget =  tbone
                    bc['Child Of'].target_space = space_type
                    bc['Child Of'].owner_space = space_type
                    bc['Child Of'].influence = 1
                    bc['Child Of'].name = "BB Child Of"
                    context_py = bpy.context.copy()
                    context_py["constraint"] = bc.active
                    utils.set_inverse(context_py, "BB Child Of")
                    
                    slave_constraint = False
                    if slave_constraint == True:
                        
                        oMaster.select_set(False)
                        bpy.context.view_layer.objects.active = oSlave
                        bc = oSlave.constraints
                        bc.new('COPY_ROTATION')
                        bc['Copy Rotation'].target = oMaster
                        bc['Copy Rotation'].target_space = space_type
                        bc['Copy Rotation'].owner_space = space_type
                        bc['Copy Rotation'].influence = 1
                        bc['Copy Rotation'].name = "BB Copy Rot"

                        sticky_proxies = False
                        if sticky_proxies == True:
                            
                            bc.new('COPY_LOCATION')
                            bc['Copy Location'].target = obj[source]
                            bc['Copy Location'].subtarget = sbone
                            bc['Copy Location'].target_space = space_type
                            bc['Copy Location'].owner_space = space_type
                            bc['Copy Location'].influence = 1
                            bc['Copy Location'].name = "BB Copy Loc - (see warning)"

                    else:
                        
                        rot_axis = ['ROT_X', 'ROT_Y', 'ROT_Z']
                        
                        slave_driver = oSlave.driver_add('rotation_euler')
                        for axis in range(3):
                            
                            slave_driver[axis].driver.type = 'AVERAGE' 
                            slave_driver[axis].driver.variables.new()
                            slave_driver[axis].driver.variables[0].name = 'FollowMaster'
                            slave_driver[axis].driver.variables[0].type = 'TRANSFORMS'
                            slave_driver[axis].driver.variables[0].targets[0].id = oMaster
                            slave_driver[axis].driver.variables[0].targets[0].transform_type = rot_axis[axis]
                            slave_driver[axis].driver.variables[0].targets[0].transform_space = 'WORLD_SPACE'

                        sticky_proxies = False
                        if sticky_proxies == True:
                            loc_axis = ['LOC_X', 'LOC_Y', 'LOC_Z']
                            sticky_driver = oSlave.driver_add('location')
                            for axis in range(3):
                                sticky_driver[axis].driver.type = 'AVERAGE'
                                sticky_driver[axis].driver.variables.new()
                                sticky_driver[axis].driver.variables[0].name = 'Follow_BB_Rig'
                                sticky_driver[axis].driver.variables[0].type = 'TRANSFORMS'
                                sticky_driver[axis].driver.variables[0].targets[0].id = obj[source]
                                sticky_driver[axis].driver.variables[0].targets[0].bone_target = sbone
                                sticky_driver[axis].driver.variables[0].targets[0].transform_type = loc_axis[axis]
                                sticky_driver[axis].driver.variables[0].targets[0].transform_space = 'WORLD_SPACE'

                    obj[source].select_set(True)
                    bpy.context.view_layer.objects.active = obj[source]
                    
                    bpy.ops.object.mode_set(mode='POSE')
                    bpy.ops.pose.select_all(action = 'DESELECT')
                    obj[source].data.bones.active = obj[source].data.bones[sbone]

                    bc = bpy.data.objects[source].pose.bones[sbone].constraints
                    bc.new('COPY_ROTATION')
                    bc['Copy Rotation'].target = oSlave
                    bc['Copy Rotation'].target_space = space_type
                    bc['Copy Rotation'].owner_space = space_type
                    bc['Copy Rotation'].influence = 1
                    bc['Copy Rotation'].name = "BB Copy Rot"
                    bpy.ops.object.mode_set(mode='OBJECT')

                for o in bpy.context.selected_objects:
                    o.select_set(False)
                bpy.context.view_layer.objects.active = obj[source]
                obj[source].select_set(True)
                bpy.ops.object.mode_set(mode='POSE')
                bpy.ops.pose.select_all(action = 'DESELECT')
                obj[source].data.bones.active = obj[source].data.bones[sbone]

                sbone = bmp.mapper_anchor_source_name

                if sbone in bpy.data.objects[source].data.bones:

                    (tarm, tbone), = bone_map[sbone].items()

                    bmp['transient']['anchor'] = sbone

                    oSlave = obj[ bmp['transient']['source'][sbone] ]

                    bmp['transient']['anchor_slave'] = oSlave.name

                    obj[source].data.bones.active = obj[source].data.bones[sbone]
                    bc = bpy.data.objects[source].pose.bones[sbone].constraints
                    bc.new('COPY_LOCATION')
                    bc['Copy Location'].target = oSlave
                    bc['Copy Location'].target_space = 'WORLD'
                    bc['Copy Location'].owner_space = 'WORLD'
                    bc['Copy Location'].influence = 1
                    bc['Copy Location'].name = "BB Copy Loc (sticky rig)"

                    bpy.ops.object.mode_set(mode='OBJECT')
                    obj[source].select_set(False)

                    oSlave.select_set(True)
                    bpy.context.view_layer.objects.active = oSlave
                    oMaster = obj[ bmp['transient']['target'][tbone] ]
                    bc = oSlave.constraints
                    bc.new('CHILD_OF')
                    bc['Child Of'].target = oMaster

                    bc['Child Of'].target_space = space_type
                    bc['Child Of'].owner_space = space_type
                    bc['Child Of'].influence = 1
                    
                    bc['Child Of'].name = bmp.constraint_name_anchor
                    context_py = bpy.context.copy()
                    context_py["constraint"] = bc.active

                    print("Disabling xyz rotations for anchor:", sbone)
                    
                    bpy.context.object.constraints[bmp.constraint_name_anchor].use_rotation_x = False
                    bpy.context.object.constraints[bmp.constraint_name_anchor].use_rotation_y = False
                    bpy.context.object.constraints[bmp.constraint_name_anchor].use_rotation_z = False
                    utils.set_inverse(context_py, bb.constraint_name_anchor)
                    
                    bmp['transient']['sticky'] = bmp.constraint_name_anchor
                    
                    if bmp.mapper_anchor_enabled == False:
                        bpy.context.object.constraints["BB Child Of - sticky rig"].mute = True

                else:
                    txt = "Anchor bone doesn't exist in the source rig!"
                    popup(txt, "Missing Bone", "ERROR")
                    print("lock reports: anchor bone doesn't exist in source armature -", sbone)

                targets = []
                for t in bmp['targets']:
                    targets.append(t)
                
                tasks = {}
                
                eval_code = r'remove_collection(name="' + cname + r'")'
                tasks['remove_collection'] = [eval_code]
                
                expire_create(trigger=source, partners=targets, objects=expires, tasks=tasks)

                bpy.context.scene.cursor.location = cursor_location

            else:
                for sbone in bone_map:
                    (tarm, tbone), = bone_map[sbone].items()
                    add_constraint(source=source, sbone=sbone, target=tarm, tbone=tbone, type="COPY_ROTATION")

            if bpy.data.collections.get(cname) != None:
                bpy.data.collections[cname].hide_viewport = True

        else:
            for sbone in bone_map:
                (tarm, tbone), = bone_map[sbone].items()
                add_constraint(source=source, sbone=sbone, target=tarm, tbone=tbone, type="COPY_LOCATION")
                add_constraint(source=source, sbone=sbone, target=tarm, tbone=tbone, type="COPY_ROTATION")

        set_obj_mode(mode="object", objects=[source])

        obj[source]['locked'] = 1

        bpy.context.scene.frame_set(frame_current)

        return {'FINISHED'}

class OnigiriJointControlProperties(bpy.types.PropertyGroup):

    def update_joints_blank(self, context):
        self["joints_blank"] = False
    joints_blank : bpy.props.BoolProperty(default=False, update=update_joints_blank)

    joints_show : bpy.props.BoolProperty(
        name="",
        description =            "Show a list of joints with their export property set.  You can remove this property using the (X)",
        default=False
    )

class OnigiriBoneControlExportSet(bpy.types.Operator):
    """Set the selected pose bones to export with the dae file, allowing joint
positions to take over for bones that have not been defined in the mesh.  Note
that this feature implicitly defines (Export Path To Pelvis)"""
    bl_idname = "onigiri.bone_control_export_set"
    bl_label = "Set export flag"

    @classmethod
    def poll(cls, context):
        if bpy.context.mode == 'POSE':
            
            rigs = 0
            for o in bpy.context.selected_objects:
                if o.type == 'ARMATURE':
                    rigs += 1
            if rigs == 1:
                return True
        return False

    def execute(self, context):
        
        for boneObj in bpy.context.selected_pose_bones:
            dBone = boneObj.bone
            
            dBone['bb_joint_export'] = True

        return {'FINISHED'}

class OnigiriBoneControlExportClear(bpy.types.Operator):
    """This only removes the export flag, the bones are still exported for SL if
they are defined in the skin data"""
    bl_idname = "onigiri.bone_control_export_clear"
    bl_label = "Clear export flag"

    @classmethod
    def poll(cls, context):
        if bpy.context.mode == 'POSE':
            
            rigs = 0
            for o in bpy.context.selected_objects:
                if o.type == 'ARMATURE':
                    rigs += 1
            if rigs == 1:
                return True
        return False

    def execute(self, context):

        for boneObj in bpy.context.selected_pose_bones:
            dBone = boneObj.bone
            dBone.pop('bb_joint_export', '')
        return {'FINISHED'}

class OnigiriBoneControlExportRemove(bpy.types.Operator):
    """click this X to remove the export property of this bone"""

    bl_idname = "onigiri.bone_control_export_remove"
    bl_label = "Remove export flag"

    name : bpy.props.StringProperty(default="")

    def execute(self, context):

        armObj = bpy.context.selected_objects[0]
        boneObj = armObj.data.bones[self.name]
        boneObj.pop('bb_joint_export', '')
        print("Removed individual export flag from", self.name)
        return {'FINISHED'}

class OnigiriMapperPackOptionsSave(bpy.types.Operator, ExportHelper):
    """Save the current pack options to a file"""
    bl_idname = "onigiri.mapper_pack_options_save"
    bl_label = "Save pack options"

    filename_ext = ".pbo"

    filter_glob : bpy.props.StringProperty(
        default='*.pbo',
        options={'HIDDEN'}
        )
    def execute(self, context):
        bmp = bpy.context.window_manager.bb_mapper
        path = self.properties.filepath

        options = {}
        options['mapper_pack_bones_length'] = bmp.mapper_pack_bones_length
        options['mapper_pack_bones_array'] = bmp.mapper_pack_bones_array
        options['mapper_pack_bones_gap'] = bmp.mapper_pack_bones_gap
        options['mapper_pack_bones_origin_x'] = bmp.mapper_pack_bones_origin_x
        options['mapper_pack_bones_origin_y'] = bmp.mapper_pack_bones_origin_y
        options['mapper_pack_bones_origin_z'] = bmp.mapper_pack_bones_origin_z
        options['mapper_pack_bones_spacing_x'] = bmp.mapper_pack_bones_spacing_x
        options['mapper_pack_bones_spacing_y'] = bmp.mapper_pack_bones_spacing_y
        options['mapper_pack_bones_spacing_z'] = bmp.mapper_pack_bones_spacing_z

        options_string = "# Pack bone options auto-generated by Onigiri\n\n"
        options_string += 'options = {' + "\n"
        for o in options:
            options_string += '    "' + o + '": ' + '"' + str(options[o]) + '",' + "\n"
        options_string += '}' + "\n"

        output = open(path, 'w', encoding='UTF8')
        output.write(options_string)
        output.close()

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriMapperPackOptionsLoad(bpy.types.Operator, ImportHelper):
    """Load pack options"""
    bl_idname = "onigiri.mapper_pack_options_load"
    bl_label = "Load pack options"

    filename_ext = ".pbo"

    filter_glob : bpy.props.StringProperty(
        default='*.pbo',
        options={'HIDDEN'}
        )
    def execute(self, context):
        bmp = bpy.context.window_manager.bb_mapper
        path = self.properties.filepath

        options = {}
        try:
            namespace = {}
            exec(open(path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("something goofy happened, can't load options")
            print(traceback.format_exc())
            return {'FINISHED'}

        options.update(namespace['options'])

        try:
            bmp.mapper_pack_bones_length = float(options['mapper_pack_bones_length'])
            bmp.mapper_pack_bones_array = int(options['mapper_pack_bones_array'])
            bmp.mapper_pack_bones_gap = float(options['mapper_pack_bones_gap'])
            bmp.mapper_pack_bones_origin_x = float(options['mapper_pack_bones_origin_x'])
            bmp.mapper_pack_bones_origin_y = float(options['mapper_pack_bones_origin_y'])
            bmp.mapper_pack_bones_origin_z = float(options['mapper_pack_bones_origin_z'])
            bmp.mapper_pack_bones_spacing_x = float(options['mapper_pack_bones_spacing_x'])
            bmp.mapper_pack_bones_spacing_y = float(options['mapper_pack_bones_spacing_y'])
            bmp.mapper_pack_bones_spacing_z = float(options['mapper_pack_bones_spacing_z'])
        except Exception as e:
            txt = "Some options were not available to import, do you need to update?"
            print(txt)
            popup(txt, "Info", "INFO")
            print(traceback.format_exc())
 
        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriMapperPackOptionsReset(bpy.types.Operator):
    """Reset pack options"""
    bl_idname = "onigiri.mapper_pack_options_reset"
    bl_label = "Reset options"

    def execute(self, context):
        bmp = bpy.context.window_manager.bb_mapper
        bmp.property_unset('mapper_pack_bones_length')
        bmp.property_unset('mapper_pack_bones_array')
        bmp.property_unset('mapper_pack_bones_gap')
        bmp.property_unset('mapper_pack_bones_origin_x')
        bmp.property_unset('mapper_pack_bones_origin_y')
        bmp.property_unset('mapper_pack_bones_origin_z')
        bmp.property_unset('mapper_pack_bones_spacing_x')
        bmp.property_unset('mapper_pack_bones_spacing_y')
        bmp.property_unset('mapper_pack_bones_spacing_z')

        return {'FINISHED'}

class OnigiriMapperPackBones(bpy.types.Operator):
    """This packs the unused bones into a grid or to a point (compressed)
in preparation for the stabilizer mesh.  If (Compress) is enabled then
this does both the packing and mesh generation at the same time"""

    bl_idname = "onigiri.mapper_pack_bones"
    bl_label = "Pack Bones"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            return False
        return True

    def execute(self, context):
        
        armObj = utils.has_armature()
        if armObj == False:
            print("The selection does not contain a qualified armature")
            popup("The selection does not contain a qualified armature")
            return {'FINISHED'}

        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper

        mode = bpy.context.mode
        active = bpy.context.active_object
        selected = bpy.context.selected_objects
        
        arm_mw = armObj.matrix_world.copy()

        state = utils.get_state()

        mesh_list = rigutils.get_associated_mesh(armObj, report=True)
        if mesh_list == False:
            print("The rig does not contain any qualified mesh so there's nothing to generate or upload")
            popup("No qualified mesh, see console")
            utils.set_state(state)
            return {'FINISHED'}

        groups = set()
        for meshObj in mesh_list:
            if len(meshObj.vertex_groups) > 0:
                for g in meshObj.vertex_groups:
                    groups.add(g.name)

        armObj.select_set(True)
        utils.activate(armObj)

        for boneObj in armObj.data.bones:
            if boneObj.name not in skel.avatar_skeleton:
                bmp["mapper_rebuild_rig"] = False
                print("SL rebuild_rig disabled, incompatible bone found:", boneObj.name)
                break

        if bmp.mapper_rebuild_rig == True:
            bpy.ops.object.mode_set(mode='EDIT')
            for bone in skel.avatar_skeleton:
                
                if " " in bone:
                    continue
                if skel.avatar_skeleton[bone]['type'] == "collision" and bmp.mapper_rebuild_rig_volume == False:
                    continue
                if skel.avatar_skeleton[bone]['type'] == "attachment" and bmp.mapper_rebuild_rig_attachment == False:
                    continue
                
                if bone not in armObj.data.edit_bones:
                    boneObj = armObj.data.edit_bones.new(bone)
                    boneObj.tail = mathutils.Vector((0,0,0.2))

            bpy.ops.object.mode_set(mode='OBJECT')
            
            armObj.matrix_world = arm_mw

        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.context.view_layer.update()
        
        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in armObj.data.edit_bones:
            boneObj.use_connect = False

        qualified_bones = set()
        for boneObj in armObj.data.bones:
            bone = boneObj.name
            if bone not in groups:
                if bone == "mPelvis" and bmp.mapper_pack_pelvis == False:
                    continue
                qualified_bones.add(bone)
        if len(qualified_bones) == 0:
            print("There are no free floating bones to add to a stabilizer mesh and as a result none can be packed.")
            print("All bones in the qualified rig are accounted for so there's nothing to do.")
            popup("No qualified bones, see console")
            utils.set_state(state)
            return {'FINISHED'}

        bone_order = {}
        for boneObj in armObj.data.bones:
            if boneObj.name in qualified_bones:
                bone_order[boneObj.name] = ""

        if bmp.mapper_pack_compress == True:
            
            target_location = mathutils.Vector((0,0,0))
            if bmp.mapper_pack_selected:
                
                if mode == 'EDIT_MESH':
                    print("Using selected vertex location as target")
                    vertex_selected = None
                    for o in selected:
                        if o.type == 'MESH':
                            for v in o.data.vertices:
                                if v.select == True:
                                    vertex_selected = v
                                    break
                            
                            if vertex_selected != None:
                                break
                        
                        if vertex_selected != None:
                            break
                    if vertex_selected != None:
                        loc = mathutils.Matrix.Translation(v.co)
                        target_location = (o.matrix_world @ loc).to_translation()
                    else:
                        print("No vertex was selected in the qualified mesh objects, defaulting to origin")
                elif mode == 'EDIT_ARMATURE' or mode == 'POSE':
                    print("Using selected pose bone location as target")
                    for boneObj in armObj.data.bones:
                        if boneObj.select == True:
                            
                            target_location = armObj.matrix_world @ armObj.pose.bones[boneObj.name].head.copy()
                
                elif len(selected) > 0:
                    target_location = selected[0].matrix_world.to_translation()

            print("Stabilizer origin at:", target_location)

            tail_z = target_location.z + bmp.mapper_pack_bones_length
            tail = mathutils.Vector((target_location.x, target_location.y, tail_z))

            head = armObj.matrix_world.inverted() @ target_location

            bpy.ops.object.mode_set(mode='EDIT')
            for boneObj in armObj.data.edit_bones:
                if boneObj.name in bone_order:
                    boneObj.head = head
                    boneObj.tail = armObj.matrix_world.inverted() @ tail
                    boneObj.roll = 0.0
            bpy.ops.object.mode_set(mode='OBJECT')
            armObj.matrix_world = arm_mw

            for o in bpy.context.selected_objects:
                o.select_set(False)
            baseObj = meshutils.build_mesh(shape="diamond")
            utils.activate(baseObj)
            mesh_list = []

            z = bmp.mapper_pack_bones_length
            baseObj.dimensions = z,z,z
            bpy.context.view_layer.update()

            for bone in bone_order:
                bpy.ops.object.duplicate()
                meshObj = bpy.context.object
                for g in meshObj.vertex_groups:
                    meshObj.vertex_groups.remove(g)
                mesh_list.append(meshObj)
                groupObj = meshObj.vertex_groups.new(name=bone)
                vertices = [v.index for v in meshObj.data.vertices]
                groupObj.add(vertices, 1, 'REPLACE' )
                
                meshObj.location = target_location
            
            baseObj.select_set(False)
            meshObj.select_set(False)

            baseObj.select_set(True)
            utils.activate(baseObj)
            bpy.ops.object.delete()
            
            for o in mesh_list:
                o.select_set(True)
            utils.activate(o)
            bpy.ops.object.join()

            o = bpy.context.object
            o.select_set(False)

            armObj.select_set(True)
            utils.activate(armObj)

        else:
            bpy.ops.object.mode_set(mode='EDIT')

            ox = bmp.mapper_pack_bones_origin_x
            oy = bmp.mapper_pack_bones_origin_y
            oz = bmp.mapper_pack_bones_origin_z

            sx = bmp.mapper_pack_bones_spacing_x
            sy = bmp.mapper_pack_bones_spacing_y
            sz = bmp.mapper_pack_bones_spacing_z

            gap = bmp.mapper_pack_bones_gap
            length = bmp.mapper_pack_bones_length
            array = bmp.mapper_pack_bones_array
     
            b_count = 0 
            a_count = 0 

            g_count = 0

            for boneObj in armObj.data.edit_bones:
                bone = boneObj.name
                if bone in bone_order:
                    b_count += 1
                    a_count += 1
                    boneObj.head = ox + sx + gap, oy + sy, oz + sz
                    boneObj.tail = ox + sx + gap, oy + sy, oz + sz + length
                    boneObj.roll = 0.0

                    if a_count == array:
                        a_count = 0
                        ox = bmp.mapper_pack_bones_origin_x
                        oy = bmp.mapper_pack_bones_origin_y
                        
                        oz = oz + length + gap
                    else:
                        ox += sx + gap
                        oy += sy
                        oz += sz
            armObj.matrix_world = arm_mw
            bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriMapperCustomStabilizer(bpy.types.Operator):
    """This creates a mesh that encompasses the unused bones and is a stabilizer
that must be uploaded and worn or attached to Animesh.  See the info button for a
detailed description.  Just hover over it, it's a passive button."""

    bl_idname = "onigiri.mapper_custom_stabilizer"
    bl_label = "bb custom stabilizer"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            return False
        return True

    def execute(self, context):
        armObj = utils.has_armature()
        if armObj == False:
            print("The selection does not contain a qualified armature")
            popup("The selection does not contain a qualified armature")
            return {'FINISHED'}

        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper

        state = utils.get_state()

        mesh_list = rigutils.get_associated_mesh(armObj, report=True)
        if mesh_list == False:
            print("The rig does not contain any qualified mesh so there's nothing to generate or upload")
            popup("No qualified mesh, see console")
            utils.set_state(state)
            return {'FINISHED'}

        qualified_bones = set()
        groups = set()
        for meshObj in mesh_list:
            if len(meshObj.vertex_groups) > 0:
                for g in meshObj.vertex_groups:
                    groups.add(g.name)
        for boneObj in armObj.data.bones:
            bone = boneObj.name
            if bone not in groups:
                if bone == "mPelvis" and bmp.mapper_pack_pelvis == False:
                    continue
                qualified_bones.add(bone)
        if len(qualified_bones) == 0:
            print("There are no free floating bones to add to a stabilizer mesh..")
            print("All bones in the qualified rig are accounted for so there's nothing to do.")
            popup("No qualified bones, see console")
            utils.set_state(state)
            return {'FINISHED'}
        
        bone_order = {}
        for boneObj in armObj.data.bones:
            if boneObj.name in qualified_bones:
                bone_order[boneObj.name] = ""

        armObj.select_set(True)
        utils.activate(armObj)

        bpy.ops.object.mode_set(mode='EDIT')
        coords = {}
        for bone in bone_order:
            boneObj = armObj.data.edit_bones[bone]
            coords.setdefault(bone, {})
            coords[bone]['head'] = tuple(boneObj.head)
            coords[bone]['tail'] = tuple(boneObj.tail)

        bpy.ops.object.mode_set(mode='OBJECT')
        armObj.select_set(False)

        verts = list()
        
        for bone in coords:
            verts.append(coords[bone]['head'])
            verts.append(coords[bone]['tail'])

        mesh = bpy.data.meshes.new("mesh")
        meshObj = bpy.data.objects.new("CustomStabilizer", mesh)
        
        col = bpy.context.collection
        col.objects.link(meshObj)
        
        bpy.context.view_layer.objects.active = meshObj
        meshObj.select_set(True)
        mesh = meshObj.data
        bm = bmesh.new()

        sx = bmp.mapper_pack_bones_spacing_x
        sy = bmp.mapper_pack_bones_spacing_y
        sz = bmp.mapper_pack_bones_spacing_z
        gap = bmp.mapper_pack_bones_gap

        if len(verts) == 2:
            
            ox,oy,oz = verts[0]
            
            bm.verts.new((ox,oy,oz))
            v1 = [ox + sx + gap, oy + sy, oz + sz]
            ox,oy,oz = verts[1]
            
            bm.verts.new((ox,oy,oz))
            v2 = [ox + sx + gap, oy + sy, oz + sz]
            
            bm.verts.new(v1)
            bm.verts.new(v2)

        else:
            
            row_count = 0
            vertex_count = 0

            for v in verts:
                bm.verts.new(v)
                vertex_count += 1
                if vertex_count == 2:
                    vert_count = 0
                    row_count += 1
                if row_count == bmp.mapper_pack_bones_array:
                    row_count = 0
            
            if row_count == 1:
                print("special condition, hit row not equal to first and only one bone")
                
                last_two = verts[-2:]
                ox,oy,oz = last_two[0]
                v1 = [ox + sx + gap, oy + sy, oz + sz]
                ox,oy,oz = last_two[1]
                
                v2 = [ox + sx + gap, oy + sy, oz + sz]
                
                bm.verts.new(v1)
                bm.verts.new(v2)

        verts_per_row = bmp.mapper_pack_bones_array

        row_limit = bmp.mapper_pack_bones_array
        
        points_count = 0
        
        vert_count = 0
        
        row_count = 0

        poly = list()
        for vObj in bm.verts:
            
            points_count +=1
            poly.append(vObj)
            if points_count == 4:
                
                bm.faces.new( (poly[3], poly[1], poly[0], poly[2]) )
                points_count = 2

                del poly[0:1]
                del poly[0:1]

            if row_count == row_limit:
                
                row_count = 0
                points_count = 0 
                print("poly size:", len(poly))
                if len(poly) == 3:
                    points_count = 1
                    del poly[0:1]
                    del poly[0:1]
                else:
                    poly.clear()

            vert_count += 1 
            if vert_count == 2:
                
                row_count += 1
                vert_count = 0

        if points_count > 0:
            print("left over points:")
        print(" points:", points_count)

        bm.verts.index_update()
        bm.to_mesh(meshObj.data)  
        bm.free()
        bpy.ops.object.mode_set(mode='EDIT')
        bm = bmesh.from_edit_mesh(meshObj.data)
        bverts = bm.verts
        bm.verts.ensure_lookup_table()

        bmesh.update_edit_mesh(meshObj.data)

        bpy.ops.object.mode_set(mode='OBJECT')

        vertex_pairs = 0
        vp = list()

        print("qualified_bones", qualified_bones)

        for bone in bone_order:
            vp.append(vertex_pairs)
            vertex_pairs += 1
            vp.append(vertex_pairs)
            vertex_pairs += 1 
            vg = meshObj.vertex_groups.new(name=bone)
            
            vg.add(vp, 1.0, "ADD") 
            vp.clear()

        if len(verts) > len(bone_order):
            
            vp.append(vertex_pairs)
            vertex_pairs += 1
            vp.append(vertex_pairs)
            vg.add(vp, 1.0, "ADD") 

        modifier = meshObj.modifiers.new('ArmatureCS', 'ARMATURE')
        
        modifier.object = armObj
        modifier.use_bone_envelopes = False
        modifier.use_vertex_groups = True
        meshObj.data.update()

        meshObj.parent = armObj
        mesh = meshutils.split_mesh(mesh=meshObj.name, group_limit=99)
        if len(mesh) == 0:
            print("split_mesh reported errors, returned zero length")
            popup("The feature split_mesh reported errors, see console", "Error", "ERROR")
        
        for o in bpy.context.selected_objects:
            o.select_set(False)
        meshObj.select_set(True)
        utils.activate(meshObj)
        bpy.ops.object.delete()
        
        for m in mesh:
            utils.remove_empty_groups(m)
            obj[m].select_set(True)
        utils.activate(obj[m])

        return {'FINISHED'}

class OnigiriMapperVisualStabilizer(bpy.types.Operator):
    """This creates a mesh that encompasses the unused bones and is a stabilizer
that must be uploaded and worn or attached to Animesh.  See the info button for a
detailed description.  Just hover over it, it's a passive button."""

    bl_idname = "onigiri.mapper_visual_stabilizer"
    bl_label = "bb visual stabilizer"

    @classmethod
    def poll(cls, context):
        bmp = bpy.context.window_manager.bb_mapper
        if bmp.mapper_enabled == False:
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper

        bmp.mapper_message = "Visual Stabilizer Generated"

        return {'FINISHED'}

class OnigiriAlignBonesProperties(bpy.types.PropertyGroup):

    def blank(self, context):
        self["blank"] = False
    blank : bpy.props.BoolProperty(
        name = "",
        description = "",
        default = False,
        update = blank
        )

    def update_first(self, context):
        if self.first == False:
            self["last"] = False
            return
        if bpy.context.mode != 'POSE':
            self["first"] = False
            return
        if len(bpy.context.selected_objects) != 1:
            self["first"] = False
            return
        if len(bpy.context.selected_pose_bones) != 1:
            self["first"] = False
            return
        
        boneObj = bpy.context.selected_pose_bones[0]
        globals.align_bones['first'] = boneObj
        if self.last == True:
            if boneObj == globals.align_bones['last']:
                globals.align_bones['last'] = None
                self["last"] = False

    def update_last(self, context):
        if self.last == False:
            self["first"] = False
            globals.align_bones['last'] = boneObj
            return
        if bpy.context.mode != 'POSE':
            self["last"] = False
            return
        if len(bpy.context.selected_objects) != 1:
            self["last"] = False
            return
        if len(bpy.context.selected_pose_bones) != 1:
            self["last"] = False
            return
        
        boneObj = bpy.context.selected_pose_bones[0]
        globals.align_bones['last'] = boneObj
        if self.first == True:
            if boneObj == globals.align_bones['first']:
                globals.align_bones['first'] = None
                self["first"] = False

    first : bpy.props.BoolProperty(
        name = "",
        description =            "These do not have to be in some order.  Pick a bone and click this, pick another bone and click the (last) button.  "            "Once you've made your selection click the (Align Bones) button.",
        default = False,
        update = update_first
        )
    last : bpy.props.BoolProperty(
        name = "",
        description =            "These do not have to be in some order.  Pick a bone and click the (first) button, pick another bone and click this "            "button.  Once you've made your selection click the (Align Bones) button.",
        default = False,
        update = update_last
        )
    def update_align_bones_info(self, context):
        self["align_bones_info"] = False
    align_bones_info : bpy.props.BoolProperty(
        name = "",
        description =            "This section allows you to align segments of bones, or in the case of a snake you can do the entire rig.  "            "\n\n"            "The usefulness of this may not be clear but here's an example."
            "\n\n"            "You have a snake, cylinder possibly, that you've used a method, maybe a path and deform, so that you can get "            "a visually appealing snake, worm, into a curled pose.  However, this pose is just its static rest pose and "            "would be difficult to adjust skin weights for it and do any other meaningful work.  If you have an armature "            "associated with this mesh you can easily straighten it out for further work.  The original pose will be "            "preserved in an animation and your original animation, if any, is still accessible in the scene.  This can "            "straighten any bone segment, not just a single chain with only 1 child, just choose your first and last bones "            "and click (Align Bones).",
        default = False,
        update = update_align_bones_info
        )
    animate : bpy.props.BoolProperty(
        name = "",
        description =            "This feature, when enabled, creates an animation between the existing arrangement of the bones "            "and the new, straightened, arrangement of the bones.  The new shape of the skeleton, or skeleton area, "            "will be the rest pose and the resulting animation will be a way to motion your bones back to where "            "they once were.  It's expected that there's a sensible hierarchy to follow, and associated influences, "            "if that is missing or the influences are not sane then this can, and probably will, go horribly wrong!",
        default = False
        )
    move : bpy.props.BoolProperty(
        name = "",
        description =            "Your bones may be separated visually, not connected, and there's nothing wrong with this arrangement.  "            "However you can use this switch to move the head of the next bone to the tail of its parent bone and "            "this is not the same as the (connected) feature in the bone properties panel, it moves the entire bone.  "            "All bones will keep their length but their positions will change if this is enabled.",
        default = False
        )
    rebind : bpy.props.BoolProperty(
        name = "",
        description =            "This can be a non-destructive process, but is less useful in that state.  With this button enabled the new "            "rest pose will be its straightened state, allowing you to skin the mesh to the new rest pose without unexpected "            "distortions.  With this disabled there will be no new rest pose and the animation will be the only affected property.  "            "This applied animation will bring you to the original state, if you enabled that.",
        default = True
        )
    offsets : bpy.props.BoolProperty(
        name = "",
        description =            "With this enabled the result may not loook accurate but it is.  The less accurate version, without this enabled, "            "is probably what most people are expecting and that's why this is disabled by default."            "\n\n"            "Enable this to preserve the bone offset of an adjusted bone with respect to its parent, this offset is for location "            "data only, all angles will match the first parent in the chain regardless of which options you choose.",
        default = False
        )

    angle : bpy.props.BoolProperty(
        name = "",
        description =            "The angle of a bone can be important with respect to its parent, so this is disabled by default.  This feature, "            "when enabled, will rotation align all of the bones in the chain with the starting bone, the one you selected.  "            "The resulting animation from this, if you enabled (animate), may turn out to be very strange.",
        default = True
        )

class OnigiriAlignBones(bpy.types.Operator):
    """Choose an end bone and click this button.  It will align all of the bones
in its parent stream to this one, keeping the relative arrangement of all other
bones and creating an animation, if chosen, to revert back"""

    bl_idname = "onigiri.align_bones"
    bl_label = "Align Bones"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return
        if bpy.context.mode != 'POSE':  
            return False
        bb_ab = bpy.context.window_manager.bb_align_bones
        if bb_ab.first == False or bb_ab.last == False:
            return False
        
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb_align_bones = bpy.context.window_manager.bb_align_bones
        armObj = bpy.context.selected_objects[0]
        utils.activate(armObj)

        firstBone = globals.align_bones['first']
        lastBone = globals.align_bones['last']

        if 1 == 0:
            align_data = {}
            bpy.ops.object.mode_set(mode='EDIT')
            for boneObj in armObj.data.edit_bones:
                align_data[boneObj.name] = {}
                align_data[boneObj.name]['matrix'] = boneObj.matrix.copy()
                align_data[boneObj.name]['head'] = boneObj.head.copy()
                align_data[boneObj.name]['tail'] = boneObj.tail.copy()
                align_data[boneObj.name]['roll'] = boneObj.roll
                
                align_data[boneObj.name]['use_connect'] = boneObj.use_connect
                boneObj.use_connect = False
            bpy.ops.object.mode_set(mode='POSE')

        align_data = {}
        for boneObj in armObj.data.bones:
            align_data[boneObj.name] = {}
            matrix_local = boneObj.matrix_local.copy()
            align_data[boneObj.name]['matrix'] = matrix_local
            align_data[boneObj.name]['head'] = boneObj.head_local.copy()
            align_data[boneObj.name]['tail'] = boneObj.tail_local.copy()
            align_data[boneObj.name]['roll'] = utils.get_bone_roll(matrix_local)

        bone_path = []
        found_first = False
        boneObj = firstBone

        bone_path.append(boneObj.name)
        while boneObj.parent:
            boneObj = boneObj.parent
            bone_path.append(boneObj.name)
            if boneObj == lastBone:
                found_first = True
                break

        if found_first == False:
            bone_path = []
            boneObj = lastBone
            
            bone_path.append(boneObj.name)
            while boneObj.parent:
                print("iterating backwards:", boneObj.name)
                boneObj = boneObj.parent
                
                bone_path.append(boneObj.name)
                if boneObj == firstBone:
                    found_first = True
                    break

        if found_first == False:
            txt = "The path search failed.  This can happen if a root bone is in the way.\n"
            txt += "For instance, if you chose a wrist bone on each arm then mPelvis would\n"
            txt += "be in the way, this cannot be resolved so choose a different path.\n"
            txt += "Another reason this can fail is if you have multiple root bones and, again\n"
            txt += "one of them is in the way, there's simply no path to the next bone."
            print(txt)
            utils.popup(txt, "Info", "INFO")
            return {'FINISHED'}

        bone_path.reverse()

        first_bone = bone_path[0]
        last_bone = bone_path[-1]

        print("first_bone:", first_bone)
        print("last_bone:", last_bone)

        print("len bone_path:", len(bone_path))

        armObj['bb_align_data'] = align_data

        if bb_align_bones.animate == True:
            
            armObj.animation_data_create()
            
            has_action = False
            action = armObj.get('bb_align_action')
            if action != None:
                actionObj = bpy.data.actions.get(action)
                if actionObj != None:
                    print("Found action:", actionObj.name)
                    has_action = True
                    armObj.animation_data.action = actionObj
                    
                    fcurves = actionObj.fcurves
                    for fc in fcurves:
                        actionObj.fcurves.remove(fc) 
           
            if has_action == False:
                actionObj = bpy.data.actions.new("BB_Align")
                armObj.animation_data.action = actionObj
                action = actionObj.name
                armObj['bb_align_action'] = action
        
        else:
            if 1 == 0:
                if armObj.animation_data:
                    armObj.animation_data_clear()
                action = armObj.get('bb_align_action')
                if action != None:
                    if action in bpy.data.actions:
                        actionObj = bpy.data.actions[action]
                        bpy.data.actions.remove(actionObj)

        if 1 == 0:
            bpy.context.scene.frame_set(1)
            M = mathutils.Matrix()
            for boneObj in armObj.pose.bones:
                boneObj.matrix_basis = M
            utils.update()

        if bb_align_bones.animate == True:
            
            bpy.context.scene.frame_set(1)
            M = mathutils.Matrix()
            for boneObj in armObj.pose.bones:
                boneObj.matrix_basis = M
            utils.update()

            for boneObj in armObj.pose.bones:
                boneObj.keyframe_insert(data_path="location", frame=1)
                boneObj.keyframe_insert(data_path="rotation_euler", frame=1)
                boneObj.keyframe_insert(data_path="rotation_quaternion", frame=1)
                boneObj.keyframe_insert(data_path="scale", frame=1)

        base_matrix = armObj.data.bones[first_bone].matrix_local.copy()
        for bone in bone_path:
            
            if bone == first_bone:
                print("skipping first bone:", first_bone)
                continue

            pBone = armObj.pose.bones[bone]
            boneObj = pBone.bone

            r = base_matrix.to_quaternion()
            
            s = pBone.matrix.to_scale()
            
            if bb_align_bones.move == True:
                
                l = pBone.parent.tail.copy()

            else:
                
                l1 = pBone.head.copy()
                l2 = pBone.parent.head.copy()
                lo = (l1 - l2)
                l = (l2 + lo) 

            L = mathutils.Matrix.Translation(l)
            R = r.to_matrix().to_4x4()
            S = mathutils.Matrix()
            for i in range(3):
                S[i][i] = s[i]

            M = L @ R @ S

            pBone.matrix = M

            utils.update()

            if 1 == 0:
                if 1 == 1:
                    
                    Mc = pBone.matrix.copy()
                    Mp = pBone.parent.matrix.copy()
                    M = Mp.inverted() @ Mp
                    lc = M.to_translation()
                    bpy.ops.transform.translate(value=(lc.x, 0, lc.z), orient_type='LOCAL')
                    utils.update()

                else:
                    lc = pBone.head.copy()
                    lp = pBone.parent.head.copy()
                    x = (lp.x - lc.x)
                    z = (lp.z - lc.z)
                    
                    armObj.data.bones.active = boneObj
                    bpy.ops.transform.translate(value=(x, 0, z), orient_type='LOCAL')

        if bb_align_bones.animate == True:
            
            for boneObj in armObj.pose.bones:
                boneObj.keyframe_insert(data_path="location", frame=2)
                boneObj.keyframe_insert(data_path="rotation_euler", frame=2)
                boneObj.keyframe_insert(data_path="rotation_quaternion", frame=2)
                boneObj.keyframe_insert(data_path="scale", frame=2)

        if 1 == 0:
            bone_list = set(bone_path)
            for bone in pose_data:
                if bone not in bone_list:
                    boneObj = armObj.pose.bones[bone]
                    boneObj.matrix = pose_data[bone]
                    utils.update()

        bb_align_bones.first = False
        bb_align_bones.last = False

        print("Align bones done!")

        return {'FINISHED'}

class OnigiriAlignKeep(bpy.types.Operator):
    """This is dangerous if you want to preserve an existing animation.  This
sets the current pose as rest pose just like in the menu area"""

    bl_idname = "onigiri.align_keep"
    bl_label = "Align Keep"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb_align_bones = bpy.context.window_manager.bb_align_bones
        armObj = bpy.context.selected_objects[0]

        rigutils.apply_pose(armObj)

        return {'FINISHED'}

class OnigiriDeformerProperties(bpy.types.PropertyGroup):

    deformer_menu_enabled : bpy.props.BoolProperty(
        description =            "Enable / Disable the deformer menu",
        default=False
        )

    deformer_transform_location : bpy.props.BoolProperty(
        name = "Deformer will use position animation",
        description =            "\n"            "The deformer is typically used with position information to correct the pose of the actual SL skeleton to comply with "            "your custom rig but you have the option to disable this.",
        default=True
        )
    deformer_transform_rotation : bpy.props.BoolProperty(
        name = "Deformer will use rotation animation",
        description =            "\n"            "The deformer is a way to correct bone positions but if you are making a static transform, a morh that never animates "            "beyond the actual transform, then this option might suite you.  I don't think there's much use for this if you are "            "intending to animate your target but it's a fun thing to use if you are just transforming.",
        default=False
        )

    deformer_default : bpy.props.BoolProperty(
        name = "Deformer for default rig",
        description =            "\n"            "Create a deformer using the default rig.  This might be useful if your next designated in-world skeleton does not match "            "the neutral rig.  You might find that others see you just slightly deformed if wearing a classic avatar after fiddling with "            "custom mesh or deformers.  This option aught to revert you back from this particular deformity.",
        default=False
        )
    deformer_acquire_animation_details : bpy.props.BoolProperty(
        name = "Auto Set Animation Details",
        description =            "\n"            "The deformer needs only 3 frames to work and it's recommended that you start with a priority of 2, depending on your needs.  "            "In addition the start of the animation aught to be on frame 1 and the loop needs to be active from frame 2 to frame 3.  With this "            "button enabled you won't have to worry about setting those options, just click (Create Deformer) and export it.  Note that these "            "details are completely automatic when using the anim export format but with BVH you'll have to set some upload options in SL, start "            "frame should be 1, loop should start at 2 and set your priority to what you need, BVH only allows 4 but anim allows 6.",
        default = True
        )
    
    deformer_keep_objects : bpy.props.BoolProperty(
        name = "Auto clean",
        description =            "After the deformer is finished there are objects in the scene that were required in order to create it.  The default is to "            "remove these objects after the deformer is exported.  If you want to examine them then choose this feature before creating your "            "deformer.  The objects will stay in the scene and their names are (Glue) and (DEFORMER_ANIMATION).  You can re-export your animation "            "from the DEFORMER_ANIMATION rig if you like and if you wish to remove the objects just delete them, it's fine.",
        default=False
        )
    
    deformer_use_template : bpy.props.BoolProperty(
        description =            "If your rig / character is mapped right now and active in the Character Tools template map or the Template Workshop "            "you can use this feature to clean up distortions in the animation which should allow you to use any animation that "            "is designed for this particular rig and map.",
        default = False,
        )
        
class OnigiriCreateDeformer(bpy.types.Operator):
    """This is a special animation that has the end result of being a pose.  This pose
is designed to rearrange your converted character bones so that they snap back
to where they belong in Second Life.  This feature can also serve to metamorph"""

    bl_idname = "onigiri.create_deformer"
    bl_label = "Create a deformer for your custom /converted rig"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        
        bbd = bpy.context.window_manager.bb_deform
        bb = bpy.context.scene.onigiri
        bba = bpy.context.scene.bb_anim

        tarmObj = bpy.context.selected_objects[0]
        tarm = tarmObj.name

        no_match = []
        yes_match = []
        match_error = False
        for boneObj in tarmObj.data.bones:
            if boneObj.name not in skel.avatar_skeleton:
                no_match.append(boneObj.name)
            else:
                yes_match.append(boneObj.name)
        if len(no_match) > 0:
            print("The following bones would not match the Second Life skeleton")
            print(no_match)
            match_error = True
        if match_error == True:
            popup("There were bone match errors, check console", "Error", "ERROR")
        if len(yes_match) == 0:
            print("There were no matching bones that could be mapped")
            return {'FINISHED'}

        old_mode = bpy.context.mode
        if old_mode == 'EDIT_ARMATURE':
            old_mode = 'EDIT'
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        sarmObj = rigutils.build_rig(rig_class="pos", rotate=True)
        sarmObj.name = "DEFORMER_ANIMATION"
        sarm = sarmObj.name

        tarmObj.select_set(False)

        sarmObj.select_set(True)
        bpy.context.view_layer.objects.active = sarmObj
        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in sarmObj.data.edit_bones:
            boneObj.use_connect = False

        bpy.ops.object.mode_set(mode='OBJECT')
        for boneObj in sarmObj.data.bones:
            boneObj.use_inherit_rotation = False

        bpy.ops.object.duplicate()
        glueObj = bpy.context.object
        glueObj.name = "Glue"
        glue = glueObj.name
        glueObj.data.display_type = 'STICK'
        glueObj.show_in_front = True

        bpy.ops.object.mode_set(mode='POSE')
        remove_armature_groups(glue)
        create_bone_group(glue, glue_group_name, glue_theme)
        for boneObj in glueObj.pose.bones:
            add_bone_to_group(armature=glue, bone=boneObj.name, group=glue_group_name)

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in glueObj.data.edit_bones:
            boneObj.parent = None
        bpy.ops.object.mode_set(mode='OBJECT')

        glueObj.select_set(False)
        sarmObj.select_set(True)
        bpy.context.view_layer.objects.active = sarmObj

        print("Creating glue...")
        bpy.ops.object.mode_set(mode='POSE')
        for boneObj in sarmObj.pose.bones:
            sbone = boneObj.name
            bpy.data.objects[sarm].data.bones.active = bpy.data.objects[sarm].data.bones[sbone]
            
            if bbd.deformer_transform_location == True:
                bc = bpy.data.objects[sarm].pose.bones[sbone].constraints
                bc.new('COPY_LOCATION')
                bc['Copy Location'].target = bpy.data.objects[glue]
                bc['Copy Location'].subtarget = sbone 
                bc['Copy Location'].target_space = 'WORLD'
                bc['Copy Location'].owner_space = 'WORLD'
                bc['Copy Location'].influence = 1
                bc['Copy Location'].name = "BB Copy Loc"
            
            if bbd.deformer_transform_rotation == True:
                bc = bpy.data.objects[sarm].pose.bones[sbone].constraints
                bc.new('COPY_ROTATION')
                bc['Copy Rotation'].target = bpy.data.objects[glue]
                bc['Copy Rotation'].subtarget = sbone 
                bc['Copy Rotation'].target_space = 'WORLD'
                bc['Copy Rotation'].owner_space = 'WORLD'
                bc['Copy Rotation'].influence = 1
                bc['Copy Rotation'].name = "BB Copy Rot"

        bpy.ops.object.mode_set(mode='OBJECT')
        sarmObj.select_set(False)
        glueObj.select_set(True)
        bpy.context.view_layer.objects.active = glueObj
        bpy.ops.object.mode_set(mode='POSE')

        for boneRef in tarmObj.pose.bones:
            bone = boneRef.name
            if bone not in glueObj.data.bones:
                continue
            glueObj.data.bones[bone].select = True
            glueObj.pose.bones[bone].keyframe_insert(data_path="location", frame=1)
            glueObj.data.bones[bone].select = False

        print("Glue locking to target to acquire matrices...")
        for boneRef in tarmObj.pose.bones:
            gbone = boneRef.name
            if gbone not in glueObj.data.bones:
                continue
            bpy.data.objects[glue].data.bones.active = bpy.data.objects[glue].data.bones[gbone]
            
            if bbd.deformer_transform_location == True:
                bc = bpy.data.objects[glue].pose.bones[gbone].constraints
                bc.new('COPY_LOCATION')
                bc['Copy Location'].target = bpy.data.objects[tarm]
                bc['Copy Location'].subtarget = gbone 
                bc['Copy Location'].target_space = 'WORLD'
                bc['Copy Location'].owner_space = 'WORLD'
                bc['Copy Location'].influence = 1
                bc['Copy Location'].name = "BB Copy Loc"
            
            if bbd.deformer_transform_rotation == True:
                bc = bpy.data.objects[glue].pose.bones[gbone].constraints
                bc.new('COPY_ROTATION')
                bc['Copy Rotation'].target = bpy.data.objects[tarm]
                bc['Copy Rotation'].subtarget = gbone 
                bc['Copy Rotation'].target_space = 'WORLD'
                bc['Copy Rotation'].owner_space = 'WORLD'
                bc['Copy Rotation'].influence = 1
                bc['Copy Rotation'].name = "BB Copy Rot"

        print("Glue converting to matrices...")
        
        bpy.context.view_layer.update()

        gmatrices = {}
        for boneRef in tarmObj.pose.bones:
            if boneRef.name not in obj[glue].data.bones:
                continue
            gmatrices[boneRef.name] = obj[glue].pose.bones[boneRef.name].matrix.copy()
        
        for boneObj in glueObj.pose.bones:
            for pbC in boneObj.constraints:
                boneObj.constraints.remove(pbC)

        for gbone in gmatrices:
            glueObj.pose.bones[gbone].matrix = gmatrices[gbone]

        print("LOCK!")

        for boneRef in tarmObj.pose.bones:
            bone = boneRef.name
            if bone not in glueObj.data.bones:
                continue
            glueObj.data.bones[bone].select = True
            if bbd.deformer_transform_location == True:
                glueObj.pose.bones[bone].keyframe_insert(data_path="location", frame=2)
                glueObj.pose.bones[bone].keyframe_insert(data_path="location", frame=3)
            if bbd.deformer_transform_rotation == True:
                glueObj.pose.bones[bone].keyframe_insert(data_path="rotation_quaternion", frame=2)
                glueObj.pose.bones[bone].keyframe_insert(data_path="rotation_euler", frame=2)
                glueObj.pose.bones[bone].keyframe_insert(data_path="rotation_quaternion", frame=3)
                glueObj.pose.bones[bone].keyframe_insert(data_path="rotation_euler", frame=3)
            glueObj.data.bones[bone].select = False

        if bbd.deformer_acquire_animation_details == True:
            
            start_frame, end_frame = obj[glue].animation_data.action.frame_range
            bb.animation_start_frame = start_frame
            bb.animation_end_frame = end_frame
            if (end_frame - start_frame) > 1:
                bba.anim_loop_in_frame = start_frame + 1
            else:
                bba.anim_loop_in_frame = start_frame
            bba.anim_loop_out_frame = end_frame

            bpy.context.scene.bb_anim.anim_base_priority = 3
            bpy.context.scene.bb_anim.anim_base_name = "deformer"
            bpy.context.scene.bb_anim.anim_loop = True

        bpy.ops.object.mode_set(mode='OBJECT')
        glueObj.select_set(False)
        sarmObj.select_set(True)
        bpy.context.view_layer.objects.active = sarmObj

        sarmObj['bb_deformer'] = True

        print("Deformer created")
        
        return {'FINISHED'}

class OnigiriCreateDeformerMapped(bpy.types.Operator):
    """This is essentially the same thing as the (Create Deformer) but it uses your
mapped source rig to define the bone positions for your targets.  You need to select
your source rig (Onigiri Rig?) instead of the target because it contains the map.
"""

    bl_idname = "onigiri.create_deformer_mapped"
    bl_label = "Create a mapped deformer for your custom /converted rig"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.get('bone_map') == None:
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bbd = bpy.context.window_manager.bb_deform
        armObj = bpy.context.selected_objects[0]
        arm = armObj.name

        temp_map = armObj['bone_map'].to_dict()
        tarms = list()
        for sbone in temp_map:
            (tarm, tbone), = temp_map[sbone].items()
            if tarm in obj:
                if tarm not in tarms:
                    tarms.append(tarm)
        
        if len(tarms) == 0:
            print("All target armatures are missing")
            popup("No targets to process", "Error", "ERROR")
            return {'FINISHED'}

        bone_map = {}
        for sbone in temp_map:
            
            if sbone not in armObj.data.bones:
                print("Source bone missing from armature that's defined in the map")
                popup("Source bone missing", "Source Missing", "ERROR")
                return {'FINISHED'}
            (tarm, tbone), = temp_map[sbone].items()
            if tbone not in obj[tarm].data.bones:
                continue
            bone_map[sbone] = {tarm:tbone}
        
        if len(bone_map) == 0:
            print("There were no mappable target bones in any of the defined rigs")
            popup("No mappable bones", "Wrong map?", "ERROR")
            return {'FINISHED'}

        old_mode = bpy.context.mode
        if old_mode == 'EDIT_ARMATURE':
            old_mode = 'EDIT'
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.onigiri.create_neutral_rig()
        sarmObj = bpy.context.object
        sarmObj.name = "_DEFORMER_MAPPED"
        sarm = sarmObj.name

        sarmObj.select_set(True)
        bpy.context.view_layer.objects.active = sarmObj
        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in sarmObj.data.edit_bones:
            boneObj.use_connect = False

        bpy.ops.object.mode_set(mode='OBJECT')
        for boneObj in sarmObj.data.bones:
            boneObj.use_inherit_rotation = False

        if 1 == 0:
        
            tarm_bones = {}
            
            for tarm in tarms:
                for boneObj in obj[tarm].pose.bones:
                    tarm_bones[boneObj.name] = boneObj.matrix.copy()

        bpy.ops.object.duplicate()
        glueObj = bpy.context.object
        glueObj.name = "_GLUE_MAPPED"
        glue = glueObj.name
        glueObj.data.display_type = 'STICK'
        glueObj.show_in_front = True

        bpy.ops.object.mode_set(mode='POSE')
        remove_armature_groups(glue)
        create_bone_group(glue, glue_group_name, glue_theme)
        for boneObj in glueObj.pose.bones:
            add_bone_to_group(armature=glue, bone=boneObj.name, group=glue_group_name)

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in glueObj.data.edit_bones:
            boneObj.parent = None
        bpy.ops.object.mode_set(mode='OBJECT')

        glueObj.select_set(False)
        sarmObj.select_set(True)
        bpy.context.view_layer.objects.active = sarmObj

        bpy.ops.object.mode_set(mode='POSE')
        for sbone in bone_map:

            print("creating constraint on bone", sbone)

            bpy.data.objects[sarm].data.bones.active = bpy.data.objects[sarm].data.bones[sbone]
            if bbd.deformer_transform_location == True:
                bc = bpy.data.objects[sarm].pose.bones[sbone].constraints
                bc.new('COPY_LOCATION')
                bc['Copy Location'].target = bpy.data.objects[glue]
                bc['Copy Location'].subtarget = sbone 
                bc['Copy Location'].target_space = 'WORLD'
                bc['Copy Location'].owner_space = 'WORLD'
                bc['Copy Location'].influence = 1
                bc['Copy Location'].name = "BB Copy Loc"
            if bbd.deformer_transform_rotation == True:
                bc = bpy.data.objects[sarm].pose.bones[sbone].constraints
                bc.new('COPY_ROTATION')
                bc['Copy Rotation'].target = bpy.data.objects[glue]
                bc['Copy Rotation'].subtarget = sbone 
                bc['Copy Rotation'].target_space = 'WORLD'
                bc['Copy Rotation'].owner_space = 'WORLD'
                bc['Copy Rotation'].influence = 1
                bc['Copy Rotation'].name = "BB Copy Rot"

        bpy.ops.object.mode_set(mode='OBJECT')
        sarmObj.select_set(False)
        glueObj.select_set(True)
        bpy.context.view_layer.objects.active = glueObj
        bpy.ops.object.mode_set(mode='POSE')

        for sbone in bone_map:
            glueObj.data.bones[sbone].select = True
            glueObj.pose.bones[sbone].keyframe_insert(data_path="location", frame=1)
            glueObj.data.bones[sbone].select = False

        print("Glue locking to mapped target to acquire matrices...")
        for sbone in bone_map:
            (tarm, tbone), = bone_map[sbone].items()
            bpy.data.objects[glue].data.bones.active = bpy.data.objects[glue].data.bones[sbone]
            if bbd.deformer_transform_location == True:
                bc = bpy.data.objects[glue].pose.bones[sbone].constraints
                bc.new('COPY_LOCATION')
                bc['Copy Location'].target = bpy.data.objects[tarm]
                bc['Copy Location'].subtarget = tbone
                bc['Copy Location'].target_space = 'WORLD'
                bc['Copy Location'].owner_space = 'WORLD'
                bc['Copy Location'].influence = 1
                bc['Copy Location'].name = "BB Copy Loc"
            if bbd.deformer_transform_rotation == True:
                bc = bpy.data.objects[glue].pose.bones[sbone].constraints
                bc.new('COPY_ROTATION')
                bc['Copy Rotation'].target = bpy.data.objects[tarm]
                bc['Copy Rotation'].subtarget = tbone
                bc['Copy Rotation'].target_space = 'WORLD'
                bc['Copy Rotation'].owner_space = 'WORLD'
                bc['Copy Rotation'].influence = 1
                bc['Copy Rotation'].name = "BB Copy Rot"

        print("Glue converting to matrices...")
        
        bpy.context.view_layer.update()

        gmatrices = {}
        for sbone in bone_map:
            gmatrices[sbone] = obj[glue].pose.bones[sbone].matrix.copy()

        for boneObj in glueObj.pose.bones:
            for pbC in boneObj.constraints:
                boneObj.constraints.remove(pbC)

        for gbone in gmatrices:
            glueObj.pose.bones[gbone].matrix = gmatrices[gbone]

        print("LOCK!")

        for sbone in bone_map:
            glueObj.data.bones[sbone].select = True
            if bbd.deformer_transform_location == True:
                glueObj.pose.bones[sbone].keyframe_insert(data_path="location", frame=2)
                glueObj.pose.bones[sbone].keyframe_insert(data_path="location", frame=3)
            if bbd.deformer_transform_rotation == True:
                glueObj.pose.bones[sbone].keyframe_insert(data_path="rotation_quaternion", frame=2)
                glueObj.pose.bones[sbone].keyframe_insert(data_path="rotation_euler", frame=2)
                glueObj.pose.bones[sbone].keyframe_insert(data_path="rotation_quaternion", frame=3)
                glueObj.pose.bones[sbone].keyframe_insert(data_path="rotation_euler", frame=3)
            glueObj.data.bones[sbone].select = False

        if bbd.deformer_acquire_animation_details == True:
            bpy.ops.onigiri.acquire_animation_details()
            bpy.context.scene.bb_anim.anim_base_priority = 3
            bpy.context.scene.bb_anim.anim_base_name = "deformer"
            bpy.context.scene.bb_anim.anim_loop = True

        bpy.ops.object.mode_set(mode='OBJECT')
        glueObj.select_set(False)
        sarmObj.select_set(True)
        bpy.context.view_layer.objects.active = sarmObj

        print("Mapped Deformer created")
        
        return {'FINISHED'}

class OnigiriShapeShifterProperties(bpy.types.PropertyGroup):

    shifter_morph_menu_enabled : bpy.props.BoolProperty(
        description =            "Expand the Shape Shifter's character morpher features"            "\n\n"            "This set of features allows you to morph your character rig from one to another through a set of "            "animation key frames.",
        default = False,
        )

    def update_shifter_morph_source_locked(self, context):
        print("=====================================")
        print("update_shifter_morph_source_locked runs...")
        print("=====================================")
        ss = bpy.context.scene.bb_shifter
        
        if ss.shifter_terminate == True:
            ss.shifter_terminate = False
            return
        if ss.shifter_morph_source_locked == False:
            bpy.ops.onigiri.shifter_morph(action="source_false")
        return
    def update_shifter_morph_target_locked(self, context):
        print("=====================================")
        print("update_shifter_morph_target_locked runs...")
        print("=====================================")
        ss = bpy.context.scene.bb_shifter
        
        if ss.shifter_terminate == True:
            ss.shifter_terminate = False
            return
        if ss.shifter_morph_target_locked == False:
            bpy.ops.onigiri.shifter_morph(action="target_false")
        return

    shifter_morph_source_name : bpy.props.StringProperty(
        description = "Morph these bones to 1 or more target armatures",
        default = ""
        )
    
    shifter_morph_source_locked : bpy.props.BoolProperty(
        description = "",
        default = False,
        update=update_shifter_morph_source_locked
        )
    
    shifter_morph_target_locked : bpy.props.BoolProperty(
        description = "Morphing your source bones to the targets initiated by this lock",
        default = False,
        update=update_shifter_morph_target_locked
        )
    
    shifter_morph_target_name : bpy.props.StringProperty(
        description = "",
        default = ""
        )

    shifter_morph_start : bpy.props.IntProperty(
        description =            "The start frame for the morph",
        default = 1,
        )
    shifter_morph_range : bpy.props.IntProperty(
        description =            "The frame range of the entire morph",
        min = 2,
        default = 3,
        )
    shifter_morph_reverse : bpy.props.BoolProperty(
        description =            "This is a fun display, it will reverse the animation from the peak frame so that it reverts back.  "            "This can have a practical use beyond being interesting to watch.",
        default = False,
        )
    shifter_morph_peak : bpy.props.IntProperty(
        description =            "This is the frame where you want the peak to be, from there to the (range) will be the reverse of the morph.",
        default = 2
       )
    
    def update_shifter_morph_location(self, context):
        ss = bpy.context.scene.bb_shifter
        bpy.ops.onigiri.shifter_transform(transform="location")
        return
    def update_shifter_morph_rotation(self, context):
        ss = bpy.context.scene.bb_shifter
        bpy.ops.onigiri.shifter_transform(transform="rotation")
        return
    def update_shifter_morph_scale(self, context):
        ss = bpy.context.scene.bb_shifter
        bpy.ops.onigiri.shifter_transform(transform="scale")
        return

    def update_shifter_morph_match(self, context):
        ss = bpy.context.scene.bb_shifter
        ss.property_unset("shifter_morph_target_locked")
        ss.shifter_morph_target_name = ""
        if len(ss.get('morph_targets', []) ) > 1:
            del ss['morph_targets']
            print("Only one target can be used with match map, targets were removed")
        return

    shifter_morph_match : bpy.props.BoolProperty(
        description =            "This option attempts to match bones from source to target instead of using a template or random match.  "            "This can only match a single target so if you get an error rest the mapper and choose only 1 target.",
        
        default=False,
        )
    shifter_morph_location : bpy.props.BoolProperty(
        description =            "Morph to the location of the target bones"            "\n\n"            "This feature can actively be enabled and disabled after morph has been engaged",
        default=True,
        update=update_shifter_morph_location
        )
    shifter_morph_rotation : bpy.props.BoolProperty(
        description =            "Morph to the rotation of the target bones"            "\n\n"            "This feature can actively be enabled and disabled after morph has been engaged",
        default=True,
        update=update_shifter_morph_rotation
        )
    shifter_morph_scale : bpy.props.BoolProperty(
        description =            "Morph to the scale of the target bones"            "\n\n"            "This feature can actively be enabled and disabled after morph has been engaged"            "\n\n"            "WARNING: This may not work as you expect since Second Life does not support bone scale.  "            "However, this might be useful if your bones are, in fact, scaled and the result of your morph "            "is not in sync with those target bones.",
        default=False,
        update=update_shifter_morph_scale
        )

    shifter_terminate : bpy.props.BoolProperty(default=False)

    shifter_freeform_menu_enabled : bpy.props.BoolProperty(
        description =            "Expand the Shape Shifter's free-form pose features"            "\n\n"            "This is a set of tools to allow you to create a transitional pose between two states "            "moving all bones from one transformed state to a defined one.  The use of this tool is to "            "ensure that all bones recieve animation attention and for Second Life that means that the "            "bones will not be forced into another position by SL.  The use of this tool is advanced and is "            "only a portion of the process that can benefit from it.  If you are confused by this tool then it's "            "probably not for you, not yet.",
        default = False,
        )
    shifter_pose_to_current : bpy.props.BoolProperty(
        description =            "Enable this if you want the generated pose to start from the current frame instead of the indicated (start)",
        default = False,
        )
    shifter_pose_to_start : bpy.props.FloatProperty(
        description = "Frame to start your pose",
        default = 1.0,
        )
    shifter_pose_to_range : bpy.props.FloatProperty(
        description =            "The amount of frames to spread the pose across, there will be interpolation indicated by your normal Blender settings",
        default = 4.0,
        )
    shifter_pose_to_location_x : bpy.props.FloatProperty(
        description = "lx",
        min = -10,
        max = 10,
        precision = 5,
        default = 0.0000,
        )
    shifter_pose_to_location_y : bpy.props.FloatProperty(
        description = "ly",
        min = -10,
        max = 10,
        precision = 5,
        default = 0.0000,
        )
    shifter_pose_to_location_z : bpy.props.FloatProperty(
        description = "lz",
        min = -10,
        max = 10,
        precision = 5,
        default = 0.0000,
        )
    shifter_pose_to_rotation_x : bpy.props.FloatProperty(
        description = "rx",
        min = -180,
        max = 180,
        precision = 4,
        default = 0.0000,
        )
    shifter_pose_to_rotation_y : bpy.props.FloatProperty(
        description = "ry",
        min = -180,
        max = 180,
        precision = 4,
        default = 0.0000,
        )
    shifter_pose_to_rotation_z : bpy.props.FloatProperty(
        description = "rz",
        min = -180,
        max = 180,
        precision = 4,
        default = 0.0000,
        )
    shifter_pose_to_scale_x : bpy.props.FloatProperty(
        description = "sx",
        min = -10,
        max = 10,
        precision = 5,
        default = 1.00000,
        )
    shifter_pose_to_scale_y : bpy.props.FloatProperty(
        description = "sy",
        min = -10,
        max = 10,
        precision = 5,
        default = 1.00000,
        )
    shifter_pose_to_scale_z : bpy.props.FloatProperty(
        description = "sz",
        min = -10,
        max = 10,
        precision = 5,
        default = 1.00000,
        )

    def update_shifter_blank(self, context):
        bpy.context.scene.bb_shifter["shifter_blank"] = False
    shifter_blank : bpy.props.BoolProperty(
        name = "",
        description = "--internal",
        default = False,
        update = update_shifter_blank
        )
    shifter_build_menu_enabled : bpy.props.BoolProperty(
        description =            "Expand the Build menu"            "\n\n"            "Release this switch to accept the new selection as the parent",
        default = False,
        )
    
    def update_shifter_build_link(self, context):
        bb_shifter = bpy.context.scene.bb_shifter
        if bb_shifter.shifter_build_link == False:
            bpy.ops.onigiri.shifter_build_attach()
    shifter_build_link : bpy.props.BoolProperty(
        description =            "Expand the Build menu"            "\n\n"            "You can build a new hierarchy using the frozen rig bones in order to have control over how "            "your rig animates.",
        default = False,
        update = update_shifter_build_link
        )

class OnigiriShapeShifterBuildAttach(bpy.types.Operator):
    """-internal"""

    bl_idname = "onigiri.shifter_build_attach"
    bl_label = "-internal"

    def execute(self, context):
        bb_shifter = bpy.context.scene.bb_shifter
        obj = bpy.data.objects
        frozenObj = bpy.context.selected_objects[0]

        glueObj = frozenObj.get('bb_glue')
        if glueObj == None:
            print("The companion armature is missing")
            
            return {'FINISHED'}
        if glueObj.name not in bpy.context.scene.objects:
            print("The companion armature is not in the scene:", glueObj.name)
            
            return {'FINISHED'}

        bpy.ops.pose.armature_apply()

        frozen_parent = bpy.context.selected_pose_bones[0].name
        frozen_children = set(shifter.props['frozen_bones'])
        print("frozen_parent:", frozen_parent)
        print("frozen_children:", frozen_children)
        armObj = shifter.props['frozen_rig']

        print("about to connect frozen_children:", frozen_children)

        if frozen_parent in frozen_children:
            print("Found parent in child bones, removing:", frozen_parent)
            frozen_children.remove(frozen_parent)

        bpy.ops.object.mode_set(mode='EDIT')
        for bone in frozen_children:
            print("iterating child:", bone)

            eBone = frozenObj.data.edit_bones[bone]
            
            connected = eBone.use_connect

            eBone.parent = armObj.data.edit_bones[frozen_parent]

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()

        shifter.props['frozen_rig'] = ""
        shifter.props['frozen_bones'] = []

        if connected == True:
            
            frozenObj.data.bones[frozen_child].select = False
            glueObj.data.bones[frozen_parent].select = True
            bpy.ops.onigiri.shifter_build_connect(use_connect="yes")
            glueObj.data.bones[frozen_parent].select = False
            frozenObj.data.bones[frozen_child].select = True

        return {'FINISHED'}

class OnigiriShapeShifterBuildLink(bpy.types.Operator):
    """Build a rig using these tools.  Click select 1 or more bones and then this button.  Click
a different bone and release this button, the selected bone will become the parent
of the previous one chosen"""

    bl_idname = "onigiri.shifter_build_link"
    bl_label = "Record child bone"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.get('bb_glue') == None:
            return False
        return True

    def execute(self, context):
        bb_shifter = bpy.context.scene.bb_shifter
        obj = bpy.data.objects
        armObj = bpy.context.selected_objects[0]
        frozen_bones = []
        for boneObj in bpy.context.selected_pose_bones:
            frozen_bones.append(boneObj.name)
        shifter.props['frozen_rig'] = armObj
        shifter.props['frozen_bones'] = frozen_bones

        print("stored children:", frozen_bones)

        bb_shifter["shifter_build_link"] = True

        return {'FINISHED'}

class OnigiriShapeShifterBuildUnlink(bpy.types.Operator):
    """Select 1 or more bones and click this to unlink them, it will remove the parent association.
This will allow you to move the bone but is not required,  you can use the (Disconnect)
to detach instead"""

    bl_idname = "onigiri.shifter_build_unlink"
    bl_label = "Remove parent link"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.get('bb_glue') == None:
            return False
        return True

    def execute(self, context):
        bb_shifter = bpy.context.scene.bb_shifter
        obj = bpy.data.objects
        armObj = bpy.context.selected_objects[0]
        bones = []
        for boneObj in bpy.context.selected_pose_bones:
            if boneObj.parent:
                bones.append(boneObj.name)
                print("Removing parent", boneObj.parent.name, "from bone", boneObj.name)
            else:
                print("No parent for", boneObj.name)
        bpy.ops.object.mode_set(mode='EDIT')
        for bone in bones:
           armObj.data.edit_bones[bone].parent = None
        bpy.ops.object.mode_set(mode='POSE')

        return {'FINISHED'}

class OnigiriShapeShifterBuildSelect(bpy.types.Operator):
    """A tool to select all children of the selected bone and to select the parent of
any selected bone"""

    bl_idname = "onigiri.shifter_build_select"
    bl_label = "Select parent of children"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.get('bb_glue') == None:
            return False
        return True

    def execute(self, context):
        bb_shifter = bpy.context.scene.bb_shifter
        obj = bpy.data.objects
        armObj = bpy.context.selected_objects[0]

        if len(bpy.context.selected_pose_bones) == 0:
            print("No bones selected")
            popup("You need at least one bone selected", "Error", "ERROR")
            return {'FINISHED'}

        selected = bpy.context.selected_pose_bones
        pbones = []
        cbones = []

        for boneObj in armObj.data.bones:
            boneObj.select = False

        if self.action == "parents":
            
            for boneObj in selected:
                dBone = boneObj.bone
                if boneObj.parent:
                    dBone.parent.select = True

        if self.action == "children":
            for boneObj in selected:
                children = boneObj.children
                for cBone in children:
                    armObj.data.bones[cBone.name].select = True

        return {'FINISHED'}

class OnigiriShapeShifterBuildSnap(bpy.types.Operator):
    """Snap the selected hierarchy to its parent bone.  If you don't want to parent the bones you can
still parent temporarily, then use snap, then unlink"""

    bl_idname = "onigiri.shifter_build_snap"
    bl_label = "Snap the hierarchy to its parent"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.get('bb_glue') == None:
            return False
        return True

    def execute(self, context):
        bb_shifter = bpy.context.scene.bb_shifter
        obj = bpy.data.objects
        armObj = bpy.context.selected_objects[0]

        if len(bpy.context.selected_pose_bones) == 0:
            print("No bones selected")
            popup("You need at least one bone selected", "Error", "ERROR")
            return {'FINISHED'}

        selected = bpy.context.selected_pose_bones
        if len(selected) > 1:
            print("Only one snap can be done at a time, too many bone selected")
            popup("Too many bones selected", "Error", "ERROR")
            return {'FINISHED'}

        print("selected:", selected)

        childBone = selected[0]
        parentBone = childBone.parent
        if parentBone == None:
            print("No parent to snap to")
            return {'FINISHED'}

        armObj.data.bones.active = childBone.bone 
        bc = childBone.constraints
        conObj = bc.new('COPY_LOCATION')
        conObj.target = armObj
        conObj.subtarget = parentBone.name
        conObj.target_space = 'WORLD'
        conObj.owner_space = 'WORLD'
        conObj.influence = 1
        conObj.head_tail = 1
        conObj.name = "BB LOC TEMP"

        bpy.ops.pose.armature_apply()

        childBone.constraints.remove(conObj)

        return {'FINISHED'}

class OnigiriShapeShifterBuildConnect(bpy.types.Operator):
    """Click to connect bones"""

    bl_idname = "onigiri.shifter_build_connect"
    bl_label = "Connect Bones"

    use_connect : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.get('bb_glue') == None:
            return False
        return True

    def execute(self, context):
        
        bb_shifter = bpy.context.scene.bb_shifter
        frozenObj = bpy.context.selected_objects[0]

        glueObj = frozenObj.get('bb_glue')
        if glueObj == None:
            print("The companion armature is missing")
            popup("The companion armature is missing", "Error", "ERROR")
            return {'FINISHED'}
        if glueObj.name not in bpy.context.scene.objects:
            print("The companion armature is not in the scene:", glueObj.name)
            popup("The companion armature is not in the scene", "Error", "ERROR")
            return {'FINISHED'}

        bpy.ops.pose.armature_apply()
        bones = []
        for boneObj in bpy.context.selected_pose_bones:
            bones.append(boneObj.name)

        if self.use_connect == "yes":
            bpy.ops.object.mode_set(mode='EDIT')

            edit_bones = {}
            no_parents = [] 
            has_parents = [] 
            for bone in bones:
                if frozenObj.data.bones[bone].parent:
                    frozenObj.data.edit_bones[bone].use_connect = True
                    has_parents.append(bone)
                    
                    edit_bones[bone] = {}
                    edit_bones[bone]['head'] = frozenObj.data.edit_bones[bone].head.copy()
                    edit_bones[bone]['tail'] = frozenObj.data.edit_bones[bone].tail.copy()
                    edit_bones[bone]['roll'] = frozenObj.data.edit_bones[bone].roll
                else:
                    no_parents.append(bone)

            bpy.ops.object.mode_set(mode='OBJECT')
            frozenObj.select_set(False)

            glueObj.select_set(True)
            bpy.context.view_layer.objects.active = glueObj
            bpy.ops.object.mode_set(mode='EDIT')
            for bone in has_parents:
                if bone not in glueObj.data.bones:
                    print("Companion bone missing from glue object:", glueObj, bone)
                    continue
                glueObj.data.edit_bones[bone].head = edit_bones[bone]['head']
                glueObj.data.edit_bones[bone].tail = edit_bones[bone]['tail']
                glueObj.data.edit_bones[bone].roll = edit_bones[bone]['roll']
            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.armature_apply()
            bpy.ops.object.mode_set(mode='OBJECT')
            glueObj.select_set(False)

            frozenObj.select_set(True)
            bpy.context.view_layer.objects.active = frozenObj
            bpy.ops.object.mode_set(mode='POSE')

            if len(no_parents) > 0:
                print("Some bones didn't have parents so could not be connected")
                print(no_parents)
            if len(has_parents) > 0:
                print("The following bones were able to be connected:")
                print(has_parents)
            else:
                print("No bones could be connected because none of them in your selection were parented")
                popup("No qualified bones were selected, see System Console", "Info", "INFO")

        else:
            
            bpy.ops.object.mode_set(mode='EDIT')
            for bone in bones:
                frozenObj.data.edit_bones[bone].use_connect = False
            bpy.ops.object.mode_set(mode='POSE')

        return {'FINISHED'}

class OnigiriShapeShifterFreezeRig(bpy.types.Operator):
    """Add a control rig that keeps all of your source bones in place, except for the one
being moved.  If you don't see the benefit of this create a Onigiri rig, click this
button, go into pose mode on the _SNAP rig and start moving bones"""

    bl_idname = "onigiri.shifter_freeze_rig"
    bl_label = "Freeze Rig, lock bones into place"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.get('bb_glue') != None:
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        sarmObj = bpy.context.object
        sarm = sarmObj.name
        tarm = shifter.freeze(sarm)
        if tarm == False:
            print("There was a problem freezing the rig:", sarm)
        else:
            print("Rig frozen:", sarm)
            
            obj[sarm]['bb_frozen'] = obj[tarm]
            obj[tarm]['bb_glue'] = obj[sarm]
            
        bpy.ops.object.mode_set(mode='POSE')

        return {'FINISHED'}

class OnigiriShapeShifterPoseRig(bpy.types.Operator):
    """Create a custom transition pose of 3 keys.  The first pose will be where your
bones are now, the second pose is the values you use here, the third pose goes back
to where it was.  The actual pose is held for 1 full frame length"""

    bl_idname = "onigiri.shifter_pose_rig"
    bl_label = "Freeze Rig, lock bones into place"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        ss = bpy.context.scene.bb_shifter

        loc = [ ss.shifter_pose_to_location_x,
                ss.shifter_pose_to_location_y,
                ss.shifter_pose_to_location_z ]
        rot = [ ss.shifter_pose_to_rotation_x,
                ss.shifter_pose_to_rotation_y,
                ss.shifter_pose_to_rotation_z ]
        sca = [ ss.shifter_pose_to_scale_x,
                ss.shifter_pose_to_scale_y,
                ss.shifter_pose_to_scale_z ]
        current = ss.shifter_pose_to_current
        start = ss.shifter_pose_to_start
        frame_range = ss.shifter_pose_to_range

        sarmObj = bpy.context.object
        sarm = sarmObj.name

        state = shifter.pose_to(sarm=sarm, location=loc, rotation=rot, scale=sca, current=current, start=start, frame_range=frame_range)
        if state == False:
            print("There was a problem posing the rig:", sarm)
        else:
            print("Rig frozen:", sarm)

        return {'FINISHED'}

class OnigiriShapeShifterMorph(bpy.types.Operator):
    """Morph between rigs, effectively morphing one character to another or multiple.  This is an advanced feature and is
not meant to act as a magic tool, there is a lot of character preparation involved before this can be useful"""

    bl_idname = "onigiri.shifter_morph"
    bl_label = "Pose morph one rig to others"

    action : bpy.props.StringProperty(default="")

    def execute(self, context):
        obj = bpy.data.objects
        ss = bpy.context.scene.bb_shifter

        def cleanup(full=False):
            print("shifter morph cleanup")
            source = ss.shifter_morph_source_name

            print("Cleanup for source:", source)

            if bpy.context.mode != 'OBJECT':
                bpy.ops.object.mode_set(mode='OBJECT')
            if source in obj:
                if obj[source].get('bone_map'):
                    del obj[source]['bone_map']
                if ss.get('morph_targets') != None:
                    del ss['morph_targets']
                if ss.get('template_map') != None:
                    del ss['template_map']
                ss.property_unset('shifter_morph_target_locked')

                if source in obj:
                    
                    for b in obj[source].pose.bones:
                        for c in b.constraints:
                            b.constraints.remove(c)
                    if obj[source].get('morph') != None:
                        glue = obj[source]['morph']['name'] 
                        del obj[source]['morph']

                        if glue in obj:
                            
                            for o in bpy.context.selected_objects:
                                o.select_set(False)
                            
                            obj[glue].select_set(True)
                            
                            bpy.ops.object.delete()
                            
                            obj[source].select_set(True)
                            bpy.context.view_layer.objects.active = obj[source]

            ss.shifter_morph_source_name = ""
            ss.shifter_morph_target_name = ""
            ss.shifter_terminate = True
            ss.shifter_morph_source_locked = False
            ss.shifter_terminate = True
            ss.shifter_morph_target_locked = False
            for o in bpy.context.selected_objects:
                o.select_set(False)
            bpy.context.view_layer.objects.active = None
            if ss.get('morph_targets'):
                del ss['morph_targets']
            if ss.get('morph_glue'):
                for name in ss['morph_glue']:
                    if name in obj:
                        obj[name].select_set(True)
                bpy.ops.object.delete()
            if ss.get('morp_clean') != None:
                for name in ss['morph_clean']:
                    if obj[name].type == 'ARMATURE':
                        for b in obj[name].pose.bones:
                            for c in b.constraints:
                                b.constraints.remove(c)
            
            if full == True:
                for p in bpy.context.scene['bb_shifter']:
                    if p == 'shifter_morph_menu_enabled': continue
                    try:
                        bpy.context.scene.bb_shifter.property_unset(p)
                    except:
                        print("No unset for custom property, skipped:", p)
                    try:
                        del bpy.context.scene['bb_shifter'][p]
                    except:
                        print("No del for read only property, skipped:", p)

            if source != "" and source in obj:
                obj[source].select_set(True)
                bpy.context.view_layer.objects.active = obj[source]
            return True

        if self.action == "reset":
            print("shifter_morph reset triggered")
            cleanup(full=True)
            return {'FINISHED'}

        arms = list()
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                arms.append(o.name)

        if self.action == "source":
            if len(arms) > 1:
                print("Too many armatures, on one source can be used")
                popup("Choose only one source please", "Too Many Sources", "INFO")
                return {'FINISHED'}
            if len(arms) == 0:
                print("You need to select a source armature")
                popup("Select a source armature", "No rig selected", "INFO")
                return {'FINISHED'}
            if ss.get('morph_targets') != None:
                if o.name in ss['morph_targets']:
                    print("Can't have your source the same as one of your morph targets:", o.name)
                    popup("The source is in your morph targets", "Source matches a target", "ERROR")
                    return {'FINISHED'}
            ss.shifter_morph_source_name = o.name
            ss.shifter_morph_source_locked = True

            if o.get('bone_map') != None:
                del o['bone_map']

            print("-----------------------------------")
            print("locked source:", o.name)
            print("-----------------------------------")

        elif self.action == "target":
            if ss.shifter_morph_source_locked == False:
                print("The bone map is stored in the source armature object which means")
                print("that it has to be locked before any targets can be assigned.")
                popup("Chose the source first", "Requires Source", "INFO")
                return {'FINISHED'}

            try:
                arms.remove(ss.shifter_morph_source_name)
            except:
                pass
            arms_len = len(arms)

            if arms_len == 0:
                print("You need at least 1 target armature selected")
                popup("Choose at least one target armature", "Choose a target rig", "INFO")
                return {'FINISHED'}
            elif arms_len == 1:
                ss.shifter_morph_target_name = arms[0]
            else:
                ss.shifter_morph_target_name = str(arms_len)
            ss['morph_targets'] = arms
            ss.shifter_morph_target_locked = True
            print("-----------------------------------")
            print("locking target(s):", arms)
            print("-----------------------------------")

            source = ss.shifter_morph_source_name

            target_bone_count = 0
            for tarm in ss['morph_targets']:
                target_bone_count += len(obj[tarm].data.bones)
            
            source_bone_count = len(obj[source].data.bones)
            print("bone count - source/target:", source_bone_count, "/", target_bone_count)

            if target_bone_count > source_bone_count:
                print("Not enough source bones to fill target: source/target:", source_bone_count, target_bone_count)
                print("You can continue if you're testing but using this as an end result is probably not what you want")
                popup("Total target bones exceeds source, see console", "Info", "INFO")

            bone_list = [a.name for a in obj[source].data.bones]
            
            bone_map = dict()
            index = 0
            for tarm in ss['morph_targets']:
                for tboneObj in obj[tarm].data.bones:
                    tbone = tboneObj.name
                    sbone = bone_list[index]
                    bone_map[sbone] = {tarm:tbone}
                    index += 1
                    
                    if index == source_bone_count:
                        print("Source bone supply exhausted before completion...")
                        print("break 1")
                        break
                if index == source_bone_count:
                    print("break 2")
                    break

            obj[source]['bone_map'] = bone_map

            del bone_map
            del bone_list

        elif self.action == "source_false":
            print("shifter source armature was unlocked")
            cleanup()

        elif self.action == "target_false":
            print("shifter target armature was unlocked")
            cleanup()

        elif self.action == "morph":
            source=ss.shifter_morph_source_name
            
            if ss.shifter_morph_source_locked == False or ss.shifter_morph_target_locked == False:
                print("both the source and targets have to be chosen before you can use this feature")
                popup("Choose a source rig and at least 1 target rig", "Requirements not met", "INFO")
                return {'FINISHED'}

            if source not in obj:
                print("The source armature is missing:", source)
                print("The source armature is missing", "Missing Source", "ERROR")
                return {'FINISHED'}
            for tarm in ss['morph_targets']:
                if tarm not in obj:
                    print("A target armature is missing:", tarm)
                    print("A target armature is missing", "Missing Target", "ERROR")
                    return {'FINISHED'}

            if ss.shifter_morph_match == True:
                if len(ss['morph_targets']) != 1:
                    print("Match type morphing can only be performed on a single target, reset your mapper and try again.")
                    popup("Too many targets for (match) mapping, see console.", "Error", "ERROR")
                    return {'FINISHED'}
                
                bone_map = {}
                target = ss['morph_targets'][0] 
                for boneObj in obj[target].data.bones:
                    bone = boneObj.name
                    if bone in obj[source].data.bones:
                        bone_map[bone] = {target: bone}
                if len(bone_map) == 0:
                    print("There were no matching bones when attempting to match map between armatures")
                    popup("There were no matching bones", "Error", "ERROR")
                    return {'FINISHED'}
                obj[source]['bone_map'] = bone_map

            if obj[source].get('morph') != None:
                print("The morpher has already been engaged, reset the interface before starting a new one")
                popup("The morpher is already enabled", "Already Enabled", "INFO")
                return {'FINISHED'}

            print("Processing morph rigs...")
            bone_map = obj[source]['bone_map'].to_dict()
            shifter.morph(
                sarm=source,
                bone_map=bone_map,
                frame_start=ss.shifter_morph_start,
                frame_range=ss.shifter_morph_range,
                reverse=ss.shifter_morph_reverse,
                peak=ss.shifter_morph_peak,
                location=ss.shifter_morph_location,
                rotation=ss.shifter_morph_rotation,
                scale=ss.shifter_morph_scale)

        else:
            print("class morph : unknown action -", self.action)

        return {'FINISHED'}

class OnigiriShapeShifterTransform(bpy.types.Operator):
    """Enable or disable morph transform types.  If the mopher has already been enabled then these features
actively effect the current outcome.  If the morpher has not been set yet then these features are applied
when the morpher is engaged"""

    bl_idname = "onigiri.shifter_transform"
    bl_label = "Enable or disable specific transforms"

    transform : bpy.props.StringProperty(default="")

    def execute(self, context):
        
        obj = bpy.data.objects
        ss = bpy.context.scene.bb_shifter
        source = ss.shifter_morph_source_name

        if source not in obj:
            print("Source missing from scene")
            return {'FINISHED'}

        if obj[source].get('morph') == None:
            print("Morpher has not been engaged so active constraint alteration is disabled")
            return {'FINISHED'}

        glue = obj[source]['morph']['name']
        if glue not in obj:
            print("The morpher rig appears to be missing.  Try resetting the interface and reassert your morph.")
            print("You may also what to look for stray morpher objects afterwards and remove them (_MORPH_RIG)")
            
            return {'FINISHED'}

        transform = obj[source]['morph']['transforms'][self.transform]

        print("active transform constraint triggered:", transform)

        if self.transform == "location":
            for boneObj in obj[glue].pose.bones:
                
                if transform not in boneObj.constraints:
                    continue
                boneObj.constraints[transform].mute = not ss.shifter_morph_location
        elif self.transform == "rotation":
            for boneObj in obj[glue].pose.bones:
                if transform not in boneObj.constraints:
                    continue
                boneObj.constraints[transform].mute = not ss.shifter_morph_rotation
        elif self.transform == "scale":
            for boneObj in obj[glue].pose.bones:
                if transform not in boneObj.constraints:
                    continue
                boneObj.constraints[transform].mute = not ss.shifter_morph_scale
        else:
            print("something weird happened, unknown transform option:", self.transform)
            
        return {'FINISHED'}

class OnigiriShapeShifterTarget(bpy.types.Operator):
    """Associate the selected rig with the target rig name indicated on this button for the template map.
The name displayed on this button is a proxy and may not identify your actual rig.
"""

    bl_idname = "onigiri.shifter_target"
    bl_label = "Associate a selected rig target with the template map one"

    name : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        obj = bpy.data.objects
        ss = bpy.context.scene.bb_shifter

        source = ss.shifter_morph_source_name
        tarmObj = bpy.context.selected_objects[0]
        tarm = tarmObj.name

        if ss.shifter_morph_source_locked == False:
            print("The bone map is stored in the source armature object which means")
            print("that it has to be locked before any targets can be assigned.")
            popup("Chose the source first", "Requires Source", "INFO")
            return {'FINISHED'}
        
        if source not in obj:
            print("Fatal error, source missing from scene")
            popup("Fatal error, source missing", "Error", "ERROR")
            return {'FINISHED'}

        if tarm == ss.shifter_morph_source_name:
            print("This target matched the source chosen, try another")
            popup("The selected rig is a source rig and cannot be used as a target", "Error", "ERROR")
            return {'FINISHED'}

        morph_targets = ss.get('morph_targets', [])

        if tarm in morph_targets:
            print("The selected rig has already been processed as a target:", tarm)
            popup("The selected rig has already been processed", "Error", "ERROR")
            return {'FINISHED'}

        del ss['targets_waiting'][self.name]

        morph_targets.append(tarm)
        ss['morph_targets'] = morph_targets
        if len(morph_targets) > 1:
            ss.shifter_morph_target_name = str(len(morph_targets))
        else:
            ss.shifter_morph_target_name = tarm

        ss.shifter_terminate = True
        ss.shifter_morph_target_locked = True

        if source not in obj:
            print("The source armature is no longer available in the scene:", source)
            popup("Source missing, see console", "Error", "ERROR")
            return {'FINISHED'}

        bone_map = obj[source].get('bone_map', {}) 
        sbone_list = list() 
        tbone_list = list()
        bad_match = dict()
        for sbone in ss['template_map']:
            (target, tbone), = ss['template_map'][sbone].items()

            if target == self.name:
                bone_map[sbone] = {tarm:tbone}

            if sbone in obj[source].data.bones:
                sbone_list.append(sbone)
            if tbone in obj[tarm].data.bones:
                tbone_list.append(tbone)
            
            if sbone not in obj[source].data.bones or tbone not in obj[tarm].data.bones:
                bad_match[sbone] = {tarm:tbone}

        obj[source]['bone_map'] = bone_map
        del bone_map

        print("If any, the following bones matched the source:", sbone_list)
        print("If any, the following bones matched the target:", tbone_list)
        if len(bad_match) > 0:
            print("There were incorrect maps, the following did not match:")
            popup("At least one map did not match, see console", "Mismatch", "INFO")
            for sbone in bad_match:
                (tarm, tbone), = bad_match[sbone].items()
                print("source bone / target armature / target bone:", sbone, "/", tarm, "/", tbone)

        return {'FINISHED'}

class OnigiriShapeShifterLoad(bpy.types.Operator, ImportHelper):
    """Load a CTM or choose your targets manually for an auto-map setup.  If you don't have a CTM for
this particular setup then you can make one in the Character Mapper, pull it down into the
Template Workshop, and save it"""

    bl_idname = "onigiri.shifter_load"
    bl_label = "Load template"

    filename_ext = ".ctm"
    filter_glob : bpy.props.StringProperty(
        default='*.bbm;*.ctm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        ss = bpy.context.scene.bb_shifter
        if ss.get('template_map') == None and ss.shifter_morph_match != True:
            return True
        return False

    def execute(self, context):
        obj = bpy.data.objects
        ss = bpy.context.scene.bb_shifter
        filename = self.properties.filepath

        try:
            namespace = {}
            exec(open(filename, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        template_map = {}
        if namespace.get('template_map') != None:
            print("Found template map")
            template_map.update(namespace['template_map'])
        rename_map = {}
        if namespace.get('rename_map') != None:
            print("Found rename map")
            template_map.update(namespace['rename_map'])

        ss['template_map'] = template_map

        targets_waiting = {}
        for sbone in template_map:
            (tarm, tbone), = template_map[sbone].items()
            targets_waiting[tarm] = ""
        ss['targets_waiting'] = targets_waiting

        del template_map
        del targets_waiting

        if ss.get('morph_targets') != None:
            del ss['morph_targets']
        
        ss.property_unset("shifter_morph_target_locked")
        ss.property_unset("shifter_morph_target_name")
        return {'FINISHED'}

class OnigiriAnimImportProperties(bpy.types.PropertyGroup):

    deformer_default : bpy.props.BoolProperty(
        name = "some anim import name",
        description =            "\n"            "some property",
        default=False
        )

class OnigiriAnimImport(bpy.types.Operator, ImportHelper):
    """This is for Second Life's .anim type animation file format.  This will import
that type of file and apply the animation to to a rig.
"""

    bl_idname = "onigiri.anim_import"
    bl_label = "Import an SL .anim animation file"

    filter_glob : bpy.props.StringProperty(
        default='*.anim',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bai = bpy.context.window_manager.anim_import
        af = open(self.filepath, "rb")
        anim_content = af.read()
        af.close()

        return {'FINISHED'}

def basic_bvh_exporter(path="", start=1, end=250, armature=""):

    if bpy.context.active_object != None:
        bpy.ops.object.mode_set(mode='OBJECT')

    for o in bpy.context.selected_objects:
        o.select_set(False)

    arm = armature
    obj = bpy.data.objects
    obj[arm].select_set(True)
    bpy.context.view_layer.objects.active = obj[arm]

    bb = bpy.context.scene.onigiri
    if bpy.context.scene.onigiri.bvh_to_sl == True:
        set_bvh_names(arm)

    if bb.bake_animation == True:
        bpy.ops.object.mode_set(mode='POSE')
        print("Baking animation")
        bpy.ops.nla.bake(
            frame_start=start,
            frame_end=end,
            step=1,
            only_selected=False,
            visual_keying=True,
            clear_constraints=False,
            clear_parents=False,
            use_current_action=True,
            bake_types={'POSE'}
            )

    bpy.ops.object.mode_set(mode='OBJECT')

    bpy.ops.export_anim.bvh(
        filepath = path,
        check_existing = True,
        filter_glob = "*.bvh",
        global_scale = 39.3701,
        frame_start = start,
        frame_end = end,
        rotate_mode = 'NATIVE',
        
        root_transform_only = bpy.context.scene.bb_anim_props.exclude_pelvis
        )
    return

class OnigiriJointDataProps(bpy.types.PropertyGroup):

    joint_data_enabled : bpy.props.BoolProperty(
        description =            "WARNING:\n\n"
            "Disable this button if you don't know what it does.  It will alter your animations in Second Life.\n\n"
            "Alter joint properties for exported animations.  Alter the application of rotation and "            "location data for specific joints.  You can also alter properties of the offset axis.",
        default = False
    )

    joint_data_enabled_override : bpy.props.BoolProperty(
        description =            "Typically you can only alter joint settings for Onigiri rigs but this option allows you to "            "enable it on any rig.  Your results might be very flaky if that chosen rig is not designed for "            "Second Life.  Good luck.",
        default = False
    )

    def update_loc_axis_inverted_x(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        sp = selected_pose_bones() 
        bjd = bpy.context.window_manager.bb_joint_data
        if sp == False or sp > 1:
            bb_settings['terminate'] = True
            bjd.loc_axis_inverted_x = False
            return
        jd = joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name

        if jd.joint_data[bone]['locked'] == True:
            bb_settings['terminate'] = True
            bjd.loc_axis_inverted_x = False
            return
        
        if bjd.loc_axis_inverted_x == True:
            jd.joint_data[bone]['loc_axis_inverted'][0] = '-'
        else:
            jd.joint_data[bone]['loc_axis_inverted'][0] = ''
    
    def update_loc_axis_inverted_y(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        sp = selected_pose_bones() 
        bjd = bpy.context.window_manager.bb_joint_data
        if sp == False or sp > 1:
            bb_settings['terminate'] = True
            bjd.loc_axis_inverted_y = False
            return
        jd = joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name
        if jd.joint_data[bone]['locked'] == True:
            bb_settings['terminate'] = True
            bjd.loc_axis_inverted_y = False
            return
        if bjd.loc_axis_inverted_y == True:
            jd.joint_data[bone]['loc_axis_inverted'][1] = '-'
        else:
            jd.joint_data[bone]['loc_axis_inverted'][1] = ''
    
    def update_loc_axis_inverted_z(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        sp = selected_pose_bones() 
        bjd = bpy.context.window_manager.bb_joint_data
        if sp == False or sp > 1:
            bb_settings['terminate'] = True
            bjd.loc_axis_inverted_z = False
            return
        jd = joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name
        if jd.joint_data[bone]['locked'] == True:
            bb_settings['terminate'] = True
            bjd.loc_axis_inverted_z = False
            return
        if bjd.loc_axis_inverted_z == True:
            jd.joint_data[bone]['loc_axis_inverted'][2] = '-'
        else:
            jd.joint_data[bone]['loc_axis_inverted'][2] = ''
    
    def update_loc_offset_inverted_x(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        sp = selected_pose_bones() 
        bjd = bpy.context.window_manager.bb_joint_data
        if sp == False or sp > 1:
            bb_settings['terminate'] = True
            bjd.loc_offset_inverted_x = False
            return
        jd = joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name
        if jd.joint_data[bone]['locked'] == True:
            bb_settings['terminate'] = True
            bjd.loc_offset_inverted_x = False
            return
        if bjd.loc_offset_inverted_x == True:
            jd.joint_data[bone]['loc_offset_inverted'][0] = '-'
        else:
            jd.joint_data[bone]['loc_offset_inverted'][0] = ''
    
    def update_loc_offset_inverted_y(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        sp = selected_pose_bones() 
        bjd = bpy.context.window_manager.bb_joint_data
        if sp == False or sp > 1:
            bb_settings['terminate'] = True
            bjd.loc_offset_inverted_y = False
            return
        jd = joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name
        if jd.joint_data[bone]['locked'] == True:
            bb_settings['terminate'] = True
            bjd.loc_offset_inverted_y = False
            return
        if bjd.loc_offset_inverted_y == True:
            jd.joint_data[bone]['loc_offset_inverted'][1] = '-'
        else:
            jd.joint_data[bone]['loc_offset_inverted'][1] = ''
    
    def update_loc_offset_inverted_z(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        sp = selected_pose_bones() 
        bjd = bpy.context.window_manager.bb_joint_data
        if sp == False or sp > 1:
            bb_settings['terminate'] = True
            bjd.loc_offset_inverted_z = False
            return
        jd = joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name
        if jd.joint_data[bone]['locked'] == True:
            bb_settings['terminate'] = True
            bjd.loc_offset_inverted_z = False
            return
        if bjd.loc_offset_inverted_z == True:
            jd.joint_data[bone]['loc_offset_inverted'][2] = '-'
        else:
            jd.joint_data[bone]['loc_offset_inverted'][2] = ''

    def update_rot_axis_inverted_x(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        sp = selected_pose_bones() 
        bjd = bpy.context.window_manager.bb_joint_data
        if sp == False or sp > 1:
            bb_settings['terminate'] = True
            bjd.rot_axis_inverted_x = False
            return
        jd = joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name
        if jd.joint_data[bone]['locked'] == True:
            bb_settings['terminate'] = True
            bjd.rot_axis_inverted_x = False
            return
        if bjd.rot_axis_inverted_x == True:
            jd.joint_data[bone]['rot_axis_inverted'][0] = '-'
        else:
            jd.joint_data[bone]['rot_axis_inverted'][0] = ''
    
    def update_rot_axis_inverted_y(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        sp = selected_pose_bones() 
        bjd = bpy.context.window_manager.bb_joint_data
        if sp == False or sp > 1:
            bb_settings['terminate'] = True
            bjd.rot_axis_inverted_y = False
            return
        jd = joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name
        if jd.joint_data[bone]['locked'] == True:
            bb_settings['terminate'] = True
            bjd.rot_axis_inverted_y = False
            return
        if bjd.rot_axis_inverted_y == True:
            jd.joint_data[bone]['rot_axis_inverted'][1] = '-'
        else:
            jd.joint_data[bone]['rot_axis_inverted'][1] = ''
    
    def update_rot_axis_inverted_z(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        sp = selected_pose_bones() 
        bjd = bpy.context.window_manager.bb_joint_data
        if sp == False or sp > 1:
            bb_settings['terminate'] = True
            bjd.rot_axis_inverted_z = False
            return
        jd = joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name
        if jd.joint_data[bone]['locked'] == True:
            bb_settings['terminate'] = True
            bjd.rot_axis_inverted_z = False
            return
        if bjd.rot_axis_inverted_z == True:
            jd.joint_data[bone]['rot_axis_inverted'][2] = '-'
        else:
            jd.joint_data[bone]['rot_axis_inverted'][2] = ''

    loc_axis_inverted_x : bpy.props.BoolProperty(default=False, update = update_loc_axis_inverted_x)
    loc_axis_inverted_y : bpy.props.BoolProperty(default=False, update = update_loc_axis_inverted_y)
    loc_axis_inverted_z : bpy.props.BoolProperty(default=False, update = update_loc_axis_inverted_z)

    loc_offset_inverted_x : bpy.props.BoolProperty(default=False, update = update_loc_offset_inverted_x)
    loc_offset_inverted_y : bpy.props.BoolProperty(default=False, update = update_loc_offset_inverted_y)
    loc_offset_inverted_z : bpy.props.BoolProperty(default=False, update = update_loc_offset_inverted_z)

    rot_axis_inverted_x : bpy.props.BoolProperty(default=False, update = update_rot_axis_inverted_x)
    rot_axis_inverted_y : bpy.props.BoolProperty(default=False, update = update_rot_axis_inverted_y)
    rot_axis_inverted_z : bpy.props.BoolProperty(default=False, update = update_rot_axis_inverted_z)

    copy_joint_data_set : bpy.props.BoolProperty(
        description =            "This allows you use another bone's data for this joint.  This does not change the internal data that is already "            "present.  Fill the text field with a bone name and click this button in order to enable it.  To remove the reference "            "just remove the name from the text field and click the (Set Copy) button again.",
        default=False,
        )

    copy_joint_data_name : bpy.props.StringProperty(
        description =            "Fill this with the joint name to use the data from.  Use the (Set Copy) button to enable it.  "            "The feature will complain if the joint is not present in the working armature.",
        default="",
    )

    def update_joint_locked(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        sp = selected_pose_bones() 
        bjd = bpy.context.window_manager.bb_joint_data
        if sp == False or sp > 1:
            bb_settings['terminate'] = True
            bjd.joint_locked = False
            return
        jd = joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name
        if bjd.joint_locked == True:
            jd.joint_data[bone]['locked'] = True
        if bjd.joint_locked == False:
            jd.joint_data[bone]['locked'] = False
        return

    joint_locked : bpy.props.BoolProperty(
        description =            "Prevent additional edits to this bone while this is enabled.",
        default = False,
        update = update_joint_locked
    )

    on_state : bpy.props.StringProperty(default = "off")

class OnigiriSaveJointData(bpy.types.Operator, ExportHelper):
    bl_idname = "onigiri.save_joint_data"
    bl_label = "Save Joint Data"

    filename_ext = ".jd"

    filter_glob : bpy.props.StringProperty(
        default='*.jd',
        options={'HIDDEN'}
        )

    def execute(self, context):
        jd = joint_data
        tp = templates
        ad = axis_defs

        jd_header = tp.joint_data_header
        jd_content = tp.joint_data_content
        jd_footer = tp.joint_data_footer

        formatted_text = jd_header

        for bone in jd.joint_data:
            jdc = jd_content.replace('%BONE', bone, 1)
            for bone_data in jd.joint_data[bone]:
                bone_data_value = bone_data + "_data"

                if bone_data == 'copy':
                    rep_txt = '"' + jd.joint_data[bone][bone_data] + '"'
                    jdc = jdc.replace(bone_data_value, rep_txt)
                    continue
                if bone_data == 'locked':
                    jdc = jdc.replace(bone_data_value, str(jd.joint_data[bone][bone_data]))
                    continue

                x,y,z = jd.joint_data[bone][bone_data]

                if bone_data.endswith("inverted"):
                    final_data = "'" + x + "', '" + y + "', '" + z + "',"
                else:
                    final_data  = str(ad.LOC_XYZ[x]) + ", "
                    final_data += str(ad.LOC_XYZ[y]) + ", "
                    final_data += str(ad.LOC_XYZ[z])

                jdc = jdc.replace(bone_data_value, final_data, 1)

            formatted_text += jdc

        formatted_text += jd_footer

        path = self.properties.filepath
        output = open(path, 'w', encoding='UTF8')
        output.write(formatted_text)
        output.close()

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriLoadJointData(bpy.types.Operator, ImportHelper):
    bl_idname = "onigiri.load_joint_data"
    bl_label = "Load Joint Data"

    filter_glob : bpy.props.StringProperty(
        default='*.jd',
        options={'HIDDEN'}
    )

    def execute(self, context):
        jd = joint_data

        path = self.properties.filepath

        try:
            namespace = {}
            exec(open(path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("something goofy happened, can't load joint data")
            print(traceback.format_exc())
            return {'FINISHED'}

        jd.joint_data.clear()
        jd.joint_data.update(namespace['joint_data'])

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriSetJointData(bpy.types.Operator):
    """
    These buttons send specific data to an operator that will alter the internal
    data that gets exported as .anim file format specifically for Second Life.
    """
    bl_idname = "onigiri.set_joint_data"
    bl_label = "set joint data"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) != 1:
            return False
        bjd = bpy.context.window_manager.bb_joint_data
        if bjd.joint_locked == True:
            return False

        return True

    def execute(self, context):

        dat = bpy.context.window_manager.bb_joint_data
        jd = joint_data
        
        ad = axis_defs

        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name

        if bone not in jd.joint_data:
            print("Bone not present in data set", bone)
            popup("Bone not present in data set", "Error", "ERROR")
            return {'FINISHED'}

        src_key = ad.axis_defs[self.action]['key']
        src_axis = ad.axis_defs[self.action]['axis']

        jd.joint_data[bone][src_key] = src_axis

        print("action:", self.action)

        return {'FINISHED'}

class OnigiriCopyJointData(bpy.types.Operator):
    """
    This sets a flag for this bone to get its data from another bone indicated
    in the text field.  The existing data will not be altered so you can test
    it freely.
    """

    bl_idname = "onigiri.copy_joint_data"
    bl_label = "copy joint data"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) != 1:
            return False
        bjd = bpy.context.window_manager.bb_joint_data
        if bjd.joint_locked == True:
            return False

        return True

    def execute(self, context):
        
        jd = joint_data
        bjd = bpy.context.window_manager.bb_joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name
        sbone = bjd.copy_joint_data_name

        if self.action == "clear":
            for b in jd.joint_data:
                if jd.joint_data[b].get('copy') != "":
                    del jd.joint_data[b]['copy']
            
            bjd.copy_joint_data_name = ""
            return {'FINISHED'}

        if sbone.strip() == "":
            print("Nothing to process")
            return {'FINISHED'}

        if sbone not in obj[arm].pose.bones:
            print("source bone not present in armature", bone)
            popup("Source bone missing from armature", "Error", "ERROR")
            return {'FINISHED'}
        
        if sbone not in jd.joint_data:
            print("Source bone not present in armature", bone)
            popup("Source bone not present in armature", "Error", "ERROR")
            return {'FINISHED'}
        
        if bone not in jd.joint_data:
            print("Target bone not present in data set", bone)
            popup("Target bone not present in data set", "Error", "ERROR")
            return {'FINISHED'}

        if self.action == "remove":
            print("attempting to remove copy joint data for bone:", bone)
            if jd.joint_data[bone].get('copy') != "":
                del jd.joint_data[bone]['copy']
                bjd.copy_joint_data_name = ""
        elif self.action == "add":
            
            if sbone == bone:
                print("source and targt are the same:", sbone, bone)
                popup("Source and target bone are the same", "Error", "ERROR")
                return {'FINISHED'}

            print("adding copy joint data for bone", bone, "with source", sbone)
            jd.joint_data[bone]['copy'] = sbone
            bjd.copy_joint_data_name = sbone

        return {'FINISHED'}

class OnigiriCopyJointBuffer(bpy.types.Operator):
    """
    Copy a joint's properties into the buffer for later use / paste.
    """

    bl_idname = "onigiri.copy_joint_buffer"
    bl_label = "copy joint properties"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) != 1:
            return False
        
        return True

    def execute(self, context):
        
        jd = joint_data
        bjd = bpy.context.window_manager.bb_joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name

        if bone not in jd.joint_data:
            print("incompatible bone")
            popup("No data for this bone, wrong rig?", "Error", "ERROR")
            return {'FINISHED'}

        jd.copy_buffer[bone] = copy.deepcopy(jd.joint_data[bone])

        return {'FINISHED'}

class OnigiriPasteJointBuffer(bpy.types.Operator):
    """
    Paste the date from this slot into the selected bone.
    """

    bl_idname = "onigiri.paste_joint_buffer"
    bl_label = "paste joint properties"

    bone : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) != 1:
            return False
        bjd = bpy.context.window_manager.bb_joint_data
        if bjd.joint_locked == True:
            return False

        return True

    def execute(self, context):
        
        jd = joint_data
        bjd = bpy.context.window_manager.bb_joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name
        print("got bone:", self.bone)

        if self.bone not in jd.joint_data:
            print("incompatible bone")
            popup("No data slot exists for this bone.", "Error", "ERROR")
            return {'FINISHED'}

        jd.joint_data[bone] = copy.deepcopy(jd.copy_buffer[self.bone])
        
        joint_properties_handler(None)

        return {'FINISHED'}

class OnigiriRemoveJointBuffer(bpy.types.Operator):
    """
    Remove this data from the buffer
    """

    bl_idname = "onigiri.remove_joint_buffer"
    bl_label = "remove joint properties data"

    bone : bpy.props.StringProperty(default="")

    def execute(self, context):
        
        jd = joint_data
        bjd = bpy.context.window_manager.bb_joint_data
        obj = bpy.data.objects
        arm = bpy.context.selected_objects[0].name
        bone = bpy.context.selected_pose_bones[0].name

        del jd.copy_buffer[self.bone]

        return {'FINISHED'}

class OnigiriAnimPropertiesAdvanced(bpy.types.PropertyGroup):

    matrix_converter_enabled : bpy.props.BoolProperty(
        description =            "THIS IS A SERIOUS WARNING!\n\n"            "It's unlikely you'll find a use for this.  It's for debugging.  The animated bones will export with "            "the chosen axis conversion below. Disable this option if you don't know what it is.  It will override your "            "bone orientation on .anim exported animations if it is enabled.",
        default=False
        )

    ac_from_forward_axis : bpy.props.StringProperty(default="X")
    ac_from_up_axis : bpy.props.StringProperty(default="X")
    ac_to_forward_axis : bpy.props.StringProperty(default="X")
    ac_to_up_axis : bpy.props.StringProperty(default="X")

    disable_axis_conversion : bpy.props.BoolProperty(
        description =
            "Disable the application of axis conversion to the exported animation (.anim only).\n\n"            "From Blender to Second Life the bone orientation is wrong.  The BB axis converter fixes this.  "            "When testing, to see how things are really working in the background, disable the application of "            "this conversion process.  This will not be useful to the average user.  It will, however, give some "            "clue as to why your converted animation may not be working.",
        default = False
        )
    disable_joint_offsets : bpy.props.BoolProperty(
        description =            "This works for .anim (native animation export) only.\n\n"
            "NOTE: This has nothing to do with the (Avastar's) reference to (joint offsets) at all!  "            "Additionally it has nothing to do with (include joint positions) for mesh upload.\n\n"            "This is for visually testing changes in your SL animation and poses.  This disables the required joint offset "            "that you probably didn't even know existed, until now.  This gives you a clean view of what's going on with your "            "poses and animations without the location of the joint being adjusted before the fact.",
        default = False
        )

class OnigiriAnimAxisConvert(bpy.types.Operator):
    """For each axis chose a conversion"""

    bl_idname = "onigiri.anim_convert_axis"
    bl_label = "convert axis"

    axis : bpy.props.StringProperty(default="X")

    def execute(self, context):
        ac = bpy.context.scene.bb_anim_advanced
        
        if self.axis == 'from_forward_pos_x':
            ac.ac_from_forward_axis = "X"
        if self.axis == 'from_forward_pos_y':
            ac.ac_from_forward_axis = "Y"
        if self.axis == 'from_forward_pos_z':
            ac.ac_from_forward_axis = "Z"
        if self.axis == 'from_forward_neg_x':
            ac.ac_from_forward_axis = "-X"
        if self.axis == 'from_forward_neg_y':
            ac.ac_from_forward_axis = "-Y"
        if self.axis == 'from_forward_neg_z':
            ac.ac_from_forward_axis = "-Z"
        
        if self.axis == 'from_up_pos_x':
            ac.ac_from_up_axis = "X"
        if self.axis == 'from_up_pos_y':
            ac.ac_from_up_axis = "Y"
        if self.axis == 'from_up_pos_z':
            ac.ac_from_up_axis = "Z"
        if self.axis == 'from_up_neg_x':
            ac.ac_from_up_axis = "-X"
        if self.axis == 'from_up_neg_y':
            ac.ac_from_up_axis = "-Y"
        if self.axis == 'from_up_neg_z':
            ac.ac_from_up_axis = "-Z"
        
        if self.axis == 'to_forward_pos_x':
            ac.ac_to_forward_axis = "X"
        if self.axis == 'to_forward_pos_y':
            ac.ac_to_forward_axis = "Y"
        if self.axis == 'to_forward_pos_z':
            ac.ac_to_forward_axis = "Z"
        if self.axis == 'to_forward_neg_x':
            ac.ac_to_forward_axis = "-X"
        if self.axis == 'to_forward_neg_y':
            ac.ac_to_forward_axis = "-Y"
        if self.axis == 'to_forward_neg_z':
            ac.ac_to_forward_axis = "-Z"
       
        if self.axis == 'to_up_pos_x':
            ac.ac_to_up_axis = "X"
        if self.axis == 'to_up_pos_y':
            ac.ac_to_up_axis = "Y"
        if self.axis == 'to_up_pos_z':
            ac.ac_to_up_axis = "Z"
        if self.axis == 'to_up_neg_x':
            ac.ac_to_up_axis = "-X"
        if self.axis == 'to_up_neg_y':
            ac.ac_to_up_axis = "-Y"
        if self.axis == 'to_up_neg_z':
            ac.ac_to_up_axis = "-Z"

        return {'FINISHED'}

class OnigiriSelectDifficultBones(bpy.types.Operator):
    """Select bones that are difficult to access"""

    bl_idname = "onigiri.select_bone"
    bl_label = "select difficult bone"

    bone : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.active_object == None:
            return False
        o = bpy.context.active_object
        if o.type == 'ARMATURE':
            return True
        return False

    def execute(self, context):
        
        obj = bpy.data.objects
        
        armObj = bpy.context.active_object
        if self.bone not in armObj.data.bones:
            print("Missing bone, wrong rig?")
            popup("Missing bone", "Info", "INFO")
            return {'FINISHED'}

        armObj.data.bones.active = armObj.pose.bones[self.bone].bone

        if bpy.context.mode == 'EDIT_ARMATURE':
            for b in armObj.data.edit_bones:
                b.select = False
                b.select_head = False
                b.select_tail = False
            armObj.data.edit_bones[self.bone].select = True
            armObj.data.edit_bones[self.bone].select_head = True
            armObj.data.edit_bones[self.bone].select_tail = True

        elif bpy.context.mode == 'POSE':
            for b in armObj.data.bones:
                b.select = False
            armObj.data.bones[self.bone].select = True
        else:
            bpy.ops.object.mode_set(mode='POSE')
            for b in armObj.data.bones:
                b.select = False
            armObj.data.bones[self.bone].select = True

        return {'FINISHED'}

class OnigiriSaveBoneMatrices(bpy.types.Operator, ExportHelper):
    """Save bone matrices from selected armature to a file for later use."""

    bl_idname = "onigiri.save_bone_matrices"
    bl_label = "Save Matrices"

    filename_ext = ".mtx"

    filter_glob : bpy.props.StringProperty(
        default='*.mtx',
        options={'HIDDEN'}
        )

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def execute(self, context):
        path = self.properties.filepath
        obj = bpy.data.objects

        armObj = bpy.context.selected_objects[0]
        mats = store_bone_matrices(armature=armObj.name)

        output = open(path, 'w', encoding='UTF8')
        output.write(mats)
        output.close()

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriLoadBoneOrientation(bpy.types.Operator, ImportHelper):
    """This will load the stored matrices and apply the bone orientation to the selected armature."""

    bl_idname = "onigiri.load_bone_orientation"
    bl_label = "Load Orientation"

    filename_ext = ".mtx"

    filter_glob : bpy.props.StringProperty(
        default='*.mtx',
        options={'HIDDEN'}
        )

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def execute(self, context):
        path = self.properties.filepath
        obj = bpy.data.objects

        armObj = bpy.context.selected_objects[0]

        bone_mats = {}
        try:
            namespace = {}
            exec(open(path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("something goofy happened, can't load matrices")
            print(traceback.format_exc())
            return {'FINISHED'}

        bone_mats.update(namespace['bone_matrices'])

        bpy.context.view_layer.objects.active = armObj
        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.armature.select_all(action='SELECT')

        world_to_target_matrix = armObj.matrix_world.inverted().to_3x3()

        for b in armObj.data.edit_bones:
            if b.name not in bone_mats:
                continue
            align_bone_x_axis( b, world_to_target_matrix @ mathutils.Vector(bone_mats[b.name]) )

        bpy.ops.object.mode_set(mode='OBJECT')

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriMatchBoneOrientation(bpy.types.Operator):
    """This will match bone orientation from a source rig to a target.  The target is the
active rig and is selected last.  There is no feedback, it works or it doesn't.
The bone names must match.  Only matching bone names will be altered."""

    bl_idname = "onigiri.match_bone_orientation"
    bl_label = "Match Bone Orientation"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) > 2:
            return False
        if len(bpy.context.selected_objects) == 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            if o.type != 'ARMATURE':
                return False
        if bpy.context.active_object == None:
            return False
        return True

    def execute(self,context):
        for o in bpy.context.selected_objects:
            if o == bpy.context.active_object:
                target = o.name
            else:
                source = o.name
        match_bone_orientation(source=source, target=target)

        txt = "Bone orientation altered on: " + target
        popup(txt, "Info", "INFO")

        bpy.ops.object.mode_set(mode='OBJECT')

        return {'FINISHED'}

class OnigiriBVHTools(bpy.types.Operator):
    """Various tools to manipulate and save BVH files including converting to XML format and back."""
    bl_idname = "onigiri.bvh_tools"
    bl_label = "BVH Tools"

    tool : bpy.props.StringProperty(default="")

    def execute(self,context):
        tool = self.tool
        armObj = bpy.context.selected_objects[0]
 
        return {'FINISHED'}

class OnigiriRigToXML(bpy.types.Operator, ExportHelper):
    """Export this rig and animation into XML format.  Observe the settings for SL/OS and Other."""

    bl_idname = "onigiri.rig_to_xml"
    bl_label = "Export Rig to XML"

    filename_ext = ".xml"
    filter_glob : bpy.props.StringProperty(
        default='*.xml',
        options={'HIDDEN'}
        )
    filename : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def execute(self,context):
        bba = bpy.context.scene.bb_anim
        bb = bpy.context.scene.onigiri
        anim_start_frame = bb.animation_start_frame
        anim_end_frame = bb.animation_end_frame
        armObj = bpy.context.selected_objects[0]

        if bba.bvh_type_other == True:
            print("Writing XML formatted BVH file for: Other platforms besides SL / OS")
            
            rigutils.set_angle(armature=armObj.name, angle=[-90,0,0])
            bpy.ops.object.transform_apply( rotation=True, location=False, scale=False )
            bvh_buf = bvh.save(
                context=context,
                filepath="",
                global_scale=1,
                frame_start=anim_start_frame,
                frame_end=anim_end_frame,
                rotate_mode='NATIVE',
                root_transform_only=False,
                buffer=True,
                )
            rigutils.set_angle(armature=armObj.name, angle=[90,0,0])
            bpy.ops.object.transform_apply( rotation=True, location=False, scale=False )
            tree = bvht.to_xml(buf=bvh_buf, return_type="string")
            try:
                bvh_file = open(self.properties.filepath, "w", newline="", encoding='UTF8')
                bvh_file.write(tree)
                bvh_file.close()
            except Exception as e:
                txt = traceback.format_exc()
                print("Caught error writing file")
                print(txt)

        elif bba.bvh_type_sl_os == True:
            print("Writing XML formatted BVH file for: SL/OS")
            print("skipping (fix_rig_orientation) for now")
            bpy.ops.object.transform_apply( rotation=True, location=False, scale=False )
            rigutils.set_angle(armature=armObj.name, angle=[-90,0,0])
            mbones_buf = bvh.save(
                context=context,
                filepath="",
                global_scale=39.3701,
                frame_start=anim_start_frame,
                frame_end=anim_end_frame,
                rotate_mode='NATIVE',
                root_transform_only=False,
                buffer=True,
                )
            rigutils.set_angle(armature=armObj.name, angle=[90,0,0])
            rigutils.set_angle(armature=armObj.name, angle=[0,0,90])
            vbones_buf = bvh.save(
                context=context,
                filepath="",
                global_scale=39.3701,
                frame_start=anim_start_frame,
                frame_end=anim_end_frame,
                rotate_mode='NATIVE',
                root_transform_only=False,
                buffer=True,
                )
            rigutils.set_angle(armature=armObj.name, angle=[0,0,-90])
            bvh_out = bvht.merge(
                vbones=vbones_buf,
                mbones=mbones_buf,
                swap_offsets=False,
                swap_endsites=False,
                swap_motion=True,
                return_type="string",
                buffer=True,
                )
            try:
                bvh_file = open(self.properties.filepath, "w", newline="", encoding='UTF8')
                bvh_file.write(bvh_out)
                bvh_file.close()
            except Exception as e:
                txt = traceback.format_exc()
                print("Caught error writing file")
                print(txt)

        print("Done writing xml")

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriBVHImport(bpy.types.Operator, ImportHelper):
    """Open a standard or SL/OS BVH or XML formatted BVH file"""

    bl_idname = "onigiri.import_bvh"
    bl_label = "Open a bvh or xml file"

    filter_glob : bpy.props.StringProperty(
        default='*.xml;*.bvh',
        options={'HIDDEN'}
        )
    filename : bpy.props.StringProperty(default="")

    def execute(self,context):
        bba = bpy.context.scene.bb_anim
        bb = bpy.context.scene.onigiri

        print("Load XML or BVH file...")

        try:
            
            f = open(self.filepath, "r", encoding='UTF8')
            buf = f.read()
            f.close()
        except Exception as e:
            bba.bvh_import_name = ""
            bba.bvh_import_path = ""

            txt = traceback.format_exc()
            print("Caught error reading file")
            print(txt)
            popup("Error reading file, see console for details", "Read Error", "ERROR")
            return {'FINISHED'}

        bba.bvh_import_name = self.filename
        bba.bvh_import_path = self.filepath 

        match = re.search(r'^\s*HIERARCHY', buf, re.DOTALL)
        if match:
            print("Detected BVH file")
            bba.bvh_identity = "bvh"
            bba.bvh_import_name = self.filename
            print("Done!")
            return {'FINISHED'}
        match = re.search(r'^.*?<ROOT>', buf, re.DOTALL)
        if match:
            print("Detected XML file")
            bba.bvh_identity = "xml"
            bba.bvh_import_name = self.filename
            print("Done!")
            return {'FINISHED'}
        
        popup("This does not appear to be either a BVH file or XML file")
        bba.bvh_identity = ""
        bba.bvh_import_name = ""
        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriBVHExportXML(bpy.types.Operator, ExportHelper):
    """Save the loaded BVH to an XML formatted file"""

    bl_idname = "onigiri.export_bvh_to_xml"
    bl_label = "Save BVH to XML"

    filename_ext = ".xml"

    filter_glob : bpy.props.StringProperty(
        default='*.xml',
        options={'HIDDEN'}
        )
    filename : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        
        bba = bpy.context.scene.bb_anim
        
        if bba.bvh_identity == "xml":
            return False
        elif bba.bvh_identity == "bvh":
            return True
        return False

    def execute(self,context):
        bba = bpy.context.scene.bb_anim
        bb = bpy.context.scene.onigiri

        bpy.app.timers.register(cleanup)

        print("Saving XML file:", self.filename)

        try:
            fsource = open(bba.bvh_import_path, "r", encoding='UTF8')
        except Exception as e:
            txt = traceback.format_exc()
            print("Caught error reading file")
            print(txt)
            popup("Error reading file, see console for details", "Read Error", "ERROR")
            return {'FINISHED'}

        try:
            ftarget = open(self.filepath, "w", encoding='UTF8')
        except Exception as e:
            txt = traceback.format_exc()
            print("Caught error reading file")
            print(txt)
            popup("Error writing file, see console for details", "Write Error", "ERROR")
            return {'FINISHED'}

        bvh_buf = fsource.read()
        fsource.close()

        bvh_buf = bvht.to_xml(buf=bvh_buf, return_type="string")
        ftarget.write(bvh_buf)
        ftarget.close()

        print("Done!")
        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriBVHExportBVH(bpy.types.Operator, ExportHelper):
    """Save the loaded XML to a BVH formatted file"""

    bl_idname = "onigiri.export_bvh_to_bvh"
    bl_label = "Save XML to BVH"

    filename_ext = ".bvh"

    filter_glob : bpy.props.StringProperty(
        default='*.bvh',
        options={'HIDDEN'}
        )
    filename : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        
        bba = bpy.context.scene.bb_anim
        
        if bba.bvh_identity == "bvh":
            return False
        elif bba.bvh_identity == "xml":
            return True
        return False

    def execute(self,context):
        bba = bpy.context.scene.bb_anim
        bb = bpy.context.scene.onigiri

        print("Saving BVH file:", self.filename)

        try:
            fsource = open(bba.bvh_import_path, "r", encoding='UTF8')
        except Exception as e:
            txt = traceback.format_exc()
            print("Caught error reading file")
            print(txt)
            popup("Error reading file, see console for details", "Read Error", "ERROR")
            return {'FINISHED'}

        try:
            ftarget = open(self.filepath, "w", encoding='UTF8')
        except Exception as e:
            txt = traceback.format_exc()
            print("Caught error reading file")
            print(txt)
            popup("Error writing file, see console for details", "Write Error", "ERROR")
            return {'FINISHED'}

        bvh_buf = fsource.read()
        fsource.close()

        bvh_buf = bvht.from_xml(buf=bvh_buf)
        ftarget.write(bvh_buf)
        ftarget.close()

        print("Done!")

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriFixBoneRoll(bpy.types.Operator):
    """There are specific properties for bones that are used for Second Life.  This is one of them and
this feature will fix the bone roll.  If you animated your rig while it was broken you should just start
over with a clean rig."""

    bl_idname = "onigiri.fix_bone_roll"
    bl_label = "Fix Bone Roll"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def execute(self,context):
        armObj = bpy.context.selected_objects[0]
        apply_sl_bone_roll(arm=armObj.name)

        bpy.ops.object.mode_set(mode='OBJECT')

        return {'FINISHED'}

class OnigiriFixDeformableBones(bpy.types.Operator):
    """Some rigs are really messed up.  The exporter tries not to mess with your
product too much but that means you're left with more decisions to make.  One of
those is how to fix broken devkit rigs.  Refresh the deform bones here"""

    bl_idname = "onigiri.fix_deformable"
    bl_label = "Fix Deformable Bones"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self,context):
        armObj = bpy.context.selected_objects[0]
        utils.activate(armObj)

        unknown = 0
        known = 0
        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in armObj.data.edit_bones:
            bone = boneObj.name
            if bone not in skel.avatar_skeleton:
                boneObj.use_deform = False
                unknown += 1
                continue
            if skel.avatar_skeleton[bone]['type'] == 'attachment':
                boneObj.use_deform = False
                known += 1
        print(known, "known bones were set to deformable")
        print(unknown, "unknown bones were set to non deformable")

        bpy.ops.object.mode_set(mode='OBJECT')

        return {'FINISHED'}

class OnigiriFixHierarchy(bpy.types.Operator):
    """This only works for SL rigs.  This is useful for reparing devkits.  It
will attempt reparent bones that require it"""

    bl_idname = "onigiri.fix_hierarchy"
    bl_label = "Fix Hierarchy"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self,context):
        armObj = bpy.context.selected_objects[0]
        utils.activate(armObj)

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in armObj.data.edit_bones:
            bone = boneObj.name
            if bone not in skel.avatar_skeleton:
                print("Skipping unknown bone:", bone)
                continue
            parent = skel.avatar_skeleton[bone]['parent']
            if parent != "":
                pbone = "" 
                if boneObj.parent:
                    pBone = boneObj.parent
                    pbone = boneObj.parent.name
                if pbone != parent:
                    if parent not in armObj.data.bones:
                        print("parent broken for bone", bone, "but parent", parent, "doesn't exist")
                        continue
                    print("repaired", bone, "with parent", parent, "- old parent was", pbone)
                    boneObj.parent = armObj.data.edit_bones[parent]

        print("Fix Hierarchy finished")

        bpy.ops.object.mode_set(mode='OBJECT')

        return {'FINISHED'}

class OnigiriRefreshBlenderFile(bpy.types.Operator):
    """This is useful if your Blender keeps crashing or you think there are corrupt
data.  Save your work before using this and then save after using this.  You'll be
given a new blend file with all of your items in it"""

    bl_idname = "onigiri.refresh_blender"
    bl_label = "Refresh the loaded blender file"

    def execute(self,context):
        import subprocess

        print("------------------------------------------------")
        print("presets_path:", presets_path)
        print("------------------------------------------------")

        blender_executable = bpy.app.binary_path
        script = script_dir + presets_path + "refresh_blender.py"
        path = script_dir + presets_path
        temp_dir = tempfile.gettempdir()

        temp_blend = temp_dir + "/onigiri_blend.blend"

        arguments = {}
        arguments['path'] = bpy.path.abspath('//') 
        arguments['file'] = bpy.path.basename(bpy.context.blend_data.filepath) 
        arguments['scenes'] = [a.name for a in bpy.data.scenes]
        arguments['status'] = False 
        arguments['stage'] = 1 

        file_match = "match"
        
        count = 0
        file_base = arguments['file'].rsplit(".blend")[0]
        while file_match == "match":
            file_name = file_base + "_" + get_unique_name_short() + ".blend"
            file_path = arguments['path'] + file_name
            if os.path.exists(file_path):
                count += 1
                if count > 5:
                    print("File name generation failed")
                    popup("File name generation failed, try again", "Info", "INFO")
                    return {'FINISHED'}
                continue
            file_match = "no match"

        arguments['file_new'] = file_path

        formatted_text = "arguments = " + str(arguments)
        args_path = temp_dir + "/onigiri_args.py"

        try:
            sf = open(args_path, "w", encoding='UTF8')
            sf.write(formatted_text)
            sf.close()
        except Exception as e:
            txt = traceback.format_exc()
            print(txt)
            print("Unable to write args for state 1, aborting")
            return {'FINISHED'}

        bpy.ops.wm.save_as_mainfile(filepath=temp_blend, copy=True)

        p = subprocess.Popen([
            blender_executable,
            '--background',
            '--factory-startup',
            '--python', script
            ],
            stdout=subprocess.PIPE,
            universal_newlines=True)

        result_out = ""
        start_time = time.time()
        while (p.poll() is None):
          result_out += p.stdout.read(8192)
          time.sleep(1)
          if (time.time() - start_time) > 5:
            print("Timeout")
            break
        print(result_out)

        print("Process appears to have exited")

        arguments = {}
        try:
            namespace = {}
            exec(open(args_path, 'r', encoding='UTF8').read(), namespace)
            arguments.update(namespace['arguments'])
        except Exception as e:
            print(traceback.format_exc())
            print("The args file could not be reopened by __init__, please report this bug")
            popup("Fatal error, see console", "Error", "ERROR")
            return {'FINISHED'}

        if arguments['status'] == False:
            print("The return value from the process is False, please report this bug")
            popup("Fatal error returned by process, see console", "Error", "ERROR")
            return {'FINISHED'}

        arguments['stage'] = 1 
        arguments['status'] = False 

        try:
            sf = open(args_path, "w", encoding='UTF8')
            sf.write(formatted_text)
            sf.close()
        except Exception as e:
            txt = traceback.format_exc()
            print("report from mian:", txt)
            print("Unable to write args for stage 2, aborting")
            return {'FINISHED'}

        print("Starting stage 2")
        pd = subprocess.Popen([
            blender_executable,
            '--python', script],
            close_fds=True)
        print("Process spawned, operator exits")

        return {'FINISHED'}

class OnigiriAnimProperties(bpy.types.PropertyGroup):

    anim_misc_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Enable some misc options"            "\n\n"            "Interpolation / Remove animation",
        default = False,
        )

    bake_animation : bpy.props.BoolProperty(
        description =            "Bake Animation on Export"            "\n\n"            "Baking an animation requires an influence that is not part of the rig, but an animated controller of sorts.  "            "This option is enabled by default when your rig is part of a retargeted set.  Your animation must be baked before "            "export if it has been retargeted to another rig, this is the best way to approach it.  There used to be another way "            "but it was inconsistent and flawed so this is what you really want, even though it takes a bit longer.  You do not need "            "this nor benefit from it if your rig is animated directly.  If you are retargeting an animation you NEED this.",
        default = True,
        )
    keep_baked_animation : bpy.props.BoolProperty(
        description =        "Keep the baked animation on your rig after calculating"        "\n\n"        "You should probably do this and prepare for it, which is to say ... your retarget set will be (reset) after the bake so that "        "your rig is separated from that retargeting system, for solo use.  You can then adjust keys as you see fit.",
        default= False,
        )

    bake_frame_step : bpy.props.IntProperty(
        name = "Sample Frame Steps",
        description =            "\n"            "This is effectively a sampling rate, with a full timeline of baked keys 10 seems great, and fast.  "            "The higher the number the less accurate the capture will be but there is a point where it's just right.  "            "Lower numbers will take longer to bake and there is some exponential effect on time vs sample so keep that in mind.",
        min = 1,
        max = 120,
        default = 5,
        )

    bake_animation_label : bpy.props.StringProperty(default = "Bake Animation Now!")
    bake_animation_alert : bpy.props.BoolProperty(default = False)

    anim_menu_enabled : bpy.props.BoolProperty(
        name = "Enable .anim export menu",
        description =            "This is a fully featured animation exporter specifically for Second Life.",
        default = False,
        )
    anim_unfold_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "There's a massive amount of options behind this menu and that's why it's hidden.  You should be "            "fine with the simple two buttons but if you need per joint priorities, emotes, interpolations, hand poses"            "animation cleanup options and some other things then here they are.",
        default = False,
        )

    anim_base_priority : bpy.props.IntProperty(
        description =            "Base priority.  This is used overall.  If you have a bone priority enabled then the priority of that "            "bone will be used instead of this.  If the bone doesn't have a priority set already then the base is used "            "as a start.  Use the (Joint priority options) to enable a bone priority and to set its priority number.",
        min = -1,
        max = 6,
        default = 2,
        )
    anim_joint_priority : bpy.props.IntProperty(
        description =            "Individual joint priority, overrides the base priority.  This has the same  priority range as "            "base priority but if you enable this then it will be used instead.",
        min = -1,
        max = 6,
        default = 2,
        )

    anim_joint_priority_enabled : bpy.props.BoolProperty(
        name = "joint priority enabled",
        description =            "This will enable the joint override priority for the selected pose bones.  The original priority will "            "be preserved when disabling or enabling this.  In order to set a new priority for the selected pose bones you'll need "            "to make sure the priority number is correct for your needs and then you'll need to click (apply priority).",
        default = False,
        )
    anim_joint_priority_disabled : bpy.props.BoolProperty(
        name = "joint priority disabled",
        description =            "This will disable the joint override priority for the selected pose bones.  The original priority will "            "be preserved when disabling or enabling this.  In order to set a new priority for the selected pose bones you'll need "            "to make sure the priority number is correct for your needs and then you'll need to click (apply priority).",
        default = False,
        )
    
    native_features_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description = "Show the (per joint) priority control options",
        default = False
        )

    anim_selected_pose_bones : bpy.props.IntProperty(default=0)

    anim_joint_priority_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Show the joint priority features",
        default = False
        )

    anim_joint_priority_view_enabled : bpy.props.BoolProperty(
        name = "joint priority view enabled",
        description =            "This feature can be confusing and cluttered that's why it's hidden by default.  Enabling this will show a list of "            "all selected pose bones along with their priority and if override is enabled on that joint.  This only works with "            "the native (.anim) export format.",
        default = False,
        )

    anim_expression_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Expression Options",
        default = False,
        )

    anim_hand_pose_enabled : bpy.props.BoolProperty(
        name = "hand pose enabled",
        description =            "This button must be pressed in for the feature to work"            "\n\n"            "A hand pose that becomes active during your animation.  This is pretty much obsoleted by Bento.  "            "This only works with the classic avatar, not mesh, because it's done with morphs, not bones.",
        default = False,
        )
    anim_hand_poses_menu = [
        ('0',"Spread",'',0),
        ('1',"Relaxed",'',1),
        ('2',"Point",'',2),
        ('3',"Fist",'',3),
        ('4',"Relaxed Left",'',4),
        ('5',"Point Left",'',5),
        ('6',"Fist Left",'',6),
        ('7',"Relaxed Right",'',7),
        ('8',"Point Right",'',8),
        ('9',"Fist Right",'',9),
        ('10',"Salute Right",'',10),
        ('11',"Typing",'',11),
        ('12',"Peace Right",'',12),
        ('13',"Palm Right",'',13),
        ]
    anim_hand_pose : bpy.props.EnumProperty(
        name = "Optional Hand Pose",
        description = "Optional hand pose during animation.",
        items = anim_hand_poses_menu,
        )
    anim_loop : bpy.props.BoolProperty(
        name = "",
        description = 
            "Enable looping"            "\n\n"            "This has to be enabled for loops to work.  Enable this then change start and end frame or click the cog for "            "fractional sections instead.",
        default = False,
        )
    anim_details : bpy.props.BoolProperty(
        name = "",
        description =            "Append animation details to filename"            "\n\n"            "This gives you a convenient way to store the animation details in order to make scripting your animations  "            "a lot easier.  It's also nice to have this when you give away, or sell, your animations since the receiver "            "will know exactly how to script for it and you can add these details as part of the product value."
            "\n\n"            "The layout is as follows, starting and ending with the delimiter # and separated by spaces.\n\n"            "Total animation time (T)\n"            "Frames per second (F)\n"            "Loop enabled (L - 0 or 1)\n"            "Loop in point, fractional seconds (I)\n"            "Loop out point, fractional seconds (O)\n"            "Ease in duration, fractional seconds (E)\n"            "Ease out duration, fraction seconds (Z)\n"
            "\n"            "Your base filename cannot be more than 63 characters total if you need the details to survive upload, the (.anim) "            "part doesn't count.  This leaves you with 17 characters for a file identifier.  Floats are truncated to 2 decimals",
        default = False,
        )
    anim_details_time : bpy.props.BoolProperty(
        name = "",
        description =            "Optional detail - Total Time, indicated by a T",
        default = True,
        )
    anim_details_fps : bpy.props.BoolProperty(
        name = "",
        description =            "Optional detail - Frames Per Second, indicated by an F",
        default = True,
        )
    anim_details_loop_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Optional detail - Loop Enabled (0/1), indicated by an L",
        default = True,
        )
    anim_details_loop_in : bpy.props.BoolProperty(
        name = "",
        description =            "Optional detail - Loop In (fractional seconds), indicated by an I",
        default = True,
        )
    anim_details_loop_out : bpy.props.BoolProperty(
        name = "",
        description =            "Optional detail - Loop Out (fractional seconds), indicated by an O",
        default = True,
        )
    anim_details_ease_in : bpy.props.BoolProperty(
        name = "",
        description =            "Optional detail - Ease In (fractional seconds), indicated by an E",
        default = True,
        )
    anim_details_ease_out : bpy.props.BoolProperty(
        name = "",
        description =            "Optional detail - Ease Out (fractional seconds), indicated by a Z",
        default = True,
        )
    anim_details_priority : bpy.props.BoolProperty(
        name = "",
        description =            "Optional detail - Base Priority (0 to 6), indicated by a P",
        default = False,
        )

    def update_anim_loop_advanced(self, context):
        
        anim = bpy.context.scene.bb_anim
        bb = bpy.context.scene.onigiri
        if anim.anim_loop_advanced == True:
 
            start_dif = anim.anim_loop_in_frame - bb.animation_start_frame + 1
            print("start_dif:", start_dif)
            end_dif = bb.animation_end_frame - anim.anim_loop_out_frame
            print("end_dif:", end_dif)
            total_frames = bb.animation_end_frame - bb.animation_start_frame + 1
            time_per_frame = bb.animation_time / total_frames
            print("time_per_frame:", time_per_frame)
            anim.loop_in_time = start_dif * time_per_frame
            anim.loop_out_time = end_dif * time_per_frame

        else:

            bb_settings['terminate'] = True
            anim.anim_loop_in_frame = int(round(anim.anim_loop_in_time))
            bb_settings['terminate'] = True
            anim.anim_loop_out_frame = int(round(anim.anim_loop_out_time))

    def update_anim_loop_in_frame(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        anim = bpy.context.scene.bb_anim
        
        bb_settings['terminate'] = True
        
        anim.anim_loop_in_time = float(anim.anim_loop_in_frame)
    def update_anim_loop_out_frame(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        anim = bpy.context.scene.bb_anim
        
        bb_settings['terminate'] = True
        anim.anim_loop_out_time = float(anim.anim_loop_out_frame)
    def update_anim_loop_in_time(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        anim = bpy.context.scene.bb_anim
        
        bb_settings['terminate'] = True
        anim.anim_loop_in_frame = int(round(anim.anim_loop_in_time))
    def update_anim_loop_out_time(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        anim = bpy.context.scene.bb_anim
        
        bb_settings['terminate'] = True
        anim.anim_loop_out_frame = int(round(anim.anim_loop_out_time))

    anim_loop_advanced : bpy.props.BoolProperty(
        name = "advanced loop",
        description = "Enable this for control over fractional time for loop in and out",
        default = 0,

        )
    anim_loop_in_frame : bpy.props.IntProperty(
        name = "loop in frame",
        description = "Fame to loop from",
        default = 0,

        )
    anim_loop_out_frame : bpy.props.IntProperty(
        name = "loop out frame",
        description = "Fame to loop to",
        default = 0,

        )
    anim_loop_in_time : bpy.props.FloatProperty(
        name = "loop in float",
        description = "Loop start time",
        default = 0,

        )
    anim_loop_out_time : bpy.props.FloatProperty(
        name = "loop out float",
        description = "Loop end time",
        default = 0,

        )

    anim_loop_in_point : bpy.props.FloatProperty(description="-- internal", default = 0,)
    anim_loop_out_point : bpy.props.FloatProperty(description="-- internal", default = 0,)

    anim_ease_in_duration : bpy.props.FloatProperty(
        name = "ease in",
        description = "Smoothness of the transition into the animation",
        default = 0.82,
        )
    anim_ease_out_duration : bpy.props.FloatProperty(
        name = "Smoothness of the transition out of the animation",
        description = "",
        default = 0.82,
        )
    anim_base_name : bpy.props.StringProperty(
        name = "base name",
        description = "Base name, helpful with bulk exports.",
        default = "bb_animation",
        )
    anim_emote_menu_enabled : bpy.props.BoolProperty (
        description =            "This will expose a list of emotes that are available for use with your animation.  The list is pretty extensive "            "so it's hidden behind this menu.  Expand the menu, click one of the emotes or (Clear) and you can close the menu "            "if you want and it'll still export with your anim"            "\n\n"            "WARNING: Second Life internal animations, when played this way, are seriously broken.  If you include a looped "            "animation you'll need to stop it in order for it to stop, it will not stop from the play interface you initiated "            "from inventory.  If you really want to use an internal animation it's best to do so directly from script rather "            "than upload it through this interface.  This feature is provided to you because it is an available option provided "            "by Second Life",
        default = False,
        )
    anim_emote_name : bpy.props.StringProperty(
        name = "in-world animation name",
        description =            "This is a (named) second life emote you can play when your animation plays.  Often times you won't want to embed this "            "into your animation but there are some uses for it.  For instance, you can type (clap), without the parentheses, into the "            "text field provided and, when this exported animation plays, so will the (clap) emote.  It's good for combined gestures "            "when space is limited.  But mostly I put it here because it's an available feature in the .anim file format for SL",
        default = "",
        )
    
    anim_inherit : bpy.props.BoolProperty(
        name = "anim inherit",
        description =            "This will inherit the motion produced by constraints, drivers and IK chains.  Essentially the rig has no animation "            "on it but the items that the bones are attached to are animated and this feature will grab that motion and export it "            "just as you see when the non-animated rig is moving.",
        default = False,
        )
    anim_preserve_interpolation : bpy.props.BoolProperty(
        name = "",
        description =            "Preserve Interpolations"            "\n\n"            "This will attempt to preserve the interpolation method provided by the key modes in Blender.  For the average "            "animation explorer, doing simple tasks, you probably won't care about this and Onigiri provides what is "            "expected.  But honestly the Onigiri interpolation method is not accurate, just typical.  If you need more "            "control over your motion, for instance bones snapping from one pose to another instantly by frame, you'll want "            "to enable this feature.  This will increase your file size significantly.  If you want a similar effect you can turn "            "this off and key start and stop frames for motion control but this feature can be used for quick prototyping.",
        default = False,
        )
    anim_record_motion : bpy.props.BoolProperty(
        name = "",
        description =            "Record Motion"            "\n\n"            "Yes, we want to record motion, but Onigiri's old way of doing that is to detect if a bone moved, per frame, and flag "            "that as a key to save.  The new way is to only flag actual keys.  If you're using the old way and want to preserve zero "            "motion keys then enable the feature (Preserve Interpolations).  If you are using the new method then expand the "            "(Native Extended Features), open the menu (Key Cleanup Options) and assign flags to bones or keys from there."            "\n\n"            "This is the usual old default for Onigiri exported anim type animations.  It has been switched to a secondary option "            "because of a feature request, the result of which will reduce your animation file size significantly.  However, if you "            "need Onigiri's old, and highly accurate, behavior then enable this.  Franky your animations may not look different "            "to you at all but if you are using a small number of frames, low frames per second or attempting to implement Onigiri's "            "fine interpolation features then you may want this old behavior enabled.",
        default = False,
        )
    
    anim_create_reference : bpy.props.BoolProperty(
        name = "Export Reference Frame",
        description =            "This makes sure that your first frame is part of your animation in Second Life."            "\n\n"            "Second Life reads the first frame as your animation reset pose, where no bones are transform, even if they are. "            "This would commonly be referred to as the T-Pose but it doesn't have to be.  The safest thing to do is to leave this "            "feature on (enabled).  One reason to disable this is if you have a custom pose that is not in a typical T-Pose but you "            "want Second Life to think it is anyway.  There is a unique condition where this can also be used as a contributing part "            "in generating a deformer or even a special deformation mesh.  You can disable this and make your own reference frame.  Just "            "slide everything over by one key, duplicate the first key frame in your animation and place that as a start frame.",
        default = True,
        )

    anim_interpolation_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "View interpolation options",
        default = False
        )
    anim_interpolate_bone : bpy.props.BoolProperty(
        name = "",
        description =            "Enable this if you want the entire frame range on the selected bone\n"            "to be set to the chosen interpolation method",
        default = False
        )

    anim_interpolation_x : bpy.props.BoolProperty(
        name = "",
        description =            "Interpolation methods can be changed on a per axis basis.  This is how\n"
            "you do it.  Choose 1 or more axis and then click a method.",
        default = False
        )
    anim_interpolation_y : bpy.props.BoolProperty(
        name = "",
        description =            "Interpolation methods can be changed on a per axis basis.  This is how\n"
            "you do it.  Choose 1 or more axis and then click a method.",
        default = False
        )
    anim_interpolation_z : bpy.props.BoolProperty(
        name = "",
        description =            "Interpolation methods can be changed on a per axis basis.  This is how\n"
            "you do it.  Choose 1 or more axis and then click a method.",
        default = False
        )

    def update_export_sl_anim(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        anim = bpy.context.scene.bb_anim
        if anim.export_sl_anim == True:
            export_sl_anim_label = "Please Wait..."
            
            try:
                bpy.ops.onigiri.export_sl_anim()
            except:
                print("didn't work")
            bb_settings['terminate'] = True
            anim.export_sl_anim = False

        anim.export_sl_anim_label = "Export Animation"

    export_sl_anim : bpy.props.BoolProperty(
        name = "Export .anim format",
        description =            "This is the internal animation format Second Life uses.  This is the recommended export.",
        default = False,
        update = update_export_sl_anim
        )

    export_sl_anim_label : bpy.props.StringProperty(default = "Export Animation")
    export_sl_anim_alert : bpy.props.BoolProperty(default = False)
    export_sl_anim_label_short : bpy.props.StringProperty(default = "Export Animation")
    export_sl_anim_old_alert : bpy.props.BoolProperty(default = False)
    export_sl_anim_old_label : bpy.props.StringProperty(default = "Use old exporter")
    export_sl_anim_old_label_short : bpy.props.StringProperty(default = "Used old exporter")

    def update_anim_show_actions(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        
        anim = bpy.context.scene.bb_anim
        obj = bpy.data.objects
        if anim.anim_show_actions == True:
            
            bpy.app.handlers.depsgraph_update_post.append(anim_sanity_check)
            print("anim_sanity_check handler enabled")
            if anim.get('actions') != None:
                actions = anim['actions'].to_dict()
                for a in actions:
                    if a not in bpy.data.actions:
                        del anim['actions'][a]
                
                for action in bpy.data.actions:
                    if action.name not in anim['actions']:
                        anim['actions'][action.name] = False 
            else:
                anim['actions'] = {}
                for action in bpy.data.actions:
                    anim['actions'][action.name] = False

        else:
            try:
                bpy.app.handlers.depsgraph_update_post.remove(anim_sanity_check)
            except:
                print("anim_sanity_check was not available for removal")
            return

        return

    anim_show_actions : bpy.props.BoolProperty(
        name = "show actions",
        description = "Show all actions and choose which ones to export",
        default = False,
        update = update_anim_show_actions
        )

    anim_action_selected : bpy.props.BoolProperty(
        name = "action selected",
        description = "Enable this action for export",
        default = False,
        )
    anim_save_path : bpy.props.StringProperty(
        name = "save path",
        description = "-- internal",
        default = "",
        )

    def update_anim_linear(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_anim = bpy.context.scene.bb_anim
        if bb_anim.anim_linear == True:
            bb_anim["anim_high_fidelity"] = False
        else:
            bb_anim["anim_high_fidelity"] = True

    def update_anim_high_fidelity(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_anim = bpy.context.scene.bb_anim
        if bb_anim.anim_high_fidelity == True:
            bb_anim["anim_linear"] = False
        else:
            bb_anim["anim_linear"] = True

    def update_anim_deviation_detection(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_anim = bpy.context.scene.bb_anim
        if bb_anim.anim_deviation_detection == True:
            bpy.context.scene.bb_anim.property_unset("anim_linear")
            bpy.context.scene.bb_anim.property_unset("anim_high_fidelity")
        else:
            
            bpy.context.scene.bb_anim.property_unset("anim_deviation_detection")

    anim_linear : bpy.props.BoolProperty(
        name = "",
        description =            "Linear Motion Only"            "\n\n"            "The linear method is a base method that is really not an interpolation but a static rate of motion without a curve.  "            "This feature is provided for convenience, if you are making that type of motion, which is great for robotic types."            "\n\n"            "Second Life does not support true interpolation data.  The best we get is ease in/out of an animation.  However, "            "the calculations done by Onigiri allow you to have a similar motion from Blender to Second Life, or an exact one "            "if you use a baking mechanism like (High Fidelity).  With this option enabled no interpolation, or smooth transitions, "            "are calculated, though you can place these keys yourself if you so desire.  This type of motion can be artsy but also is "            "an option for expert animators that want to have complete control over the animation.",
        default = False,
        update = update_anim_linear
        )

    export_mapped_animation : bpy.props.BoolProperty(
        name = "",
        description =            "WARNING: This is not expected to work yet : Export Mapped Animation"            "\n\n"            "This is similar to the (Export Mapped Mesh) in that it converts bone names to their corresponding targets on export, allowing "            "you to you to export incompatible animations for use with Second Life.  If your rig is an Avastar rig then this feature "            "may be overridden by any Avastar switches you enable.  This feature is enabled by default because, when there is a mapped "            "rig, there's a map available for that rig and can be utilized to convert the names for use with the target",
        default = False
        )
    
    export_retargeted_animation : bpy.props.BoolProperty(
        name = "",
        description =            "Bulk export retargeted rig animation"            "\n\n"            "-- INTERNAL: This particular property should not show up in the UI, it is used as a directive only since retargeted singluarl "            "animations are already a thing and this property group section is for controlling how the base animaiton data is processed. "            "\n\n"            "If bulk exporting a custom incompatible rig that needs to be retargeted keep your set engaged in the retargeter and try this "            "feature out.  This should work smoothly.  This is enabled by default because a reatarget set can be detected.  However, if "            "you've left old retarget sets in the scene, that is to say you forgot to reset the stage, then this state may be falsly "            "detected and ruine your day.  You can disable this in that case but you really should clean up your scene",
        default = True,
        )

    anim_high_fidelity : bpy.props.BoolProperty(
        name = "",
        description =            "High Fidelity"            "\n\n"            "This is an animation bake.  Any and all motion, including IK, constraints and drivers, will be captured frame by frame."            "\n\n"            "Animation exports to Second Life are extrapolated from intent and not actually interpolated.  If the exporter knew exactly "            "what you wanted then the file size could be much smaller.  With that in mind there are some additional features you may "            "like to try when using (High Fidelity).  There's the option of grabbing just key data from controllers in order to use "            "for linear motion and this can also be smooth baked.  There's a proxy bake option that's helpful for debugging which, "            "when bake is set to linear, will capture just the key data from the source, the targets or both, and with the indicated "            "transforms only.  When using this type of animation export you can reduce the file size by resampling the keys using "            "(Resample) feature under the cleanup options",
       default = True,
        update = update_anim_high_fidelity
        )
    
    def update_anim_use_keys_smooth(self, context):
        bb_anim = bpy.context.scene.bb_anim
        if bb_anim.anim_use_keys_smooth == True:
            bb_anim['anim_use_keys_linear'] = False
        if bb_anim.anim_use_keys_smooth == False:
            bb_anim['anim_use_keys_linear'] = True
    def update_anim_use_keys_linear(self, context):
        bb_anim = bpy.context.scene.bb_anim
        if bb_anim.anim_use_keys_linear == True:
            bb_anim['anim_use_keys_smooth'] = False
        if bb_anim.anim_use_keys_linear == False:
            bb_anim['anim_use_keys_smooth'] = True

    anim_use_keys_smooth : bpy.props.BoolProperty(
        name = "",
        description =            "NOTE: This option is for (High Fidelity) and only works if you enable one or both (Use Source Keys / Use Target Keys)."            "\n\n"            "Smooth motion is what most will want, your bones will ease in and out of their motion.  Robotic type motion can be "            "achieved using (Linear) instead and the file size for linear is much smallter.",
        default = True,
        update = update_anim_use_keys_smooth
        )
    anim_use_keys_linear : bpy.props.BoolProperty(
        name = "",
        description =            "NOTE: This option is for (High Fidelity) and only works if you enable one or both (Use Source Keys / Use Target Keys)."            "\n\n"            "Linear motion is great for machines and robots, you can achieve a mix of both smooth and linear as long as your "            "animation sources move in that way, regarrdless of the type of export.  However, Onigiri does not add data to "            "your animation, it only determines where to place a key and if you choose (Linear) it will only place keys where "            "YOU have placed keys, from source or targets or both, depending on your choices.",
        default = False,
        update = update_anim_use_keys_linear
        )
    
    anim_use_source_keys : bpy.props.BoolProperty(
        name = "",
        description =            "Use keys from the source to determine animated bones and their transforms.  This can allow you to (freeze) bones even when "            "they are not animated and was the original reason for this feature.  Additionally you can export linear motion while "            "preserving the keys that you intended to export.  You can use the source rig for all of your keys, the target rigs for "            "all of your keys or both.",
        default = False,
        )
    anim_use_source_keys_rotation : bpy.props.BoolProperty(
        name = "",
        description =            "You have the option to use only rotation or location data, or both.",
        default = True,
        )
    anim_use_source_keys_location : bpy.props.BoolProperty(
        name = "",
        description =            "You have the option to bake use rotation or location data, or both.",
        default = True,
        )
    anim_use_target_keys : bpy.props.BoolProperty(
        name = "",
        description =            "Use keys from the target to determine animated bones and their transforms.  As with the source option you have the ability "            "to export motion based on the keys of your target rigs/controllers that are responsible for making your animation export "            "rig bones move and rotate.  This allows you to freeze bones even when they don't move.  While this is not exactly retargeting "            "it does have similar features where your animation rig (BB Rig) is being influenced by another object and that object's keys "            "can be written to the animation using this option.",
        default = False,
        )
    anim_use_target_keys_rotation : bpy.props.BoolProperty(
        name = "",
        description =            "You have the option to use only rotation or location data, or both.",
        default = True,
        )
    anim_use_target_keys_location : bpy.props.BoolProperty(
        name = "",
        description =            "You have the option to use only rotation or location data, or both.",
        default = False,
        )
    
    anim_deviation_detection : bpy.props.BoolProperty(
        name = "",
        description =            "This used to be Deviation, the term (Smooth Motion) makes more sense."            "\n\n"            "The intent of the deviation detection was to reduce file size and the trouble maintaining it wasn't worth the small "            "savings.  The current process is typical and uses your key framed animation to produce the desired, visually accurate, "            "result in Second Life.  Second Life doesn't have an interpolation method, only an ease factor for start and stop of "            "an animation, so we have to add some data to represent your animation accurately in Second Life.  To get an idea of how "            "your animation actually would look, without this extra data, change your animated bones to (linear interpolation) and turn "            "on (Linear) for the animation export option.  In Second Life your animation will contain only those keys that you set "            "here in Blender, and nothing else.  Without the additional data provided by the (Smooth Motion) export method your animation "            "would look exactly like that.",
        default = False, 

        )
    
    anim_deviation_rotation : bpy.props.FloatProperty(
        name = "",
        description =            "Rotation Deviation Tolerance in radians",
        min = 0.0,
        max = 10.0,
        precision = 4,
        default = 0.1000,
        )
    anim_deviation_location : bpy.props.FloatProperty(
        name = "",
        description =            "Location Deviation in fractional meters",
        min = 0.0,
        max = 0.1,
        precision = 4,
        default = 0.0010,
        )
    anim_exclude_from_cleaning : bpy.props.BoolProperty(
        name = "",
        description =            "Exclude From Cleaning"            "\n\n"            "During the process of generating keys, removing useless keys, determining interpolation methods and keys, many of the "            "existing keys in the time line will be removed and also some keys will simply never be placed into the time line since "            "the algorithm deemed it unnecessary.  However, with this feature enabled, and the flagging of various items such as "            "bones and/or keys, those flagged items will not be cleaned/removed and, if they simply don't exist, there will be a key "            "placed on the frame indicated or all keys on a bone will be preserved if a bone is flagged.  This is a complicated and "            "advanced topic that expert animators will appreciate.  The reason we need these features is because SL does not process "            "animations as you would expect and the controls that Onigiri gives you are designed to transfer expected behavior "            "into Second Life.  If you're using the (Hold) transform keys in the auto-key tools then those keys are flagged "            "automatically and will honor the setting of this feature, or dismiss it if it's not enabled.",
        default = True,
        )

    mark_tol_options : bpy.props.BoolProperty(
        name = "Expand key discard options",
        description =            "Expand these advanced options to test animation transport processing",
        default = False,
        )
    mark_tol : bpy.props.BoolProperty(
        name = "Clean keys by tolerance",
        description =            "From key to key there is a certain amount of jiggle, or wiggle room, that you typically won't see in your animation, "            "or maybe just isn't important.  You can choose the wiggle room using these fractional numbers, one for angles of rotation "            "and the other in fractional meters for location / translation.  Increasing these numbers discards more keys in order to make "            "room for longer animations, although you're better off using the animation splitter than reducing accuracy here."            "\n\n"            "Disabling this won't be useful to most people but can be helpful when testing the transfer process from export to "            "import in SL.  Keys are flagged as unusable by this tolerance feature and are not saved into the .anim file.  It's "            "useful to have this turned on by default because even the shortest animation may be too large for Second Life to accept, "            "a max of 250kb per file.",
        default = True,
        )
    
    mark_tol_rot : bpy.props.FloatProperty(
        name = "rotation tolerances",
        description = "Rotation keys that are not changed from frame to frame by at least this amount are discarded.  This is in degrees.",
        min = -180,
        max = 180,
        precision = 4,
        default = 0.001,
        )
    mark_tol_loc : bpy.props.FloatProperty(
        name = "rotation tolerances",
        description = "Position keys that are not changed from frame to frame by at least this amount are discarded.  This is in meters.",
        min = -10,
        max = 10,
        precision = 4,
        default = 0.001,
        )
    
    anim_resample : bpy.props.BoolProperty(
        name = "",
        description =            "Resample to reduce keys"            "\n\n"            "The number indicates the amount of frames to skip before removing a key.  Setting it to 2 should cut your file size in half.",
        default = False,
        )
    
    def update_anim_resample_auto(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_anim = bpy.context.scene.bb_anim
        bb = bpy.context.scene.onigiri
        if bb_anim.anim_resample_auto == True:
            frame_start = bb.animation_start_frame
            frame_end = bb.animation_end_frame
            frame_range = abs(frame_start - frame_end+1)
            rate = int( (0.2 * frame_range) / 100 )
            bb_settings['terminate'] = True
            bb_anim.anim_resample_rate_rotation = rate
            bb_settings['terminate'] = True
            bb_anim.anim_resample_rate_location = rate
        bpy.context.scene.bb_anim.property_unset("anim_resample_auto")

    anim_resample_auto : bpy.props.BoolProperty(
        name = "",
        description =            "Auto resample"            "\n\n"            "You will have to click this button new, guessed, sample.  The only thing this does is give you a sane number to work with."            "\n\n"            "This guesses from the frame range, it's about 0.2 percent of the total, this is usually sufficient",
        default = False,
        update = update_anim_resample_auto
        )

    anim_resample_rate_rotation : bpy.props.IntProperty(
        name = "",
        description =            "This is an integer, it can be no less than 2, since 1 is as if you turned it off.",
        min = 2,
        default = 3,
        update = update_anim_resample_auto
        )
    anim_resample_rate_location : bpy.props.IntProperty(
        name = "",
        description =            "This is an integer, it can be no less than 2, since 1 is as if you turned it off.",
        min = 2,
        default = 3,
        update = update_anim_resample_auto
        )
    
    def bvh_type_sl_os_update(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bba = bpy.context.scene.bb_anim
        bb_settings['terminate'] = True
        bba.bvh_type_other = not bba.bvh_type_sl_os
        return
    def bvh_type_other_update(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bba = bpy.context.scene.bb_anim
        bb_settings['terminate'] = True
        bba.bvh_type_sl_os = not bba.bvh_type_other
        return

    bvh_menu_enabled : bpy.props.BoolProperty(
        name = "BVH Tools",
        description = "Enable view of BVH tools.  You can load, save and convert between xml and bvh formatted files.",
        default = False,
        )
    bvh_type_sl_os : bpy.props.BoolProperty(
        name = "Type of BVH - SL specific",
        description =            "This type of BVH is specific for SL/OS, although it may still work on other platforms and you can probably re-import it "            "into Blender.  However, if you save your work as an SL BVH you cannot revert back to the original so make a backup.",
        default = True,
        update = bvh_type_sl_os_update,
        )
    bvh_type_other : bpy.props.BoolProperty(
        name = "Type of BVH - ordinary",
        description =            "This type of BVH is transportable, it's the best way to store your animation for later use.",
        default = False,
        update = bvh_type_other_update,
        )
    bvh_import_name : bpy.props.StringProperty(
        name = "import a BVH",
        description = "open a bvh file",
        default = "",
        )
    
    bvh_import_path : bpy.props.StringProperty(default="")

    bvh_identity : bpy.props.StringProperty(default="")

    bvh_buffer : bpy.props.StringProperty(default="")

class OnigiriSetInterpolation(bpy.types.Operator):
    """An advanced feature that gives you fine control over how your bones move,
how fast they transition and if there is an animation or a SNAP!  For the original
exporter make sure to enable (Preserve Interpolations)"""

    bl_idname = "onigiri.set_interpolation"
    bl_label = "Set interpolation mode"

    mode : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if bpy.context.mode != 'POSE':
            return False
        if bpy.context.active_object == None:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        if o.animation_data == None:
            return False
        if o.animation_data.action == None:
            return False
        return True

    def execute(self, context):
        bb_anim = bpy.context.scene.bb_anim
        armObj = bpy.context.selected_objects[0]
        arm = armObj.name

        actionObj = armObj.animation_data.action
        fcurves = actionObj.fcurves

        bpy.context.view_layer.update()
        frame_current = bpy.context.scene.frame_current
        print("frame_current:", frame_current)

        pose_paths = {}

        if bb_anim.anim_interpolate_bone == True:
            print("Interpolate bone")
            for boneObj in bpy.context.selected_pose_bones:
                path_key = 'pose.bones["' + boneObj.name + '"]'
                pose_paths[path_key] = boneObj.name
            for fc in fcurves:
                dp, i = fc.data_path, fc.array_index
                bone_path, delimiter, transform_type = dp.rpartition('.')
                if bone_path in pose_paths:
                    for kfp in fc.keyframe_points:
                        kfp.interpolation = self.mode
        else:
            print("Interpolate key")
            for boneObj in bpy.context.selected_pose_bones:
                path_key = 'pose.bones["' + boneObj.name + '"]'
                pose_paths[path_key] = boneObj.name
                for fc in fcurves:
                    dp, i = fc.data_path, fc.array_index
                    bone_path, delimiter, transform_type = dp.rpartition('.')
                    if bone_path in pose_paths:
                        for kfp in fc.keyframe_points:
                            f = int(kfp.co.x)
                            if f == frame_current:
                                print("co[1]:", kfp.co[1])
                                kfp.interpolation = self.mode
        return {'FINISHED'}

class OnigiriAnimEnableJointPriority(bpy.types.Operator):
    """Enable joint priority on selected pose bones"""

    bl_idname = "onigiri.anim_enable_joint_priority"
    bl_label = "enable joint priority"

    @classmethod
    def poll(cls, context):
        if selected_pose_bones() == False:
            return False
        return True
    def execute(self, context):
        enable_pose_bone_priority()
        return {'FINISHED'}

class OnigiriAnimDisableJointPriority(bpy.types.Operator):
    """Disable joint priority on selected pose bones"""

    bl_idname = "onigiri.anim_disable_joint_priority"
    bl_label = "disable joint priority"

    @classmethod
    def poll(cls, context):
        if selected_pose_bones() == False:
            return False
        return True
    def execute(self, context):
        disable_pose_bone_priority()
        return {'FINISHED'}

class OnigiriAnimApplyJointPriority(bpy.types.Operator):
    """Apply the set priority to the selected pose bones"""

    bl_idname = "onigiri.anim_apply_joint_priority"
    bl_label = "apply joint priority"

    priority : bpy.props.IntProperty(default=0)

    @classmethod
    def poll(cls, context):
        if selected_pose_bones() == False:
            return False
        return True

    def execute(self, context):
        
        set_pose_bone_priority(priority=self.priority)
        return {'FINISHED'}

class OnigiriAnimSelectPriority(bpy.types.Operator):
    """Select all bones with specific priority"""

    bl_idname = "onigiri.select_priority"
    bl_label = "Select bones with specific priority"

    priority : bpy.props.IntProperty(default=0)

    @classmethod
    def poll(cls, context):
        if bpy.context.active_object == None:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        armObj = bpy.context.object

        if bpy.context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        for o in bpy.context.selected_objects:
            o.select_set(False)
        activate(armObj.name)
        armObj.select_set(True)

        bpy.ops.object.mode_set(mode='POSE')
        for b in armObj.data.bones:
            b.select = False
        for boneObj in armObj.pose.bones:
            if boneObj.get('priority') == self.priority:
                armObj.data.bones[boneObj.name].select = True

        bpy.context.scene.bb_anim.anim_selected_pose_bones = len(bpy.context.selected_pose_bones)

        return {'FINISHED'}

class OnigiriAcquireAnimationDetails(bpy.types.Operator):
    """Use the animation frame range and length to populate the start and end
frames as well as the loop information.
"""
    bl_idname = "onigiri.acquire_animation_details"
    bl_label = "Acquire animation details"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.animation_data == None:
            return False
        if o.animation_data.action == None:
            return False
        return True

    def execute(self, context):
        bb = bpy.context.scene.onigiri
        bba = bpy.context.scene.bb_anim
        armObj = bpy.context.selected_objects[0]

        start_frame, end_frame = animutils.get_frame_range(armObj, start=True, end=False)

        fps = bb.animation_fps

        bb.animation_start_frame = start_frame
        bb.animation_end_frame = end_frame

        if armObj.get('reference') != None:
            if (end_frame - start_frame) > 1:
                bba.anim_loop_in_frame = start_frame + 1
            else:
                bba.anim_loop_in_frame = start_frame
            
            if armObj.get('bb_reference_frame') != None:
                bba.anim_loop_in_frame = armObj['bb_reference_frame']

        else:
            bba.anim_loop_in_frame = start_frame

        bba.anim_loop_out_frame = end_frame

        return {'FINISHED'}

class OnigiriSplitAnimProperties(bpy.types.PropertyGroup):

    def update_split_blank(self, context):
            self["split_blank"] = False
            return
    split_blank : bpy.props.BoolProperty(
        description =            "Enable animation bulk export splitter",
        default = False,
        update=update_split_blank
        )

    split_enabled : bpy.props.BoolProperty(
        description =            "Enable animation bulk export splitter",
        default = False,
        )

    split_time : bpy.props.FloatProperty(
        description =            "Adjust the time of each segment",
        min = 0.1,
        max = 60.0,
        default = 60,
        )

    split_overlap : bpy.props.FloatProperty(
        description =            "This can help smooth between segments if needed.  This can be particularly useful when using the resulting composed animaton as "            "an avatar",
        min = 0.0,
        max = 2.0,
        default = 0.0,
        )

    split_kill : bpy.props.BoolProperty(
        name="",
        description = ""            "Stop Previous"            "\n\n"            "Sometimes you want an animation to stop just after playing a new one, enable this for that effect.  You may want to add delay as well",
        default=False,
        )
    split_delay : bpy.props.FloatProperty(
            name = "",
            description =                "This is sort of the reverse of (overlap) but not quite, the two can be used together but the results are unclear.  This puts a "                "delay between the end of your animation segment time and the start of the new one, by simply adding this to the segment total time",
        min = 0.0,
        max = 60.0,
        default = 0.0,
        )

    split_ease_in : bpy.props.FloatProperty(
        description =            "animation ease in segment",
        min = 0.0,
        max = 1.0,
        default = 0.82,
        )
    split_ease_out : bpy.props.FloatProperty(
        description =            "animation ease out segment",
        min = 0.0,
        max = 1.0,
        default = 0.82,
        )
    split_debug : bpy.props.BoolProperty(
        name="",
        description = ""            "Debug Messages"            "\n\n"            "With this enabled you'll see extensive messages while the animation is running, when it's rezed "            "and, if it's for an Avatar, when it's attached",
        default=False,
        )
    split_owner : bpy.props.BoolProperty(
        name="",
        description = ""            "Owner Only"            "\n\n"            "With this enabled nobody else can manipulate the object that activates and deactivates the sequence",
        default=True,
        )
    split_loop : bpy.props.BoolProperty(
        name="",
        description = ""            "Loop Sequence"            "\n\n"            "With this enabled your sequence will continue playing in a loop, this is not the same as single looped "            "but has the same visual effect since the sequenced animation is virtually seamless",
        default=True,
        )
    split_touch : bpy.props.BoolProperty(
        name="",
        description = ""            "On Touch"            "\n\n"            "If enabled then when the object that contains the script is touched the animation will toggle between "            "start and stop states",
        default=True,
        )
    split_on_start : bpy.props.BoolProperty(
        name="",
        description = ""            "On Start"            "\n\n"            "If enabled, and if using the avatar type animation script, the animation sequence will start automatically "            "when the proper conditios are met, (attached and permission granted)",
        default=True,
        )
    split_listen : bpy.props.BoolProperty(
        name="",
        description = ""            "On Listen"            "\n\n"            "If enabled then when the proper command is given then the animation will start or stop depending on the command",
        default=True,
        )
    
    def split_channel(self, context):
        channel = self.split_channel
        sign = ""
        if channel.startswith("-"):
            sign = channel[:1]
            channel = channel[1:]
        if channel.isdecimal() == False:
            txt = "The IntProperty in Blender cannot represent the numeric value appropriate for this content so "            + "a string value is used and converted, unfortunately your string value contains something other than numbers and the (-) sign.  "            + "Your input was as follows: " + self.split_channel
            print(txt)
            popup("Input can only consist of an integer of range -2147483648 to 2147483647", "Error", "ERROR")
            self["split_script_channel"] = "5"
        result = int(sign + channel)
        if result < -2147483648 or result > 2147483647:
            print("The value you entered:", result)
            print("is out of range, use a value between -2147483648 and 2147483647")
            popup("Your value is out of range, see console for instructions", "Error", "ERROR")
            self["split_script_channel"] = "5"
        print("result:", result)

    split_channel : bpy.props.StringProperty(
        name="",
        description = ""            "Channel"            "\n\n"            "This is the channel you want to use for the start/stop commands.  It's suggested to use a negative channel when "            "using object to object communications but the default is 5 for easy testing, /5 start .  The channel range you can "            "use is between  -2147483648 and 2147483647, where 2147483647 is actually the debug channel so you probably don't "            "want to use that one, 0 is public so it's often not used for control listeners",
        default="5",
        update=split_channel
        )
    split_start : bpy.props.StringProperty(
        name="",
        description = ""            "Start Command"            "\n\n"            "This is the command you'll use in order to start your animation, it can be anything you like but the default is (start) "            "for clarity.  You'll want to at least change this if you haven't changed the channel number so you don't get confused "            "with other people utilizing this feature of Onigiri that may be near by you",
        default="start",
        )
    split_stop : bpy.props.StringProperty(
        name="",
        description = ""            "Stop Command"            "\n\n"            "This is the command you'll use in order to stop your animation, it can be anything you like but the default is (stop) "            "for clarity.  You'll want to at least change this if you haven't changed the channel number so you don't get confused "            "with other people utilizing this feature of Onigiri that may be near by you",
        default="stop",
        )

class OnigiriSaveAnimationScript(bpy.types.Operator, ExportHelper):
    """When you have split enabled and you export your animation then two scripts
written for you and saved to disk.  For convenience you have the option to do that
manually, which will observe any changes in  your settings"""

    bl_idname = "onigiri.save_animation_script"
    bl_label = "Save animation script"

    filename_ext = ".txt"

    filter_glob : bpy.props.StringProperty(
        default='*.txt',
        options={'HIDDEN'}
        )

    filename : bpy.props.StringProperty(default="")

    target : bpy.props.StringProperty(default="avatar")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        bpy.context.scene.bb_anim.anim_save_path = save_path
        self.filepath = save_path + bpy.context.scene.bb_anim.anim_base_name
        wm = context.window_manager.fileselect_add(self)

        return {'RUNNING_MODAL'}

    def execute(self, context):

        obj = bpy.data.objects
        bb = bpy.context.scene.onigiri
        bba = bpy.context.scene.bb_anim_props

        bb_split = bpy.context.window_manager.bb_split

        anim = bpy.context.scene.bb_anim
        jd = joint_data

        if anim.anim_base_name == "":
            txt  = "A base name is required for this feature.  I can't know what the file names\n"
            txt += "are that you may have already exported.  If you have not actually exported\n"
            txt += "anything yet, no animations, then there's nothing to record really.  If\n"
            txt += "you have exported animations then use their old base name, possibly\n"
            txt += "bb_animatin ?"
            print(txt)
            utils.popup(txt, "Info", "INFO")
            return {'FINISHED'}

        file_prefix = anim.anim_base_name 

        if self.filename == "":
            txt  = "A filename is necessary in order to save a script.  There was no filename\n"
            txt += "provided for this data to be written."
            print(txt)
            utils.popup(txt, "Info", "INFO")
            return {'FINISHED'}

        armObj = bpy.context.selected_objects[0]
        arm = armObj.name

        bpy.app.timers.register(cleanup)

        bb_anim = bpy.context.scene.bb_anim

        frame_start = bb.animation_start_frame
        frame_end = bb.animation_end_frame
        frame_fps = bb.animation_fps
        split_time = bb_split.split_time

        actions = animutils.split_time(frame_start=frame_start, frame_end=frame_end, fill_fps=frame_fps, fill_time=split_time)
        if actions == False:
            print("Couldn't get action segments")
            return {'FINISHED'}

        count = len(actions)

        path, file_name = os.path.split(self.properties.filepath)

        suffix = self.filename

        full_path = path + "/"

        print("path:", path)
        print("suffix:", suffix)
        print("filename:", self.filename)
        print("file_name:", file_name)

        files = utils.make_filenames(prefix=file_prefix, count=count, ext=".anim")

        print("actions:", actions)
        print("files:", files)

        if self.target == "animesh":
            lsl_file = bb_settings["files"]["lsl_split_animmesh"]
            source = script_dir + presets_path + lsl_file
            target = full_path + suffix + "_lsl.txt"
            result = animutils.write_lsl(source=source, target=target, actions=actions, prefix=file_prefix, fps=bb.animation_fps)
            if result == False:
                print("Result from writing scripts for Animesh was False")
                popup("Script write failure", "Error", "ERROR")

        elif self.target == "avatar":
            lsl_file = bb_settings["files"]["lsl_split_animation"]
            source = script_dir + presets_path + lsl_file
            target = full_path + suffix + "_lsl.txt"
            result = animutils.write_lsl(source=source, target=target, actions=actions, prefix=file_prefix, fps=bb.animation_fps)
            if result == False:
                print("Result from writing scripts for Avatar was False")
                popup("Script write failure", "Error", "ERROR")
        else:
            print("The animation target is wrong:", self.target)
            popup("Invalid animation target", "Error", "ERROR")

        return {'FINISHED'}

class OnigiriExportSLAnim(bpy.types.Operator, ExportHelper):
    """Export .anim animation type for Second Life.  This features allows for higher
priorities and per bone priorities."""

    bl_idname = "onigiri.export_sl_anim"
    bl_label = "Export SL .anim"

    filename_ext = ".anim"
    filter_glob : bpy.props.StringProperty(
        default='*.anim',
        options={'HIDDEN'}
        )

    filename : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        bpy.context.scene.bb_anim.anim_save_path = save_path
        self.filepath = save_path + bpy.context.scene.bb_anim.anim_base_name
        wm = context.window_manager.fileselect_add(self)

        return {'RUNNING_MODAL'}

    def execute(self, context):

        obj = bpy.data.objects
        bb = bpy.context.scene.onigiri
        bba = bpy.context.scene.bb_anim_props

        bb_split = bpy.context.window_manager.bb_split

        anim = bpy.context.scene.bb_anim
        jd = joint_data

        armObj = bpy.context.selected_objects[0]
        arm = armObj.name

        bpy.app.timers.register(cleanup)

        if bb_split.split_enabled == True:
            print("Splitting animation...")

            bb_anim = bpy.context.scene.bb_anim

            frame_start = bb.animation_start_frame
            frame_end = bb.animation_end_frame
            frame_fps = bb.animation_fps
            split_time = bb_split.split_time

            actions = animutils.split_time(frame_start=frame_start, frame_end=frame_end, fill_fps=frame_fps, fill_time=split_time)
            if actions == False:
                print("Couldn't get action segments")
                return {'FINISHED'}

            count = len(actions)

            path, file_name = os.path.split(self.properties.filepath)
            ext = file_name.split(".")[-1]
            file_prefix = file_name.split(".")[-2]
            full_path = path + "/"

            files = utils.make_filenames(prefix=file_prefix, count=count, ext=".anim")

            print("actions:", actions)
            print("files:", files)

            anim_start_frame = bb.animation_start_frame
            anim_end_frame = bb.animation_end_frame
            anim_fps = bb.animation_fps
            anim_ease_in = bb_anim.anim_ease_in_duration
            anim_ease_out = bb_anim.anim_ease_out_duration
            anim_loop = bb_anim.anim_loop
            anim_loop_advanced = anim.anim_loop_advanced
            anim_loop_in_frame = anim.anim_loop_in_frame
            anim_loop_out_frame = anim.anim_loop_out_frame
            disable_location_offsets = bba.disable_location_offsets
            mark_tol = anim.mark_tol
            mark_tol_rot = anim.mark_tol_rot
            mark_tol_loc = anim.mark_tol_loc
            fill_missing_keys = bba.fill_missing_keys
            high_fidelity = bb_anim.anim_high_fidelity
            anim_resample = anim.anim_resample
            anim_resample_rate_rotation = anim.anim_resample_rate_rotation
            anim_resample_rate_location = anim.anim_resample_rate_location
            anim_base_priority = bb_anim.anim_base_priority

            bb_anim.anim_loop = False

            state = utils.get_state()

            for i in actions:
                frame_start = actions[i]['frame_start']
                frame_end = actions[i]['frame_end']
                filename = files[i]
                filepath = full_path + filename

                bb.animation_start_frame = frame_start
                bb.animation_end_frame = frame_end

                result = animutils.export_sl_anim(armature=armObj.name, path=filepath)
                if result == False:
                    txt  = "The split feature is enabled and the export returned an error so in order to save you \n"
                    txt += "some time the operation was canceled after the first write.  This file will not upload \n"
                    txt += "to Second Life.  Reduce the frames per slice in order to continue.  The total file size \n"
                    txt += "that can be uploaded per slice is 250,000 bytes."
                    
                    print(txt)

                    utils.set_state(state)
                    bb.animation_start_frame = anim_start_frame
                    bb.animation_end_frame = anim_end_frame
                    bb.animation_fps = anim_fps
                    bb_anim.anim_ease_in_duration = anim_ease_in
                    bb_anim.anim_ease_out_duration = anim_ease_out
                    bb_anim.anim_loop = anim_loop
                    anim.anim_loop_advanced = anim_loop_advanced
                    anim.anim_loop_in_frame = anim_loop_in_frame
                    anim.anim_loop_out_frame = anim_loop_out_frame
                    bba.disable_location_offsets = disable_location_offsets
                    anim.mark_tol = mark_tol
                    anim.mark_tol_rot = mark_tol_rot
                    anim.mark_tol_loc = mark_tol_loc
                    bba.fill_missing_keys = fill_missing_keys
                    bb_anim.anim_high_fidelity = high_fidelity
                    anim.anim_resample = anim_resample
                    anim.anim_resample_rate_rotation = anim_resample_rate_rotation
                    anim.anim_resample_rate_location = anim_resample_rate_location
                    bb_anim.anim_base_priority = anim_base_priority
                    return {'FINISHED'}

            utils.set_state(state)

            suffix = "Animesh_Animation"
            lsl_file = bb_settings["files"]["lsl_split_animmesh"]
            source = script_dir + presets_path + lsl_file
            target = full_path + suffix + "_lsl.txt"
            result = animutils.write_lsl(source=source, target=target, actions=actions, prefix=file_prefix, fps=bb.animation_fps)
            if result == False:
                print("Result from writing scripts for Animesh was False")
                popup("Script write failure", "Error", "ERROR")

            suffix = "Avatar_Animation"
            lsl_file = bb_settings["files"]["lsl_split_animation"]
            source = script_dir + presets_path + lsl_file
            target = full_path + suffix + "_lsl.txt"
            result = animutils.write_lsl(source=source, target=target, actions=actions, prefix=file_prefix, fps=bb.animation_fps)
            if result == False:
                print("Result from writing scripts for Avatar was False")
                popup("Script write failure", "Error", "ERROR")

            bb.animation_start_frame = anim_start_frame
            bb.animation_end_frame = anim_end_frame
            bb.animation_fps = anim_fps
            bb_anim.anim_ease_in_duration = anim_ease_in
            bb_anim.anim_ease_out_duration = anim_ease_out
            bb_anim.anim_loop = anim_loop
            anim.anim_loop_advanced = anim_loop_advanced
            anim.anim_loop_in_frame = anim_loop_in_frame
            anim.anim_loop_out_frame = anim_loop_out_frame
            bba.disable_location_offsets = disable_location_offsets
            anim.mark_tol = mark_tol
            anim.mark_tol_rot = mark_tol_rot
            anim.mark_tol_loc = mark_tol_loc
            bba.fill_missing_keys = fill_missing_keys
            bb_anim.anim_high_fidelity = high_fidelity
            anim.anim_resample = anim_resample
            anim.anim_resample_rate_rotation = anim_resample_rate_rotation
            anim.anim_resample_rate_location = anim_resample_rate_location
            bb_anim.anim_base_priority = anim_base_priority

            return {'FINISHED'}

        if 'bb_deformer' in armObj:
            anim_high_fidelity = anim.anim_high_fidelity
            anim_resample = anim.anim_resample
            anim.anim_high_fidelity = True
            anim.anim_resample = False

        print("New default exporter chosen, deferring...")
        animutils.export_sl_anim(armature=arm, path=self.properties.filepath)
        anim.export_sl_anim_label_short = anim.export_sl_anim_label
        anim.export_sl_anim_alert = True

        if 'bb_deformer' in armObj:
            anim.anim_high_fidelity = anim_high_fidelity
            anim.anim_resample = anim_resample

        return {'FINISHED'}

class OnigiriBakeProxy(bpy.types.Operator):
    """Bake the animation to a proxy rig, without exporting, so you can see the
result of your animation before committing to it.  This is also a good way to
examine the keys functions for accurate data"""

    bl_idname = "onigiri.bake_proxy"
    bl_label = "Bake Proxy"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def execute(self, context):
        arm = bpy.context.selected_objects[0].name
        bpy.app.timers.register(cleanup)

        proxyObj = rigutils.build_rig(rig_class="pos", rotate=True)
        proxyObj.location.y = 0.6

        result = animutils.bake_motion(sarm=arm, tarm=proxyObj)
        if result == False:
            print("Couldn't bake")

        else:
            print("Finished baking!")

        return {'FINISHED'}

        print("Proxy bake only")
        animutils.export_sl_anim(armature=arm)

        return {'FINISHED'}

class OnigiriExportSLAnimOld(bpy.types.Operator, ExportHelper):
    """Export .anim animation type for Second Life.  This features allows for higher
priorities and per bone priorities.  This is the older exporter and just as accurate
though it may have some timing issues, I may have fixed, I don't know"""

    bl_idname = "onigiri.export_sl_anim_old"
    bl_label = "Export SL .anim"

    filename_ext = ".anim"
    filter_glob : bpy.props.StringProperty(
        default='*.anim',
        options={'HIDDEN'}
        )

    filename : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        bpy.context.scene.bb_anim.anim_save_path = save_path
        self.filepath = save_path + bpy.context.scene.bb_anim.anim_base_name
        wm = context.window_manager.fileselect_add(self)

        return {'RUNNING_MODAL'}

    def execute(self, context):

        obj = bpy.data.objects
        bb = bpy.context.scene.onigiri
        bba = bpy.context.scene.bb_anim_props

        anim = bpy.context.scene.bb_anim
        jd = joint_data

        armObj = bpy.context.selected_objects[0]
        arm = armObj.name

        bpy.app.timers.register(cleanup)

        if bb.export_onigiri_disabled != True:
            if armObj.get('onigiri') == None:
                print("1 Onigiri rig check is enabled but the rig is not Onigiri.  Disable the check in (Extended Options) to override.")
                txt = "\n"
                txt += "\n"
                txt += "\n"
                txt += "\n"
                txt += "Onigiri rig checking prevents export.  You can disable this feature or    \n"
                txt += "choose a Bento buddy rig that's desiged for animation export.                 \n"
                txt += "\n"
                txt += "\n"
                txt += "\n"
                txt += "\n"
                txt += "\n"

                utils.popup(txt, "Info", "INFO")
                return {'FINISHED'}

        if bb.export_sl_limitations_check_disabled != True:
            
            print("skipping time check")
            
        hide_state = rigutils.save_hide_state(arm)

        preserve_interpolation = anim.anim_preserve_interpolation

        record_motion = anim.anim_record_motion

        anim.export_sl_anim_old_label = "Saving: please wait..."
        
        anim.export_sl_anim_old_label_short = anim.export_sl_anim_old_label
        anim.export_sl_anim_old_alert = True
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

        inherit_motion = False
        if armObj.animation_data == None:
            inherit_motion = True
            record_motion = False
            print("No animation data, attempting to inherit motion, (Keys Only) cannot be used.")
            
        if getattr(armObj.animation_data, "action", None) == None:
            inherit_motion = True
            record_motion = False
            print("No action associated with the armature, attempting to inherit motion, (Keys Only) will be turned off.")
            
        if inherit_motion == True:
            
            real_start_frame, real_end_frame = bb.animation_start_frame, bb.animation_end_frame
            anim_start_frame = real_start_frame
            anim_end_frame = real_end_frame
            
        else:
            actionObj = armObj.animation_data.action

            real_start_frame, real_end_frame = map(int, armObj.animation_data.action.frame_range)

            anim_start_frame = bb.animation_start_frame
            anim_end_frame = bb.animation_end_frame

        anim_fps = bb.animation_fps
        total_frames = abs(anim_start_frame - anim_end_frame)
        total_steps = total_frames 
        total_time = round(total_steps / anim_fps, 6)
        time_per_frame = round(total_time / total_steps, 6)

        if anim.anim_loop_advanced == True:
            
            anim_loop_in_point = round(anim.anim_loop_in_time, 6)
            anim_loop_out_point = round(anim.anim_loop_out_time, 6)

        else:
            loop_in = abs(anim_start_frame - anim.anim_loop_in_frame)
            loop_range = abs(anim.anim_loop_in_frame - anim.anim_loop_out_frame)
            loop_out = loop_in + loop_range
            
            anim_loop_in_point   = round( ( loop_in  * time_per_frame), 6)
            anim_loop_out_point  = round( ( loop_out * time_per_frame), 6)

        if 1 == 0:
            
            frame_check = True
            if anim_start_frame > anim_end_frame:
                print("requested start frame crossover, ignoring -", "start:", anim_start_frame, "end:", anim_end_frame)
                frame_check = False
            if anim_end_frame < real_start_frame:
                print("requested end frame crossover, ignoring -", "start:", anim_start_frame, "end:", anim_end_frame)
                frame_check = False
            
            if anim_start_frame == anim_end_frame:
                print("requested start and end frames are the same, ignoring")
                frame_check = False
            
            if anim_start_frame < real_start_frame:
                print("requested start frame is out of bounds, skipping", str(anim_start_frame), "vs", str(real_start_frame))
                frame_check = False
            
            if anim_end_frame > real_end_frame:
                print("requested end frame is out of bounds, skipping", str(anim_end_frame), "vs", str(real_end_frame))
                frame_check = False

        rig_class = None
        if armObj.get('rig_class') == "default":
            rig_class = "default"
        elif armObj.get('rig_class') == "neutral":
            rig_class = "neutral"

        print("==============================================")
        if rig_class != None:
            print("rig_class:", rig_class)
        print("anim_file_name:", anim.anim_base_name)
        print("base_priority:", anim.anim_base_priority)
        print("real_start_frame:", real_start_frame)
        print("real_end_frame:", real_end_frame)
        print("anim_start_frame:", anim_start_frame)
        print("anim_end_frame:", anim_end_frame)
        print("anim_fps:", anim_fps)
        print("total_time:", total_time)
        print("total_frames:", total_frames)
        print("loop enabled:", anim.anim_loop)
        print("loop_in_frame:", anim.anim_loop_in_frame)
        print("loop_out_frame:", anim.anim_loop_out_frame)
        print("loop_in_point:", anim_loop_in_point)
        print("loop_out_point:", anim_loop_out_point)
        print("ease_in:", anim.anim_ease_in_duration)
        print("ease_out:", anim.anim_ease_out_duration)
        print("hand_pose", anim.anim_hand_pose)
        print("time_per_frame:", time_per_frame)
        print("record_motion:", record_motion)
        print("==============================================")
        
        file_content = {}

        file_content['header'] = {}

        file_content['header']['version'] = (1).to_bytes(2, byteorder='little')
        file_content['header']['sub_version'] = (0).to_bytes(2, byteorder='little')
        file_content['header']['base_priority'] = (anim.anim_base_priority).to_bytes(4, byteorder='little')
        file_content['header']['anim_length'] = struct.pack('f', total_time)
        
        file_content['header']['emote_name'] = struct.pack("%dsB"%len(anim.anim_emote_name), bytes(anim.anim_emote_name,'utf8') , 0)
        
        file_content['header']['loop_in'] = struct.pack('f', anim_loop_in_point)
        file_content['header']['loop_out'] = struct.pack('f', anim_loop_out_point)
        
        file_content['header']['loop'] = (anim.anim_loop).to_bytes(4, byteorder='little')
        
        file_content['header']['ease_in'] = struct.pack('f', anim.anim_ease_in_duration)
        file_content['header']['ease_out'] = struct.pack('f', anim.anim_ease_out_duration)
        
        if anim.anim_hand_pose_enabled == True:
            
            hp = int(anim.anim_hand_pose)
            file_content['header']['hand_pose'] = struct.pack("i", hp)
        else:
            file_content['header']['hand_pose'] = (0).to_bytes(4, byteorder='little')

        if inherit_motion == False:
            print("get_compatible_bone_list disabled")
            if 1 == 0:
                bone_names = anim.get_compatible_bone_list(armature=armObj.name)
                print("The following bones are animated:")
                print(bone_names)

        old_mode = get_mode()
        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.transform_apply(scale=False, rotation=True, location=False)

        if 1 == 1:
            if armObj.get('fly_paper') != None and armObj.get('fly_paper') != "":
                print(".anim exporter detected mapped rig, applying new pose")
                bpy.ops.object.mode_set(mode='POSE')
                bpy.ops.pose.armature_apply()
                bpy.ops.object.mode_set(mode='OBJECT')

        if old_mode != None:
            bpy.ops.object.mode_set(mode=old_mode)

        print("saving raw animation data...")
        bvh_buf = bvh.save(
            context=context,
            filepath="",
            global_scale=1,
            frame_start=anim_start_frame,
            frame_end=anim_end_frame,
            rotate_mode='NATIVE',
            root_transform_only=bba.disable_location_offsets,
            buffer=True,
            )

        if 1 == 0:
            print("file:", self.properties.filepath)
            try:
                f = open(self.properties.filepath + ".bvh", "w", encoding='UTF8')
                f.write(bvh_buf)
                f.close()
            except:
                print("couldn't open file:")

        print("Converting to xml")

        tree = bvht.to_xml(buf=bvh_buf, return_type="object")

        if bb.export_volume_motion == True:
            print("will export volumes")

        print("processing animation buffer...")

        motion = bvht.read(
            doc=tree,
            sl_only=True,
            export_volumes=bb.export_volume_motion,
            mark_tol=anim.mark_tol,
            rot_tol=anim.mark_tol_rot,
            loc_tol=anim.mark_tol_loc
            )

        del tree

        bone_names = list()
        for bone in motion['joints']:
            if anim.mark_tol == True:
                if motion['joints'][bone]['animated']:
                    bone_names.append(bone)
            
            else:
                bone_names.append(bone)

        if armObj.animation_data != None:
            if armObj.animation_data.action != None:
                print("gathering interpolation data...")
                frame_data = curves.get_fcurve_data(armObj.name)
            else:
                print("No action data, interpolation will be disabled")
                preserve_interpolation = False
        else:
            print("No animation data, interpolation will be disabled")
            preserve_interpolation = False

        if 1 == 0:
            anim.mark_tol = True
            bone_names = [] 
            
            real_keys = animutils.get_animated_keys(armature=armObj.name)
            print("real_keys:", real_keys)
            bone_names = [n for n in real_keys]
            print("bone_names:", bone_names)

            for bone in motion['joints']:
                
                motion['joints'][bone]['animated'] = False
                quats = []
                locs = []
                if bone in bone_names:
                    motion['joints'][bone]['animated'] = True

                    if real_keys[bone].get('rot') == None:
                        motion['joints'][bone]['tol']['rot_count'] = 0
                    else:
                        motion['joints'][bone]['tol']['rot_count'] = len(real_keys[bone]['rot']['frames'])
                        
                        motion['joints'][bone]['tol']['rot'] = [ True for r in real_keys[bone]['rot']['frames'] ]
                        for f in real_keys[bone]['rot']['frames']:
                            quats.append(motion['joints'][bone]['quats'][f-1]) 
                        motion['joints'][bone]['quats'] = quats 

                    if real_keys[bone].get('loc') == None:
                        motion['joints'][bone]['tol']['loc_count'] = 0
                    else:

                        motion['joints'][bone]['tol']['loc_count'] = len(real_keys[bone]['loc']['frames'])
                        motion['joints'][bone]['tol']['loc'] = [ True for l in real_keys[bone]['loc']['frames'] ]

                        if motion['joints'][bone].get('loc_pose') == None:

                            print("got none from loc_pose for bone:", bone)

                            for f in real_keys[bone]['loc']['frames']:
                                bpy.context.scene.frame_set(f)
                                matrix_real = pill.get_real_matrix(armObj.name, bone)
                                loc = matrix_real.to_transltion()
                                locs.append([0,0,0])
                        else:
                            for f in real_keys[bone]['loc']['frames']:
                                index = f-1
                                print("index:", index)
                                locs.append(motion['joints'][bone]['loc_pose'][index])

                        motion['joints'][bone]['loc_pose'] = locs

        testing = False

        file_content['header']['joint_count'] = (int(len(bone_names))).to_bytes(4, byteorder='little')

        file_content['joints'] = {}
        for bone in bone_names:
            file_content['joints'][bone] = {}
            
            file_content['joints'][bone]['name'] = struct.pack("%dsB"%len(bone), bytes(bone,'utf8') , 0)

            priority = anim.anim_base_priority
            if armObj.pose.bones[bone].get('priority_enabled') == 1:
                if armObj.pose.bones[bone].get('priority') != None:
                    priority = armObj.pose.bones[bone]['priority']

            file_content['joints'][bone]['priority'] = struct.pack("i", priority)

            if anim.mark_tol == True:
                file_rot_count = motion['joints'][bone]['tol']['rot_count']
            else:
                file_rot_count = len(motion['joints'][bone]['rot'])

            file_content['joints'][bone]['rot_count'] = file_rot_count.to_bytes(4, byteorder='little')

            count = 0
            current_time = 0

            time_after = True
            if time_after == True:
                
                last_time = 0

                this_time = 0

                next_time = 0

            if file_rot_count > 0:
                file_content['joints'][bone]['rot_data'] = []

                for r in motion['joints'][bone]['quats']:

                    if time_after == True:
                        
                        last_time = this_time
                        this_time = next_time
                        next_time = time_per_frame * (count + anim_start_frame)
                        current_time = this_time

                    else:
                        current_time = time_per_frame * (count - anim_start_frame)

                    if anim.mark_tol == True:
                        if motion['joints'][bone]['tol']['rot'][count] == False:
                            count += 1
                            continue

                    rot_x, rot_y, rot_z = r

                    x = F32_to_U16(rot_x, -1, 1)
                    y = F32_to_U16(rot_y, -1, 1)
                    z = F32_to_U16(rot_z, -1, 1)

                    rot_time = F32_to_U16(float(current_time), 0, total_time)
                    time_data = struct.pack("H", rot_time)

                    if preserve_interpolation == True:
                        
                        if bone in frame_data:
                            if (count+1) in frame_data[bone]['rot']:
                                
                                if frame_data[bone]['rot'][count+1]['interpolation'] == 'CONSTANT':
                                    snap_time = last_time + 0.001
                                    rot_time = F32_to_U16(float(snap_time), 0, total_time)
                                    time_data = struct.pack("H", rot_time)

                    if testing == True:
                        if bone == 'mHipRight':
                            print("Bone:", bone)
                            print("count/f:", count)
                            print("time   :", rot_time)
                            print("rot xyz:", x,y,z)

                    file_content['joints'][bone]['rot_data'].extend(time_data)
                    file_content['joints'][bone]['rot_data'].extend((x).to_bytes(2, byteorder='little'))
                    file_content['joints'][bone]['rot_data'].extend((y).to_bytes(2, byteorder='little'))
                    file_content['joints'][bone]['rot_data'].extend((z).to_bytes(2, byteorder='little'))

                    count += 1

            if anim.mark_tol == True:
                file_loc_count = motion['joints'][bone]['tol']['loc_count']
            else:
                 file_loc_count = len(motion['joints'][bone]['loc'])

            file_content['joints'][bone]['loc_count'] = file_loc_count.to_bytes(4, byteorder='little')

            count = 0
            current_time = 0

            time_after = True
            if time_after == True:
                
                last_time = 0

                this_time = 0

                next_time = 0

            if file_loc_count > 0:
                file_content['joints'][bone]['loc_data'] = []

                for l in motion['joints'][bone]['loc_pose']:

                    if time_after == True:
                        
                        last_time = this_time
                        this_time = next_time
                        next_time = time_per_frame * (count + anim_start_frame)
                        current_time = this_time
                    
                    else:
                        current_time = time_per_frame * (count - anim_start_frame)

                    if anim.mark_tol == True:

                        if motion['joints'][bone]['tol']['loc'][count] == False: 
                            count += 1 
                            continue

                    loc_x, loc_y, loc_z = l

                    x = F32_to_U16(loc_x/LL_MAX_PELVIS_OFFSET, -1, 1)
                    y = F32_to_U16(loc_y/LL_MAX_PELVIS_OFFSET, -1, 1)
                    z = F32_to_U16(loc_z/LL_MAX_PELVIS_OFFSET, -1, 1)

                    loc_time = F32_to_U16(float(current_time), 0, total_time)
                    time_data = struct.pack("H", loc_time)

                    if preserve_interpolation == True:

                        if bone in frame_data:
                            if (count+1) in frame_data[bone]['loc']:
                                if frame_data[bone]['loc'][count+1]['interpolation'] == 'CONSTANT':
                                    snap_time = last_time + 0.001
                                    loc_time = F32_to_U16(float(snap_time), 0, total_time)
                                    time_data = struct.pack("H", loc_time)
                    
                    if testing == True:
                        if bone == 'mHipRight':
                            print("Bone:", bone)
                            print("count/f:", count)
                            print("time   :", loc_time)
                            print("loc xyz:", x,y,z)

                    file_content['joints'][bone]['loc_data'].extend(time_data)
                    file_content['joints'][bone]['loc_data'].extend((x).to_bytes(2, byteorder='little'))
                    file_content['joints'][bone]['loc_data'].extend((y).to_bytes(2, byteorder='little'))
                    file_content['joints'][bone]['loc_data'].extend((z).to_bytes(2, byteorder='little'))

                    count += 1

        file_content['constraints'] = {}
        file_content['constraints']['count'] = (0).to_bytes(4, byteorder='little')

        file_data = bytearray()

        for header in file_content['header']:
            file_data.extend( file_content['header'][header] )

        for bone in file_content['joints']:
            file_data.extend( file_content['joints'][bone]['name'] )
            file_data.extend( file_content['joints'][bone]['priority'] )
            file_data.extend( file_content['joints'][bone]['rot_count'] )
            if file_content['joints'][bone].get('rot_data') != None:
                file_data.extend( file_content['joints'][bone]['rot_data'] )
            file_data.extend( file_content['joints'][bone]['loc_count'] )
            if file_content['joints'][bone].get('loc_data') != None:
                file_data.extend( file_content['joints'][bone]['loc_data'] )
        
        file_data.extend( file_content['constraints']['count'] )

        filepath = self.properties.filepath
        animF = open(filepath, 'wb')
        animF.write(file_data)
        animF.close()

        file_length = len(file_data)
        if file_length > 250000:
            print("init::OnigiriExportSLAnimOld: Your file size is rather large, it may not upload.")
            popup("File is too large for Second Life, exported anyway.")
        print("len file_data:", len(file_data))

        if 1 == 0:
            print("- header item lengths -")
            for header in file_content['header']:
                file_data.extend( file_content['header'][header] )
                print("     length ", header, ":", str(len(file_content['header'][header])))
            print(" -header content -\n",
                "      version:", int.from_bytes( file_content['header']['version'], byteorder='little', signed=False ), "\n",
                "  sub version:", int.from_bytes( file_content['header']['sub_version'], byteorder='little', signed=True ), "\n",
                "base priority:", int.from_bytes( file_content['header']['base_priority'], byteorder='little', signed=False ), "\n",
                "  anim length:", struct.unpack('f', file_content['header']['anim_length'])[0]
                )
            
            count = 0
            name = ""
            for c in file_content['header']['emote_name'][:-1]:
                count += 1 
                if c == 0:
                    break
                name += str(chr(c))
            print(
                "    emote name:", name, "\n",
                
                "      loop in:", struct.unpack('f', file_content['header']['loop_in'])[0], "\n",
                "     loop out:", struct.unpack('f', file_content['header']['loop_out'])[0], "\n",
                "      ease in:", struct.unpack('f', file_content['header']['ease_in'])[0], "\n",
                "     ease out:", struct.unpack('f', file_content['header']['ease_out'])[0], "\n",
                "    hand pose:", int.from_bytes( file_content['header']['hand_pose'], byteorder='little', signed=False ), "\n",
                "  joint count:", int.from_bytes( file_content['header']['joint_count'], byteorder='little', signed=False )
                )
            
            for bone in file_content['joints']:
                count = 0
                name = ""
                for c in file_content['joints'][bone]['name'][:-1]:
                    count += 1
                    if c == 0:
                        break
                    name += str(chr(c))
                print("    joint name:", name)
                print("         priority:", int.from_bytes( file_content['joints'][name]['priority'], byteorder='little', signed=True ))
                print("",
                "        rot count:", int.from_bytes( file_content['joints'][name]['rot_count'], byteorder='little', signed=True )
                    )

                if file_content['joints'][name].get('rot_data') != None:
                    print("           keys -")
                    rots = file_content['joints'][name]['rot_data']
                    for c in range(0, len(rots), 8):
                        
                        t = int.from_bytes(rots[c:c+2], byteorder='little', signed=False)
                        x = int.from_bytes(rots[c+2:c+4], byteorder='little', signed=False)
                        y = int.from_bytes(rots[c+4:c+6], byteorder='little', signed=False)
                        z = int.from_bytes(rots[c+6:c+8], byteorder='little', signed=False)
                        print("",
                        "               duration:", t, "\n",
                        "                  angle:", x, y, z
                        )

                print("",
                "        loc count:", int.from_bytes( file_content['joints'][name]['loc_count'], byteorder='little', signed=True )
                    )
                
                if file_content['joints'][name].get('loc_data') != None:
                    print("           keys -")
                    locs = file_content['joints'][name]['loc_data']
                    for c in range(len(locs)):
                        
                        t = int.from_bytes(locs[c:c+2], byteorder='little', signed=False)
                        x = int.from_bytes(locs[c+2:c+4], byteorder='little', signed=False)
                        y = int.from_bytes(locs[c+4:c+6], byteorder='little', signed=False)
                        z = int.from_bytes(locs[c+6:c+8], byteorder='little', signed=False)
                        print("",
                        "               duration:", t, "\n",
                        "               location:", x, y, z
                        )

        print("anim export done!")

        bpy.context.scene.bb_anim.property_unset("export_sl_anim_old_label")
        
        bpy.context.scene.bb_anim.property_unset("export_sl_anim_old_label_short")
        anim.export_sl_anim_old_alert = False

        rigutils.restore_hide_state(hide_state)

        return {'FINISHED'}

class OnigiriExportSLPose(bpy.types.Operator, ExportHelper):
    """This is a 3 frame animation that exports at priority 6 with a loop from its
second to third frame, where all of the bones have been flagged as animated in order
to give you a frozen/static pose, except for some goofy bones"""

    bl_idname = "onigiri.export_sl_pose"
    bl_label = "Pose .anim"

    filename_ext = ".anim"
    filter_glob : bpy.props.StringProperty(
        default='*.anim',
        options={'HIDDEN'}
        )

    filename : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        bpy.context.scene.bb_anim.anim_save_path = save_path
        self.filepath = save_path + bpy.context.scene.bb_anim.anim_base_name
        wm = context.window_manager.fileselect_add(self)

        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb = bpy.context.scene.onigiri
        bba = bpy.context.scene.bb_anim_props
        anim = bpy.context.scene.bb_anim
        bb_anim = anim

        obj = bpy.data.objects
        armObj = bpy.context.selected_objects[0]
        arm = armObj.name
        bpy.app.timers.register(cleanup)

        old_mode = bpy.context.mode
        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        frame_current = bpy.context.scene.frame_current

        anim_start_frame = bb.animation_start_frame
        anim_end_frame = bb.animation_end_frame
        anim_fps = bb.animation_fps
        anim_loop = bb_anim.anim_loop
        anim_loop_advanced = anim.anim_loop_advanced
        anim_loop_in_frame = anim.anim_loop_in_frame
        anim_loop_out_frame = anim.anim_loop_out_frame
        disable_location_offsets = bba.disable_location_offsets
        export_volume_motion = bb.export_volume_motion
        mark_tol = anim.mark_tol
        mark_tol_rot = anim.mark_tol_rot
        mark_tol_loc = anim.mark_tol_loc
        fill_missing_keys = bba.fill_missing_keys
        high_fidelity = bb_anim.anim_high_fidelity
        anim_resample = anim.anim_resample
        anim_resample_rate_rotation = anim.anim_resample_rate_rotation
        anim_resample_rate_location = anim.anim_resample_rate_location
        base_priority = bb_anim.anim_base_priority

        bpy.ops.object.duplicate()
        proxyObj = bpy.context.object
        proxy = proxyObj.name

        if 'scratchpad' in bpy.data.actions:
            scratchpad = bpy.data.actions['scratchpad']
            bpy.data.actions.remove(scratchpad)
        scratchpad = bpy.data.actions.new("scratchpad")
        has_anim = False
        if proxyObj.animation_data != None:
            if proxyObj.animation_data.action != None:
                has_anim = True
        if has_anim == False:
            proxyObj.animation_data_create()

        proxyObj.animation_data.action = scratchpad

        for boneObj in proxyObj.pose.bones:

            pmat = boneObj.matrix.copy()
            boneObj.matrix = pmat

            rotation_mode = boneObj.rotation_mode
            if rotation_mode == 'QUATERNION':
                rmode = 'rotation_quaternion'
            else:
                rmode = 'rotation_euler'
            boneObj.keyframe_insert(data_path=rmode, frame=frame_current)
            boneObj.keyframe_insert(data_path='location', frame=frame_current)

        animutils.remove_deps(armature=proxyObj.name)
        bpy.context.view_layer.update()

        frame_now = frame_current - 1
        bpy.context.scene.frame_set(frame_now)

        if bb.export_attachment_motion == False:
            bpy.ops.object.mode_set(mode='EDIT')
            for boneObj in proxyObj.data.edit_bones:
                bone = boneObj.name
                if bone in skel.avatar_skeleton:
                    if skel.avatar_skeleton[bone]['type'] == "attachment":
                        proxyObj.data.edit_bones.remove(boneObj)
            bpy.ops.object.mode_set(mode='OBJECT')

        for boneObj in proxyObj.pose.bones:
            rotation_mode = boneObj.rotation_mode
            if rotation_mode == 'QUATERNION':
                rmode = 'rotation_quaternion'
            else:
                rmode = 'rotation_euler'
            boneObj.keyframe_insert(data_path=rmode, frame=frame_now)
            boneObj.keyframe_insert(data_path='location', frame=frame_now)

        frame_now = frame_current - 2
        bpy.context.scene.frame_set(frame_now)

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action='SELECT')
        bpy.ops.pose.transforms_clear()
        bpy.ops.object.mode_set(mode='OBJECT')

        for boneObj in proxyObj.pose.bones:
            rotation_mode = boneObj.rotation_mode
            if rotation_mode == 'QUATERNION':
                rmode = 'rotation_quaternion'
            else:
                rmode = 'rotation_euler'
            boneObj.keyframe_insert(data_path=rmode, frame=frame_now)
            boneObj.keyframe_insert(data_path='location', frame=frame_now)

        frame_start, frame_end = proxyObj.animation_data.action.frame_range
        bb_anim.anim_loop = True
        anim.anim_loop_advanced = False
        anim.anim_loop_in_frame = frame_current - 1
        anim.anim_loop_out_frame = frame_current
        bb.animation_start_frame = frame_start
        bb.animation_end_frame = frame_end
        bb.animation_fps = 5
        bb_anim.anim_base_priority = 6
        anim.mark_tol = False
        anim.anim_resample = False
        bba.fill_missing_keys = False
        bb_anim.anim_high_fidelity = False
        bba.disable_location_offsets = True
        bb.export_volume_motion = False

        print("Call to animutils::export_sl_anim will throw an error if the time line is not in sync")

        animutils.export_sl_anim(armature=proxy, path=self.properties.filepath)

        bpy.context.scene.frame_set(frame_current)

        bpy.ops.object.delete()
        a = bpy.data.actions['scratchpad']
        bpy.data.actions.remove(a)

        bb.animation_start_frame = anim_start_frame
        bb.animation_end_frame = anim_end_frame
        bb.animation_fps = anim_fps
        bba.disable_location_offsets = disable_location_offsets
        bb.export_volume_motion = export_volume_motion
        anim.mark_tol = mark_tol
        anim.mark_tol_rot = mark_tol_rot
        anim.mark_tol_loc = mark_tol_loc
        bba.fill_missing_keys = fill_missing_keys
        bb_anim.anim_high_fidelity = high_fidelity
        anim.anim_resample = anim_resample
        anim.anim_resample_rate_rotation = anim_resample_rate_rotation
        anim.anim_resample_rate_location = anim_resample_rate_location

        bb_anim.anim_loop = anim_loop
        anim.anim_loop_advanced = anim_loop_advanced
        anim.anim_loop_in_frame = anim_loop_in_frame
        anim.anim_loop_out_frame  = anim_loop_out_frame
        bb_anim.anim_base_priority = base_priority

        armObj.select_set(True)
        bpy.context.view_layer.objects.active = armObj
        bpy.ops.object.mode_set(mode=old_mode)

        return {'FINISHED'}

class OnigiriAddEmote(bpy.types.Operator):
    """Any of the buttons listed here will enable export of the named emote.  To remove the
emote just cick the (Clear) button.  When you assign an emote the button will show a check"""

    bl_idname = "onigiri.add_emote"
    bl_label = "Enable an emote for the exported animation"

    emote : bpy.props.StringProperty(default = "")

    def execute(self, context):
        anim = bpy.context.scene.bb_anim
        obj = bpy.data.objects

        anim.anim_emote_name = self.emote

        return {'FINISHED'}

class OnigiriMapperExport(bpy.types.Operator, ExportHelper):
    """Export your custom mapped mesh / character(s).  This is a different process than the SL / OS exporter.
Use this one for your mapped characters or Animesh, it's non-descructive.  The use for this is very obvious
when using auto-map"""

    bl_idname = "onigiri.mapper_export"
    bl_label = "Custom dae Exporter"

    type : bpy.props.StringProperty(default="")

    filename_ext = ".dae"
    filter_glob : bpy.props.StringProperty(
        default='*.dae',
        options={'HIDDEN'}
    )

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper

        if bmp.mapper_source_name == "":
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bmp = bpy.context.window_manager.bb_mapper
        bb_mesh = bpy.context.scene.bb_mesh

        active = bpy.context.active_object
        selected = [a for a in bpy.context.selected_objects]
        
        old_mode = bpy.context.mode

        mesh = list()
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                mesh.append(o.name)

        if len(mesh) == 0:
            txt = "No mesh objects selected"
            print(txt)
            popup(txt, "Error", "ERROR")
            return {'FINISHED'}

        mesh_rigs = {}
        for m in mesh:
            arm = get_mesh_armature(mesh=m)
            if arm == False:
                print("get_mesh_armature returned False:", m)
                return {'FINISHED'}
            
            mesh_rigs[m] = arm

        print("OnigiriMapperExport reports: passed armature modifier check")

        if bpy.context.mode != 'OBJECT' and len(bpy.context.selected_objects) > 0:
            bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')

        for m in mesh_rigs:
            arm = mesh_rigs[m]
            
            obj[m]['name'] = m
            obj[arm]['name'] = arm
            
            bpy.data.objects[m].select_set(True)
            bpy.data.objects[arm].select_set(True)

        obj[bmp.mapper_source_name].select_set(True)

        bpy.context.view_layer.objects.active = bpy.data.objects[m]

        bpy.ops.object.duplicate()

        count = 0
        for o in bpy.context.selected_objects:
            n = obj[o.name]['name']

            obj[o.name]['name'] = n + "_" + get_unique_name_short() + "_" + str(count)
            count += 1
        
        for o in bpy.context.selected_objects:
            o.name = o['name']
            
            if o.get('role') == "source":
                print("Found source rig for pairing:", o.name)
                source = o.name
                
                o.animation_data_clear()
            
        for o in bpy.context.selected_objects:
            print("new names:", o.name)
            if o.type == 'ARMATURE':
                o.animation_data_clear()

        mesh = list()
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                mesh.append(o.name)

        rig_names = list()
        mesh_rigs = {}
        for m in mesh:
            arm = get_mesh_armature(mesh=m)
            if arm == False:
                print("get_mesh_armature returned False:", m)
                return {'FINISHED'}
            
            mesh_rigs[m] = arm

            if arm not in rig_names:
                rig_names.append(arm)

        for o in bpy.context.selected_objects:
            o.select_set(False)

        print("OnigiriMapperExport reports: rebinding...")
        for arm in rig_names:
            print("about to rebind for rig:", arm)
            rigutils.rebind(arm)

        print("OnigiriMapperExport reports: applying transforms to mesh object(s)")
        for arm in rig_names:
            apply_transforms(object=arm, rotation=True, scale=True, location=True)
            print("applied transforms to armature :", arm)
        for mesh in mesh_rigs:
            apply_transforms(object=mesh, rotation=True, scale=True, location=True)
            print("applied transforms to mesh:", mesh)

        if bb_mesh.remove_empty_groups == True:
            for m in mesh_rigs:
                obj[m].select_set(True)
            print("Removing empty vertex groups")
            bpy.ops.onigiri.remove_unused_groups(method="best")

        for o in bpy.context.selected_objects:
            o.select_set(False)
        for m in mesh_rigs:
            obj[m].select_set(True)
            bpy.context.view_layer.objects.active = obj[arm]
            arm = mesh_rigs[m]
            for g in obj[m].vertex_groups:
                if g.name not in obj[arm].data.bones:
                    print("Missing bone in armature", arm, "for vertex group", g.name, "removed")
                    obj[m].vertex_groups.remove(g)
            obj[m].select_set(False)

        source_map = obj[source]['bone_map'].to_dict()
        rename_map = {}
        for arm in rig_names:
            rename_map[arm] = {}
            print("processing target armature:", arm)
            bone_map = obj[arm]['bone_map'].to_dict()
            for tbone in bone_map:
                (sarm, sbone), = bone_map[tbone].items()
                if tbone not in obj[arm].data.bones:
                    print("Skipping missing target bone:", tbone)
                    continue
                
                for i in range(100):
                    tname = utils.get_temp_name() + "_" + str(i)
                    
                    if tname not in obj[arm].data.bones and tname not in obj[source].data.bones and tname not in rename_map[arm]:
                        rename_map[arm][tbone] = {}
                        rename_map[arm][tbone]['temp'] = tname
                        rename_map[arm][tbone]['sbone'] = sbone
                        break
                if i >98:
                    
                    print("Fatal error, this shouldn't happen, there may be a runaway process preventing a rename")
                    popup("Fatal error when processing bones, see console", "Error", "ERROR")
                    for o in bpy.context.selected_objects:
                        o.select_set(False)
                    for m in mesh_rigs:
                        r = mesh_rigs[m]
                        obj[m].select_set(True)
                        obj[r].select_set(True)
                    bpy.ops.object.delete()
                    return {'FINISHED'}
        
        for arm in rename_map:
            for tbone in rename_map[arm]:
                obj[arm].data.bones[tbone].name = rename_map[arm][tbone]['temp']
        
        for arm in rename_map:
            for tbone in rename_map[arm]:
                temp = rename_map[arm][tbone]['temp']
                obj[arm].data.bones[temp].name = rename_map[arm][tbone]['sbone']
        
        apply_transforms(object=source, rotation=True, scale=True, location=True)
        apply_rest_pose(armature=source)

        for m in mesh_rigs:
            a = mesh_rigs[m]
            obj[m].select_set(True)

            mod = get_mesh_armature_modifier(mesh=m)

            attach_armature_modifier(mesh=m, mod=mod, arm=source)

            obj[m].parent = obj[source]

        file_out_temp = tempfile.gettempdir() + "/onigiri_" + get_unique_name_short() + ".dae"

        delete_files = list()
        delete_files.append(file_out_temp)

        if bb_mesh.remove_empty_groups == True:
            print("Removing empty vertex groups")
            bpy.ops.onigiri.remove_unused_groups(method="best")

        bb_mesh = bpy.context.scene.bb_mesh

        bpy.ops.wm.collada_export(
            filepath = file_out_temp,
            check_existing = True,
            apply_modifiers = bb_mesh.export_apply_modifiers,
            selected = True,
            include_children = False,
            include_armatures = True,
            include_shapekeys = False,
            include_animations=False,
            deform_bones_only = True,
            triangulate = False,
            use_object_instantiation = False,
            use_blender_profile = True,
            sort_by_name = True,
            export_object_transformation_type_selection = 'matrix',
            
            open_sim = True,
            export_global_forward_selection='-X',
            export_global_up_selection='Z',
            apply_global_orientation=True,
            )

        print("Phase 1 finished!")

        if bmp.mapper_fitted == True:
            if 1 == 1:
                print("BB adjusting matrices...")
                ET.register_namespace('',"http://www.collada.org/2005/11/COLLADASchema")
                tree = ET.parse(file_out_temp)
                root = tree.getroot()
                
                controllers = fix_bind_matrices(root, transform=1)
                condition_matrices(controllers)
                print("Finished adjusting matrices, writing dae file:", self.properties.filepath)
                tree.write(self.properties.filepath,
                    xml_declaration = True,
                    encoding = 'utf-8',
                    method = 'xml'
                    )
                print("Finished!")

        else:
            shutil.copyfile(file_out_temp, self.properties.filepath)

        for f in delete_files:
            try:
                os.remove(f)
                print("BB dae cleanup on rename pass removing file:", f)
            except:
                print("BB Warning: unable to remove temporary file:", f)

        for mesh in mesh_rigs:
            arm = mesh_rigs[mesh]
            obj[mesh].select_set(True)
            obj[arm].select_set(True)

            print("selected arm/mesh:", arm, mesh)

        bpy.ops.object.delete()

        if old_mode == 'OBJECT':
            for o in selected:
                o.select_set(True)
            bpy.context.view_layer.objects.active = active

        print("Onigiri collada export complete")

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriForceRigToClass(bpy.types.Operator):
    """Try to force a foreign rig into a certain class, including Avastar rigs.  If your
conversion was successful you may want to swap over to a Onigiri rig.
"""

    bl_idname = "onigiri.force_rig_to_class"
    bl_label = "force to class"

    rig_class : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            o = bpy.context.selected_objects[0]
            if o.type == 'ARMATURE':
                if o.get('rig_class') == None:
                    return True
        return False

    def execute(self, context):
        arm = bpy.context.selected_objects[0].name
        rigutils.force_rig_to_class(armature=arm, rig_class=self.rig_class)
        return {'FINISHED'}

class OnigiriCreateAnimationRig(bpy.types.Operator):
    """This rig has joint positions intended for animating the classic default
avatar in Second Life.  Many early animations were based on this and may give
you the synchronicity you need.  This is not compete yet, it's just a rig"""

    bl_idname = "onigiri.create_animation_rig"
    bl_label = "Create an SL animation rig"

    def execute(self, context):
        bb = bpy.context.scene.onigiri
        obj = bpy.data.objects

        if 1 == 0:
            armObj = rigutils.create_animation_rig(target="default", type="pos")
            if armObj == False:
                print("something bad happened")
            else:
                armObj["onigiri"] = bl_info['version']
                armObj["rig_class"] = "default"
                armObj["class_name"] = "default"
        
        object = bb_settings['files']['rigs']['types']['animation']

        has_collision = False
        if object in obj:
            print("Name collision, processing...")
            has_collision = True
            
            name1 = get_unique_name_short(prefix=object)
            if name1 == False:
                print("An attempt to generate a unique name for a Blender object failed, this could very well be a bug")
                popup("Houston we have a problem!  Name collision, check console", "Name Collision 98", "ERROR")
                return {'FINISHED'}

            bpy.ops.mesh.primitive_cube_add(size=0.5, enter_editmode=False, location=(0, 0, 0))
            name2 = bpy.context.object.name
            bpy.ops.object.delete()

            obj[object].name = name2

        path = script_dir + presets_path
        file = bb_settings['files']['rigs']['lib']

        full_path = path + file

        filepath = path + file + "/Object/" + object + "/"
        directory = full_path + "/Object/"
        filename = object

        if os.path.exists(full_path) == False:
            print("OnigiriCreateAnimationRig reports: missing data", full_path)
            popup("External rig data is missing, your installation might be damaged")
            return {'FINISHED'}

        bpy.ops.wm.append(
            filepath = filepath,
            directory = directory,
            filename = filename,
            )
        
        bbRig = bpy.context.selected_objects[0]
        bpy.context.view_layer.objects.active = bbRig
        print("Loaded animation rig:", bbRig.name)

        if has_collision == True:
            print("Name collision, new name is:", name1)
            bbRig.name = name1
            obj[name2].name = object

        return {'FINISHED'}

class OnigiriCreateOldRig(bpy.types.Operator):
    """This is the rig used before the Bento project, it contains 52 bones including
the volume/collision bones.  It is rarely used in new content but some kits, even
new ones, are a little broken, so this option is here for you and used by the system"""

    bl_idname = "onigiri.create_old_rig"
    bl_label = "Create an old 52 bone rig"

    def execute(self, context):
        bb = bpy.context.scene.onigiri

        armObj = rigutils.create_rig(target="basic")
        if armObj == False:
            print("something bad happened")
        else:
            armObj["onigiri"] = bl_info['version']
            armObj["rig_class"] = "pos"
            armObj["class_name"] = "pos"
            armObj["legacy"] = True
            rigutils.save_rig(armObj.name)

        return {'FINISHED'}

class OnigiriAttachProxyRig(bpy.types.Operator):
    """This copies your rig and attaches the original bones to that copy using direct controllers for Rotation,
Location and Scale so that the original is fully glued to the copy/proxy.  There's an option remove original
controllers, constraints"""

    bl_idname = "onigiri.attach_proxy_rig"
    bl_label = "Attach Controllers"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_rig = bpy.context.window_manager.bb_rig
        obj = bpy.data.objects
        sarmObj = bpy.context.object
        sarm = sarmObj.name

        proxyObj = sarmObj.get('has_proxy')
        animObj = None
        if proxyObj:
            
            try:
                if proxyObj.name in obj:
                    if proxyObj.animation_data != None:
                        if proxyObj.animation_data.action != None:
                            animObj = proxyObj.animation_data.action
                            
                    sarmObj.select_set(False)
                    proxyObj.select_set(True)
                    bpy.context.view_layer.objects.active = proxyObj
                    bpy.ops.object.delete()
                    sarmObj.select_set(True)
                    bpy.context.view_layer.objects.active = sarmObj
            except:
                pass
        
        sarmObj.pop('has_proxy', "")

        tarm = rigutils.attach_proxy_rig(armature=sarm, clean=bb_rig.rig_clean)

        if tarm == False:
            print("There was a problem adding the control rig:", sarm)
        else:
            print("Controller attached:", sarm)
            sarmObj['has_proxy'] = obj[tarm] 
            obj[tarm]['is_proxy'] = sarmObj

        if animObj:
            sarmObj.animation_data_create()
            proxyObj.animation_data.action = animObj

        is_proxy = sarmObj.get('is_proxy')
        if is_proxy:
            print("The item you've added a proxy to is already a proxy, I did it anyway but expect goofy results")
            try:
                if is_proxy.name in obj:
                    print("The item that this is proxied to is:", is_proxy.name, "and you should examine this chain for errors")
                    popup("The item you proxied is also a proxy and has a rig attached already but I did it anyway, have run", "Info", "INFO")
            except:
                print("... in addition the attached item is missing so maybe it's ok.")
                popup("This is a proxy already but the attached item is missing so I removed the reference", "Info", "INFO")
                sarmObj.pop('is_proxy', "")

        return {'FINISHED'}

class OnigiriCreateSLRig(bpy.types.Operator):
    """This builds rig.  If you're making animations you may want to use the POS rig instead of this"""

    bl_idname = "onigiri.create_sl_rig"
    bl_label = "Create SL rig"

    rig_class : bpy.props.StringProperty(default="pos")

    def execute(self, context):
        bb_rig = bpy.context.window_manager.bb_rig
        rotate = bb_rig.rig_rotate

        armObj = rigutils.build_rig(rig_class=self.rig_class, rotate=rotate)

        if armObj == False:
            print("Couldn't build a", self.rig_class, "rig")
        else:
            print("Rig created:", armObj.name, "of class", self.rig_class)

        return {'FINISHED'}

class OnigiriCreateSLPosRig(bpy.types.Operator):
    """This builds a pos rig.  A pos rig gives you the least complications but may be visually
less appealing, initially, than other options.  You can use whatever you want but keep in mind
that your animations may suffer"""

    bl_idname = "onigiri.create_pos_rig"
    bl_label = "Create Pos rig"

    def execute(self, context):
        bb_rig = bpy.context.window_manager.bb_rig
        rotate = bb_rig.rig_rotate
        
        armObj = rigutils.build_rig(rig_class="pos", rotate=rotate, connect=False)
        if armObj == False:
            print("Couldn't build a pos rig")
        else:
            print("Rig created:", armObj.name, "of class pos")

        return {'FINISHED'}

class OnigiriCreateSLPivotRig(bpy.types.Operator):
    """This builds a pivot rig.  If you're animating use your source rig or a pos rig"""

    bl_idname = "onigiri.create_pivot_rig"
    bl_label = "Create Pivot rig"

    def execute(self, context):
        bb_rig = bpy.context.window_manager.bb_rig
        rotate = bb_rig.rig_rotate
        armObj = rigutils.build_rig(rig_class="pivot", rotate=rotate)
        if armObj == False:
            print("Couldn't build a pivot rig")
        else:
            print("Rig created:", armObj.name, "of class pivot")

        return {'FINISHED'}

class OnigiriCreateDefaultRig(bpy.types.Operator):
    """This is a custom rig used by Avastar"""

    bl_idname = "onigiri.create_default_rig"
    bl_label = "Create a default SL rig"

    def execute(self, context):
        bb = bpy.context.scene.onigiri

        armObj = rigutils.create_rig(target="default")
        if armObj == False:
            print("something bad happened")
        else:
            armObj["onigiri"] = bl_info['version']
            armObj["rig_class"] = "default"
            armObj["class_name"] = "default"

        return {'FINISHED'}

class OnigiriCreateNeutralRig(bpy.types.Operator):
    """This is a natural / neutral rig that represents a rig without sliders effecting
bone behavior, this doesn't actually exist in SL but the item was provided by another
tool for devkits so it's been used to make mesh"""

    bl_idname = "onigiri.create_neutral_rig"
    bl_label = "Create a neutral SL rig"

    def execute(self, context):

        armObj = rigutils.create_rig(target="neutral")
        if armObj == False:
            print("something bad happened")
        else:
            armObj["onigiri"] = bl_info['version']
            armObj["rig_class"] = "neutral"

        return {'FINISHED'}

class OnigiriCreateDevkitRig(bpy.types.Operator):
    """Please do not use any of these unless you are repairing a devkit produced
by Avastar"""

    bl_idname = "onigiri.create_devkit_rig"
    bl_label = "Create Devkit Rig"

    rig_class : bpy.props.StringProperty(default="female_neutral")

    def execute(self, context):
        armObj = rigutils.build_devkit_rig(target=self.rig_class)
        return {'FINISHED'}

class OnigiriCreateMaleRig(bpy.types.Operator):
    """This is a male rig.  This is not recommended but it's here for you to use with
your old devkits if needed."""

    bl_idname = "onigiri.create_male_rig"
    bl_label = "Create a male SL rig"

    rig_class : bpy.props.StringProperty(default="default")

    def execute(self, context):
        bb = bpy.context.scene.onigiri

        armObj = rigutils.create_rig(target=self.rig_class)
        if armObj == False:
            print("something bad happened")
        else:
            armObj["onigiri"] = bl_info['version']
            armObj["rig_class"] = self.rig_class
            armObj["class_name"] = self.rig_class

        return {'FINISHED'}

class OnigiriCreateRig(bpy.types.Operator):
    """Create a clean Second Life  skeleton.  This skeleton is useful for making your own characters and for
the associated garments as well as standard mesh."""

    bl_idname = "onigiri.add_standard_rig"
    bl_label = "bb_add_standard_rig"

    def execute(self, context):
        bb = bpy.context.scene.onigiri

        for flag in bb_flags:
            bb_flags[flag] = getattr(bpy.context.scene.onigiri, flag)

        if getattr(bpy.context.scene.onigiri, 'pos_rig') == True:
            bb_rig = create_rig(skel_type="pos", add_control_rig=bb.add_control_rig)
        else:
            bb_rig = create_rig(skel_type="pivot", add_control_rig=bb.add_control_rig)

        bpy.data.objects[bb_rig.name]["onigiri_control_rig"] = bpy.context.scene.onigiri.add_control_rig
        
        bpy.data.objects[bb_rig.name]["onigiri"] = bl_info['version']
        setattr(context.scene, "bone_source", bb_rig.name)
        return {'FINISHED'}

class OnigiriReferenceRig(bpy.types.Operator):
    """ This button generates a Second Life skeleton rig for human character creation and animation"""

    bl_idname = "onigiri.add_reference_rig"
    bl_label = "bb_add_reference_rig"

    @classmethod
    def poll(cls, context):
        if getattr(context.scene.onigiri, "selected_reference") == True:
            if context.scene.bone_source == "":
                return False
        return True

    def execute(self, context):
        bb = bpy.context.scene.onigiri

        for flag in bb_flags:
            bb_flags[flag] = getattr(bpy.context.scene.onigiri, flag)

        if getattr(context.scene.onigiri, "selected_reference") == True:
            ref_arm = getattr(context.scene, "bone_source")
            if ref_arm == "":
                popup("No source rig for reference is chosen.  Use the the bone source dropdown list.")
                print("You've enabled the Selected Reference button so you'll need to choose a reference rig in the dropdown list.")
                return {'FINISHED'}

            if bpy.data.objects.get(ref_arm) is None:
                print("Object missing for selected_reference")
                popup("There's not reference to build from", "Rig Error", "ERROR")
                return {'FINISHED'}

            if bpy.data.objects[ref_arm].type != 'ARMATURE':
                print("The reference must be an armature.")
                popup("No suitable object reference was chosen", "Invalid Reference", "ERROR")
                return {'FINISHED'}

            print("FIRST IF WORKS")
            bb_rig = create_selected_reference_rig(ref_arm, "OnigiriSelRef", bb.add_control_rig)

            bpy.data.objects[bb_rig.name]["onigiri"] = bl_info['version']
            setattr(context.scene, "bone_source", bb_rig.name)

        elif getattr(context.scene.onigiri, "neutral_reference") == True:
            print("SECOND IF ELIF")
            bb_rig = create_neutral_reference_rig("OnigiriRef", bb.add_control_rig)
            bpy.data.objects[bb_rig.name]["onigiri"] = bl_info['version']
            setattr(context.scene, "bone_source", bb_rig.name)
        else:
            print("ELSE WAS TRIGGERED")
            print("do we need a control rig for this one?")
            
            bb_rig = create_default_reference_rig("OnigiriRef", add_control_rig=bb.add_control_rig)
            bpy.data.objects[bb_rig.name]["onigiri"] = bl_info['version']
            setattr(context.scene, "bone_source", bb_rig.name)

        bpy.data.objects[bb_rig.name]["onigiri_control_rig"] = bpy.context.scene.onigiri.add_control_rig

        print("bpy.context.scene.onigiri.add_control_rig:", bpy.context.scene.onigiri.add_control_rig)

        return {'FINISHED'}

class OnigiriChangeRigPrefix(bpy.types.Operator):
    """Use the text field to change the prefix or remove it, then click this. Do not change the Second Life armature"""
    bl_idname = "onigiri.change_rig_prefix"
    bl_label = "Change or remove the prefix for the bones in this rig"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False

        return True

    def execute(self, context):
        
        def tickle_groups():
            print("------------------")
            print("Bledner 3 bug hooper engaged!")
            print("------------------")
            children = armObj.children
            for meshObj in children:
                if meshObj.type == 'MESH':
                    if len(meshObj.vertex_groups) > 0:
                        vgroups = meshObj.vertex_groups
                        for g in vgroups:
                            print(" -", g.name)
                            vgroups.active_index = vgroups[g.name].index
                            
        brp = bpy.context.window_manager.bb_rigprops
        armObj = bpy.context.selected_objects[0]
        arm = armObj.name
        
        if brp.bone_prefix_name == rigutils.get_bone_prefix():
            print("Same prefix")
            return {'FINISHED'}

        bone_prefix = get_bone_prefix(arm)
        remove_bone_prefix(arm, bone_prefix)
        
        print("Base property Rig / Bone prefix update may collide with armature ['rig_data'], removed!")
        
        if brp.bone_prefix_name == "":
            tickle_groups()
            return {'FINISHED'}

        else:
            for b in armObj.data.bones:
                b.name = brp.bone_prefix_name + b.name

        brp.bone_prefix_name = ""

        tickle_groups()

        return {'FINISHED'}

class OnigiriChangeBonePrefix(bpy.types.Operator):
    """Use the text field to change the prefix or remove it, then click this. Do not change the Second Life armature"""
    bl_idname = "onigiri.change_bone_prefix"
    bl_label = "bb_change_bone_prefix"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        brp = bpy.context.window_manager.bb_rigprops
        
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            
            if brp.bone_prefix_last_armature == "":
                return True

            if brp.bone_prefix_last_armature not in obj:
                del brp['rig_data'][brp.bone_prefix_last_armature]
                
                brp.bone_prefix_last_armature = ""
                
                brp.bone_prefix_label = ""
                return True

        if len(selected) == 1:
            o = bpy.context.selected_objects[0]
            if o.type == 'ARMATURE':
                arm = o.name
                
                brp.bone_prefix_last_armature = arm
                
                if brp.get('rig_data') == None:
                    
                    brp['rig_data'] = {}
                
                if arm not in brp['rig_data']:
                    bone_prefix = get_bone_prefix(arm)
                    brp['rig_data'][arm] = {}
                    brp['rig_data'][arm]['bone_prefix'] = bone_prefix
                    brp.bone_prefix_label = bone_prefix
                else:
                    brp.bone_prefix_label = brp['rig_data'][arm]['bone_prefix']

                return True

        brp.bone_prefix_label = ""
        return False

    def execute(self, context):
        brp = bpy.context.window_manager.bb_rigprops
        armObj = bpy.context.selected_objects[0]

        arm = armObj.name

        if brp.bone_prefix_name == brp['rig_data'][arm]['bone_prefix']:
            print("Same prefix")
            return {'FINISHED'}

        bone_prefix = get_bone_prefix(arm)
        remove_bone_prefix(arm, bone_prefix)
        
        brp['rig_data'][arm]['bone_prefix'] = ""

        if brp.bone_prefix_name == "":
            return {'FINISHED'}

        else:
            for b in armObj.data.bones:
                b.name = brp.bone_prefix_name + b.name

        brp['rig_data'][arm]['bone_prefix'] = brp.bone_prefix_name

        brp.bone_prefix_name = ""

        return {'FINISHED'}

class OnigiriFixArmatureMeshLinks(bpy.types.Operator):
    """In some cases the Armature modifier's object property, the rig, is not the same as the parent of the object/mesh.
This needs to be repaired if it's to be used with Onigiri and/or Character Converter.  This happens with VRoid Studio"""

    bl_idname = "onigiri.fix_armature_mesh_links"
    bl_label = "bb_fix_armature_mesh_links"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) > 0:
            selected = bpy.context.selected_objects
            for obj in selected:
                if obj.type == 'MESH':
                    return True
        return False

    def execute(self, context):
        
        bba = bpy.context.scene.bb_anim_props
        obj = bpy.data.objects

        selected = bpy.context.selected_objects
        bpy.ops.object.select_all(action='DESELECT')

        for obj in selected:
            obj.parent = None
            
            obj.select_set(True)
            bpy.context.view_layer.objects.active = obj
            obj.rotation_mode = 'XYZ'
            bpy.ops.object.select_all(action='DESELECT')

        for obj in selected:
            
            obj.select_set(True)
            bpy.ops.object.visual_transform_apply()
            bpy.ops.object.constraints_clear()
            bpy.ops.object.select_all(action='DESELECT')

            if obj.type != 'MESH':
                continue

            modifiers = obj.modifiers

            for mod in modifiers:
                if mod.type == 'ARMATURE':
                    obj.parent = mod.object

        return {'FINISHED'}

class OnigiriSynchronizeMesh(bpy.types.Operator):
    """ Rebind
    Synchronize all of the mesh associated with this rig.  This will remove constrains and
    create a new rest pose.  It may not be what you want but often times you'll want this
    done before using Onigiri features.
    """
    bl_idname = "onigiri.sync_mesh_to_armature"
    bl_label = "Freeze current pose and rebind"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            obj = bpy.context.selected_objects[0]
            if obj.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        obj = bpy.data.objects
        old_mode = bpy.context.mode
        if old_mode == 'EDIT_ARMATURE':
            old_mode = 'EDIT'

        arm = bpy.context.selected_objects[0].name
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action = 'SELECT')
        bpy.ops.pose.constraints_clear()
        bpy.ops.pose.select_all(action = 'DESELECT')
        bpy.ops.object.mode_set(mode='OBJECT')
        
        bba = bpy.context.scene.bb_anim_props
        rigutils.rebind(arm, keep_animation=bba.rebind_keep_animation)

        for o in bpy.context.selected_objects:
            o.select_set(False)

        obj[arm].select_set(True)
        bpy.context.view_layer.objects.active = obj[arm]
        bpy.ops.object.mode_set(mode=old_mode)

        return {'FINISHED'}

class OnigiriRotationMode(bpy.types.Operator):
    """Sets the rotation mode on all selected bones.  If you don't know what that means then you don't need it yet."""
    bl_idname = "onigiri.rotation_mode"
    bl_label = "bb_rotation_mode"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            obj = bpy.context.selected_objects[0]
            if obj.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        bba = bpy.context.scene.bb_anim_props
        armObj = bpy.context.selected_objects[0]

        print("rotation_mode", bba.rotation_mode)
        if bpy.context.mode != 'POSE':
            
            armObj.rotation_mode = bba.rotation_mode
            return {'FINISHED'}

        for bone in bpy.context.selected_pose_bones:
            armObj.data.bones[bone.name].select = True
            armObj.pose.bones[bone.name].rotation_mode = bba.rotation_mode
            armObj.data.bones[bone.name].select = False
        return {'FINISHED'}

class OnigiriRotateRig(bpy.types.Operator):
    """This is not just a rotate button.  It applies the rotation to the rig and associated objects.
If all of your objects don't follow along then reload your data and use the (Fix Armature / Mesh Links) button, then try this again."""

    bl_idname = "onigiri.rotate_rig"
    bl_label = "bb_rotate_rig"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            obj = bpy.context.selected_objects[0]
            if obj.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        bba = bpy.context.scene.bb_anim_props

        armObj = bpy.context.selected_objects[0]

        children = armObj.children

        xrot = math.radians(bba.x_rotate_value)
        yrot = math.radians(bba.y_rotate_value)
        zrot = math.radians(bba.z_rotate_value)

        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)

        old_rot_mode = armObj.rotation_mode
        armObj.rotation_mode = 'XYZ'
        armObj.rotation_euler = (xrot, yrot, zrot)
        bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
        bpy.ops.object.select_all(action='DESELECT')
        armObj.rotation_mode = old_rot_mode

        for meshObj in children:
            meshObj.select_set(True)
            
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
            old_rot_mode = meshObj.rotation_mode
            meshObj.rotation_mode = 'XYZ'
            bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
            
            meshObj.rotation_mode = old_rot_mode
            bpy.ops.object.select_all(action='DESELECT')

        armObj.select_set(True)
 
        return {'FINISHED'}

class OnigiriRotateToggle(bpy.types.Operator):
    """Some of the Onigiri tools may not have been converted yet to use the new animation
system.  If you get weird deformations try using this on the rig that exports the animations,
it's from the old system that we shouldn't need anymore"""

    bl_idname = "onigiri.rotate_toggle"
    bl_label = "Apply SL Transform Rotation"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            obj = bpy.context.selected_objects[0]
            if obj.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        
        armObj = bpy.context.selected_objects[0]
        print("Rotate toggle on", armObj.name)
        rotate_toggle(armObj.name)
        return {'FINISHED'}

class OnigiriShowRigConfig(bpy.types.Operator):
    """Toggle the rig from / to different classes and types"""
    bl_idname = "onigiri.show_rig_config"
    bl_label = "Toggle rig to different classes and types"

    @classmethod
    def poll(cls, context):
        return False

    def execute(self, context):
        pass
        
        return {'FINISHED'}

class OnigiriConvertAvastarRig(bpy.types.Operator):
    """Converting your Avastar rig to a Onigiri rig will give you a more
stream-lined work-flow and prevent some common problems as wella speed up the
processing"""

    bl_idname = "onigiri.convert_avastar_rig"
    bl_label = "Convert Avastar rig to Onigiri"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            o = bpy.context.selected_objects[0]
            if o.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        bb_misc = bpy.context.window_manager.bb_misc
        
        avaRig = bpy.context.selected_objects[0]

        if avaRig.get('avastar') == None:
            print("Not an avastar rig")
            popup("This does not appear to be an Avastar rig", "Not an Avastar Rig", "ERROR")
            return {'FINISHED'}
        if avaRig.get('avastar') != None and avaRig.get('onigiri') != None:
            print("This appears to already be converted")
            popup("It appears as though this rig has already been converted", "Already Converted", "INFO")
            return {'FINISHED'}

        old_mode = bpy.context.mode
        if old_mode == 'EDIT_ARMATURE':
            old_mode == 'EDIT'

        bpy.ops.object.mode_set(mode='OBJECT')

        rigutils.remove_deps(avaRig.name)

        bpy.context.scene.frame_set(1)

        layers = [True for i in avaRig.data.layers] 
        avaRig.data.layers = layers

        pose_mats = dict()
        edit_bones = dict()
        for boneObj in avaRig.pose.bones:
            pose_mats[boneObj.name] = boneObj.matrix.copy()
        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in avaRig.data.edit_bones:
            
            boneObj.hide = False
            boneObj.hide_select = False
            parent = None
            if boneObj.parent:
                parent = boneObj.parent.name
            edit_bones[boneObj.name] = {
                "matrix": boneObj.matrix.copy(),
                "head": boneObj.head.copy(),
                "tail": boneObj.tail.copy(),
                "roll": boneObj.roll,
                "parent": parent,
                "use_connect": boneObj.use_connect,
                "use_deform": boneObj.use_deform,
                }
        bpy.ops.object.mode_set(mode='OBJECT')

        bbRig = rigutils.build_rig(rig_class="pos", rotate=True)

        bpy.context.view_layer.objects.active = bbRig

        bbRig.matrix_world = avaRig.matrix_world.copy()

        object_data = [
            "JointOffsetList",
            ]
        bone_props  = [
            "b0tail",
            "reltail",
            "rot0",
            "restpose_scale_y",
            "restpose_scale_x",
            "restpose_scale_z",
            "scale",
            "scale0",
            ]
        for p in object_data:
            if avaRig.get(p) != None:
                bbRig.data[p] = avaRig.data[p]
        for boneObj in bbRig.data.bones:
            if boneObj.name in avaRig.data.bones:
                for p in bone_props:
                    if avaRig.data.bones[boneObj.name].get(p) != None:
                        boneObj[p] = avaRig.data.bones[boneObj.name][p]
        
        if avaRig.get('avastar') != None:
            bbRig['avastar'] = avaRig['avastar']

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in bbRig.data.edit_bones:
            boneObj.use_connect = False
        bpy.ops.object.mode_set(mode='OBJECT')

        for bone in pose_mats:
            if bone in bbRig.pose.bones:
                bbRig.pose.bones[bone].matrix = pose_mats[bone]
        bpy.context.view_layer.update()

        bpy.ops.object.mode_set(mode='EDIT')

        if 1 == 0:
        
            for bone in mod_data.misc_bones:
                newBone = bbRig.data.edit_bones.new(bone)
                newBone.head = edit_bones[bone]['head']
                newBone.tail = edit_bones[bone]['tail']
                parent = edit_bones[bone]['parent']
                if parent:
                    newBone.parent = bbRig.data.edit_bones[parent]
                
                newBone.use_deform = False

        for bone in edit_bones:
            if bone in bbRig.data.edit_bones:
                bbRig.data.edit_bones[bone].matrix = edit_bones[bone]['matrix']
                bbRig.data.edit_bones[bone].head = edit_bones[bone]['head']
                bbRig.data.edit_bones[bone].tail = edit_bones[bone]['tail']
                
                if bb_misc.use_old_rig == True:
                    roll = 0.0
                    
                    if bone == 'mPelvis':
                        bbRig.data.edit_bones[bone].tail = edit_bones['mTorso']['head']
                        bbRig.data.edit_bones[bone].roll = 0.0
                    
                    elif bone == 'mHipRight':
                        roll = -0.13089969754219055
                    elif bone == 'mHipLeft':
                        roll = 0.13089969754219055
                    bbRig.data.edit_bones[bone].roll = roll
                else:
                    bbRig.data.edit_bones[bone].roll = edit_bones[bone]['roll']
                
                if 1 == 0:
                    if bone == 'mPelvis':
                        if bb_misc.use_old_rig == True:
                            parent = edit_bones[bone]['parent']
                            if parent:
                                bbRig.data.edit_bones[bone].parent = bbRig.data.edit_bones[parent]
        bpy.ops.object.mode_set(mode='OBJECT')

        for o in bpy.data.objects:
            if o.type == 'MESH':
                for m in o.modifiers:
                    if m.type == 'ARMATURE':
                        if m.object == avaRig:
                            o.parent = bbRig
                            m.object = bbRig
                            break
        
        bpy.ops.object.mode_set(mode='POSE')
        for boneObj in bbRig.data.bones:
            boneObj.select = True
        bpy.ops.pose.transforms_clear()
        bpy.ops.object.mode_set(mode='OBJECT')

        if 1 == 0:
        
            animObj = animutils.convert_animated_controllers(source=avaRig.name, target=bbRig.name)
            if animObj != False:
                print("Animation transferred from", avaRig.name, "to", bbRig.name)

            else:
                print("Unable to transfer the animation from", avaRig.name, "to", bbRig.name, "is there an animation?")

        bbRig.select_set(False)
        avaRig.select_set(True)
        bpy.context.view_layer.objects.active = avaRig
        bpy.ops.object.delete()
        bbRig.select_set(True)
        bpy.context.view_layer.objects.active = bbRig

        bpy.ops.object.mode_set(mode=old_mode)
        return {'FINISHED'}

class OnigiriConvertFromAvastar(bpy.types.Operator):
    """You can convert from Avastar to a Full Onigiri rig.  This may damage your
mesh export process so save your work.  Often the original Avastar rig is good enough
and if it's causing lag use the "Nuke" feature found elsewhere"""

    bl_idname = "onigiri.convert_from_avastar"
    bl_label = "Convert from Avastar"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            o = bpy.context.selected_objects[0]
            if o.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        bb_misc = bpy.context.window_manager.bb_misc
        
        avaRig = bpy.context.selected_objects[0]

        if avaRig.get('avastar') == None:
            print("Not an avastar rig")
            popup("This does not appear to be an Avastar rig", "Not an Avastar Rig", "ERROR")
            return {'FINISHED'}
        if avaRig.get('avastar') != None and avaRig.get('onigiri') != None:
            print("This appears to already be converted")
            popup("It appears as though this rig has already been converted", "Already Converted", "INFO")
            return {'FINISHED'}

        old_mode = bpy.context.mode
        if old_mode == 'EDIT_ARMATURE':
            old_mode == 'EDIT'

        bpy.ops.object.mode_set(mode='OBJECT')

        rigutils.remove_deps(avaRig.name)

        bpy.context.scene.frame_set(1)

        layers = [True for i in avaRig.data.layers] 
        avaRig.data.layers = layers

        utils.activate(avaRig)
        bpy.ops.object.mode_set(mode='EDIT')
        
        print("Removing control rig")
        control_bones = []
        for boneObj in avaRig.data.edit_bones:
            bone = boneObj.name
            if bone.startswith('a') or bone.startswith('m'):
                continue
            if bone in skel.avatar_skeleton:
                if skel.avatar_skeleton[bone]['type'] == 'collision':
                    continue
            avaRig.data.edit_bones.remove(boneObj)
            control_bones.append(bone)
        print("Bones removed:")
        print(control_bones)
        print("Renaming attachment bone to correct names for rebuilding...")
        bad_bones = []
        rename_bones = {}
        for boneObj in avaRig.data.edit_bones:
            bone = boneObj.name
            if bone.startswith('a'):
                abone = bone[1:] 
                if abone in skel.avatar_skeleton:
                    if skel.avatar_skeleton[abone]['type'] != 'attachment':
                        print("A noted 'a' bone was not found as an attachment bone, flagged for removal:", bone)
                        bad_bones.append(bone)
                    else:
                        rename_bones[bone] = abone
                else:
                    print("Unknown bone wearing an attachment bone disguise has been ignored and flagged for removal:", bone)
                    bad_bones.append(bone)

        print("Removing bad bones...")
        for bone in bad_bones:
            boneObj = avaRig.data.edit_bones[bone]
            avaRig.data.edit_bones.remove(boneObj)
        print("Renaming dumb bones...")
        for bone in rename_bones:
            boneObj = avaRig.data.edit_bones[bone]
            boneObj.name = rename_bones[bone]
        bpy.ops.object.mode_set(mode='OBJECT')
        
        pose_mats = dict()
        edit_bones = dict()
        for boneObj in avaRig.pose.bones:
            pose_mats[boneObj.name] = boneObj.matrix.copy()
        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in avaRig.data.edit_bones:
            
            boneObj.hide = False
            boneObj.hide_select = False
            parent = None
            if boneObj.parent:
                parent = boneObj.parent.name
            edit_bones[boneObj.name] = {
                "matrix": boneObj.matrix.copy(),
                "head": boneObj.head.copy(),
                "tail": boneObj.tail.copy(),
                "roll": boneObj.roll,
                "parent": parent,
                "use_connect": boneObj.use_connect,
                "use_deform": boneObj.use_deform,
                }
        bpy.ops.object.mode_set(mode='OBJECT')

        matrix_local = {}
        for boneObj in avaRig.data.bones:
            matrix_local[boneObj.name] = boneObj.matrix_local.copy()

        bbRig = rigutils.build_rig(rig_class="pos", rotate=True)
        bpy.context.view_layer.objects.active = bbRig
        
        bbRig.matrix_world = avaRig.matrix_world.copy()

        for p in avaRig.keys():
            bbRig[p] = avaRig[p]
        for boneObj in avaRig.pose.bones:
            bone = boneObj.name
            for p in avaRig.pose.bones[bone].keys():
                bbRig.pose.bones[bone][p] = avaRig.pose.bones[bone][p]
            for p in avaRig.data.bones[bone].keys():
                bbRig.data.bones[bone][p] = avaRig.data.bones[bone][p]
        
        edit_props = {}
        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in avaRig.data.edit_bones:
            for p in boneObj.keys():
                edit_props[boneObj.name] = p
        bpy.ops.object.mode_set(mode='OBJECT')
        bbRig.select_set(True)
        utils.activate(bbRig)
        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in bbRig.data.edit_bones:
            for p in edit_props:
                boneObj[p] = edit_props[p]
        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in bbRig.data.edit_bones:
            boneObj.use_connect = False
        bpy.ops.object.mode_set(mode='OBJECT')

        print("Matching custom bind pose...")
        for bone in pose_mats:
            if bone in bbRig.pose.bones:
                bbRig.pose.bones[bone].matrix = matrix_local[bone]
            bpy.context.view_layer.update()
        print(".")

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')

        bbRig.select_set(False)

        bpy.ops.object.mode_set(mode='EDIT')
        for bone in edit_bones:
            if bone in bbRig.data.bones:
                bbRig.data.edit_bones[bone].head = edit_bones[bone]['head']
                bbRig.data.edit_bones[bone].tail = edit_bones[bone]['tail']
                bbRig.data.edit_bones[bone].roll = edit_bones[bone]['roll']
        bpy.ops.object.mode_set(mode='OBJECT')

        for o in bpy.data.objects:
            if o.type == 'MESH':
                for m in o.modifiers:
                    if m.type == 'ARMATURE':
                        if m.object == avaRig:
                            o.parent = bbRig
                            m.object = bbRig
                            break
        
        if 1 == 1:
            print("Clearing pose transforms, this may not be needed...")
            
            bpy.ops.object.mode_set(mode='POSE')
            for boneObj in bbRig.data.bones:
                boneObj.select = True
            bpy.ops.pose.transforms_clear()
            bpy.ops.object.mode_set(mode='OBJECT')

        if 1 == 0:
        
            animObj = animutils.convert_animated_controllers(source=avaRig.name, target=bbRig.name)
            if animObj != False:
                print("Animation transferred from", avaRig.name, "to", bbRig.name)

            else:
                print("Unable to transfer the animation from", avaRig.name, "to", bbRig.name, "is there an animation?")

        bbRig.select_set(False)
        avaRig.select_set(True)
        bpy.context.view_layer.objects.active = avaRig
        bpy.ops.object.delete()
        bbRig.select_set(True)
        bpy.context.view_layer.objects.active = bbRig

        bbRig['avastar_converted'] = 1
        
        bpy.ops.object.mode_set(mode=old_mode)

        bone_groups = bbRig.get('bb_bone_groups')
        if bone_groups == None:
            print("No bone groups were found in order to set the UI")
        else:
            print("- Processing bone_groups to sync up toggles -")
            for group in bone_groups.keys():
                if "attach" in group.lower() or "volume" in group.lower():
                    print("Setting state of group", group, "to False")
                    rigutils.show_bones(armature=bbRig, group=group, state=False)
                else:
                    print("Setting state of group", group, "to True")
                    rigutils.show_bones(armature=bbRig, group=group, state=True)
        bbRig.data.display_type = 'STICK'
        bbRig.show_in_front = True

        return {'FINISHED'}

class OnigiriConvertToFullRigDISABLED(bpy.types.Operator):
    """Convert incomplete or partial Second Life compatible rig to a full Onigiri Rig so that
you can have more control over the associated animation, mesh and attachment features"""

    bl_idname = "onigiri.convert_to_full_rigDISABLED"
    bl_label = "Convert a partial SL rig to a full BB rig"

    @classmethod
    def poll(cls, context):
        
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        bb_misc = bpy.context.window_manager.bb_misc
        obj = bpy.data.objects
        old_mode = bpy.context.mode
        if old_mode == 'EDIT_ARMATURE':
            old_mode == 'EDIT'

        bpy.context.scene.frame_set(1)

        arms = list()
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                arms.append(o)

        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        qualified_rigs = list()
        rig_error = False
        for armObj in arms:

            for boneObj in armObj.data.bones:
                if boneObj.name in skel.avatar_skeleton:
                    print("Compatible bone found, adding rig:", armObj.name)
                    qualified_rigs.append(armObj)
                    break

        if len(qualified_rigs) == 0:
            print("None of the selected rigs are compatible with Second Life so cannot be converted")
            popup("No compatible rigs were selected", "Error", "ERROR")
            return {'FINISHED'}

        for o in bpy.context.selected_objects:
            o.select_set(False)

        for armObj in qualified_rigs:
            arm = armObj.name 

            print("Found qualified rig:", arm)

            pose_data = {}
            bone_data = {}
            edit_data = {}

            armObj.select_set(True)
            bpy.context.view_layer.objects.active = armObj

            for boneObj in armObj.pose.bones:
                pose_data[boneObj.name] = {}
                pose_data[boneObj.name]['matrix'] = boneObj.matrix.copy()
            for boneObj in armObj.data.bones:
                bone_data[boneObj.name] = {}
                bone_data[boneObj.name]['matrix'] = boneObj.matrix.copy()
            bpy.ops.object.mode_set(mode='EDIT')
            for boneObj in armObj.data.edit_bones:
                edit_data[boneObj.name] = {}
                edit_data[boneObj.name]['matrix'] = boneObj.matrix.copy()
                edit_data[boneObj.name]['head'] = boneObj.head.copy()
                edit_data[boneObj.name]['tail'] = boneObj.tail.copy()
                edit_data[boneObj.name]['roll'] = boneObj.roll
            bpy.ops.object.mode_set(mode='OBJECT')

            print("Convert rig to full needs an update to pos when the code is available")

            bpy.ops.onigiri.create_neutral_rig()

            bbRig = bpy.context.selected_objects[0]
            bbarm = bbRig.name 
            bpy.context.view_layer.objects.active = bbRig

            bbRig.matrix_world = armObj.matrix_world.copy()

            bpy.ops.object.mode_set(mode='EDIT')
            for boneObj in bbRig.data.edit_bones:
                boneObj.use_connect = False
            bpy.ops.object.mode_set(mode='OBJECT')

            for prop in obj[arm].keys():
                obj[bbarm][prop] = obj[arm][prop]

            bpy.ops.object.mode_set(mode='EDIT')
            for bone in edit_data:
                if bone not in bbRig.data.bones:
                    continue
                bbRig.data.edit_bones[bone].head = edit_data[bone]['head']
                bbRig.data.edit_bones[bone].tail = edit_data[bone]['tail']
                bbRig.data.edit_bones[bone].roll = edit_data[bone]['roll']
            bpy.ops.object.mode_set(mode='OBJECT')
            
            for childObj in armObj.children:
                for modObj in childObj.modifiers:
                    if modObj.type == 'ARMATURE':
                        modObj.object = bbRig
                        break
                childObj.parent = bbRig

            bbRig.show_in_front = True

            bbRig.select_set(False)
            armObj.select_set(True)
            bpy.context.view_layer.objects.active = armObj 

            bpy.ops.object.delete()

            bbRig['converted_to_full'] = 1 

        return {'FINISHED'}

class OnigiriConvertToFullRig(bpy.types.Operator):
    """Convert incomplete or partial Second Life compatible rig to a full Onigiri Rig so that
you can have more control over the associated animation, mesh and attachment features"""

    bl_idname = "onigiri.convert_to_full_rig"
    bl_label = "Convert to full rig"

    @classmethod
    def poll(cls, context):
        
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            return False
        rigs_count = 0
        for o in selected:
            if o.type == 'ARMATURE':
                rigs_count += 1
        if rigs_count != 1:
            return False
        return True

    def execute(self, context):
        bb_misc = bpy.context.window_manager.bb_misc
        obj = bpy.data.objects

        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                armObj = o
                break

        rotate = bb_misc.rig_rotate
        resize = bb_misc.rig_resize
        connect = bb_misc.rig_connect
        strip = bb_misc.rig_strip
        align = bb_misc.rig_align
        fix = bb_misc.rig_fix
        match = bb_misc.rig_match

        avadumb_bones = {'Origin', 'COG', 'PelvisInv', 'Tinker'}
        got_dumbed = False
        for bone in avadumb_bones:
            if bone in armObj.data.bones:
                got_dumbed = True
                break
        if got_dumbed == True:
            armObj.select_set(True)
            utils.activate(armObj)
            bpy.ops.onigiri.convert_from_avastar()
            
            armObj = bpy.context.object

        state = utils.get_state()

        frame_start, frame_end = animutils.get_frame_range(armObj, start=True)
        bpy.context.scene.frame_set(frame_start)

        if 1 == 0:
            print("Skipping new call to make_complete, add later")
            result = rigutils.make_complete(
                armature=armObj, rotate=True,
                fix=True, resize=resize)

        else:
            print("new call to make_complete, make sure it doesn't damage the kit")
            result = rigutils.make_complete(
                armature=armObj, rotate=rotate,
                resize=resize, connect=connect,
                strip=strip, align=align,
                fix=fix, match=match,)

        if result == False:
            print("Rig update failed")
            popup("Rig conversion failed", "Error", "ERROR")

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriRemoveRigData(bpy.types.Operator):
    """Remove the rig data set that was stored onto this rig.  A backup will be stored
before the data is removed, which you can recover using the (Restore Rig Data) button.
The reason for this feature is for debugging and experimenting"""

    bl_idname = "onigiri.remove_rig_data"
    bl_label = "Remove rig data"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type == 'ARMATURE':
            if bpy.context.selected_objects[0].get('rig_data') == None:
                return False
        return True

    def execute(self, context):
        armObj = bpy.context.selected_objects[0]
        bb_misc = bpy.context.window_manager.bb_misc

        if armObj.get('rig_data') != None:
            rb = armObj['rig_data'].to_dict()
            armObj['rig_data_backup'] = rb
            del armObj['rig_data']
            print("Removed rig_data and stored it to a backup")
            del rb
        else:
            print("No rig data, nothing to do")

        return {'FINISHED'}

class OnigiriManageRigData(bpy.types.Operator):
    """Store / Restore - the current bone properties from/to a data set in
the rig itself which is used when restoring the rig to its original form.  This is
used in special cases like recovering from rig a disaster"""

    bl_idname = "onigiri.manage_rig_data"
    bl_label = "Manage rig data"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        armObj = bpy.context.selected_objects[0]
        bb_misc = bpy.context.window_manager.bb_misc

        if self.action == "restore":
            if armObj.get('rig_data_backup') == None:
                popup("No rig data to restore", "Missing rig data", "ERROR")
            else:
                armObj['rig_data'] = armObj['rig_data_backup']
                popup("Rig data restored", "Restored", "INFO")
            return {'FINISHED'}
        elif self.action == "store":
            if armObj.get('rig_data') != None:
                
                if armObj.get('rig_data_backup') == None or bb_misc.overwrite_rig_data_backup == True:
                    rb = armObj['rig_data'].to_dict()
                    armObj['rig_data_backup'] = rb
                    del rb
            rigutils.save_rig(armature=armObj.name, force=True)
            
            if armObj.get('rig_data_backup') == None:
                rb = armObj['rig_data'].to_dict()
                armObj['rig_data_backup'] = rb
                del rb

        return {'FINISHED'}

class OnigiriAlterVolumeBoneScale(bpy.types.Operator):
    """Experimental
"""

    bl_idname = "onigiri.alter_volume_bone_scale"
    bl_label = "Alter Volume Bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        armObj = bpy.context.selected_objects[0]
        bb_misc = bpy.context.window_manager.bb_misc

        if self.action == "apply":
            for bone in volumes.vol_joints:
                if bone not in armObj.pose.bones:
                    continue
                scale = volumes.vol_joints[bone]['scale']
                armObj.pose.bones[bone].scale = scale
        elif self.action == "restore":
            for bone in volumes.vol_joints:
                if bone not in armObj.pose.bones:
                    continue
                armObj.pose.bones[bone].scale = 1,1,1

        return {'FINISHED'}

class OnigiriTransferObjectProperties(bpy.types.Operator):
    """These set of tools allow you to copy, paste object/rig properties from and to
objects as well as reset the internal data store and print it out into the System
Console for examination.  The dot indicates there's something in the buffer"""
    bl_idname = "onigiri.transfer_object_props"
    bl_label = "Transfer object properties"

    action : bpy.props.StringProperty(default = "")

    def execute(self, context):
        obj = bpy.data.objects
        bb_misc = bpy.context.window_manager.bb_misc

        if len(bpy.context.selected_objects) == 1:
            o = bpy.context.object
            if o.type == 'MESH' or o.type == 'ARMATURE':
                ready = True
            else:
                ready = False
        else:
            ready = False

        if self.action == "copy":
            if ready == False:
                print("No qualified object was selected for copying or too many objects")
                popup("Select a single mesh or rig", "Error", "ERROR")
                return {'FINISHED'}
            buf = {}
            buf['object'] = {}
            for p in o.keys():
                buf['object'][p] = o[p]
            if o.type == 'ARMATURE':
                buf['pbones'] = {}
                buf['dbones'] = {}
                for pBone in o.pose.bones:
                    dBone = pBone.bone
                    bone = pBone.name
                    buf['dbones'][bone] = {}
                    buf['pbones'][bone] = {}
                    for p in dBone.keys():
                        buf['dbones'][bone][p] = dBone[p]
                    for p in pBone.keys():
                        buf['pbones'][bone][p] = pBone[p]
            bb_misc['prop_buffer'] = buf
            print("props copied to buffer")
        elif self.action == "paste":
            if ready == False:
                print("No qualified object was selected for pasting, or too many objects")
                popup("Select a single mesh or rig", "Error", "ERROR")
                return {'FINISHED'}
            if bb_misc.get('prop_buffer') == None:
                print("No properties appear to have been saved")
                popup("Buffer is empty, use copy first", "Info", "INFO")
                return {'FINISHED'}
            for p in bb_misc['prop_buffer']['object']:
                o[p] = bb_misc['prop_buffer']['object'][p]
            if o.type == 'ARMATURE':
                for bone in bb_misc['prop_buffer']['pbones']:
                    if bone not in o.pose.bones:
                        print("no matching bone, skipping:", bone)
                        continue
                    for p in bb_misc['prop_buffer']['pbones'][bone]:
                        o.pose.bones[bone][p] = bb_misc['prop_buffer']['pbones'][bone][p]
                    for p in bb_misc['prop_buffer']['dbones'][bone]:
                        o.data.bones[bone][p] = bb_misc['prop_buffer']['dbones'][bone][p]
            print("props pasted")
        elif self.action == "clear":
            if bb_misc.get('prop_buffer') == None:
                print("transfer buffer was empty")
            else:
                del bb_misc['prop_buffer']
        elif self.action == "print":
            if bb_misc.get('prop_buffer') == None:
                print("transfer buffer was empty")
                popup("Buffer is empty, nothing to print", "Info", "INFO")
                return {'FINISHED'}
            buffer = bb_misc['prop_buffer'].to_dict()
            print(buffer)
            popup("Buffer printed, check System Console", "Info", "INFO")

        else:
            print("This should not happen, the action is empty or wrong")

        return {'FINISHED'}

class OnigiriFixRigFlags(bpy.types.Operator):
    """This adjusts the provided rig flags only and nothing else.  Some Onigiri tools
expect certain flags to be set in order to perform related functions and this is a fix.  This
could ruine your setup, use only if instructed"""

    bl_idname = "onigiri.fix_rig_flags"
    bl_label = "Adjust flags to work with tools"

    rig_class : bpy.props.StringProperty(default = "")
    
    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        armObj = bpy.context.selected_objects[0]

        print("Entering fix_rig_flags with class_type:", self.rig_class)

        if self.rig_class != "":
            armObj['rig_class'] = self.rig_class
            print("rig_class set to:", self.rig_class)
        else:
            print("This shouldn't happen, it's just probramers dummy bucket")

        self.rig_class = ""

        return {'FINISHED'}

class OnigiriFixSLAliasBones(bpy.types.Operator):
    """If you used the BVH exporter and chose to export with BVH bone names then imported
the resulting rig back into Blender, you'll have a broken setup.  Choose your rig and click
this button then match mapper will work again"""

    bl_idname = "onigiri.fix_sl_alias_bones"
    bl_label = "Rename exported SL BVH back to normal"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            o = bpy.context.selected_objects[0]
            if o.type == 'ARMATURE':
                return True
        return False
    def execute(self, context):
        armObj = bpy.context.selected_objects[0]
        old_mode = bpy.context.mode
        if old_mode == 'EDIT_ARMATURE':
            old_mode == 'EDIT'
        bpy.ops.object.mode_set(mode='EDIT')
        bpy.context.view_layer.objects.active = armObj
        count = 0
        for bone in bvh_names:
            bvh_bone = bvh_names[bone]
            if bvh_bone in armObj.data.edit_bones:
                print("renaming bone:", bvh_bone, "to", bone)
                armObj.data.edit_bones[bvh_bone].name = bone
                count += 1
        print("fixed bone count:", count)
        txt = "Fixed [" + str(count) + "] bones"
        popup(txt, "Rename:", "INFO")

        set_mode(armObj.name, old_mode)
        return {'FINISHED'}

class OnigiriFixRigOrientation(bpy.types.Operator):
    """
    Did you rotate your rig and didn't mean to?  Is it facing the wrong way?  If your rig is not easily
    replaced then this is a good feature to employ.  Simply choose your damaged transformed rig and
    hit this button, SL rigs only
    """
    bl_idname = "onigiri.fix_rig_orientation"
    bl_label = "bb_rotate_rig"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            obj = bpy.context.selected_objects[0]
            if obj.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        arm = bpy.context.selected_objects[0].name
        rigutils.fix_rig_orientation(armature=arm, bone = "mPelvis")
        return {'FINISHED'}

class OnigiriBindData(bpy.types.Operator):
    """Add or remove the respective bind data types from the bones in the selected
armature.  These are Second Life specific"""
    bl_idname = "onigiri.bind_data"
    bl_label = "Add/Remove Bind Data"

    action : bpy.props.StringProperty()
    transform : bpy.props.StringProperty()

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bbm = bpy.context.window_manager.bb_misc
        obj = bpy.data.objects
        armObj = bpy.context.selected_objects[0]
        state = utils.get_state()

        armObj.select_set(True)
        utils.activate(armObj)

        bpy.ops.object.mode_set(mode='EDIT')
        sk = skel.avatar_skeleton
        for bone in sk:
            if bone not in armObj.data.bones:
                continue
            
            dBone = armObj.data.bones[bone]
            eBone = armObj.data.edit_bones[bone]
            if self.action == "add":
                if self.transform == "loc":
                    x,y,z = sk[bone]['pos']
                    dBone['restpose_loc_x'] = x
                    dBone['restpose_loc_y'] = y
                    dBone['restpose_loc_z'] = z
                    eBone['restpose_loc_x'] = x
                    eBone['restpose_loc_y'] = y
                    eBone['restpose_loc_z'] = z
                if self.transform == "rot":
                    x,y,z = sk[bone]['rot']
                    dBone['restpose_rot_x'] = x
                    dBone['restpose_rot_y'] = y
                    dBone['restpose_rot_z'] = z
                    eBone['restpose_rot_x'] = x
                    eBone['restpose_rot_y'] = y
                    eBone['restpose_rot_z'] = z
                if self.transform == "scl":
                    x,y,z = sk[bone]['scale']
                    dBone['restpose_scale_x'] = x
                    dBone['restpose_scale_y'] = y
                    dBone['restpose_scale_z'] = z
                    eBone['restpose_scale_x'] = x
                    eBone['restpose_scale_y'] = y
                    eBone['restpose_scale_z'] = z
            if self.action == "del":
                for p in dBone.keys():
                    if isinstance(p, str):
                        if self.transform == "loc":
                            if p.startswith('restpose_loc'):
                                del dBone[p]
                                if p in eBone:
                                    del eBone[p]
                        if self.transform == "rot":
                            if p.startswith('restpose_rot'):
                                del dBone[p]
                                if p in eBone:
                                    del eBone[p]
                        if self.transform == "scl":
                            if p.startswith('restpose_scale'):
                                del dBone[p]
                                if p in eBone:
                                    del eBone[p]

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriBindInformation(bpy.types.Operator):
    """This is an advanced feature, it was initially placed here for testing but it may come in handy.
One thing that it can be used for is to transfer bind information from the rig of an imported dae file
to your working rig."""

    bl_idname = "onigiri.bind_info"
    bl_label = "Add Bind Information"

    action : bpy.props.StringProperty()

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        
        if o != bpy.context.active_object:
            return False
        return True

    def execute(self, context):
        bbm = bpy.context.window_manager.bb_misc
        obj = bpy.data.objects
        armObj = bpy.context.selected_objects[0]

        bpy.ops.object.mode_set(mode='EDIT')

        flag = 0

        if self.action == "set_0":
            for boneObj in armObj.data.edit_bones:
                if boneObj.get('bind_mat') == None:
                    continue
                boneObj['bind_mat'][0]  = 0.0
                boneObj['bind_mat'][5]  = 0.0
                boneObj['bind_mat'][10] = 0.0
            bpy.ops.object.mode_set(mode='OBJECT')
        elif self.action == "set_1":
            for boneObj in armObj.data.edit_bones:
                if boneObj.get('bind_mat') == None:
                    continue
                boneObj['bind_mat'][0]  = 1.0
                boneObj['bind_mat'][5]  = 1.0
                boneObj['bind_mat'][10] = 1.0
            bpy.ops.object.mode_set(mode='OBJECT')

        elif self.action.startswith("scale_vbones"):
            
            bpy.ops.object.mode_set(mode='OBJECT')

            txt = str(self.action)
            popup(txt, "Yap!", "INFO")
            
            new_arm = bpy.context.selected_objects[0].name

            bpy.ops.object.mode_set(mode='POSE')
            for vbone in vol_joints:
                if vbone in obj[new_arm].pose.bones:
                    obj[new_arm].pose.bones[vbone].scale = vol_joints[vbone]['scale']
                    print(vbone + ":", vol_joints[vbone]['scale'])
            bpy.ops.pose.armature_apply()
            bpy.ops.object.mode_set(mode='OBJECT')

        elif self.action == "save_bind_data":
            bind_file = script_dir + data_path + "bind.dat"
            bd = open(bind_file, "w", encoding='UTF8')
            bpy.ops.object.mode_set(mode='EDIT')
            bind_list = {}
            for b in armObj.data.edit_bones:
                bind_list[b.name] = {}
                bind_list[b.name]['bind_mat'] = b['bind_mat'].to_list()
                bind_list[b.name]['rest_mat'] = b['rest_mat'].to_list()
            bd.write("bind_list = ")
            bd.write(str(bind_list))
            bd.close()
            popup("data saved")

        elif self.action == "load_bind_data":
            print("attempting to restore bind data")
            bind_file = script_dir + data_path + "bind.dat"
            bind_list = {}
            try:
                namespace = {}
                exec(open(bind_file, 'r', encoding='UTF8').read(), namespace)
                bind_list.update(namespace['bind_list'])
            except Exception as e:
                print(traceback.format_exc())

            bpy.ops.object.mode_set(mode='EDIT')
            for vbone in vol_joints:
                if vbone in armObj.data.edit_bones:
                    armObj.data.edit_bones[vbone]['bind_mat'][0]  = vol_joints[vbone]['scale'][0]
                    armObj.data.edit_bones[vbone]['bind_mat'][5]  = vol_joints[vbone]['scale'][1]
                    armObj.data.edit_bones[vbone]['bind_mat'][10] = vol_joints[vbone]['scale'][2]
                    
                    armObj.data.edit_bones[vbone]['bind_mat'][2]  = bind_list[vbone]['bind_mat'][2]
                    armObj.data.edit_bones[vbone]['bind_mat'][8]  = bind_list[vbone]['bind_mat'][8]
                    
                    armObj.data.edit_bones[vbone]['bind_mat'][0]  = bind_list[vbone]['bind_mat'][0]
                    armObj.data.edit_bones[vbone]['bind_mat'][5]  = bind_list[vbone]['bind_mat'][5]
                    armObj.data.edit_bones[vbone]['bind_mat'][10] = bind_list[vbone]['bind_mat'][10]

            bpy.ops.object.mode_set(mode='OBJECT')

        elif self.action == "remove":
            for boneObj in armObj.data.edit_bones:
                if boneObj.get('bind_mat'):
                    del boneObj['bind_mat']
                if boneObj.get('rest_mat'):
                    del boneObj['rest_mat']
            for boneObj in armObj.data.bones:
                if boneObj.get('bind_mat'):
                    del boneObj['bind_mat']
                    flag = 1 
                if boneObj.get('rest_mat'):
                    del boneObj['rest_mat']
                    flag = 1 
            if flag == 0:
                print("no matrices were available to remove")
                popup("no matrices were found ")
            print("Remove bind info complete")
            bpy.ops.object.mode_set(mode='OBJECT')

        elif self.action == "remove_bind_matrix":
            for boneObj in armObj.data.edit_bones:
                if boneObj.get('bind_mat'):
                    del boneObj['bind_mat']
                    flag = 1 
            for boneObj in armObj.data.bones:
                if boneObj.get('bind_mat'):
                    del boneObj['bind_mat']
                    flag = 1 
            if flag == 0:
                print("no bind matrices were available to remove")
                popup("no bind matrices were found ")
            print("Remove bind matrices complete")
            bpy.ops.object.mode_set(mode='OBJECT')

        elif self.action == "remove_rest_matrix":
            for boneObj in armObj.data.edit_bones:
                if boneObj.get('rest_mat'):
                    del boneObj['rest_mat']
                    flag = 1 
            for boneObj in armObj.data.bones:
                if boneObj.get('rest_mat'):
                    del boneObj['rest_mat']
                    flag = 1 
            if flag == 0:
                print("no rest matrices were available to remove")
                popup("no rest matrices were found ")
            print("Remove rest matrices complete")
            bpy.ops.object.mode_set(mode='OBJECT')

        elif self.action == "copy":
            bbm['bind_info'] = dict()
            for boneObj in armObj.data.edit_bones:
                if boneObj.get('bind_mat') == None:
                    print(boneObj.name, "copy - missing bind_mat, moving on ...")
                    continue
                bbm['bind_info'][boneObj.name] = dict()
                bbm['bind_info'][boneObj.name]['bind_mat'] = boneObj['bind_mat']
                bbm['bind_info'][boneObj.name]['rest_mat'] = boneObj['rest_mat']
            bpy.ops.object.mode_set(mode='OBJECT')
            print("Copy bind info complete")

        elif self.action == "paste":
            if bbm.get('bind_info') == None:
                print("no bind info available yet, use copy first")
                popup("No bind info available yet, use copy first.", "Error", "ERROR")
                bpy.ops.object.mode_set(mode='OBJECT')
                return {'FINISHED'}
            
            for boneObj in armObj.data.edit_bones:
                if boneObj.name not in bbm['bind_info']:
                    continue
                boneObj['bind_mat'] = bbm['bind_info'][boneObj.name]['bind_mat']
                boneObj['rest_mat'] = bbm['bind_info'][boneObj.name]['rest_mat']

            bpy.ops.object.mode_set(mode='OBJECT')
            del bbm['bind_info']
            print("Paste bind info complete")
            return {'FINISHED'}

            for boneObj in armObj.data.edit_bones:
                if boneObj.name == 'RIGHT_PEC':
                    print("BEFORE")
                    print("ID bone", id(boneObj['bind_mat']))
                    print("ID bind", id(bind_mat))

                bind_mat = list()
                bind_mat = bbm['bind_info'][boneObj.name]['bind_mat'].to_list()
                del boneObj['bind_mat']
                new_list = [1.0] * 16
                boneObj['bind_mat'] = new_list
                for c in range(16):
                    boneObj['bind_mat'][c] = new_list[c]
                for c in range(16):
                    boneObj['bind_mat'][c] = bind_mat[c]

                if boneObj.name == 'RIGHT_PEC':
                    print("AFTER")
                    print("ID bone", id(boneObj['bind_mat']))
                    print("ID bind", id(bind_mat))
                    print(boneObj['bind_mat'].to_list())

            bpy.ops.object.mode_set(mode='OBJECT')
            del bbm['bind_info']
            print("Paste bind info complete")

        else:
            print("bind action unknown:", self.action)

        return {'FINISHED'}

class OnigiriCollapseToSL(bpy.types.Operator):
    """Remove everything from the rig that's not SL compliant.  This can be helpful
in order to speed up future processing if you're transforming an Avastar rig"""

    bl_idname = "onigiri.collapse_to_sl"
    bl_label = "Remove non SL items"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        
        old_mode = bpy.context.mode
        if old_mode == 'EDIT_ARMATURE':
            old_mode = 'EDIT'

        armObj = bpy.context.selected_objects[0]

        original = [i for i in armObj.data.layers]
        layers = [True for i in armObj.data.layers]
        
        armObj.data.layers = layers

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in armObj.data.edit_bones:
            boneObj.hide = False
            boneObj.hide_select = False

        rigutils.remove_deps(armObj.name)

        for boneObj in armObj.data.edit_bones:
            if boneObj.name not in skel.avatar_skeleton:
                armObj.data.edit_bones.remove(boneObj)

        bpy.ops.object.mode_set(mode=old_mode)

        armObj.data.layers = original

        bbRig.pop('avastar', "")

        return {'FINISHED'}

class OnigiriAccessAllBones(bpy.types.Operator):
    """Make all bones viewable and accessible for manipulation"""

    bl_idname = "onigiri.access_all_bones"
    bl_label = "View and manipulate all bones"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        old_mode = bpy.context.mode
        if old_mode == 'EDIT_ARMATURE':
            old_mode = 'EDIT'

        armObj = bpy.context.selected_objects[0]
        state = utils.get_state()
        armObj.select_set(True)
        utils.activate(armObj)

        layers = [True for i in armObj.data.layers] 
        armObj.data.layers = layers

        for boneObj in armObj.data.bones:
            boneObj.hide = False
            boneObj.hide_select = False

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in armObj.data.edit_bones:
            boneObj.hide = False
            boneObj.hide_select = False

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriRemoveBoneShapes(bpy.types.Operator):
    """The rig you're working with may be hard to (read) if there are custom bone shapes.  This allows you to
remove that property from all bones in the chosen rig.  This is not reversible with the restore feature.
"""
    bl_idname = "onigiri.remove_bone_shapes"
    bl_label = "remove bone shapes"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        old_mode = bpy.context.mode
        if old_mode == 'EDIT_ARMATURE':
            old_mode = 'EDIT'

        armObj = bpy.context.selected_objects[0]

        bpy.ops.object.mode_set(mode='OBJECT')
        for pBone in armObj.pose.bones:
            pBone.use_custom_shape_bone_size = False
            pBone.custom_shape = None

        bpy.ops.object.mode_set(mode=old_mode)

        return {'FINISHED'}

class OnigiriMoveTailToHead(bpy.types.Operator):
    """Are you bones all goofy looking?  They're pointing in odd directions?  This
may be able to fix it, it shouldn't damage anything"""

    bl_idname = "onigiri.move_tail_to_head"
    bl_label = "move tail to head"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].type == 'ARMATURE':
                return True
        return False

    def execute(self, context):

        old_mode = bpy.context.mode

        armObj = bpy.context.selected_objects[0]

        state = utils.get_state()

        armObj.select_set(True)
        utils.activate(armObj)
        bpy.ops.object.mode_set(mode='EDIT')
        edit_bones = {}
        for boneObj in armObj.data.edit_bones:
            if boneObj.parent:
                if len(boneObj.parent.children) == 1:
                    roll = boneObj.parent.roll
                    boneObj.parent.tail = boneObj.head.copy()
                    boneObj.parent.roll = roll
                    print(boneObj.parent.name, "connects to", boneObj.name)
        bpy.ops.object.mode_set(mode='OBJECT')

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriSafeConnect(bpy.types.Operator):

    """This will do the reverse of what Blender does.  Blender cannot know which head to connect with
because there can be multiple child bones, but with a little care most of the work can be done and you'll
end up with a cleaner looking rig.
"""
    bl_idname = "onigiri.safe_connect"
    bl_label = "save connect"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        old_mode = bpy.context.mode

        armObj = bpy.context.selected_objects[0]

        state = utils.get_state()

        armObj.select_set(True)
        utils.activate(armObj)
        bpy.ops.object.mode_set(mode='EDIT')
        edit_bones = {}
        for boneObj in armObj.data.edit_bones:
            if boneObj.parent:
                if len(boneObj.parent.children) == 1:
                    roll = boneObj.parent.roll
                    boneObj.parent.tail = boneObj.head.copy()
                    boneObj.parent.roll = roll
                    print(boneObj.parent.name, "connects to", boneObj.name)
        bpy.ops.object.mode_set(mode='OBJECT')

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriMagnifyBones(bpy.types.Operator):
    """This will probably break your rig but it will help you visualize your bones a lot
easier.  If you're mapping you can do anything you want to the rig for that mapping stage
and then just use a new rig for the final result.
"""
    bl_idname = "onigiri.magnify_bones"
    bl_label = "magnify bones"

    mag : bpy.props.IntProperty(default=1)

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        old_mode = bpy.context.mode
        if old_mode == 'EDIT_ARMATURE':
            old_mode = 'EDIT'

        armObj = bpy.context.selected_objects[0]

        rigutils.save_rig(armature=armObj.name)

        bpy.ops.object.mode_set(mode='EDIT')

        for eBone in armObj.data.edit_bones:
            head = eBone.head.copy()
            tail = eBone.tail.copy()
            L1 = mathutils.Matrix.Translation(head)
            L2 = mathutils.Matrix.Translation(tail)
            M = L2 @ L1.inverted()
            l = M.to_translation()
            eBone.tail += l * self.mag

        bpy.ops.object.mode_set(mode=old_mode)

        return {'FINISHED'}

class OnigiriRestoreBones(bpy.types.Operator):
    """If you used magnify, move tail to head, safe connect and many other features then you may
be able to restore the bones using this option.  Bone data is stored when a destructive process
is about to begin and restored from that data when requested.
"""
    bl_idname = "onigiri.restore_bones"
    bl_label = "restore bones"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        old_mode = bpy.context.mode
        if old_mode == 'EDIT_ARMATURE':
            old_mode = 'EDIT'

        armObj = bpy.context.selected_objects[0]
        
        rigutils.restore_rig(armObj.name)

        bpy.ops.object.mode_set(mode=old_mode)

        return {'FINISHED'}

class OnigiriFixBoneOrientation(bpy.types.Operator):
    """This will reset the bone orientation for all bones of the selected rig to something that
Onigiri and Second Life expects.  Current animations will break so transfer them to
a new rig first then you can transfer them back."""

    bl_idname = "onigiri.fix_bone_orientation"
    bl_label = "Fix bone orientation"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) > 1:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def execute(self, context):
        obj = bpy.data.objects

        path = script_dir + presets_path + bb_settings["files"]["bone_orientation"]

        armObj = bpy.context.selected_objects[0]

        bone_mats = {}
        try:
            namespace = {}
            exec(open(path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("something goofy happened, can't load matrices")
            print(traceback.format_exc())
            return {'FINISHED'}

        bone_mats.update(namespace['bone_matrices'])

        bpy.context.view_layer.objects.active = armObj

        selected_bones = list()
        if bpy.context.mode == 'EDIT_ARMATURE':
            old_mode = 'EDIT'
            for b in bpy.context.selected_bones:
                selected_bones.append(b.name)
        elif bpy.context.mode == 'POSE':
            for b in bpy.context.selected_pose_bones:
                selected_bones.append(b.name)
            old_mode = 'POSE'
        else:
            old_mode = bpy.context.mode

        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.armature.select_all(action='SELECT')

        world_to_target_matrix = armObj.matrix_world.inverted().to_3x3()

        for b in armObj.data.edit_bones:
            if b.name not in bone_mats:
                continue
            align_bone_x_axis( b, world_to_target_matrix @ mathutils.Vector(bone_mats[b.name]) )

        bpy.ops.object.mode_set(mode='POSE')
        for b in armObj.data.bones:
            b.select = False

        bpy.ops.object.mode_set(mode=old_mode)
        if old_mode != 'OBJECT':
            for b in selected_bones:
                if old_mode == 'EDIT':
                    armObj.data.edit_bones[b].select = True
                elif old_mode == 'POSE':
                    armObj.data.bones[b].select = True

        bpy.ops.object.mode_set(mode=old_mode)

        return {'FINISHED'}

class OnigiriResetBoneRoll(bpy.types.Operator):
    """This is an advanced feature.  It is not designed to be used with Second Life.
Resetting the bone roll is a good starting point when creating a rig."""

    bl_idname = "onigiri.reset_bone_roll"
    bl_label = "Reset bone roll to 0s"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            obj = bpy.context.selected_objects[0]
            if obj.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        bbm = bpy.context.window_manager.bb_misc

        armObj = bpy.context.selected_objects[0]
        bpy.ops.object.mode_set(mode='EDIT')

        for bone in armObj.data.edit_bones:
            bone.select = True
            bone.select_head = True
            bone.select_tail = True

        bpy.ops.armature.roll_clear(roll=0.0)
        bpy.ops.object.mode_set(mode='OBJECT')

        return {'FINISHED'}

class OnigiriAutoKeyProperties(bpy.types.PropertyGroup):

    autokey_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Expand the Auto Key options"            "\n\n"            "Pose your character without having to remember which bones you moved.  Click the (Auto Key) button and you're ready "            "for the next pose to create your keys between motion, for seamless and worry free animation."            "\n\n"            "For fine tuning, capturing, and manual key reduction for retargeting just record your reference, move the time slider "            "a little bit and hit that (Auto Key) button.  Continue on down that line until you're finished then export your animation.",
        default = False,
        )
    autokey_steps : bpy.props.IntProperty(
        name = "",
        description =            "Auto Step to frame after keying"            "\n\n"            "A convenience tool that will automatically move the time slider ahead by the number of frames indicated "            "so that you can concentrate on motion instead of Blender details.  Later you can move your keys where you "            "like but using steps is not a bad idea and if you have too many steps you can reduce them using Onigiri's "            "(Resample) tool.  Note, you can set this to negative to key backwards, if you're feeling backwards today.",
        default = 10,
        )
    autokey_steps_disabled : bpy.props.BoolProperty(
        name = "",
        description =            "Disable Auto Step",
        default = False,
        )
    autokey_bake_progress : bpy.props.StringProperty(
        name = "",
        description = "-- internal",
        default = "",
        )
    autokey_bake_progress_show : bpy.props.BoolProperty(
        name = "",
        description =            "Show Bake Progress"            "\n\n"            "This is very slow!  Enable this to see the progress of the bake.  It will update the scene on every frame write.  "            "This is against Blender policy O.o, but for prototyping it can be useful.  Choose a small bake frame-range for your "            "progress view, enable this button, and hit the bake key.  Turn it off for production work",
        default = False,
        )
    autokey_bake_rotation_disabled : bpy.props.BoolProperty(
        name = "",
        description =            "Disable Rotation Baking"            "\n\n"            "The data will still be stored for later use but it just won't be baked when you hit one of "            "the bake keys.  This is usually not what you want but for custom characters or when using Animesh in a "            "unique way you can turn this off to be sure that those values don't get in the way and it's good for debugging your "            "prosses",
        default = False,
        )
    autokey_bake_location_disabled : bpy.props.BoolProperty(
        name = "",
        description =            "Disable Location Baking"            "\n\n"            "The data will still be stored but it won't be baked when you use one of the baking methods.  This is often times what "            "you want, to disable location data from baking, it's less confusing where the problem is "            "when you find strange distortions in your finished product.  It shouldn't really cause a problem, to allow location "            "baking but it also saves on data if those keys aren't being used.",
        default = False,
        )

    autokey_bake_start : bpy.props.IntProperty(
        name = "",
        description =            "Bake Start Frame"            "\n\n"            "What frame to start baking from.  The (Bake Stored Keys) baker will not bake more keys than are in the buffer "            "so you can range this quite wide for safety.  You can set this wide and the baker will just take the keys inside "            "but the (Bake Range) feature will bake all keys inside the range, which is good for automatically baking for "            "retargeted animations",
        default = 1,
        )
    autokey_bake_end : bpy.props.IntProperty(
        name = "",
        description =            "Bake End Frame"            "\n\n"            "What frame to end baking at.  The (Bake Stored Keys) baker will not bake more keys than are in the buffer "            "so you can range this quite wide for safety.  You can set this wide and the baker will just take the keys inside "            "but the (Bake Range) feature will bake all keys inside the range, which is good for automatically baking for "            "retargeted animations",
        default = 100,
        )

    autokey_tol_rot : bpy.props.FloatProperty(
        name = "",
        description =            "Rotation Tolerance"            "\n\n"            "Rotation motion that has not changed from frame to frame by at least this amount are not recorded.  This is in degrees.",
        min = -180,
        max = 180,
        precision = 4,
        default = 0.01,
        )
    autokey_tol_loc : bpy.props.FloatProperty(
        name = "",
        description =            "Location Tolerance"            "\n\n"            "Position motion that has not changed from frame to frame by at least this amount are not recorded.  This is in meters.",
        min = -10,
        max = 10,
        precision = 4,
        default = 0.001,
        )
    autokey_paste_to_selected : bpy.props.BoolProperty(
        name = "",
        description =            "Paste to selected bones only"            "\n\n"            "You can paste to multiple rigs the same pose and, on those rigs, you can choose only certain bones, they don't have "            "have to match each other, and enable this feature.  The bones that are currently selected on the target rigs are the "            "only bones that will receive the stored pose.  To achieve this you'll need to be in pose mode on the entire rig selection  "            "and then choose the bones on those rigs that will receive the pose.",
        default = False,
        )

class OnigiriAutoKey(bpy.types.Operator):
    """Pose your rig then push this button to auto-key any new motion.  This will
sense rotation, location or both and will only key those motions that are new"""

    action : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.auto_key"
    bl_label = "Auto Key Newly Moved Bones"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type == 'ARMATURE':
            return True
        return False

    def execute(self, context):
        
        bpy.context.view_layer.update()

        bb_autokey = bpy.context.scene.bb_autokey
        frame_current = bpy.context.scene.frame_current
        obj = bpy.data.objects
        armObj = bpy.context.object
        frame_start = bb_autokey.autokey_bake_start
        frame_end = bb_autokey.autokey_bake_end

        if self.action == "acquire":
            if armObj.animation_data == None:
                print("no animation data")
                popup("no animation is present from which to sample the frame range", "Missing Animation", "INFO")
                return {'FINISHED'}
            if armObj.animation_data.action == None:
                print("no action data")
                popup("no action is present from which to sample the frame range", "Missing Action", "INFO")
                return {'FINISHED'}
            frame_start, frame_end = armObj.animation_data.action.frame_range
            bb_autokey.autokey_bake_start = int(frame_start)
            bb_autokey.autokey_bake_end = int(frame_end)
            print("acquired frame range from animation")
            return {'FINISHED'}

        if self.action == 'copy':
            ani = bpy.data.actions.get('scratchpad')
            if ani == None:
                print("Created disposable action")
                ani = bpy.data.actions.new("scratchpad")
            old_ani = None
            if armObj.animation_data != None:
                if armObj.animation_data.action != None:
                    old_ani = armObj.animation_data.action
            else:
                armObj.animation_data_create()

            armObj.animation_data.action = ani

            for boneObj in armObj.pose.bones:
                rotation_mode = boneObj.rotation_mode
                if rotation_mode == 'QUATERNION':
                    rmode = 'rotation_quaternion'
                else:
                    rmode = 'rotation_euler'
                boneObj.keyframe_insert(data_path=rmode, frame=frame_current)
                boneObj.keyframe_insert(data_path='location', frame=frame_current)

                pmat = boneObj.matrix.copy()
                boneObj.matrix = pmat

            pose = {}
            for pBone in armObj.pose.bones:
                pose[pBone.name] = armObj.pose.bones[pBone.name].matrix_basis.copy()
                
            bb_autokey['pose'] = pose
            print("Current pose copied to buffer")

            old_mode = bpy.context.mode
            if old_mode.startswith('EDIT'):
                old_mode = 'EDIT'
            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.select_all(action = 'SELECT')
            bpy.ops.anim.keyframe_clear_v3d()
            bpy.ops.pose.select_all(action = 'DESELECT')
            bpy.ops.object.mode_set(mode=old_mode)

            if old_ani != None:
                armObj.animation_data.action = old_ani

        if self.action == 'key':
            frame_current = bpy.context.scene.frame_current

            pose = {}
            for pBone in armObj.pose.bones:
                pose[pBone.name] = armObj.pose.bones[pBone.name].matrix.copy()

            if armObj.get('bb_motion') == None:
                
                armObj['bb_autokey_reference_frame'] = frame_current

                bpy.context.scene.frame_set(frame_start)

                rigutils.reset_pose(armature=armObj.name, location=True, rotation=True, scale=True, space="rig")
                ref_pose = {}
                for pBone in armObj.pose.bones:
                    bone = pBone.name
                    ref_pose[pBone.name] = armObj.pose.bones[pBone.name].matrix.copy()
                armObj['bb_reference'] = ref_pose
                print("Reference saved")
                for bone in pose:
                    mat = mathutils.Matrix(pose[bone])
                    armObj.pose.bones[bone].matrix = mat
                    bpy.context.view_layer.update()
                print("Pose restored")
                
                f = str(frame_current)
                motion = {}
                motion[f] = {}

                motion[f]['reference'] = ""

                for boneObj in armObj.pose.bones:
                    bone = boneObj.name
                    
                    motion[f][bone] = {}
                    motion[f][bone]['rot'] = True
                    motion[f][bone]['loc'] = True
                    motion[f][bone]['matrix'] = armObj.pose.bones[bone].matrix_basis.copy()

                    rotation_mode = armObj.pose.bones[bone].rotation_mode
                    if rotation_mode == 'QUATERNION':
                        rmode = 'rotation_quaternion'
                    else:
                        rmode = 'rotation_euler'
                    armObj.pose.bones[bone].keyframe_insert(data_path=rmode, frame=frame_current)
                    armObj.pose.bones[bone].keyframe_insert(data_path='location', frame=frame_current)

                    motion[f][bone]['matrix'] = armObj.pose.bones[bone].matrix_basis.copy()

                armObj['bb_motion'] = motion
                frame = frame_current
                if bb_autokey.autokey_steps_disabled == False:
                    frame += bb_autokey.autokey_steps
                bpy.context.scene.frame_set(frame)
                self.action = ""
                return {'FINISHED'}

            motion = armObj['bb_motion'] 

            frame_old = frame_current
            if bb_autokey.autokey_steps_disabled == False:
                if bb_autokey.autokey_steps < 0:
                    frame_old = frame_current + 1
                else:
                    frame_old = frame_current - 1

            rtol = math.radians(bb_autokey.autokey_tol_rot)
            ltol = bb_autokey.autokey_tol_loc

            old_mats = {}
            new_mats = {}

            for boneObj in armObj.pose.bones:
                
                mat = animutils.get_real_matrix(armature=armObj.name, bone=boneObj.name)
                new_mats[boneObj.name] = mat

            bpy.context.scene.frame_set(frame_old)

            for boneObj in armObj.pose.bones:
                
                mat = animutils.get_real_matrix(armature=armObj.name, bone=boneObj.name)
                old_mats[boneObj.name] = mat

            bpy.context.scene.frame_set(frame_current)

            for bone in pose:
                mat = mathutils.Matrix(pose[bone])
                armObj.pose.bones[bone].matrix = mat

            f = str(frame_current)

            if motion.get(f) != None:
                print("Unpredicted frame in motion:", f)
            else:
                motion[f] = {}

            for bone in new_mats:
                this_mat = new_mats[bone]
                last_mat = old_mats[bone]

                rot = this_mat.to_euler()
                loc = this_mat.to_translation()
                last_rot = last_mat.to_euler()
                last_loc = last_mat.to_translation()

                motion[f][bone] = {}
                motion[f][bone]['rot'] = False
                motion[f][bone]['loc'] = False

                rmatch = False
                lmatch = False
                for r in range(3):
                    if animutils.close_enough(rot[r], last_rot[r], tol=rtol) == True:
                        rmatch = True
                        break
                for l in range(3):
                    if animutils.close_enough(loc[l], last_loc[l], tol=ltol) == True:
                        lmatch = True
                        break
                if rmatch:
                    motion[f][bone]['rot'] = True
                if lmatch:
                    motion[f][bone]['loc'] = True
                if rmatch or lmatch:
                    motion[f][bone]['matrix'] = armObj.pose.bones[bone].matrix_basis.copy()

            rots = 0
            locs = 0
            for bone in motion[f]:
                if motion[f][bone]['rot'] == True:
                    if bb_autokey.autokey_bake_rotation_disabled == False:
                        rots += 1
                        rotation_mode = armObj.pose.bones[bone].rotation_mode
                        if rotation_mode == 'QUATERNION':
                            rmode = 'rotation_quaternion'
                        else:
                            rmode = 'rotation_euler'
                        armObj.pose.bones[bone].keyframe_insert(data_path=rmode, frame=frame_current)
                if motion[f][bone]['loc'] == True:
                    if bb_autokey.autokey_bake_location_disabled == False:
                        locs += 1
                        armObj.pose.bones[bone].keyframe_insert(data_path='location', frame=frame_current)
            print("keyed", rots, "rotations and", locs, "locations")

            frame = frame_current
            if bb_autokey.autokey_steps_disabled == False:
                frame += bb_autokey.autokey_steps
            bpy.context.scene.frame_set(frame)

        self.action = ""

        return {'FINISHED'}

class OnigiriAutoKeyStore(bpy.types.Operator):
    """Store an existing animation into the buffer which you can save into the library
afterwards.  Click (Acquire) to get your frame range or manually set your range to
just a portion of the animation to store.  This doesn't honor (Steps)"""

    bl_idname = "onigiri.auto_key_store"
    bl_label = "Reference/Rest Pose"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.animation_data == None:
            return False
        if o.animation_data.action == None:
            return False
        return True

    def execute(self, context):
        bb_autokey = bpy.context.scene.bb_autokey
        obj = bpy.data.objects
        armObj = bpy.context.object

        if armObj.get('bb_motion'):
            print("There's motion data already stored, remove it first, maybe save it?")
            popup("Motion data exists, remove it first using the X near the Auto Key button", "Error", "ERROR")
            return {'FINISHED'}

        frame_current = bpy.context.scene.frame_current
        frame_start = bb_autokey.autokey_bake_start
        frame_end = bb_autokey.autokey_bake_end

        action = armObj.animation_data.action
        fcurves = action.fcurves

        fcurve_paths = {}
        for boneObj in armObj.data.bones:
            path_key = 'pose.bones["' + boneObj.name + '"]'
            fcurve_paths[path_key] = boneObj.name

        frame_data = {}

        for fc in fcurves:
            dp = fc.data_path
            bone_path, delimiter, transform_type = dp.rpartition('.')
            if bone_path not in fcurve_paths:
                continue

            real_bone = fcurve_paths[bone_path]
            rot_mode = armObj.pose.bones[real_bone].rotation_mode

            if transform_type == 'rotation_quaternion': 
                loc_rot = 'rot'
            elif transform_type == 'rotation_euler': 
                loc_rot = 'rot'
            elif transform_type == 'location':
                loc_rot = 'loc'
            elif transform_type == 'scale':
                continue
            else:
                continue

            if real_bone not in frame_data:
                frame_data[real_bone] = {}
            if loc_rot not in frame_data[real_bone]:
                frame_data[real_bone][loc_rot] = {}

            frames = [int(k.co.x) for k in fc.keyframe_points]

            frames_set = set(frames)
            frame_numbers = list(sorted(frames_set))
            frame_data[real_bone][loc_rot]['frames'] = frame_numbers

        motion = {}

        for bone in frame_data:

            rots = frame_data[bone]['rot']['frames']
            locs = frame_data[bone]['loc']['frames']
            frames = []
            frames.extend(rots)
            frames.extend(locs)
            for frame in frames:
                if frame < frame_start:
                    continue
                if frame > frame_end:
                    continue
                f = str(frame)
                if motion.get(f) == None:
                    motion[f] = {}
                
                motion[f][bone] = {}
                motion[f][bone]['rot'] = False
                motion[f][bone]['loc'] = False
            
            for frame in rots:
                if frame < frame_start:
                    continue
                if frame > frame_end:
                    continue
                f = str(frame)
                motion[f][bone]['rot'] = True
            for frame in locs:
                if frame < frame_start:
                    continue
                if frame > frame_end:
                    continue
                f = str(frame)
                motion[f][bone]['loc'] = True

        for f in motion:
            frame = int(f)
            bpy.context.scene.frame_set(frame)
            for bone in motion[f]:
                if bone not in armObj.data.bones:
                    print("Missing bone:", bone)
                    continue
                pmat = armObj.pose.bones[bone].matrix_basis.copy()
                motion[f][bone]['matrix'] = pmat

        frames = [f for f in motion]
        numbers = [int(f) for f in frames]
        frames_sorted = sorted(numbers)
        first_frame = frames_sorted[0]
        last_frame = frames_sorted[-1]
        armObj['bb_motion'] = motion
        print("Motion stored to armature, frames", first_frame, "to", last_frame)

        return {'FINISHED'}

class OnigiriAutoKeyReference(bpy.types.Operator):
    """An extra slot that saves a pose to your armature.  Presumably it would be your
rest pose so that you can restore it at some point.
"""
    action : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.auto_key_reference"
    bl_label = "Reference/Rest Pose"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def execute(self, context):
        bb_autokey = bpy.context.scene.bb_autokey
        obj = bpy.data.objects
        armObj = bpy.context.object

        if self.action == 'save':
            ref_pose = {}
            for pBone in armObj.pose.bones:
                ref_pose[pBone.name] = armObj.pose.bones[pBone.name].matrix.copy()
            armObj['bb_reference'] = ref_pose
            print("Current pose saved as reference")
        if self.action == 'restore':
            
            if armObj.get('bb_reference') == None:
                print("No reference saved")
                popup("No reference saved", "Info", "INFO")
                return {'FINISHED'}
            pose = armObj['bb_reference']
            for bone in pose:
                if bone in armObj.data.bones:
                    mat = mathutils.Matrix(pose[bone])
                    armObj.pose.bones[bone].matrix = mat
                    bpy.context.view_layer.update()
                else:
                    print("Missing bone:", bone)
            print("Reference restored")

        self.action = ""

        return {'FINISHED'}

class OnigiriAutoKeyInsert(bpy.types.Operator):
    """This inserts a hold key for either rotation or location.  It's the same thing
as manually keying a bone that you must select first.  This allows for convenient
stops, where the bone doesn't have to move, but it's just a key."""

    action : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.auto_key_insert"
    bl_label = "Insert a hold key\n"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.get('bb_motion') == None:
            return False
        return True

    def execute(self, context):
        
        bpy.context.view_layer.update()

        bb_autokey = bpy.context.scene.bb_autokey
        frame_current = bpy.context.scene.frame_current
        obj = bpy.data.objects
        armObj = bpy.context.object

        if self.action == 'hold_rot':
            for boneObj in bpy.context.selected_pose_bones:
                rotation_mode = boneObj.rotation_mode
                if rotation_mode == 'QUATERNION':
                    rmode = 'rotation_quaternion'
                else:
                    rmode = 'rotation_euler'
                boneObj.keyframe_insert(data_path=rmode, frame=frame_current)

        if self.action == 'hold_loc':
            for boneObj in bpy.context.selected_pose_bones:
                boneObj.keyframe_insert(data_path='location', frame=frame_current)

        return {'FINISHED'}

        frame = frame_current
        if bb_autokey.autokey_steps_disabled == False:
            frame += bb_autokey.autokey_steps
        bpy.context.scene.frame_set(frame)
        self.action = ""

        return {'FINISHED'}

class OnigiriAutoKeyBakeStored(bpy.types.Operator):
    """Stored keys are sort of fake keys, your (Auto Key) clicks stores all of the
transform data needed to generate a resulting animation.  The timeline would have
also been peppered with keys.  If there are controllers you need to bake the keys"""

    action : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.auto_key_bake_stored"
    bl_label = "Bake Saved Data"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.get('bb_motion') == None:
            return False
        if o.type == 'ARMATURE':
            return True
        return False

    def execute(self, context):
        
        bpy.context.view_layer.update()
        frame_current = bpy.context.scene.frame_current

        bb_autokey = bpy.context.scene.bb_autokey
        obj = bpy.data.objects
        armObj = bpy.context.selected_objects[0]

        motion = armObj['bb_motion'].to_dict()
        bb_autokey.autokey_bake_stored_progress = "0%"
        bake_start = bb_autokey.autokey_bake_start
        bake_end = bb_autokey.autokey_bake_end
        real_range = len(motion)
        count = 0
        
        frame_ints = [int(f) for f in motion]
        frames = sorted(frame_ints)
        frames_str = [str(f) for f in frames]
        for f in frames_str:
        
            progress_enabled = True
            if bb_autokey.autokey_bake_progress_show == True:
                count += 1
                percentage = int( (count / real_range) * 100)
                bb_autokey.autokey_bake_progress = str (percentage) + "%"
                bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
                
            frame = int(f)
            if frame < bake_start:
                continue
            if frame > bake_end:
                break
            bpy.context.scene.frame_set(frame)
            
            for bone in motion[f]:
                if bone in armObj.pose.bones:
                    rot = motion[f][bone]['rot']
                    loc = motion[f][bone]['loc']
                    if rot == True or loc == True:
                        mat = mathutils.Matrix(motion[f][bone]['matrix'])
                        armObj.pose.bones[bone].matrix_basis = mat

                    else:
                        continue
                else:
                    print("Missing bone:", bone)
                    continue
                
                if rot == True:
                    if bb_autokey.autokey_bake_rotation_disabled == False:
                        rotation_mode = armObj.pose.bones[bone].rotation_mode
                        if rotation_mode == 'QUATERNION':
                            rmode = 'rotation_quaternion'
                        else:
                            rmode = 'rotation_euler'
                        armObj.pose.bones[bone].keyframe_insert(data_path=rmode, frame=frame)
                if loc == True:
                    if bb_autokey.autokey_bake_location_disabled == False:
                        armObj.pose.bones[bone].keyframe_insert(data_path='location', frame=frame)

        bb_autokey.autokey_bake_progress = ""
        bpy.context.scene.frame_set(frame_current)
        print("Finished bake")
        return {'FINISHED'}

        self.action = ""

        return {'FINISHED'}

class OnigiriAutoKeyBakeRange(bpy.types.Operator):
    """This will bake the range shown in the start and end properties.  This is
good for baking in retargeted animations automatically.  Click the rig with the
animation on it, click acquire, click the BB rig and then click this button"""

    bl_idname = "onigiri.auto_key_bake_range"
    bl_label = "Bake Range"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def execute(self, context):
        
        bpy.context.view_layer.update()
        frame_current = bpy.context.scene.frame_current

        bb_autokey = bpy.context.scene.bb_autokey
        obj = bpy.data.objects
        armObj = bpy.context.object

        if bb_autokey.autokey_steps_disabled == True:
            print("Step must be enabled and steps must be a non-zero value")
            popup("Steps must be enabled or bake makes no sense", "Error", "ERROR")
            return {'FINISHED'}

        if bb_autokey.autokey_steps == 0:
            print("Step must be a non-zero value")
            popup("Steps must be a non-zero value, even negative is fine", "Error", "ERROR")
            return {'FINISHED'}

        frame_start = int(bb_autokey.autokey_bake_start)
        frame_end = int(bb_autokey.autokey_bake_end)

        if armObj.get('bb_motion') != None:
            txt  = "------------------------\n"
            txt += "There's saved keys on the rig.  This protection is for your good, you may not want to overwrite this data.  "
            txt += "You can save it to the library and then remove it with the red X on the (Auto Key) button or just remove it "
            txt += "and try again.\n"
            txt += "------------------------\n"
            print(txt)
            popup("There's existing key information saved on the object, see Console", "Existing Keys Prevent Storage", "ERROR")
            return {'FINISHED'}

        armObj['bb_autokey_reference_frame'] = frame_current

        f = str(frame_start)
        motion = {}
        motion[f] = {}
        last_mats = {}
        for boneObj in armObj.pose.bones:
            bone = boneObj.name

            last_mats[bone] = {}
            last_mats[bone]['moved'] = True
            last_mats[bone]['real_matrix'] = animutils.get_real_matrix(armature=armObj.name, bone=bone)

            motion[f][bone] = {}
            motion[f][bone]['rot'] = True
            motion[f][bone]['loc'] = True
            pmat = armObj.pose.bones[bone].matrix_basis.copy()
            armObj.pose.bones[bone].matrix_basis = pmat
            motion[f][bone]['matrix'] = pmat
            
            rotation_mode = armObj.pose.bones[bone].rotation_mode
            if rotation_mode == 'QUATERNION':
                rmode = 'rotation_quaternion'
            else:
                rmode = 'rotation_euler'
            armObj.pose.bones[bone].keyframe_insert(data_path=rmode, frame=frame_start)
            armObj.pose.bones[bone].keyframe_insert(data_path='location', frame=frame_start)
        
        frame_now = frame_start
        frame_steps = bb_autokey.autokey_steps
        frame_start = bb_autokey.autokey_bake_start
        frame_end = bb_autokey.autokey_bake_end
        rtol = math.radians(bb_autokey.autokey_tol_rot)
        ltol = bb_autokey.autokey_tol_loc

        for frame in range(frame_start, frame_end + frame_steps, frame_steps):
            if frame > frame_end:
                print("Bake breaks early to comply with range")
                break
            f = str(frame) 
            frame_now += frame_steps
            bpy.context.scene.frame_set(frame_now)
            for boneObj in armObj.pose.bones:
                bone = boneObj.name

                if last_mats[bone]['moved'] == True:
                    last_mats[bone]['moved'] = False
                    lmat = last_mats[bone]['real_matrix']
                    last_rot = lmat.to_euler()
                    last_loc = lmat.to_translation()
                
                rmat = animutils.get_real_matrix(armature=armObj.name, bone=bone)
                rot = rmat.to_euler()
                loc = rmat.to_translation()

                rmatch = False
                lmatch = False
                for r in range(3):
                    if animutils.close_enough(rot[r], last_rot[r], tol=rtol) == True:
                        rmatch = True
                        break
                for l in range(3):
                    if animutils.close_enough(loc[l], last_loc[l], tol=ltol) == True:
                        lmatch = True
                        break

                if rmatch or lmatch:
                    if f not in motion:
                        motion[f] = {}
                    motion[f][bone] = {}
                    motion[f][bone]['rot'] = False
                    motion[f][bone]['loc'] = False
                    
                    motion[f][bone]['moved'] = True
                    
                    if rmatch:
                        motion[f][bone]['rot'] = True
                    if lmatch:
                        motion[f][bone]['loc'] = True

        for f in motion:
            frame = int(f)
            bpy.context.scene.frame_set(frame)

            for bone in motion[f]:
                
                pmat = armObj.pose.bones[bone].matrix.copy()
                armObj.pose.bones[bone].matrix = pmat

                if motion[f][bone]['rot'] == True:
                    if bb_autokey.autokey_bake_rotation_disabled == False:
                        rotation_mode = armObj.pose.bones[bone].rotation_mode
                        if rotation_mode == 'QUATERNION':
                            rmode = 'rotation_quaternion'
                        else:
                            rmode = 'rotation_euler'
                        armObj.pose.bones[bone].keyframe_insert(data_path=rmode, frame=frame)
                if motion[f][bone]['loc'] == True:
                    if bb_autokey.autokey_bake_location_disabled == False:
                        armObj.pose.bones[bone].keyframe_insert(data_path='location', frame=frame)

                pmat = armObj.pose.bones[bone].matrix_basis.copy()
                motion[f][bone]['matrix'] = pmat

        print("Cleaning motion buffer...")
        for f in motion:
            for bone in motion[f]:
                motion[f][bone].pop('real_matrix', {})
                motion[f][bone].pop('moved', {})
        print("Cleanup finished, storing...")
        armObj['bb_motion'] = motion

        bb_autokey.autokey_bake_range_progress = ""
        bpy.context.scene.frame_set(frame_current)
        self.action = ""

        animutils.remove_deps(armature=armObj.name)

        print("Finished bake")

        return {'FINISHED'}

class OnigiriAutoKeyReset(bpy.types.Operator):
    """As you progress through keys they are saved for later baking and library
storage.  If this button is active then you have something stored that may be
important.  You may want to save it in Onigiri's animation library"""

    action : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.auto_key_reset"
    bl_label = "Empty Storage Buffer\n"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.get('bb_motion') == None:
            return False
        if o.type == 'ARMATURE':
            return True
        return False

    def execute(self, context):
        
        bpy.context.view_layer.update()

        bb_autokey = bpy.context.scene.bb_autokey
        obj = bpy.data.objects
        armObj = bpy.context.object
        armObj.pop('bb_motion', {})

        frame = 1
        if armObj.animation_data != None:
            if armObj.animation_data.action != None:
                frame_start, frame_end = armObj.animation_data.action.frame_range
                
                if bb_autokey.autokey_steps_disabled == False:
                    if bb_autokey.autokey_steps < 0:
                        frame = int(frame_end)
                    else:
                        frame = int(frame_start)
                else:
                    frame = int(frame_start)

        bpy.context.scene.frame_set(frame)

        print("Pose flag reset")

        return {'FINISHED'}

class OnigiriAutoKeyIsolate(bpy.types.Operator):
    """Remove constraints and drivers so that your bones are free to animate on their
own along the timeline.  This is pretty much a prototype tool since the bakers
already do this"""

    bl_idname = "onigiri.auto_key_isolate"
    bl_label = "Isolate"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type == 'ARMATURE':
            return True
        return False

    def execute(self, context):
        bb_autokey = bpy.context.scene.bb_autokey
        obj = bpy.data.objects
        armObj = bpy.context.object

        animutils.remove_deps(armature=armObj.name)
        print("Removed constraints and drivers")

        return {'FINISHED'}

class OnigiriAutoKeyPastePose(bpy.types.Operator):
    """Paste the pose from the current buffer to 1 or more rigs.  Use the (clear)
button to remove the pose from the buffer if needed.  Don't forget to key your
pose if you want to keep the pasted poses"""

    action : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.auto_key_paste_pose"
    bl_label = "Paste Pose"

    @classmethod
    def poll(cls, context):
        bb_autokey = bpy.context.scene.bb_autokey
        if bb_autokey.get('pose') == None:
            return False
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        
        bb_autokey = bpy.context.scene.bb_autokey

        if self.action == "clear":
            bb_autokey.pop('pose', {})
            print("Buffer cleared")
            return {'FINISHED'}

        bpy.context.view_layer.update()
        obj = bpy.data.objects

        selected = [o for o in bpy.context.selected_objects]
        active = bpy.context.active_object

        rigs = []
        for o in selected:
            if o.type == 'ARMATURE':
                rigs.append(o)

        pose = bb_autokey['pose']

        to_selected = False

        if bb_autokey.autokey_paste_to_selected == True:
            if bpy.context.mode == 'POSE':
                to_selected = True

        if to_selected == True:
            selected_bones = [b for b in bpy.context.selected_pose_bones]
            for boneObj in selected_bones:
                arm = boneObj.id_data.name
                bone = boneObj.name
                if bone in pose:
                    mat = mathutils.Matrix(pose[bone])
                    obj[arm].pose.bones[bone].matrix_basis = mat
                    
                else:
                    print("Buffer missing bone", bone, "from armature", arm)
        else:
            for armObj in rigs:
                for bone in pose:
                    if bone in armObj.data.bones:
                        mat = mathutils.Matrix(pose[bone])
                        armObj.pose.bones[bone].matrix_basis = mat
                        
                    else:
                        print("Missing bone", bone, "in armature", o.name)
                print("Pose pasted to", armObj.name)

        print("Paste finished")

        return {'FINISHED'}

class OnigiriAnimationLibraryProperties(bpy.types.PropertyGroup):

    def update_blank(self, context):
        self["blank"] = False
    blank : bpy.props.BoolProperty(default=False, update=update_blank)

    def update_alib_anim_name_new(self, context):
        bb_alib = bpy.context.scene.bb_alib
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        new_name = bb_alib.alib_anim_name_new
        old_name = bb_alib.alib_anim_name_backup

        if new_name.strip() == "":
            print("New name is empty")
        elif new_name == old_name:
            print("new name is old", new_name)
        else:
            print("new to old:", new_name, old_name)
            
            if new_name in bb_alib['motion']:
                print("New name exists in motion library already")
            else:
                print("Name transferred to new buffer")
                bb_alib['motion'][new_name] = bb_alib['motion'][old_name]
                del bb_alib['motion'][old_name]

        bb_alib.alib_anim_name_edit = False
        bb_settings['terminate'] = True
        bb_alib.alib_anim_name_new = ""

        return

    alib_motion_processing_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =        "Motion processing contains bulk exporters,"        "\n"        "animation and pose library along with bulk"
        "\n"        "action and pose exporters",
        default = False
        )

    alib_anim_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =        "Expand / contract the animation library",
        default = False
        )

    alib_anim_name_edit : bpy.props.BoolProperty(
        default=False,
        )

    alib_anim_name_new : bpy.props.StringProperty(
        default="",
        update = update_alib_anim_name_new
        )

    alib_anim_name : bpy.props.StringProperty(
        name = "",
        description =            "Set a name here or Onigiri will create one automatically which you can rename after",
        default = "",
        )
    
    alib_anim_last_loaded : bpy.props.StringProperty(
        default = "",
        )
    
    alib_anim_name : bpy.props.StringProperty(default="")
    alib_anim_name_backup : bpy.props.StringProperty(default="")

    alib_action_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =        "Expand / contract the action library",
        default = False
        )
    alib_action_overwrite : bpy.props.BoolProperty(
        name = "",
        description =        "Overwrite Existing Files"        "\n\n"        "Enable this if you know you want to overwrite any files that collide with the names what will be generated.  "        "The name that's in the target field is used as a prefix, to which a suffix will be added (.001) etc.  If you are "        "beta testing then it makes sense to turn this on and also to choose a unique name prefix, the generator can help with "        "that.  This will destroy all of your previous saves with the same settings.",
        default = False
        )
    alib_action_use_selected_rig : bpy.props.BoolProperty(
        name = "",
        description =        "Use rig selection"        "\n\n"        "The bulk action/animation exporter generates a rig in order to accomplish the task.  This is ok for standard bipedal "        "characters but if you have a custom rig, especially with altered joint positions, this will not work.  Enabling this "        "option is safe, even with standard bipeds, if you have the proper rig chosen.  For bipeds it's the Onigiri Safe rig.",
        default = True
        )

    alib_action_use_source_keys : bpy.props.BoolProperty(
        name = "",
        description =        "Use Real Keys"        "\n\n"        "The common exporter is build for a huge variety of tasks and the most common way to process animations is through motion "        "detection.  However, when exporting bulk animations we're not expecting a proxy rig for this purpose and a key cleanup "        "process could damage the stops that you've included in your animation, for instance a single pose and key, so enabling this will "        "process your rig with actual keys only and no other data checking will be enabled.",
        default = False
        )
    alib_action_use_source_keys_rotation : bpy.props.BoolProperty(
        name = "",
        description =        "Use Rotations"        "\n\n"        "Along with (Use Keys) you can chose to include both rotation and location or one or the other, but if you disable both "        "with the (Use Keys) option on then you'll get nothing",
        default = True
        )
    alib_action_use_source_keys_location : bpy.props.BoolProperty(
        name = "",
        description =        "Use Locations"        "\n\n"        "Along with (Use Keys) you can chose to include both rotation and location or one or the other, but if you disable both "        "with the (Use Keys) option on then you'll get nothing",
        default = True
        )

    def update_export_mapped_animation(self, context):
        if self["alib_action_export_mapped_animation"] == True:
            self["alib_action_export_retargeted_animation"] = False
    def update_export_retargeted_animation(self, context):
        if self["alib_action_export_retargeted_animation"] == True:
            self["alib_action_export_mapped_animation"] = False
    alib_action_export_mapped_animation : bpy.props.BoolProperty(
        name = "",
        description =        "Export Mapped Animation"        "\n\n"            "This is similar to the (Export Mapped Mesh) in that it converts bone names to their corresponding targets on export, allowing "            "you to you to export bulk incompatible animations for use with Second Life.  If your rig is an Avastar rig then this feature "            "may be overridden by any Avastar switches you enable.  This feature is enabled by default because, when there is a mapped "            "rig, there's a map available for that rig and can be utilized to convert the names for use with the target",
        default = False,
        update=update_export_mapped_animation
        )
    alib_action_export_retargeted_animation : bpy.props.BoolProperty(
        name = "",
        description =            "Bulk export retargeted rig animation"            "\n\n"            "If bulk exporting a custom incompatible rig that needs to be retargeted keep your set engaged in the retargeter and try this "            "feature out.  This should work smoothly.  This is enabled by default because a reatarget set can be detected.  However, if "            "you've left old retarget sets in the scene, that is to say you forgot to reset the stage, then this state may be falsly "            "detected and ruine your day.  You can disable this in that case but you really should clean up your scene",
        default = True,
        update=update_export_retargeted_animation
        )

    alib_action_name : bpy.props.StringProperty(
        name = "",
        description =            "Empty this field if you want to export action names.  This is a base name for bulk export.  If this "            "is defined then all bulk exported actions will have as its prefix the defined text",
        default = "",
        )

    alib_action_rotation_fix : bpy.props.BoolProperty(
        name = "",
        description =        "Try fixing incompatible rotation modes"        "\n\n"        "This may not work but if you need it your setup is broken and it needs fixing.  The expected rotation mode for Onigiri "        "rig bones is Quaternion but if the animation is primarily Euler then there's a problem that cannot be fixed automatically.  "        "However, there is a chance that this feature can get you back in the game but the source issue is not fixed.  Your options "        "are to change bone modes manually, Onigiri has a tool for that in (Rig Tools), or retarget the animation.",
        default = False
        )

    alib_ranges_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Expand / contract the loops and ranges area.  This is for exports only and does not effect anything at all in Blender itself.",
        default = False
        )
    def update_alib_ranges_all_enabled(self, context):
        if self.alib_ranges_all_enabled == True:
            for actionObj in bpy.data.actions:
                actionObj['frame_range'] = True
        else:
            for actionObj in bpy.data.actions:
                actionObj['frame_range'] = False
    def update_alib_loops_all_enabled(self, context):
        if self.alib_loops_all_enabled == True:
            for actionObj in bpy.data.actions:
                actionObj['loop_range'] = True
        else:
            for actionObj in bpy.data.actions:
                actionObj['loop_range'] = False

    alib_ranges_all_enabled : bpy.props.BoolProperty(
        name = "",
        description =        "Force all custom frame ranges to toggle active or inactive",
        default = False,
        update = update_alib_ranges_all_enabled
        )
    alib_loops_all_enabled : bpy.props.BoolProperty(
        name = "",
        description =        "Force all custom loops ranges to toggle active or inactive",
        default = False,
        update = update_alib_loops_all_enabled
        )

    def update_alib_ease_all_enabled(self, context):
        if self.alib_ease_all_enabled == True:
            for actionObj in bpy.data.actions:
                actionObj['ease'] = True
        else:
            for actionObj in bpy.data.actions:
                actionObj['ease'] = False
    alib_ease_all_enabled : bpy.props.BoolProperty(
        name = "",
        description =        "Force all custom easeing to active or inactive",
        default = False,
        update = update_alib_ease_all_enabled
        )

    def update_alib_action_frame_start(self, context):
        action = self.alib_action_range_set_name
        actionObj = bpy.data.actions[action]
        actionObj['frame_start'] = self.alib_action_frame_start
        self.alib_action_range_set_name = ""
    def update_alib_action_frame_end(self, context):
        action = self.alib_action_range_set_name
        actionObj = bpy.data.actions[action]
        actionObj['frame_end'] = self.alib_action_frame_end
        self.alib_action_range_set_name = ""
    def update_alib_action_loop_start(self, context):
        action = self.alib_action_range_set_name
        actionObj = bpy.data.actions[action]
        actionObj['loop_start'] = self.alib_action_loop_start
        self.alib_action_range_set_name = ""
    def update_alib_action_loop_end(self, context):
        action = self.alib_action_range_set_name
        actionObj = bpy.data.actions[action]
        actionObj['loop_end'] = self.alib_action_loop_end
        self.alib_action_range_set_name = ""
    
    def update_alib_action_priority(self, context):
        action = self.alib_action_range_set_name
        actionObj = bpy.data.actions[action]
        actionObj['priority'] = self.alib_action_priority
        self.alib_action_range_set_name = ""

    def update_alib_action_ease_in(self, context):
        action = self.alib_action_range_set_name
        actionObj = bpy.data.actions[action]
        actionObj['ease_in'] = round(self.alib_action_ease_in, 2)
        self.alib_action_range_set_name = ""
    def update_alib_action_ease_out(self, context):
        action = self.alib_action_range_set_name
        actionObj = bpy.data.actions[action]
        actionObj['ease_out'] = round(self.alib_action_ease_out, 2)
        self.alib_action_range_set_name = ""

    alib_action_range_set_name : bpy.props.StringProperty(default="")

    alib_action_frame_start : bpy.props.IntProperty(
        name = "",
        description =            "Frame start for this action.",
        default = 0,
        update = update_alib_action_frame_start
        )
    alib_action_frame_end : bpy.props.IntProperty(
        name = "",
        description =            "Frame end for this action.",
        default = 0,
        update = update_alib_action_frame_end
        )
    alib_action_loop_start : bpy.props.IntProperty(
        name = "",
        description =            "Loop start for this action.",
        default = 0,
        update = update_alib_action_loop_start
        )
    alib_action_loop_end : bpy.props.IntProperty(
        name = "",
        description =            "Loop end for this action.",
        default = 0,
        update = update_alib_action_loop_end
        )
    
    alib_action_priority : bpy.props.IntProperty(
        name = "",
        description =            "Set base priority for this action.  If you want (per bone priorities) enable them in (Joint Priority Options)",
        min = -1,
        max = 6,
        default = 1,
        update = update_alib_action_priority
        )

    alib_action_ease_in : bpy.props.FloatProperty(
        name = "",
        description =            "Ease in",
        max = 1.0,
        default = 0.0,
        update = update_alib_action_ease_in
        )
    alib_action_ease_out : bpy.props.FloatProperty(
        name = "",
        description =            "Ease out",
        max = 1.0,
        default = 0.0,
        update = update_alib_action_ease_out
        )

    def update_alib_action_rename_new(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_alib = bpy.context.scene.bb_alib
        name = bb_alib.alib_action_rename_new
        old_name = bb_alib.alib_action_rename
        if name == old_name:
            print("Same name, rejecting")
            bb_alib.property_unset("alib_action_rename_new")
            bb_alib.property_unset("alib_action_rename")
            return
        if name.strip() == "":
            print("White space only, rejecting")
            bb_alib.property_unset("alib_action_rename_new")
            bb_alib.property_unset("alib_action_rename")
            return
        print("got rename trigger:", name)
        actions = [a.name for a in bpy.data.actions]
        if name in actions:
            print("The new name would collide with an existing one in the actions library, rejecting")
            bb_alib.property_unset("alib_action_rename_new")
            bb_alib.property_unset("alib_action_rename")
            return
        
        animutils.recycle_actions()

        state = bb_alib['actions'][old_name]['flagged']
        del bb_alib['actions'][old_name]
        bb_alib['actions'][name] = {}
        bb_alib['actions'][name]['flagged'] = state
        bpy.data.actions[old_name].name = name
        bb_alib.property_unset("alib_action_rename_new")
        bb_alib.property_unset("alib_action_rename")
        print("Action library transfer from", old_name, "to", name)
        return

    alib_action_rename : bpy.props.StringProperty(
        name = "",
        description = "-- internal",
        default = "",
        )
    
    alib_action_rename_new : bpy.props.StringProperty(
        name = "",
        description = "Rename the action",
        default = "",
        update = update_alib_action_rename_new
        )

    def update_alib_action_flag(self, context):
        
        pass
        return
    alib_action_flag : bpy.props.BoolProperty(default=False, update=update_alib_action_flag)

    def update_action_fill_fps(self, context):
        print("would have processed fps to refresh fill")
    def update_action_fill_time(self, context):
        print("would have processed time to refresh fill")
    action_fill_fps : bpy.props.FloatProperty(
        name="",
        description = ""            "This version of FPS is not the same as in the main animation UI.  This one is for the "            "bulk exporter only and works with the (fill) tool as well.",
        default=24,
        min=1,
        
        )
    action_fill_time : bpy.props.FloatProperty(
        name="",
        description = ""            "This version of (Time) is not a calculated value, it is for you to set in order to restrict "            "each fill slice to that total time.  When you use fill a number of frames will be calculated "            "per slice which will be equal to or less than (Time).  Enabling (Embed Anim Details) and the "            "(T) option will embed the time data into the filename for ease of use and parsing.  Be careful "            "with your base filename since import into SL will truncate the entire prefix to 63 characters",
        default=60,
        min=1,
        
        )
    action_fill_ease_in : bpy.props.FloatProperty(
        name="",
        description = ""            "Ease In"            "\n\n"            "Like the ease in/out in the main UI this will replace that feature for the animations exporting "            "using this bulk tool.  If using the (Fill) option you only really need to care about the first and "            "last segments since these will transition from an already playing animation.  But, because each "            "segment takes over for the previous, the following animation segment will obfuscate the view of "            "this easing until there's no more segments to play, which will be for the last one.  If you don't "            "want this easing effect simply set it to 0",
        default=0.82,
        )
    action_fill_ease_out : bpy.props.FloatProperty(
        name="",
        description = ""            "Ease Out"            "\n\n"            "Like the ease in/out in the main UI this will replace that feature for the animations exporting "            "using this bulk tool.  If using the (Fill) option you only really need to care about the first and "            "last segments since these will transition from an already playing animation.  But, because each "            "segment takes over for the previous, the following animation segment will obfuscate the view of "            "this easing until there's no more segments to play, which will be for the last one.  If you don't "            "want this easing effect simply set it to 0",
        default=0.82,
        )
    
    action_script_debug : bpy.props.BoolProperty(
        name="",
        description = ""            "Debug Messages"            "\n\n"            "With this enabled you'll see extensive messages while the animation is running, when it's rezed "            "and, if it's for an Avatar, when it's attached",
        default=False,
        )
    action_script_owner : bpy.props.BoolProperty(
        name="",
        description = ""            "Owner Only"            "\n\n"            "With this enabled nobody else can manipulate the object that activates and deactivates the sequence",
        default=True,
        )
    action_script_loop : bpy.props.BoolProperty(
        name="",
        description = ""            "Loop Sequence"            "\n\n"            "With this enabled your sequence will continue playing in a loop, this is not the same as single looped "            "but has the same visual effect since the sequenced animation is virtually seamless",
        default=True,
        )
    action_script_touch : bpy.props.BoolProperty(
        name="",
        description = ""            "On Touch"            "\n\n"            "If enabled then when the object that contains the script is touched the animation will toggle between "            "start and stop states",
        default=True,
        )
    action_script_listen : bpy.props.BoolProperty(
        name="",
        description = ""            "On Listen"            "\n\n"            "If enabled then when the proper command is given then the animation will start or stop depending on the command",
        default=True,
        )
    
    def action_script_channel(self, context):
        channel = self.action_script_channel
        sign = ""
        if channel.startswith("-"):
            sign = channel[:1]
            channel = channel[1:]
        if channel.isdecimal() == False:
            txt = "The IntProperty in Blender cannot represent the numeric value appropriate for this content so "            + "a string value is used and converted, unfortunately your string value contains something other than numbers and the (-) sign.  "            + "Your input was as follows: " + self.action_script_channel
            print(txt)
            popup("Input can only consist of an integer of range -2147483648 to 2147483647", "Error", "ERROR")
            self["action_script_channel"] = "5"
        result = int(sign + channel)
        if result < -2147483648 or result > 2147483647:
            print("The value you entered:", result)
            print("is out of range, use a value between -2147483648 and 2147483647")
            popup("Your value is out of range, see console for instructions", "Error", "ERROR")
            self["action_script_channel"] = "5"
        print("result:", result)

    action_script_channel : bpy.props.StringProperty(
        name="",
        description = ""            "Channel"            "\n\n"            "This is the channel you want to use for the start/stop commands.  It's suggested to use a negative channel when "            "using object to object communications but the default is 5 for easy testing, /5 start .  The channel range you can "            "use is between  -2147483648 and 2147483647, where 2147483647 is actually the debug channel so you probably don't "            "want to use that one, 0 is public so it's often not used for control listeners",
        default="5",
        update=action_script_channel
        )
    action_script_start : bpy.props.StringProperty(
        name="",
        description = ""            "Start Command"            "\n\n"            "This is the command you'll use in order to start your animation, it can be anything you like but the default is (start) "            "for clarity.  You'll want to at least change this if you haven't changed the channel number so you don't get confused "            "with other people utilizing this feature of Onigiri that may be near by you",
        default="start",
        )
    action_script_stop : bpy.props.StringProperty(
        name="",
        description = ""            "Stop Command"            "\n\n"            "This is the command you'll use in order to stop your animation, it can be anything you like but the default is (stop) "            "for clarity.  You'll want to at least change this if you haven't changed the channel number so you don't get confused "            "with other people utilizing this feature of Onigiri that may be near by you",
        default="stop",
        )

class OnigiriAnimationLibrarySave(bpy.types.Operator, ExportHelper):
    """Save an animation library"""
    bl_idname = "onigiri.animation_library_save"
    bl_label = "Save .ani lib"

    filename_ext = ".ani"

    filter_glob : bpy.props.StringProperty(
        default='*.ani',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):

        bb_alib = bpy.context.scene.bb_alib

        formatted_text = str(bb_alib['motion'].to_dict())

        anim_file = self.properties.filepath
        output = open(anim_file, 'w', encoding='UTF8')
        output.write("motion = ")
        output.write(formatted_text)
        output.close()

        return {'FINISHED'}

class OnigiriAnimationLibraryLoad(bpy.types.Operator, ImportHelper):
    """Load an animation library"""
    bl_idname = "onigiri.animation_library_load"
    bl_label = "Load .ani lib"

    filter_glob : bpy.props.StringProperty(
        default='*.ani',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        anim_file = self.properties.filepath

        motion = {}
        try:
            namespace = {}
            exec(open(anim_file, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("There was a problem reading your animation file, the following trace might give a clue what happened")
            print(traceback.format_exc())
            return {'FINISHED'}
        try:
            motion.update(namespace['motion'])
        except:
            print("I couldn't find the animation library in the file")
            popup("No animation library found", "Library Error", "ERROR")
            return {'FINISHED'}

        bb_alib['motion'] = motion

        return {'FINISHED'}

class OnigiriAnimationLibraryMerge(bpy.types.Operator, ImportHelper):
    """Merge an animation library into the panel.  It will combine with
your existing library which you can re-compose, delete from, add to and save as
a new library"""

    bl_idname = "onigiri.animation_library_merge"
    bl_label = "Merge .ani lib"

    filter_glob : bpy.props.StringProperty(
        default='*.ani',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        anim_file = self.properties.filepath

        motion = {}
        try:
            namespace = {}
            exec(open(anim_file, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("There was a problem reading your animation file, the following trace might give a clue what happened")
            print(traceback.format_exc())
            return {'FINISHED'}
        try:
            motion.update(namespace['motion'])
        except:
            print("I couldn't find the animation library in the file")
            popup("No animation library found", "Library Error", "ERROR")
            return {'FINISHED'}

        for name in motion:
            n = name
            if name in bb_alib['motion']:
                print("Name collision, generating hash")
                for i in range(20):
                    new_name = utils.get_temp_name()
                    if new_name not in bb_alib['motion']:
                        break
                if i > 10:
                    print("Fatal collision error")
                    popup("A name could not be generated to merge, this is a serious issue", "Fatal Error", "ERROR")
                    return {'FINISHED'}
                n = name + "_" + new_name
            bb_alib['motion'][n] = motion[name]
        
        return {'FINISHED'}

class OnigiriAnimationLibraryAdd(bpy.types.Operator):
    """Add the animation data from the current rig into the library"""

    bl_idname = "onigiri.animation_library_add"
    bl_label = "Animation Library Add"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.get('bb_motion') == None:
            return False
        return True

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        bb_autokey = bpy.context.scene.bb_autokey

        armObj = bpy.context.object

        if bb_alib.get('motion') == None:
            bb_alib['motion'] = {}

        name =  bb_alib.alib_anim_name

        if name.strip() == "":
            
            for i in range(20):
                name = utils.get_temp_name()
                if name in bb_alib['motion']:
                    print("Name collision:", name)
                else:
                    break
            if i > 10:
                print("An attempt to get a unique hash failed.  Is your library huge?  This failure only happen 1 in 100,000 times.")
                print("The failure occurred more 10 times")
                popup("Internal hash failure, this shouldn't happen", "Fatal Error", "ERROR")
                return {'FINISHED'}

        if name in bb_alib['motion']:
            print("Name already taken")
            popup("Name taken, use another", "Info", "INFO")
            return {'FINISHED'}

        bb_alib['motion'][name] = armObj['bb_motion'].to_dict() 
        bb_alib.alib_anim_name = ""

        self.action = ""

        return {'FINISHED'}

class OnigiriAnimationLibraryDelete(bpy.types.Operator):
    """Delete this animation from the library"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.animation_library_delete"
    bl_label = "Animation Library Delete"

    @classmethod
    def poll(cls, context):
        bb_alib = bpy.context.scene.bb_alib
        if bb_alib.get('motion') == None:
            return False
        return True

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        bb_autokey = bpy.context.scene.bb_autokey

        del bb_alib['motion'][self.name]

        self.name = ""

        return {'FINISHED'}

class OnigiriAnimationLibraryRename(bpy.types.Operator):
    """Rename this animation"""

    name : bpy.props.StringProperty(default="")
    
    action : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.animation_library_rename"
    bl_label = "Animation Rename"

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        bb_autokey = bpy.context.scene.bb_autokey

        new_name = bb_alib.alib_anim_name_new
        old_name = bb_alib.alib_anim_name_backup

        if self.action == "rename":

            bb_alib.alib_anim_name_edit = False
            bb_settings['terminate'] = True
            bb_alib.alib_anim_name_new = ""

            return {'FINISHED'}

        if self.name != "":

            if bb_alib.alib_anim_name_edit == True:
                bb_alib.alib_anim_name_edit = False
                bb_settings['terminate'] = True
                bb_alib.alib_anim_name_new = ""

            else:
                bb_alib.alib_anim_name_edit = True
                bb_settings['terminate'] = True
                bb_alib.alib_anim_name_new = self.name
                bb_alib.alib_anim_name_backup = self.name

        return {'FINISHED'}

        return {'FINISHED'}

        if name.strip() == "":
            print("garbage in garbage out")
            return {'FINISHED'}

        if name in bb_alib['motion']:
            print("Name already taken")
            popup("Name taken, use another", "Info", "INFO")
            return {'FINISHED'}

        bb_alib['motion'][name] = bb_alib['motion'][old_name].to_dict()
        del bb_alib['motion'][old_name]

        self.action = ""

        return {'FINISHED'}

class OnigiriAnimationLibraryApply(bpy.types.Operator):
    """Apply this animation to the selected rig.  This does not generate an instant
animation.  You have to bake it in using the Auto Key tools"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.animation_library_apply"
    bl_label = "Animation Library Apply"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        bb_autokey = bpy.context.scene.bb_autokey
        armObj = bpy.context.object
        if armObj.get('bb_motion'):
            print("There's saved data motion on the target rig, remove it before applying the animation")
            popup("Motion data exists, remove it first using the X near the Auto Key button", "Error", "ERROR")
        else:
            armObj['bb_motion'] = bb_alib['motion'][self.name].to_dict()
            print("Animation data from", self.name, "was transfered to the rig", armObj.name)

        return {'FINISHED'}

class OnigiriAnimationLibrary(bpy.types.Operator):
    """Save, Load, Apply, Name, Rename, Reset animation libraries.  This is like the pose
library but for animations instead.  You will find some test animations here to
experiment with"""

    action : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.animation_library"
    bl_label = "Animation Library"

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        bb_autokey = bpy.context.scene.bb_autokey

        if self.action == 'prefix':
            print("would have removed prefix")

        elif self.action == 'reset':
            bb_alib.pop('motion', {})
            print("Entire worlds have collapsed, your library is toast!")

        else:
            print("programmers goof")

        self.action = ""

        return {'FINISHED'}

class OnigiriAnimationActionApply(bpy.types.Operator):
    """Apply this action to the selected armature"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.alib_action_apply"
    bl_label = "Apply action to rig"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        
        return True

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        selected = [o for o in bpy.context.selected_objects]

        actionObj = bpy.data.actions[self.name]
        for o in selected:
            if o.animation_data == None:
                o.animation_data_create()
            o.animation_data.action = actionObj
        return {'FINISHED'}

        qualified = []
        for o in selected:
            if o.type == 'ARMATURE':
                qualified.append(o)
        for armObj in qualified:
            if armObj.animation_data == None:
                armObj.animation_data_create()
            elif armObj.animation_data.action == None:
                armObj.animation_data_create()
            actionObj = bpy.data.actions[self.name]
            armObj.animation_data.action = actionObj

        self.name = ""
        
        for o in qualified:
            print(o.name)

        return {'FINISHED'}

class OnigiriAnimationActionFlag(bpy.types.Operator):
    """Flag this action for processing in bulk.  If using the (Fill) tool then
flag only one action for splitting
"""

    action : bpy.props.StringProperty(default="")
    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.alib_action_flag"
    bl_label = "Flag action for processing, bulk export"

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib

        animutils.recycle_actions()

        if self.action == "all":
            for a in bb_alib['actions'].keys():
                bb_alib['actions'][a]['flagged'] = True
            self.name = ""
            self.action = ""
            return {'FINISHED'}
        if self.action == "none":
            for a in bb_alib['actions'].keys():
                bb_alib['actions'][a]['flagged'] = False
            self.name = ""
            self.action = ""
            return {'FINISHED'}
        if self.action != "":
            print("Some strange action occured with the action library flagging")
            self.name = ""
            self.action = ""
            return {'FINISHED'}

        flag = bb_alib['actions'][self.name]['flagged']

        bb_alib['actions'][self.name]['flagged'] = not flag

        self.name = ""
        self.action = ""

        return {'FINISHED'}

class OnigiriAnimationActionRangeSet(bpy.types.Operator):
    """Click this to alter the ranges for this action.  When the runnning guy's
background is red it's in edit mode, if the running guy is replaced by a red
dot it means that the frame range exceeds 60 seconds for the current fps"""

    bl_idname = "onigiri.alib_action_range_set"
    bl_label = "Click to alter the ranges"

    action : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        bb_anim = bpy.context.scene.bb_anim
        bb = bpy.context.scene.onigiri

        bb_frame_start = bb.animation_start_frame
        bb_frame_end = bb.animation_end_frame
        bb_loop_start = bb_anim.anim_loop_in_frame
        bb_loop_end = bb_anim.anim_loop_out_frame
        bb_ease_in = bb_anim.anim_ease_in_duration
        bb_ease_out = bb_anim.anim_ease_out_duration

        actionObj = bpy.data.actions[self.action]

        if actionObj.get('frame_start') == None:
            actionObj['frame_start'] = bb_frame_start
        if actionObj.get('frame_end') == None:
            actionObj['frame_end'] = bb_frame_end
        if actionObj.get('loop_start') == None:
            actionObj['loop_start'] = bb_loop_start
        if actionObj.get('loop_end') == None:
            actionObj['loop_end'] = bb_loop_end
        if actionObj.get('frame_range') == None:
            actionObj['frame_range'] = False
        if actionObj.get('loop_range') == None:
            actionObj['loop_range'] = False
        if actionObj.get('priority') == None:
            actionObj['priority'] = bb_anim.anim_base_priority
        if actionObj.get('ease_in') == None:
            actionObj['ease_in'] = bb_ease_in
        if actionObj.get('ease_out') == None:
            actionObj['ease_out'] = bb_ease_out

        action_frame_start = actionObj['frame_start']
        action_frame_end = actionObj['frame_end']
        action_loop_start = actionObj['loop_start']
        action_loop_end = actionObj['loop_end']
        action_priority = actionObj['priority']
        action_ease_in = round(actionObj['ease_in'], 2)
        action_ease_out = round(actionObj['ease_out'], 2)

        bb_alib["alib_action_frame_start"] = action_frame_start
        bb_alib["alib_action_frame_end"] = action_frame_end
        bb_alib["alib_action_loop_start"] = action_loop_start
        bb_alib["alib_action_loop_end"] = action_loop_end
        bb_alib["alib_action_priority"] = action_priority
        bb_alib["alib_action_ease_in"] = action_ease_in
        bb_alib["alib_action_ease_out"] = action_ease_out

        if bb_alib.alib_action_range_set_name == self.action:
            bb_alib.alib_action_range_set_name = ""

        else:
            bb_alib.alib_action_range_set_name = self.action

        return {'FINISHED'}

class OnigiriAnimationActionRangeAll(bpy.types.Operator):
    """Toggle all custom frame ranges to enable or disable them"""

    bl_idname = "onigiri.alib_action_range_all"
    bl_label = "Toggle custom frame range for all"

    action : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib

        return {'FINISHED'}

class OnigiriAnimationActionLoopAll(bpy.types.Operator):
    """Toggle all custom loop ranges to enable or disable them"""

    bl_idname = "onigiri.alib_action_loop_all"
    bl_label = "Toggle custom loop ranges for all"

    action : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib

        return {'FINISHED'}

class OnigiriAnimationActionRange(bpy.types.Operator):
    """Toggle custom frame range for this action"""

    bl_idname = "onigiri.alib_action_range"
    bl_label = "Toggle custom frame range"

    action : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        if bpy.data.actions[self.action].get('frame_range') == None:
            bpy.data.actions[self.action]['frame_range'] = False

        state = bpy.data.actions[self.action]['frame_range']
        bpy.data.actions[self.action]['frame_range'] = not state
        print("Toggled range for", self.action, "to", not state)

        return {'FINISHED'}

class OnigiriAnimationActionLoop(bpy.types.Operator):
    """Toggle custom loop range for this action"""

    bl_idname = "onigiri.alib_action_loop"
    bl_label = "Toggle custom loop range"

    action : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        if bpy.data.actions[self.action].get('loop_range') == None:
            bpy.data.actions[self.action]['loop_range'] = False

        state = bpy.data.actions[self.action]['loop_range']
        bpy.data.actions[self.action]['loop_range'] = not state
        print("Toggled loop for", self.action, "to", not state)

        return {'FINISHED'}

class OnigiriAnimationActionEase(bpy.types.Operator):
    """Toggle custom ease for this action"""

    bl_idname = "onigiri.alib_action_ease"
    bl_label = "Toggle custom ease"

    action : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        if bpy.data.actions[self.action].get('ease') == None:
            bpy.data.actions[self.action]['ease'] = False

        state = bpy.data.actions[self.action]['ease']
        bpy.data.actions[self.action]['ease'] = not state
        print("Toggled ease for", self.action, "to", not state)

        return {'FINISHED'}

class OnigiriAnimationActionDelete(bpy.types.Operator):
    """Delete this action from the user base, it will still be inside Blender but
will be removed when the file save/load cycle is renewed"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.alib_action_delete"
    bl_label = "Remove action from users"

    def execute(self, context):
        
        bb_alib = bpy.context.scene.bb_alib

        a = bpy.data.actions[self.name]
        action_name = a.name
        bpy.data.actions.remove(a)

        if bb_alib.get('action') == None:
            print("No stored action flags")
        else:
            
            bb_alib['action'].pop(self.name, "")

        print("Action", action_name, "removed from Blender data.")
        return {'FINISHED'}

class OnigiriAnimationActionCopy(bpy.types.Operator):
    """This copies the action so that you know it's safetly stored and has at least
1 user which ensures that it saves with the blender file"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.alib_action_copy"
    bl_label = "Duplicate this action"

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib

        if len(bpy.context.selected_objects) != 1:
            return {'FINISHED'}
        animObj = bpy.context.selected_objects[0]
        if animObj.animation_data == None:
            return {'FINISHED'}
        if animObj.animation_data.action == None:
            return {'FINISHED'}

        actionObj = bpy.data.actions[self.name]
        action_name = actionObj.name
        fakeObj = actionObj.copy()
        fakeObj.use_fake_user = True
        print("Action", action_name, "copied.")
        return {'FINISHED'}

class OnigiriAnimationActionFakeUser(bpy.types.Operator):
    """Enable or Disable fake user so that your actions save with your Blender file
even if they are not associated with anything"""

    bl_idname = "onigiri.alib_action_fake_user"
    bl_label = "Fake User"

    action : bpy.props.BoolProperty(default=True)
    def execute(self, context):

        for actionObj in bpy.data.actions:
            actionObj.use_fake_user = self.action

        return {'FINISHED'}

class OnigiriAnimationActionName(bpy.types.Operator):
    """Generate a unique name that you can customize for export.  When exporting
a number will be append to this entire name and incremented for each file.  If a
collision is predicted then the process will not even start, choose a good name"""

    bl_idname = "onigiri.alib_action_name"
    bl_label = "Generate a unique name"

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        bb_alib.property_unset("alib_action_name")
        base_name = bb_alib.alib_action_name
        post_fix = utils.get_temp_name()
        bb_alib.alib_action_name = base_name + "_" + post_fix

        return {'FINISHED'}

class OnigiriAnimationActionRename(bpy.types.Operator):
    """Rename the action to something sensible"""

    action : bpy.props.StringProperty(default="")
    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.alib_action_rename"
    bl_label = "Rename this action"

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib

        if self.action == "rename":
            bb_settings['terminate'] = True
            bb_alib.alib_action_rename_new = ""
            return {'FINISHED'}

        if self.name != "":
            
            if bb_alib.alib_action_rename_new == self.name:
                
                bb_settings['terminate'] = True
                bb_alib.alib_action_rename_new = ""
            else:
                
                bb_alib.alib_action_rename = self.name
                
                bb_settings['terminate'] = True
                bb_alib.alib_action_rename_new = self.name

        self.action = ""
        self.name = ""

        return {'FINISHED'}

class OnigiriAnimationActionConvert(bpy.types.Operator):
    """Keep your old Avastar animations.  Load up a Blend file with your Avastar rig
contained within, you must have the rig, choose the rig, flag each action that you want
converted to Onigiri and click the convert button."""

    bl_idname = "onigiri.alib_action_convert"
    bl_label = "Convert Avastar to Onigiri"

    @classmethod
    def poll(cls, context):
        bb_alib = bpy.context.scene.bb_alib
        if len(bpy.context.selected_objects) != 1:
            return False
        
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb_alib = bpy.context.scene.bb_alib

        if bb_alib.get('actions') == None:
            print("There are no actions or the existing actions have not been flagged yet")
            popup("No actions or no flagged ones to convert", "Error", "ERROR")
            return {'FINISHED'}

        armObj = bpy.context.selected_objects[0]
        bpy.context.view_layer.objects.active = armObj
        bpy.ops.object.mode_set(mode='OBJECT')
        frame_current = bpy.context.scene.frame_current
        old_mode = bpy.context.mode

        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'

        print("Cleaning Avastar rigs before converting...")
        candidates = []
        for o in obj:
            if o.type == 'ARMATURE':
                if o.get('avastar', None) != None:
                    candidates.append(o.name)
        for rig in candidates:
            result = rigutils.clean_controllers(armature=rig)
            if result == False:
                print("I couldn't clean the Avastar rigs, unknown error, maybe try (Remove Unusable Controllers) in (Rig Tools)")
                popup("Unknown error when cleaning rigs", "Error", "ERROR")
                return {'FINISHED'}

        actions = {a.name for a in bpy.data.actions}
        qualified = []
        for aname in bb_alib['actions']:
            if aname not in actions:
                
                print("Action name stored does not exist, this is probably a bug:", aname)
                continue
            
            if bb_alib['actions'][aname]['flagged'] == True:
                qualified.append(aname)
        if len(qualified) == 0:
            print("There were no qualified actions to convert.  You got your broken rigs cleaned though, that's something.")
            popup("No actions qualify for conversion, did you flag any yet?", "Nothing to do", "INFO")
            return {'FINISHED'}

        has_animation_data = False
        if armObj.animation_data != None:
            has_animation_data = True

        has_action = False
        if has_animation_data == True:
            if armObj.animation_data.action != None:
                has_action = True
                oldAction = armObj.animation_data.action
                armObj.animation_data.action = None

        bpy.ops.object.duplicate()
        avaObj = bpy.context.object

        if has_animation_data == False:
            avaObj.animation_data_create()

        slaveObj = rigutils.attach_slave_rig(armature=avaObj.name)
        if slaveObj == False:
            print("The process (attach_slave_rig) failed, not sure why")
            popup("A process failed, see System Console", "Error", "ERROR")
            return {'FINISHED'}

        print("got slave object:", slaveObj.name)

        avaObj.animation_data_create()

        bb_actions = []

        for action in qualified:
            print("converting action:", action)
            actionObj = bpy.data.actions[action]
            avaObj.animation_data.action = actionObj
            
            frame_data = animutils.get_action_keys(armature=avaObj.name, action=action)

            for frame in frame_data:
                bpy.context.scene.frame_set(frame)
                for pbone in frame_data[frame]:
                    
                    if pbone not in mod_data.pbone_map:
                        continue
                    
                    mbone = mod_data.pbone_map[pbone]
                    
                    pmat = slaveObj.pose.bones[mbone].matrix.copy()
                    slaveObj.pose.bones[mbone].matrix = pmat

                    for transform in frame_data[frame][pbone]:

                        if transform == "rotation":
                            slaveObj.pose.bones[mbone].keyframe_insert(data_path="rotation_quaternion", frame=frame)
                        elif transform == "location":
                            slaveObj.pose.bones[mbone].keyframe_insert(data_path="location", frame=frame)
                        elif transform == "scale":
                            slaveObj.pose.bones[mbone].keyframe_insert(data_path="scale", frame=frame)

            bb_actions.append(slaveObj.animation_data.action.name)
            slaveObj.animation_data.action = None

        slaveObj.select_set(True)
        bpy.ops.object.delete()

        armObj.select_set(True)
        bpy.context.view_layer.objects.active = armObj
        bpy.ops.object.mode_set(mode=old_mode)

        if has_action != False:
            armObj.animation_data.action = oldAction

        bpy.context.scene.frame_set(frame_current)

        bb_alib.pop('actions', None)
        bb_alib['actions'] = {}
        for action in bb_actions:
            bb_alib['actions'][action] = {}
            bb_alib['actions'][action]['flagged'] = True

        return {'FINISHED'}

class OnigiriAnimationActionExport(bpy.types.Operator, ExportHelper):
    """Bulk exporter.  Make sure your animation settings are correct for your
particular work-flow before using this.  There are frame range and loop range
options here to eneable/disable and the ranges are in a lower menu"""

    filename_ext = ".anim"

    filter_glob : bpy.props.StringProperty(
        default='*.anim',
        options={'HIDDEN'}
    )

    bl_idname = "onigiri.alib_action_export"
    bl_label = "SL .anim only"

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//") + bpy.context.scene.bb_alib.alib_action_name
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        bb_alib = bpy.context.scene.bb_alib
        if bb_alib.get('actions') == None:
            return False
        return True

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib
        base_name = bb_alib.alib_action_name

        bb = bpy.context.scene.onigiri
        bba = bpy.context.scene.bb_anim_props
        anim = bpy.context.scene.bb_anim
        bb_anim = anim

        obj = bpy.data.objects

        print("use_selected_rig has been disabled, which also means generated rigs are disabled as well as the Avastar animation converter")
        if 1 == 0:
            if bb_alib.alib_action_use_selected_rig == True:
                armatures = []
                for o in bpy.context.selected_objects:
                    if o.type == 'ARMATURE':
                        armatures.append(o)
                if len(armatures) > 1:
                    print("The option (use selected rig) is chosen but there are too many rigs selected")
                    popup("The option to use the selected rig is enabled but there are too many rigs selected", "Error", "ERROR")
                    anim.export_sl_anim_label_short = anim.export_sl_anim_label
                    anim.export_sl_anim_alert = False

                    return {'FINISHED'}
                if len(armatures) == 0:
                    print("The option (use selected rig) is chosen but there are NO rigs selected")
                    popup("The option to use the selected rig is enabled but there are NO rigs selected", "Error", "ERROR")
                    anim.export_sl_anim_label_short = anim.export_sl_anim_label
                    anim.export_sl_anim_alert = False
                    return {'FINISHED'}

            armatures = []
            sourceObj = None
            targetObj = None
            for o in bpy.context.selected_objects:
                if o.type == 'ARMATURE':
                    armatures.append(o)
                if len(armatures) == 1:
                    sourceObj = o
                    
                    targetObj = sourceObj.get('controller_target')
            if targetObj != None:
                print("armature has a controller target")
                
                try:
                    targetObj.select_set(True)
                    targetObj.select_set(False)
                except:
                    print("controller target is not viable")
                    print("The armature you're attempting to export from has a controller target but the target is missing.")
                    print("Remove the map info if you want to use this armature and try again.  Alternatively you can start")
                    print("with a new armature.")
                    popup("Damaged set, your mapped target is missing, see System Console", "Error", "ERROR")
                    return {'FINISHED'}

            state = utils.get_state()
            
            if bb_alib.alib_action_use_selected_rig:
                if targetObj != None:
                    armObj = targetObj
                else:
                    print("Use Selected Rig is chosen but no custom set was found, will attempt action on this rig:", sourceObj.name)
                    armObj = sourceObj
                    armObj.animation_data_clear()
                    armObj.animation_data_create()

            else:
                
                bpy.ops.onigiri.create_pos_rig()
                armObj = bpy.context.selected_objects[0]
                print("Generated a neutral rig to capture transforms:", armObj.name)
                armObj.animation_data_create()

        count = 0
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                count += 1
                armObj = o
        if count > 1:
            print("Too many rigs selected.  Choose your animation rig and try again")
            return False

        if bb_alib.alib_action_export_retargeted_animation == True:
            print("Retargeted animation export requested...")
            
            retarget_set = False
            inRig = motion.get_director(armObj)
            if inRig != False:
                retarget_set = True
                print("Found director:", inRig.name)
                outRig = inRig.get('bb_motion_actor')
                if outRig == None:
                    retarget_set = False
                else:
                    print("Found actor:", outRig.name)
            if retarget_set == False:
                print("Unable to acquire both the actor and director for a retargeting set, moving on...")
            else:
                armObj = outRig
        state = utils.get_state()

        actions = {a.name for a in bpy.data.actions}
        qualified = []
        for aname in bb_alib['actions'].keys():
            if aname not in actions:
                continue
            if bb_alib['actions'][aname]['flagged'] == True:
                qualified.append(aname)
        if len(qualified) == 0:
            print("There were no qualified actions to export")
            popup("No actions qualify for export, did you flag any yet?", "Nothing to do", "INFO")
            return {'FINISHED'}
        
        if (bb_alib.alib_action_name).strip() != "":
            if len(qualified) > 999:
                print("While it's unlikely that you'd ever actually reach this number, you seem to have done so with great magic.")
                print("The number of actions that are in the exporter exceeds the incremental function of 999.  Please export")
                print("in smaller blocks")
                popup("The number of potential exported items exceeds iterator, see System Console", "Fatal Error", "ERROR")
                return {'FINISHED'}
        else:
            print("Action default name is not defined, using action names instead")

        path, file_name = os.path.split(self.properties.filepath)

        print("path:", path)
        print("file_name:", file_name)

        try:
            ext = file_name.split(".")[-1]
            file_prefix = file_name.split(".")[-2]
        except:
            print("No filename given, we'll be exporting from action names")

        full_path = path + "/"
        if 1 == 0:
            print("path:", path)
            print("ext:", ext)
            print("------------------")
            print("full_path:", full_path)
            print("file_name:", file_name)
            print("file_prefix:", file_prefix)
            print("returning early for testing")
            return {'FINISHED'}

        file_names = []
        
        if (bb_alib.alib_action_name).strip() == "":
            print("No base name set, using action names instead")
            for a in qualified:
                file_names.append(a + ".anim")

        else:
            n = 0
            for a in qualified:
                
                n += 1
                ns = str(n)
                zf = ns.zfill(3)
                anim_name = file_prefix + "_" + zf + ".anim"
                file_names.append(anim_name)

        if bb_alib.alib_action_overwrite == False:
            for name in file_names:
                if os.path.isfile(full_path + name):
                    print("name collision with", name, ", exiting")
                    popup("File collision, see System Console for details", "Error", "ERROR")
                    return {'FINISHED'}

        anim_start_frame = bb.animation_start_frame
        anim_end_frame = bb.animation_end_frame
        anim_fps = bb.animation_fps
        anim_ease_in = bb_anim.anim_ease_in_duration
        anim_ease_out = bb_anim.anim_ease_out_duration
        anim_loop = bb_anim.anim_loop
        anim_loop_advanced = anim.anim_loop_advanced
        anim_loop_in_frame = anim.anim_loop_in_frame
        anim_loop_out_frame = anim.anim_loop_out_frame
        disable_location_offsets = bba.disable_location_offsets
        mark_tol = anim.mark_tol
        mark_tol_rot = anim.mark_tol_rot
        mark_tol_loc = anim.mark_tol_loc
        fill_missing_keys = bba.fill_missing_keys
        high_fidelity = bb_anim.anim_high_fidelity
        anim_resample = anim.anim_resample
        anim_resample_rate_rotation = anim.anim_resample_rate_rotation
        anim_resample_rate_location = anim.anim_resample_rate_location
        anim_base_priority = bb_anim.anim_base_priority

        use_source_keys = bb_anim.anim_use_source_keys
        use_source_keys_rotation = bb_anim.anim_use_source_keys_rotation
        use_source_keys_location = bb_anim.anim_use_source_keys_location
        bb_anim.anim_use_source_keys = bb_alib.alib_action_use_source_keys
        bb_anim.anim_use_source_keys_rotation = bb_alib.alib_action_use_source_keys_rotation
        bb_anim.anim_use_source_keys_location = bb_alib.alib_action_use_source_keys_location

        export_mapped_animation = bb_anim.export_mapped_animation
        bb_anim.export_mapped_animation = bb_alib.alib_action_export_mapped_animation
        
        export_retargeted_animation = bb_anim.export_retargeted_animation
        bb_anim.export_retargeted_animation = bb_alib.alib_action_export_retargeted_animation

        bba.fill_missing_keys = True

        for i in range(len(qualified)):
            action = qualified[i]
            filename = file_names[i]
            filepath = full_path + filename
            actionObj = bpy.data.actions[action]

            rotation_fix = False 
            if bb_alib.alib_action_rotation_fix == True:
                fcurve_paths = {}
                for boneObj in armObj.data.bones:
                    path_key = 'pose.bones["' + boneObj.name + '"]'
                    fcurve_paths[path_key] = boneObj.name
                for fc in actionObj.fcurves:
                    dp, idx = fc.data_path, fc.array_index
                    bone_path, delimiter, transform_type = dp.rpartition('.')
                    if bone_path not in fcurve_paths:
                        continue
                    real_bone = fcurve_paths[bone_path]
                    
                    rot_mode = armObj.pose.bones[real_bone].rotation_mode
                    
                    if transform_type == 'rotation_quaternion' and rot_mode != 'QUATERNION':
                        rotation_fix = True
                        armObj.pose.bones[real_bone].rotation_mode = 'QUATERNION'
                    if transform_type == 'rotation_euler' and rot_mode == 'QUATERNION':
                        rotation_fix = True
                        armObj.pose.bones[real_bone].rotation_mode = 'XYZ' 

                if rotation_fix == True:
                    rotation_fix = False
                    print("rotation_fix applied to proxy rig when examining the action", actionObj.name)

            frame_start = int(actionObj.frame_range[0])
            frame_end = int(actionObj.frame_range[1])
            anim_loop = False
            loop_start = bb_anim.anim_loop_in_frame
            loop_end = bb_anim.anim_loop_out_frame

            if actionObj.get('frame_range', False) == True:
                frame_start = actionObj.get('frame_start', frame_start)
                frame_end = actionObj.get('frame_end', frame_end)

            if actionObj.get('loop_range', False) == True:
                loop_start = actionObj.get('loop_start', loop_start)
                loop_end = actionObj.get('loop_end', loop_end)
                anim_loop = True

            if actionObj.get('priority') != None:
                bb_anim.anim_base_priority = actionObj['priority']

            bb.animation_fps = bb_alib.action_fill_fps
            
            bb_anim.anim_ease_in_duration = bb_alib.action_fill_ease_in
            bb_anim.anim_ease_out_duration = bb_alib.action_fill_ease_out

            if actionObj.get('ease', False) == True:
                print("Custom easing is True")
                ease_in = actionObj.get('ease_in')
                if ease_in != None:
                    bb_anim.anim_ease_in_duration = ease_in
                ease_out = actionObj.get('ease_out')
                if ease_out != None:
                    bb_anim.anim_ease_out_duration = ease_out
            else:
                print("Custom easing is False")

            bb.animation_start_frame = frame_start
            bb.animation_end_frame = frame_end
            bb_anim.anim_loop_in_frame = loop_start
            bb_anim.anim_loop_out_frame = loop_end
            bb_anim.anim_loop = anim_loop

            if 1 == 0:
                if targetObj == None:
                    armObj.animation_data.action = actionObj
                    animutils.export_sl_anim(armature=armObj.name, path=filepath)
                else:
                    targetObj.animation_data.action = actionObj
                    animutils.export_sl_anim(armature=sourceObj.name, path=filepath)

            if bb_alib.alib_action_export_retargeted_animation == True and retarget_set == True:
                inRig.animation_data.action = actionObj
                result = animutils.export_sl_anim(armature=outRig.name, path=filepath)
                if result == False:
                    if animutils.props['FATAL'] == True:
                        txt = "retargeted export - fatal error returned from animutils.  Check console for details."
                        print(txt)
                        popup(txt, "Error", "ERROR")
                        utils.set_state(state)
                        return {'FINISHED'}
            else:
                armObj.animation_data.action = actionObj
                result = animutils.export_sl_anim(armature=armObj.name, path=filepath)
                if result == False:
                    if animutils.props['FATAL'] == True:
                        txt = "direct export - fatal error returned from animutils.  Check console for details."
                        print(txt)
                        popup(txt, "Error", "ERROR")
                        utils.set_state(state)
                        return {'FINISHED'}

        bb.animation_start_frame = anim_start_frame
        bb.animation_end_frame = anim_end_frame
        bb.animation_fps = anim_fps
        bb_anim.anim_ease_in_duration = anim_ease_in
        bb_anim.anim_ease_out_duration = anim_ease_out
        bba.disable_location_offsets = disable_location_offsets
        anim.mark_tol = mark_tol
        anim.mark_tol_rot = mark_tol_rot
        anim.mark_tol_loc = mark_tol_loc
        bba.fill_missing_keys = fill_missing_keys
        bb_anim.anim_high_fidelity = high_fidelity
        anim.anim_resample = anim_resample
        anim.anim_resample_rate_rotation = anim_resample_rate_rotation
        anim.anim_resample_rate_location = anim_resample_rate_location
        bb_anim.anim_loop = anim_loop
        anim.anim_loop_advanced = anim_loop_advanced
        anim.anim_loop_in_frame = anim_loop_in_frame
        anim.anim_loop_out_frame  = anim_loop_out_frame
        bb_anim.anim_base_priority = anim_base_priority

        bb_anim.anim_use_source_keys = use_source_keys
        bb_anim.anim_use_source_keys_rotation = use_source_keys_rotation
        bb_anim.anim_use_source_keys_location = use_source_keys_location

        bb_anim.export_mapped_animation = export_mapped_animation
        bb_anim.export_retargeted_animation = export_retargeted_animation

        if bb_alib.alib_action_use_selected_rig == False:
            bpy.ops.object.delete()

        if 1 == 0:
            
            for o in selected:
                o.select_set(True)
            if active != None:
                bpy.context.view_layer.objects.active = active
            if old_mode != 'OBJECT':
                bpy.ops.object.mode_set(mode=old_mode)
            
            if old_mode == 'POSE':
                arm = active.name 
                bpy.ops.pose.select_all(action = 'DESELECT')
                for pbone in selected_pose_bones:
                    bone = pbone.name
                    obj[arm].data.bones[bone].select = True
                obj[arm].data.bones.active = obj[arm].data.bones[active_pose_bone]
        else:
            utils.set_state(state)

        txt = "---------------------------------------------------------------------------------------------\n"
        txt += "The neutral rig generation function used to be called in order to generate a proxy for this\n"
        txt += "bulk exporter.  The directive has been changed to utilize the pos_rig instead.  If you\n"
        txt += "encounter any errors on bulk export it's because it hasn't been tested yet and apparently\n"
        txt += "it doesn't work.  REPORT THIS AS A BUG IN THE BULK ANIMATION EXPORTER!\n"
        txt += "---------------------------------------------------------------------------------------------\n"

        return {'FINISHED'}

class OnigiriActionFillScript(bpy.types.Operator, ExportHelper):
    """Export LSL for Avatars or Animesh.  If you are using (Embed Anim Details)
you will have to edit the script manually or alter the asset name in-world to
match what's deposited into the anim_list array"""

    bl_idname = "onigiri.action_fill_script"
    bl_label = "Export LSL Script"

    filename_ext = ".lsl.txt"

    filter_glob : bpy.props.StringProperty(
        default='*.txt',
        options={'HIDDEN'}
    )

    filename : bpy.props.StringProperty(default="")

    action : bpy.props.StringProperty(default="avatar")

    @classmethod
    def poll(cls, context):
        bb_alib = bpy.context.scene.bb_alib
        if bb_alib.get('actions') == None:
            return False
        return True

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")

        if self.action == "avatar":
            suffix = "Avatar_Animation"
        elif self.action == "animesh":
            suffix = "Animesh_Animation"

        self.filepath = save_path + suffix
        wm = context.window_manager.fileselect_add(self)

        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib

        actions = [a for a in bpy.data.actions]
        if len(actions) == 0:
            print("No actions available to derive data from")
            popup("No actions available", "Info", "INFO")
            return {'FINISHED'}

        qualified = []
        for actionObj in actions:
            action = actionObj.name
            if action in bb_alib['actions']:
                if bb_alib['actions'][action]['flagged'] == True:
                    qualified.append(actionObj)

        if len(qualified) == 0:
            print("No flagged actions available")
            popup("No flagged actions available", "Info", "INFO")
            return {'FINISHED'}

        if len(qualified) > 999:
            print("Too many flagged actions, 999+")
            popup("No many flagged actions, 999+", "Error", "ERROR")
            return {'FINISHED'}

        base = bb_alib.alib_action_name
        n = 0
        anim_list = []
        for a in qualified:
            
            n += 1
            ns = str(n)
            zf = ns.zfill(3)
            anim_name = base + "_" + zf 
            anim_list.append(anim_name)

        time_list = []
        
        for actionObj in qualified:
            action_frame_start = actionObj.get('frame_start') 
            if action_frame_start == None:
                print("INIT: Bug catch, this should not happen, actioObj has no property 'frame_start' !!!")
                popup("FATAL ERROR! No frame_start, see console!", "Error", "ERROR")
                return {'FINISHED'}
            action_frame_end = actionObj.get('frame_end')
            if action_frame_end == None:
                print("INIT: Bug catch, this should not happen, actioObj has no property 'frame_end' !!!")
                popup("FATAL ERROR! No frame_end, see console!", "Error", "ERROR")
                return {'FINISHED'}

            total_time = abs(action_frame_start - action_frame_end) / bb_alib.action_fill_fps
            total_time_text = str(round(total_time, 2))
            time_list.append(total_time_text)

        anim_string = ""
        last = ", "
        count = 0
        for anim in anim_list:
            count += 1
            if count == len(anim_list):
                last = ""
            anim_string += '"' + anim + '"' + last
        time_string = ""
        last = ", "
        count = 0
        for time in time_list:
            count += 1
            if count == len(time_list):
                last = ""
            time_string += '"' + time + '"' + last

        print("anim_string:", anim_string)
        print("time_list:", time_string)

        path = script_dir + presets_path

        if self.action == "avatar":
            lsl_file = bb_settings["files"]["lsl_animation"]
        elif self.action == "animesh":
            lsl_file = bb_settings["files"]["lsl_animmesh"]

        f = open(path+lsl_file)
        code = f.read()
        f.close()

        code = code.replace( "%ANIM_LIST", anim_string, 1 )
        code = code.replace( "%TIME_LIST", time_string, 1 )
        code = code.replace( "%DEBUG", str(bb_alib.action_script_debug).upper(), 1 )
        code = code.replace( "%OWNER_ONLY", str(bb_alib.action_script_owner).upper(), 1 )
        code = code.replace( "%ANIM_LOOP", str(bb_alib.action_script_loop).upper(), 1 )
        code = code.replace( "%ON_TOUCH", str(bb_alib.action_script_touch).upper(), 1 )
        code = code.replace( "%ON_LISTEN", str(bb_alib.action_script_listen).upper(), 1 )
        code = code.replace( "%CHANNEL", bb_alib.action_script_channel, 1 )
        code = code.replace( "%START", bb_alib.action_script_start, 1 )
        code = code.replace( "%STOP", bb_alib.action_script_stop, 1 )

        f = open(self.filepath, "w")
        f.write(code)
        f.close()

        print("Saved to:", self.filepath)

        return {'FINISHED'}

class OnigiriActionFillAdd(bpy.types.Operator):
    """Automatically fill up a series of sements weith their range covering the
length of the entire flagged animation"""

    bl_idname = "onigiri.action_fill_add"
    bl_label = "Auto Fill Add"

    @classmethod
    def poll(cls, context):
        bb_alib = bpy.context.scene.bb_alib
        if bb_alib.get('actions') == None:
            return False
        
        flags = 0
        for action in bb_alib['actions'].keys():
            if bb_alib['actions'][action]['flagged'] == True:
                flags += 1
        if flags != 1:
            return False
        return True

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib

        actionObj = None
        for action in bb_alib['actions'].keys():
            if bb_alib['actions'][action]['flagged'] == True:
                actionObj = bpy.data.actions[action]
                print("found flagged action:", action)
                break
        
        if actionObj == None:
            print("Something strange happened when attempting to find a single flagged action")
            popup("Error: didn't find a flagged action", "Error", "ERROR")
            return {'FINISHED'}

        frame_start, frame_end = [int(f) for f in actionObj.frame_range]
        fill_fps = bb_alib.action_fill_fps
        fill_time = bb_alib.action_fill_time

        frame_range = frame_start + frame_end - 1
        
        total_time = (frame_range / fill_fps)

        print("frame_range:", frame_range)
        print("fill_time:", fill_time)
        print("total_time:", total_time)

        if total_time <= fill_time:
            print("The custom fill time accomodates the entire animation, splitting is not required.")
            print("In order to split your animation reduce your custom time to below", round(total_time, 2))
            popup("Warning: split not required, see console", "Error", "ERROR")
            return {'FINISHED'}

        base_float = total_time / fill_time
        base_int = int(base_float)
        if base_int == base_float:
            clones = base_int
        else:
            clones = base_int + 1

        print("clones:", clones)
        print("base_float:", base_float)
        print("base_int:", base_int)

        tpf = 1 / fill_fps
        frames = 0
        while (tpf * frames) < fill_time:
            frames += 1
        print("frames per full segment:", frames)

        actions = {}
        for count in range(clones):
            print("count:", count)
            newAction = actionObj.copy()
            newAction.use_fake_user = True
            name = newAction.name
            
            actions[name] = "" 
            bb_alib['actions'][name] = {}
            bb_alib['actions'][name]['flagged'] = True

        animutils.recycle_actions()

        bb_alib['actions'][actionObj.name]['flagged'] = False

        bb_alib['fill_actions'] = actions
        
        bb_alib['fill_flag'] = actionObj.name

        count = 1
        frame_now = frame_start
        for action in actions:
            actionObj = bpy.data.actions[action]
            actionObj['frame_start'] = frame_now
            
            if count == clones:
                actionObj['frame_end'] = frame_end
            else:
                actionObj['frame_end'] = frame_now + frames
            
            frame_now = (frame_now + frames + 1)
            actionObj['frame_range'] =  True 
            print("next pass for frame_now:", frame_now)
            count += 1

        return {'FINISHED'}

class OnigiriActionFillDel(bpy.types.Operator):
    """Delete the filler data added by the (Add) tool"""

    bl_idname = "onigiri.action_fill_del"
    bl_label = "Auto Fill Del"

    @classmethod
    def poll(cls, context):
        bb_alib = bpy.context.scene.bb_alib
        if bb_alib.get('actions') == None:
            return False
        if bb_alib.get('fill_actions') == None:
            return False
        return True

    def execute(self, context):
        bb_alib = bpy.context.scene.bb_alib

        actions = bb_alib.pop('fill_actions', None)
        for action in actions:
            if action in bpy.data.actions:
                actionObj = bpy.data.actions[action]
                print("Removing action object:", action)
                bpy.data.actions.remove(actionObj)

        action = bb_alib.pop('fill_flag', None)
        if action != None:
            if action in bpy.data.actions:
                
                if action not in bb_alib['actions']:
                    bb_alib['actions'][action] = {}
                print("restored flag to", action)
                bb_alib['actions'][action]['flagged'] = True

        animutils.recycle_actions()

        return {'FINISHED'}

class OnigiriPoseLibraryProperties(bpy.types.PropertyGroup):

    def update_pose_library_rename_new(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_pose = bpy.context.scene.bb_pose
        name = bb_pose.pose_library_rename_new
        old_name = bb_pose.pose_library_rename_old
        if name == old_name:
            print("Same name, rejecting")
            bb_pose.property_unset("pose_library_rename_new")
            bb_pose.property_unset("pose_library_rename_old")
            return
        if name.strip() == "":
            print("White space only, rejecting")
            bb_pose.property_unset("pose_library_rename_new")
            bb_pose.property_unset("pose_library_rename_old")
            return
        print("got rename trigger:", name)
        if name in bb_pose['poses']:
            print("The new name would collide with an existing one in the pose library, rejecting")
            bb_pose.property_unset("pose_library_rename_new")
            bb_pose.property_unset("pose_library_rename_old")
            return

        bb_pose['poses'][name] = bb_pose['poses'][old_name].to_dict()
        del bb_pose['poses'][old_name]
        bb_pose.property_unset("pose_library_rename_new")
        bb_pose.property_unset("pose_library_rename_old")
        print("Pose library transfer from", old_name, "to", name)
        return

    pose_library_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =        "Expand / contract the pose library",
        default = False
        )
    pose_library_name : bpy.props.StringProperty(
        name = "",
        description = "The name of a new entry, it has to be unique",
        default = "Pose"
        )
    
    pose_library_rename_new : bpy.props.StringProperty(
        name = "",
        description = "Change the name of this pose",
        default = "",
        update = update_pose_library_rename_new
        )
    pose_library_rename_old : bpy.props.StringProperty(
        name = "",
        description = "-- internal",
        default = ""
        )
    
    pose_library_name_base : bpy.props.StringProperty(
        name = "",
        description = "-- internal",
        default = "Pose"
        )
    pose_library_overwrite : bpy.props.BoolProperty(
        name = "",
        description =        "Disable overwrite checking and just overwrite any existing files if they match the exports.  "        "If you know what you're doing this is a quick prototype tool.  The suggestion is that you have "        "a special folder for your exports instead of flooding some other folder with misc items.",
        default = False
        )

    pose_library_last_loaded : bpy.props.StringProperty(
        name = "",
        description = "-- internal, the name of the last loaded library file",
        default = ""
        )

class OnigiriPoseLibraryAdd(bpy.types.Operator):
    """Add the pose from the selected rig to your library"""
    bl_idname = "onigiri.pose_library_add"
    bl_label = "Add pose"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose
        name = bb_pose.pose_library_name
        name_base = bb_pose.pose_library_name_base
        armObj = bpy.context.object

        if name == name_base:
            name = name_base + "_" + utils.get_temp_name()

        if bb_pose.get('poses') == None:
            bb_pose['poses'] = {}

        if name in bb_pose['poses']:
            print("The library already contains the name", name, ", generating a new one.")
            bb_pose.property_unset("pose_library_name")
            name = bb_pose.pose_library_name + "_" + utils.get_temp_name()
            if name in bb_pose['poses']:
                print("... generated name collision, one more time ...")
                bb_pose.property_unset("pose_library_name")
                name = bb_pose.pose_library_name + "_" + utils.get_temp_name()
                if name in bb_pose['poses']:
                    print("Fatal Error!  A doulbe collision prevented the action, this should never happen")
                    popup("There was an unusual name collision, try a different name")
                    bb_pose.pose_library_name = name 

        old_mode = bpy.context.mode

        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'

        if old_mode == 'EDIT':
            print("There's no pose in edit mode, what are you doing?  GO into pose mode, pose the rig.")
            print("You can capture the pose in object mode as well but, again, there's no pose in edit mode")
            popup("There's no pose in edit mode", "Error", "ERROR")
            return {'FINISHED'}

        frame_current = bpy.context.scene.frame_current

        if 1 == 0:
            bpy.ops.object.duplicate()
            proxyObj = bpy.context.object
            proxy = proxyObj.name
            if 'scratchpad' in bpy.data.actions:
                scratchpad = bpy.data.actions['scratchpad']
                bpy.data.actions.remove(scratchpad)
            scratchpad = bpy.data.actions.new("scratchpad")
            has_anim = False
            if proxyObj.animation_data != None:
                if proxyObj.animation_data.action != None:
                    has_anim = True
            if has_anim == False:
                proxyObj.animation_data_create()
            
            proxyObj.animation_data.action = scratchpad

        pose_matrix = {}
        for pBone in armObj.pose.bones:
            pmat = pBone.matrix.copy()
            pBone.matrix = pmat
            matb = pBone.matrix_basis.copy()
            pose_matrix[pBone.name] = matb

        bb_pose['poses'][name] = {}
        bb_pose['poses'][name]['pose_matrix'] = pose_matrix

        bpy.ops.object.mode_set(mode=old_mode)

        print("Added pose", name, "to your library")

        return {'FINISHED'}

class OnigiriPoseLibraryDelete(bpy.types.Operator):
    """Delete this pose from your library"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.pose_library_delete"
    bl_label = "Delete Pose"

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose
        del bb_pose['poses'][self.name]
        print("Deleted", self.name, "from your library")
        self.name = ""
        return {'FINISHED'}

class OnigiriPoseLibraryHash(bpy.types.Operator):
    """Generate a rather unique name prefix for your exports"""

    bl_idname = "onigiri.pose_library_hash"
    bl_label = "Create a unique name"

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose

        bb_pose.property_unset("pose_library_name")

        name = utils.get_temp_name()
        old_name = bb_pose.pose_library_name
        new_name = old_name + "_" + name
        bb_pose.pose_library_name = new_name

        print("New name generated:", new_name)

        return {'FINISHED'}

class OnigiriPoseLibraryDelete(bpy.types.Operator):
    """Delete this pose from your library"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.pose_library_delete"
    bl_label = "Delete Pose"

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose
        del bb_pose['poses'][self.name]
        print("Deleted", self.name, "from your library")
        self.name = ""
        return {'FINISHED'}

class OnigiriPoseLibraryReset(bpy.types.Operator):
    """Reset the pose library buffer.  Save your lib first if you want to keep it"""

    bl_idname = "onigiri.pose_library_reset"
    bl_label = "Reset Library"

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose

        bb_pose.property_unset("pose_library_name")
        bb_pose.property_unset("pose_library_last_loaded")

        bb_pose.pop('poses', {})
        print("Pose library has been destroyed!")

        return {'FINISHED'}

class OnigiriPoseLibraryPrefix(bpy.types.Operator):
    """Remove the prefix from this pose"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.pose_library_prefix"
    bl_label = "Remove Prefix"

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose

        prefix = bb_pose['poses'][self.name]['prefix']
        mats = bb_pose['poses'][self.name]['pose_matrix'].to_dict()
        pose_matrix = {}
        for bone in mats:
            new_bone = bone.replace(prefix, "", 1)
            pose_matrix[new_bone] = mats[bone]
        bb_pose['poses'][self.name]['pose_matrix'] = pose_matrix
        del bb_pose['poses'][self.name]['prefix']

        self.name = ""

        print("removed prefix", prefix, "from pose", self.name)

        return {'FINISHED'}

class OnigiriPoseLibraryRename(bpy.types.Operator):
    """Rename this pose"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.pose_library_rename"
    bl_label = "Rename pose"

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose

        if self.name != "":
            print("rename triggered for", self.name)
            
            if bb_pose.pose_library_rename_new == self.name:
                
                bb_settings['terminate'] = True
                bb_pose.pose_library_rename_new = ""
            else:
                
                bb_settings['terminate'] = True
                bb_pose.pose_library_rename_new = self.name
                
                bb_pose.pose_library_rename_old = self.name

        self.name = ""

        return {'FINISHED'}

class OnigiriPoseLibrarySave(bpy.types.Operator, ExportHelper):
    """Save this library to a file"""

    bl_idname = "onigiri.pose_library_save"
    bl_label = "Save pose lib"

    filename_ext = ".bpl"

    filter_glob : bpy.props.StringProperty(
        default='*.bpl',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose

        poses = bb_pose['poses'].to_dict()

        formatted_poses = "# Pose library auto-generated by Onigiri \n\n"
        formatted_poses += "poses = {\n"

        for pose in poses:
            formatted_poses += '    "' + pose + '": {' + "\n"

            formatted_poses += "        " + '"pose_matrix": {' + "\n"
            for bone in poses[pose]['pose_matrix']:
                
                matrix_basis = matrix_to_tuples(poses[pose]['pose_matrix'][bone])
                formatted_poses += '            "' + bone + '": ' + str(matrix_basis) + ",\n"
            formatted_poses += "            },\n"
            formatted_poses += "        },\n"
        formatted_poses += "    }\n"

        pose_file = self.properties.filepath
        output = open(pose_file, 'w', encoding='UTF8')
        output.write(formatted_poses)
        output.close()

        print("Pose library saved")

        return {'FINISHED'}

class OnigiriPoseLibraryLoad(bpy.types.Operator, ImportHelper):
    """Save this library to a file"""

    bl_idname = "onigiri.pose_library_load"
    bl_label = "Load pose lib"

    filter_glob : bpy.props.StringProperty(
        default='*.bpl',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose
        obj = bpy.data.objects
        pose_file = self.properties.filepath

        file_poses = {}
        try:
            namespace = {}
            exec(open(pose_file, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("There was a problem reading your pose file, the following trace might give a clue what happened")
            print(traceback.format_exc())
            return {'FINISHED'}
        try:
            file_poses.update(namespace['poses'])
        except:
            print("I couldn't find the pose library in the file")
            popup("No pose library found", "Library Error", "ERROR")
            return {'FINISHED'}

        for p in file_poses:
            pose_matrix = file_poses[p]['pose_matrix']
            prefix = get_data_prefix(pose_matrix)

            if prefix != "m":
                if prefix != "":
                    file_poses[p]['prefix'] = prefix

        bb_pose['poses'] = file_poses

        path, name = os.path.split(self.properties.filepath)

        bb_pose.pose_library_last_loaded = name
        print("Pose library loaded", name)

        return {'FINISHED'}

class OnigiriPoseLibraryMerge(bpy.types.Operator, ImportHelper):
    """Merge a pose library with the loaded one"""

    bl_idname = "onigiri.pose_library_merge"
    bl_label = "Merge pose lib"

    filter_glob : bpy.props.StringProperty(
        default='*.bpl',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = script_dir + data_path
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose

        pose_file = self.properties.filepath
        file_poses = {}
        try:
            namespace = {}
            exec(open(pose_file, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print("There was a problem reading your pose file, the following trace might give a clue what happened")
            print(traceback.format_exc())
            return {'FINISHED'}

        try:
            file_poses.update(namespace['poses'])
        except:
            print("I couldn't find the pose library in the file")
            popup("No pose library found", "Library Error", "ERROR")
            return {'FINISHED'}

        if bb_pose.get('poses') == None:
            bb_pose['poses'] = {}

        new_poses = bb_pose['poses'].to_dict()
        for pose in file_poses:
            new_pose = pose
            if pose in bb_pose['poses']:
                
                ext = utils.get_temp_name()
                new_pose = pose + "." + ext
                if new_pose in bb_pose['poses']:
                    txt = "Internal renaming error when attempting to generate a unique pose name, " + new_pose
                    print(txt)
                    
                    ext = utils.get_unique_name()
                    new_pose = pose + "." + ext
                    if new_pose in bb_pose['poses']:
                        txt = "Last ditch attempt to rename failed, you have serious library issues: " + new_pose
                        print (txt)
                        popup("Pose renaming failed after collision, see System Console", "Fatal Error", "ERROR")
                        return {'FINISHED'}
            new_poses[new_pose] = file_poses[pose]

        for p in new_poses:
            pose_matrix = new_poses[p]['pose_matrix']
            prefix = get_data_prefix(pose_matrix)
            
            if prefix != "m":
                if prefix != "":
                    new_poses[p]['prefix'] = prefix

        bb_pose['poses'] = new_poses

        del pose_matrix
        del file_poses
        del new_poses

        print("Pose library merged")

        return {'FINISHED'}

class OnigiriPoseLibraryFlag(bpy.types.Operator):
    """Flag this for bulk export"""

    action : bpy.props.StringProperty(default="")
    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.pose_library_flag"
    bl_label = "Flag for export"

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose

        if bb_pose.get('poses') == None:
            bb_pose['poses'] = {}

        if self.action == "all":
            for pose in bb_pose['poses']:
                bb_pose['poses'][pose]['flagged'] = True
            self.action = ""
            self.name = ""
            return {'FINISHED'}

        if self.action == "none":
            for pose in bb_pose['poses']:
                bb_pose['poses'][pose]['flagged'] = False
            self.action = ""
            self.name = ""
            return {'FINISHED'}

        if self.name != "":
            state = bb_pose['poses'][self.name].get('flagged', False)
            bb_pose['poses'][self.name]['flagged'] = not state

        self.action = ""
        self.name = ""
        return {'FINISHED'}

class OnigiriPoseLibraryExport(bpy.types.Operator, ExportHelper):
    """Export flagged poses.  The flagged poses will be exported, one for each
file, that you can then bulk upload to Second Life.  Check your base priority!
Unlike the static pose feature this honors the your priority settings"""

    bl_idname = "onigiri.pose_library_export"
    bl_label = "Export .anim only"

    filename_ext = ".anim"

    filter_glob : bpy.props.StringProperty(
        default='*.anim',
        options={'HIDDEN'}
    )

    @classmethod
    def poll(cls, context):
        bb_pose = bpy.context.scene.bb_pose
        if bb_pose.get('poses') == None:
            return False
        return True

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//") + bpy.context.scene.bb_pose.pose_library_name
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose

        bb = bpy.context.scene.onigiri
        bba = bpy.context.scene.bb_anim_props
        anim = bpy.context.scene.bb_anim
        bb_anim = anim
        frame_current = bpy.context.scene.frame_current

        poses = bb_pose['poses'].to_dict()

        pose_names = []
        for pose in poses:
            if bb_pose['poses'][pose].get('flagged') == True:
                pose_names.append(pose)
        if len(pose_names) == 0:
            print("None of the available poses in the library are flagged as exportable")
            popup("No exportable flagged poses were found", "Info", "INFO")
            return {'FINISHED'}
        if len(pose_names) > 999:
            print("While it's unlikely that you'd ever actually reach this number, you seem to have done so with great magic.")
            print("The number of poses that are in the exporter exceeds the incremental function of 999.  Please export")
            print("in smaller blocks")
            popup("The number of potential exported items exceeds iterator, see System Console", "Fatal Error", "ERROR")
            return {'FINISHED'}

        full_path = bpy.path.abspath("//")
        file_name = self.filepath.replace(full_path,"")
        file_prefix = os.path.splitext(file_name)[0]

        n = 0
        file_names = []
        for a in pose_names:
            
            n += 1
            ns = str(n)
            zf = ns.zfill(3)
            pose_name = file_prefix + "_" + zf + ".anim"
            file_names.append(pose_name)
        
        if bb_pose.pose_library_overwrite == False:
            for name in file_names:
                if os.path.isfile(full_path + name):
                    print("name collision with", name, ", exiting.  If you want to overwrite please set that option")
                    popup("File collision, see System Console for details", "Error", "ERROR")
                    return {'FINISHED'}

        anim_start_frame = bb.animation_start_frame
        anim_end_frame = bb.animation_end_frame
        anim_fps = bb.animation_fps
        anim_loop = bb_anim.anim_loop

        anim_loop_advanced = anim.anim_loop_advanced
        anim_loop_in_frame = anim.anim_loop_in_frame
        anim_loop_out_frame = anim.anim_loop_out_frame
        disable_location_offsets = bba.disable_location_offsets
        export_volume_motion = bb.export_volume_motion
        mark_tol = anim.mark_tol
        mark_tol_rot = anim.mark_tol_rot
        mark_tol_loc = anim.mark_tol_loc
        fill_missing_keys = bba.fill_missing_keys
        high_fidelity = bb_anim.anim_high_fidelity
        anim_resample = anim.anim_resample
        anim_resample_rate_rotation = anim.anim_resample_rate_rotation
        anim_resample_rate_location = anim.anim_resample_rate_location

        old_mode = bpy.context.mode
        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'
        selected = [o for o in bpy.context.selected_objects]
        active = bpy.context.active_object

        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        for o in selected:
            o.select_set(False)

        bpy.ops.onigiri.create_neutral_rig()
        proxyObj = bpy.context.object
        print("Generated a neutral rig to capture transforms:", proxyObj.name)
        proxyObj.animation_data_create()
        proxy = proxyObj.name

        if 'scratchpad' in bpy.data.actions:
            scratchpad = bpy.data.actions['scratchpad']
            bpy.data.actions.remove(scratchpad)

        has_anim = False
        if proxyObj.animation_data != None:
            if proxyObj.animation_data.action != None:
                has_anim = True
        if has_anim == False:
            proxyObj.animation_data_create()

        frame_start, frame_end = frame_current - 2, frame_current
        bb_anim.anim_loop = True
        anim.anim_loop_advanced = False
        anim.anim_loop_in_frame = frame_current - 1
        anim.anim_loop_out_frame = frame_current
        bb.animation_start_frame = frame_start
        bb.animation_end_frame = frame_end
        bb.animation_fps = 5
        anim.mark_tol = False
        anim.anim_resample = False
        bba.fill_missing_keys = False
        bb_anim.anim_high_fidelity = False
        bba.disable_location_offsets = True
        bb.export_volume_motion = False

        for i in range(len(pose_names)):
            p = pose_names[i]
            f = file_names[i]
            
            scratchpad = bpy.data.actions.new("scratchpad")
            
            proxyObj.animation_data.action = scratchpad

            for boneObj in proxyObj.pose.bones:
                bone = boneObj.name
                if bone not in bb_pose['poses'][p]['pose_matrix']:
                    continue
                boneObj.matrix_basis = mathutils.Matrix(bb_pose['poses'][p]['pose_matrix'][bone])

            for boneObj in proxyObj.pose.bones:
                rotation_mode = boneObj.rotation_mode
                if rotation_mode == 'QUATERNION':
                    rmode = 'rotation_quaternion'
                else:
                    rmode = 'rotation_euler'
                boneObj.keyframe_insert(data_path=rmode, frame=frame_current)
                boneObj.keyframe_insert(data_path='location', frame=frame_current)

            frame_now = frame_current - 1
            bpy.context.scene.frame_set(frame_now)

            for boneObj in proxyObj.pose.bones:
                rotation_mode = boneObj.rotation_mode
                if rotation_mode == 'QUATERNION':
                    rmode = 'rotation_quaternion'
                else:
                    rmode = 'rotation_euler'
                boneObj.keyframe_insert(data_path=rmode, frame=frame_now)
                boneObj.keyframe_insert(data_path='location', frame=frame_now)

            frame_now = frame_current - 2
            bpy.context.scene.frame_set(frame_now)

            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.select_all(action='SELECT')
            bpy.ops.pose.transforms_clear()
            bpy.ops.object.mode_set(mode='OBJECT')

            for boneObj in proxyObj.pose.bones:
                rotation_mode = boneObj.rotation_mode
                if rotation_mode == 'QUATERNION':
                    rmode = 'rotation_quaternion'
                else:
                    rmode = 'rotation_euler'
                boneObj.keyframe_insert(data_path=rmode, frame=frame_now)
                boneObj.keyframe_insert(data_path='location', frame=frame_now)

            filepath = full_path + f
            animutils.export_sl_anim(armature=proxy, path=filepath)

            proxyObj.animation_data.action = None
            bpy.data.actions.remove(scratchpad)

        bpy.context.scene.frame_set(frame_current)
        bpy.ops.object.delete()

        bb.animation_start_frame = anim_start_frame
        bb.animation_end_frame = anim_end_frame
        bb.animation_fps = anim_fps
        bba.disable_location_offsets = disable_location_offsets
        bb.export_volume_motion = export_volume_motion

        anim.mark_tol = mark_tol
        anim.mark_tol_rot = mark_tol_rot
        anim.mark_tol_loc = mark_tol_loc
        bba.fill_missing_keys = fill_missing_keys
        bb_anim.anim_high_fidelity = high_fidelity
        anim.anim_resample = anim_resample
        anim.anim_resample_rate_rotation = anim_resample_rate_rotation
        anim.anim_resample_rate_location = anim_resample_rate_location

        bb_anim.anim_loop = anim_loop
        anim.anim_loop_advanced = anim_loop_advanced
        anim.anim_loop_in_frame = anim_loop_in_frame
        anim.anim_loop_out_frame  = anim_loop_out_frame

        for o in selected:
            o.select_set(True)
        bpy.context.view_layer.objects.active = active
        if len(bpy.context.selected_objects) > 0:
            bpy.ops.object.mode_set(mode=old_mode)

        return {'FINISHED'}

class OnigiriPoseLibraryApply(bpy.types.Operator):
    """Apply this pose to the selected rig"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.pose_library_apply"
    bl_label = "Apply pose"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose
        old_mode = bpy.context.mode
        if old_mode.startswith('EDIT'):
            print("Can't pose an armature in edit mode")
            popup("Can't pose an armature while its in edit mode", "Error", "ERROR")
            return {'FINISHED'}

        qualified = []
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                qualified.append(o)

        pose = bb_pose['poses'][self.name]['pose_matrix']
        for o in qualified:
            print("applying pose", self.name, "to", o.name)
            for bone in pose:
                if bone not in o.pose.bones:
                    print("skipping missing bone:", bone)
                    continue
                mat = mathutils.Matrix(pose[bone])
                o.pose.bones[bone].matrix_basis = mat

        self.name = ""
        print("Finished posing")

        return {'FINISHED'}

class OnigiriPoseLibraryApplyToSelected(bpy.types.Operator):
    """Apply this pose to the selected pose bones"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.pose_library_apply_to_selected"
    bl_label = "Apply pose to selected"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        bb_pose = bpy.context.scene.bb_pose
        old_mode = bpy.context.mode
        if old_mode.startswith('EDIT'):
            print("Can't pose an armature in edit mode")
            popup("Can't pose an armature while its in edit mode", "Error", "ERROR")
            return {'FINISHED'}

        if len(bpy.context.selected_objects) != 1:
            print("Only takes one object")
            return {'FINISHED'}
        armObj = bpy.context.selected_objects[0]
        if armObj.type != 'ARMATURE':
            print("Requires an armature")
            return {'FINISHED'}
        if bpy.context.mode != 'POSE':
            print("Requires pose mode")
            return {'FINISHED'}
        if len(bpy.context.selected_pose_bones) == 0:
            print("Requires pose bones selected")
            return {'FINISHED'}
        pose_bones = set([b.name for b in bpy.context.selected_pose_bones])
        pose = bb_pose['poses'][self.name]['pose_matrix']
        for bone in pose:
            if bone not in armObj.pose.bones:
                print("skipping missing bone:", bone)
                continue
            if bone not in pose_bones:
                continue
            mat = mathutils.Matrix(pose[bone])
            armObj.pose.bones[bone].matrix_basis = mat

        self.name = ""
        print("Finished posing selected bones")

        return {'FINISHED'}

class OnigiriMotionMixerProperties(bpy.types.PropertyGroup):

    def update_mixer_cleanup(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] == False
            return
        bb_mixer = bpy.context.window_manager.bb_mixer
        bb_settings['terminate'] = True
        bb_mixer.mixer_cleanup = False

        print("mixer_cleanup")
        tObj = bb_mixer.get('target')
        if tObj:
            if tObj.name not in bpy.context.scene.objects:
                bpy.data.objects.remove(tObj)
        
        targetObj = bb_mixer.pop('target', None)
        sources = bb_mixer.pop('sources', None)

        maps = bb_mixer.pop('maps', "")
        bb_mixer.mixer_target_name = ""
        bb_mixer.mixer_anchor_name = ""
        bb_mixer.mixer_active_rig_name = ""
        bb_mixer.property_unset("mixer_ready")
        bb_mixer.property_unset("mixer_target_locked")

        old_mode = bpy.context.mode
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        for o in bpy.context.selected_objects:
            o.select_set(False)
        if targetObj:
            targetObj.select_set(True) 
            print("Bone groups reset")
            
            bpy.context.view_layer.objects.active = targetObj
            for g in targetObj.pose.bone_groups:
                targetObj.pose.bone_groups.remove(g)
            for boneObj in targetObj.pose.bones:
                constraints = boneObj.constraints
                for c in constraints:
                    boneObj.constraints.remove(c)
        if sources:
            for o in sources:
                for g in o.pose.bone_groups:
                    o.pose.bone_groups.remove(g)

        return

    def update_mixer_target_locked(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] == False
            return
        bb_mixer = bpy.context.window_manager.bb_mixer
        if bb_mixer.mixer_target_locked == True:
            print("Mixer target:", bpy.context.selected_objects[0].name)
        else: 
            
            bb_mixer.mixer_cleanup = True

        return

    mixer_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description = "Open the animation mixer",
        default = False
        )
    mixer_target_locked : bpy.props.BoolProperty(
        name = "",
        description =        "This shows that your target is enabled and you're now ready to choose sources",
        default = False,
        update = update_mixer_target_locked
        )
    mixer_target_name : bpy.props.StringProperty(
        name = "",
        description = "-- internal, target name",
        default = " ",
        )
    
    mixer_cleanup : bpy.props.BoolProperty(
        name = "",
        description = "--internal",
        default = False,
        update = update_mixer_cleanup
        )

    def update_mixer_transform_info(self, context):
        bpy.context.window_manager.bb_mixer.property_unset("mixer_transform_info")
        return
    mixer_transform_info : bpy.props.BoolProperty(
        name = "",
        description =            "This button is informative only"            "\n\n"            "Location, Rotation and Scale are initial settings when you add bones to the mixer.  Scale data cannot be used in SL, yet, "            "and we're not aware of any plans that will allow for that but the feature is here for future growth.  Rotation and Location "            "are the focus for Second Life with (Location) being the least used so the default here is (Rotation) only.  However, the "            "versatile utility of Onigiri does allow for location data to be used in animations with your BVH and anim exports and "            "is usually required when you auto-map a custom character.  You can tick the feature off per bone for testing it out and "            "watching the viewport.",
        default = False,
        update = update_mixer_transform_info
        )

    mixer_location : bpy.props.BoolProperty(
        name = "",
        description =            "Enable location transform influence as a default for new bone additions",
        default = False,
        )
    mixer_rotation : bpy.props.BoolProperty(
        name = "",
        description =            "Enable rotation transform influence as a default for new bone additions",
        default = True,
        )
    mixer_scale : bpy.props.BoolProperty(
        name = "",
        description =            "Enable scale transform influence as a default for new bone additions (no recommended)",
        default = False,
        )

    def update_mixer_anchor(self, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        
        if bb_mixer.mixer_anchor == False:
            obj = bpy.data.objects
            source = bb_mixer.mixer_anchor_name
            bb_mixer.mixer_anchor_name = ""
            
            for boneObj in bpy.context.selected_pose_bones:
                dBone = boneObj.bone
                dBone.select = False
            armObj = obj[source]
            bpy.context.view_layer.objects.active = armObj
            armObj.data.bones['mPelvis'].select = True
            bpy.ops.onigiri.mixer_remove_bones()
            bb_mixer.property_unset("mixer_anchor")
            print("Removed anchor from", source)
        return

    mixer_anchor : bpy.props.BoolProperty(
        name = "",
        description =            "Disable this anchor",
        default = True,
        update = update_mixer_anchor
        )
    mixer_anchor_name : bpy.props.StringProperty(
        name = "",
        description =            "--internal name for the anchor",
        default = "",
        )

    def update_mixer_active_rig(self, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        bb_mixer.mixer_active_rig_name = ""
        bb_mixer.property_unset("mixer_active_rig")
        return
    mixer_active_rig : bpy.props.BoolProperty(
        name = "",
        description =            "Click to close the list or click another rig name to swap views.",
        default = False,
        update = update_mixer_active_rig
        )
    mixer_active_rig_name : bpy.props.StringProperty(
        name = "",
        description =            "--internal, holds the name of the active rig showing a list of associated bones that influence the target",
        default = "",
        )

    def update_mixer_ready(self, context):
        
        bb_mixer = bpy.context.window_manager.bb_mixer
        if bb_mixer.mixer_ready == True:
            return
        old_mode = bpy.context.mode
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        for o in bpy.context.selected_objects:
            o.select_set(False)
        return

    mixer_ready : bpy.props.BoolProperty(
        name = "",
        description =            "Click to suspend (ready) mode if you need to choose more rigs or remove existing ones.",
        default = False,
        update = update_mixer_ready
        )

    def update_mixer_location_set(self, context):
        
        bb_mixer = bpy.context.window_manager.bb_mixer
        if bb_mixer.mixer_location_set == False:
            bone = globals.bb_mixer['bone_location_set']
            globals.bb_mixer['constraints'][bone]['location'].influence = 0
            bb_mixer.property_unset("mixer_location_set")
            
            if bone == 'mPelvis':
                print("Disabled anchor")
                bb_mixer.mixer_anchor_name = ""
            print("L bone:", bone)
            print("active bone name:", bb_mixer.mixer_active_bone_name)
        return

    def update_mixer_rotation_set(self, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        if bb_mixer.mixer_rotation_set == False:
            bone = globals.bb_mixer['bone_rotation_set']
            globals.bb_mixer['constraints'][bone]['rotation'].influence = 0
            bb_mixer.property_unset("mixer_rotation_set")
            print("R bone:", bone)
            print("active bone name:", bb_mixer.mixer_active_bone_name)
        return

    def update_mixer_scale_set(self, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        if bb_mixer.mixer_scale_set == False:
            bone = globals.bb_mixer['bone_scale_set']
            globals.bb_mixer['constraints'][bone]['scale'].influence = 0
            bb_mixer.property_unset("mixer_scale_set")
            print("S bone:", bone)
            print("active bone name:", bb_mixer.mixer_active_bone_name)
        return

    mixer_location_set : bpy.props.BoolProperty(
        name = "",
        description =            "Click this to disable the position influence for this bone",
        default = True,
        update = update_mixer_location_set
        )
    mixer_rotation_set : bpy.props.BoolProperty(
        name = "",
        description =            "Click this to disable the rotation influence for this bone",
        default = True,
        update = update_mixer_rotation_set
        )
    mixer_scale_set : bpy.props.BoolProperty(
        name = "",
        description =            "Click this to disable the scale influence for this bone",
        default = True,
        update = update_mixer_scale_set
        )
    mixer_active_bone_name : bpy.props.StringProperty(
        name = "",
        description =            "-internal",
        default = "",
        )
    
class OnigiriMotionMixerLockTarget(bpy.types.Operator):
    """Add the main target rig, this is the armature that will receive all of the
motion from your animated source rigs.  These must all be Onigiri rigs so
retarget your animations first then motion mix with this tool"""

    bl_idname = "onigiri.mixer_lock_target"
    bl_label = "Lock the target armature"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].type == 'ARMATURE':
                if bpy.context.selected_objects[0].get('onigiri') != None:
                    return True
        return False

    def execute(self, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        targetObj = bpy.context.selected_objects[0]
        bb_mixer.mixer_target_locked = True
        bb_mixer.mixer_target_name = targetObj.name
        bb_mixer['target'] = targetObj

        old_mode = bpy.context.mode
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'

        bpy.context.view_layer.objects.active = targetObj
        bpy.ops.object.mode_set(mode='OBJECT')
        for g in targetObj.pose.bone_groups:
            targetObj.pose.bone_groups.remove(g)
        
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.group_add()
        targetObj.pose.bone_groups.active.name = mixer_group_target_inactive_name
        targetObj.pose.bone_groups.active.color_set = mixer_group_target_inactive_theme
        bpy.ops.pose.group_add()
        targetObj.pose.bone_groups.active.name = mixer_group_target_active_name
        targetObj.pose.bone_groups.active.color_set = mixer_group_target_active_theme
        
        for boneObj in targetObj.pose.bones:
            boneObj.bone_group = targetObj.pose.bone_groups[mixer_group_target_inactive_name]

        bpy.ops.object.mode_set(mode='OBJECT')

        rigutils.remove_deps(armature=targetObj.name)

        for boneObj in targetObj.pose.bones:
            
            if 1 == 1:
                bone = boneObj.name

                print("targetObj.name / boneObj.name:", targetObj.name, boneObj.name)

                targetObj.data.bones.active = targetObj.data.bones[bone]
                bc = boneObj.constraints
                bc.new('COPY_LOCATION')
                
                bc['Copy Location'].target_space = 'LOCAL' 
                bc['Copy Location'].owner_space = 'LOCAL'
                bc['Copy Location'].influence = 0
                globals.bb_mixer['constraints'][bone]['location'] = bc['Copy Location']
                bc['Copy Location'].name = "BB Copy Location"

                bc = boneObj.constraints
                bc.new('COPY_ROTATION')
                
                bc['Copy Rotation'].target_space = 'LOCAL'
                bc['Copy Rotation'].owner_space = 'LOCAL'
                bc['Copy Rotation'].influence = 0
                globals.bb_mixer['constraints'][bone]['rotation'] = bc['Copy Rotation']
                bc['Copy Rotation'].name = "BB Copy Rotation"

                bc = boneObj.constraints
                bc.new('COPY_SCALE')
                
                bc['Copy Scale'].target_space = 'LOCAL'
                bc['Copy Scale'].owner_space = 'LOCAL'
                bc['Copy Scale'].influence = 0
                globals.bb_mixer['constraints'][bone]['scale'] = bc['Copy Scale']
                bc['Copy Scale'].name = "BB Copy Scale"
            else:
                bone = boneObj.name
                targetObj.data.bones.active = targetObj.data.bones[bone]
                bc = boneObj.constraints
                bc.new('CHILD_OF')
                conObj = bc.new(constraint)
                cname = conObj.name
                conObj.target = targetObj
                
                conObj.target_space = 'LOCAL'
                conObj.owner_space = 'LOCAL'
                conObj.influence = 0
                if constraint == 'CHILD_OF':
                    context_py = bpy.context.copy()
                    context_py["constraint"] = bc.active
                    utils.set_inverse(context_py, cname)
                    
                globals.bb_mixer['constraints'][bone]['child_of'] = conObj['Child Of']
                conObj.name = "BB " + cname

        return {'FINISHED'}

class OnigiriMotionMixerAddSource(bpy.types.Operator):
    """Add an animated source rig, it must be a Onigiri rig.  You can get these
sources by retargeting existing animated sources or creating your own, possibly
loading them onto a rig from the action library or baking from the animation lib"""

    bl_idname = "onigiri.mixer_add_source"
    bl_label = "Add an animated source rig"

    @classmethod
    def poll(cls, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        
        if bb_mixer.mixer_ready == True:
            return False
        
        if len(bpy.context.selected_objects) == 0:
            return False
        
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                if o.get('onigiri') != None:
                    
                    if bb_mixer.get('target') != o:
                        return True
        return False

    def execute(self, context):
        bb_mixer = bpy.context.window_manager.bb_mixer

        selected = [o for o in bpy.context.selected_objects]

        old_mode = bpy.context.mode
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'

        for o in selected:
            o.select_set(False)

        candidates = []
        for o in selected:
            if o.type == 'ARMATURE':
                if o.get('onigiri') != None:
                    if bb_mixer['target'] != o:
                        candidates.append(o)
                    else:
                        print("Target in source selection, skipping:", o.name)

        sources = bb_mixer.get('sources', [])
            
        verified = []
        for sourceObj in candidates:
            if sourceObj not in sources:
                sources.append(sourceObj)
                verified.append(sourceObj)
            else:
                print("Source already recorded:", sourceObj.name)

            bb_mixer['sources'] = sources

        for sourceObj in verified:

            print("Verified source is:", sourceObj.name)

            sourceObj.select_set(True)
            bpy.context.view_layer.objects.active = sourceObj
            for g in sourceObj.pose.bone_groups:
                sourceObj.pose.bone_groups.remove(g)
            
            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.group_add()
            sourceObj.pose.bone_groups.active.name = mixer_group_source_inactive_name
            sourceObj.pose.bone_groups.active.color_set = mixer_group_source_inactive_theme
            bpy.ops.pose.group_add()
            sourceObj.pose.bone_groups.active.name = mixer_group_source_active_name
            sourceObj.pose.bone_groups.active.color_set = mixer_group_source_active_theme
            
            for boneObj in sourceObj.pose.bones:
                boneObj.bone_group = sourceObj.pose.bone_groups[mixer_group_source_inactive_name]
            bpy.ops.object.mode_set(mode='OBJECT')
            sourceObj.select_set(False)

        bpy.ops.object.mode_set(mode=old_mode)

        return {'FINISHED'}

class OnigiriMotionMixerRemoveSource(bpy.types.Operator):
    """Remove a source rig from the list of influences"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.mixer_remove_source"
    bl_label = "Remove a source rig"

    @classmethod
    def poll(cls, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        
        if bb_mixer.mixer_ready == True:
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb_mixer = bpy.context.window_manager.bb_mixer

        if self.name not in obj:
            print("Something strange happened, the object is not in the scene.")

        if bb_mixer.get('maps') == None:
            bb_mixer['maps'] = {}
        if bb_mixer['maps'].get('sources') == None:
            bb_mixer['maps']['sources'] = {}

        sources = []
        for sourceObj in bb_mixer['sources']:
            if sourceObj.name == self.name:
                continue
            sources.append(sourceObj)

        if len(sources) == 0:
            bb_mixer.pop('sources', [])
        else:
            bb_mixer['sources'] = sources

        old_mode = bpy.context.mode
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'
        
        for o in bpy.context.selected_objects:
            o.select_set(False)
        
        sourceObj = obj[self.name]
        sourceObj.select_set(True)
        bpy.context.view_layer.objects.active = sourceObj

        for g in sourceObj.pose.bone_groups:
            sourceObj.pose.bone_groups.remove(g)
        
        targetObj = bb_mixer['target']
        target = targetObj.name

        sources = bb_mixer['maps']['sources'].get(self.name, [])

        for bone in sources:
            targetObj.pose.bones[bone].bone_group = targetObj.pose.bone_groups[mixer_group_target_inactive_name]
            
            constraints = targetObj.pose.bones[bone].constraints
            for c in constraints:
                if c.type == 'COPY_LOCATION':
                    c.target = None
                    targetObj.pose.bones[bone].constraints[c.name].influence = 0
                if c.type == 'COPY_ROTATION':
                    c.target = None
                    targetObj.pose.bones[bone].constraints[c.name].influence = 0
                if c.type == 'COPY_SCALE':
                    c.target = None
                    targetObj.pose.bones[bone].constraints[c.name].influence = 0

        bb_mixer['maps']['sources'].pop(self.name, "")

        return {'FINISHED'}

class OnigiriMotionMixerReady(bpy.types.Operator):
    """Click this when you're ready to start picking influence bones.  The resulting
state will also allow you to click it again when you need to add or remove rigs
from/to the influences."""

    bl_idname = "onigiri.mixer_ready"
    bl_label = "Enable this to start picking bones"

    @classmethod
    def poll(cls, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        
        if bb_mixer.get('target') == None:
            return False
        sources = bb_mixer.get('sources', [])
        if len(sources) == 0:
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb_mixer = bpy.context.window_manager.bb_mixer

        old_mode = bpy.context.mode
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'

        for o in bpy.context.selected_objects:
            o.select_set(False)
        targetObj = bb_mixer['target']
        sources = bb_mixer['sources']
        for o in sources:
            o.select_set(True)
        targetObj.select_set(True)
        bpy.context.view_layer.objects.active = targetObj
        bpy.ops.object.mode_set(mode='POSE')
        bb_mixer.mixer_ready = True

        print("Mixer enabled")

        return {'FINISHED'}

class OnigiriMotionMixerActiveRigName(bpy.types.Operator):
    """Click to show the associated bone list"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.mixer_active_rig_name"
    bl_label = "Activate bone list"

    @classmethod
    def poll(cls, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        
        if bb_mixer.mixer_ready == False:
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb_mixer = bpy.context.window_manager.bb_mixer

        if bb_mixer.get('maps') == None:
            bb_mixer['maps'] = {}
        if bb_mixer['maps'].get('sources') == None:
            bb_mixer['maps']['sources'] = {}

        bb_mixer.mixer_active_rig_name = self.name

        return {'FINISHED'}

class OnigiriMotionMixerSetAnchor(bpy.types.Operator):
    """Set the anchor rig, this allows location data on the pelvis, which is
usually what you want so that one of your source rigs controls the pelvis/hip
location of the target rig"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.mixer_set_anchor"
    bl_label = "Set anchor for this rig\n"

    @classmethod
    def poll(cls, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        
        if bb_mixer.mixer_ready == False:
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb_mixer = bpy.context.window_manager.bb_mixer

        bone = 'mPelvis' 

        if bb_mixer.get('maps') == None:
            bb_mixer['maps'] = {}
        if bb_mixer['maps'].get('sources') == None:
            bb_mixer['maps']['sources'] = {}

        for sourceObj in bb_mixer['sources']:
            sourceObj.pose.bones[bone].bone_group = sourceObj.pose.bone_groups[mixer_group_source_inactive_name]

        bone_dict = None
        for rig in bb_mixer['maps']['sources']:
            bone_dict = bb_mixer['maps']['sources'][rig].pop(bone, None)
        
        rotation = 1
        scale = 0
        if bone_dict != None:
            rotation = bone_dict['transforms']['rotation']
            scale = bone_dict['transforms']['scale']

        if self.name not in bb_mixer['maps']['sources']:
            bb_mixer['maps']['sources'][self.name] = {}

        bb_mixer['maps']['sources'][self.name][bone] = {}
        bb_mixer['maps']['sources'][self.name][bone]['transforms'] = {
            "location": 1,
            "rotation": rotation,
            "scale": scale,
            }

        targetObj = bb_mixer['target']
        sourceObj = obj[self.name]
        targetObj.pose.bones[bone].bone_group = targetObj.pose.bone_groups[mixer_group_source_active_name]
        obj[self.name].pose.bones[bone].bone_group = obj[self.name].pose.bone_groups[mixer_group_source_active_name]
        constraints = targetObj.pose.bones[bone].constraints
        for c in constraints:
            if c.type == 'COPY_LOCATION':
                c.target = obj[self.name]
                c.subtarget = bone
                targetObj.pose.bones[bone].constraints[c.name].target_space = motion.props['target_space']
                targetObj.pose.bones[bone].constraints[c.name].owner_space = motion.props['owner_space_anchor']
                
                targetObj.pose.bones[bone].constraints[c.name].influence = 1
            if c.type == 'COPY_ROTATION':
                c.target = obj[self.name]
                c.subtarget = bone
                targetObj.pose.bones[bone].constraints[c.name].target_space = motion.props['target_space']
                targetObj.pose.bones[bone].constraints[c.name].owner_space = motion.props['owner_space_anchor']
                targetObj.pose.bones[bone].constraints[c.name].mix_mode = motion.props['mix_mode_anchor']
                targetObj.pose.bones[bone].constraints[c.name].influence = rotation
            if c.type == 'COPY_SCALE':
                c.target = obj[self.name]
                c.subtarget = bone
                targetObj.pose.bones[bone].constraints[c.name].target_space = motion.props['target_space_anchor']
                targetObj.pose.bones[bone].constraints[c.name].owner_space = motion.props['owner_space_anchor']
                
                targetObj.pose.bones[bone].constraints[c.name].influence = scale

        bb_mixer.mixer_anchor_name = self.name

        return {'FINISHED'}

class OnigiriMotionMixerMode(bpy.types.Operator):
    """Sets the order of priority for motion.  This effects the selected bones.
There is no feed back for flags to show.  If your motion is weird use this on
parent bones first to test out it effects the indicated bone motion"""

    action : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.mixer_mode"
    bl_label = "Mix Mode\n"

    @classmethod
    def poll(cls, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        
        if bb_mixer.mixer_ready == False:
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb_mixer = bpy.context.window_manager.bb_mixer

        bones = set([b.name for b in bpy.context.selected_pose_bones])

        if len(bones) == 0:
            print("No bones selected")
            return {'FINISHED'}

        targetObj = bb_mixer['target']
        target = targetObj.name

        for bone in bones:
            boneObj = targetObj.pose.bones[bone]
            for C in boneObj.constraints:
                if C.type == motion.props['rotation_controller']:
                    C.mix_mode = self.action

        return {'FINISHED'}

class OnigiriMotionMixerSpace(bpy.types.Operator):
    """This is a type of inheritance.  If your bones are not reflecting what you
expect then try different types of target and owner space.  This, like the (mix)
type, are advanced features and are here for convenience"""

    action : bpy.props.StringProperty(default="")
    space : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.mixer_space"
    bl_label = "Target / Owner space\n"

    @classmethod
    def poll(cls, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        
        if bb_mixer.mixer_ready == False:
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb_mixer = bpy.context.window_manager.bb_mixer

        bones = set([b.name for b in bpy.context.selected_pose_bones])

        if len(bones) == 0:
            print("No bones selected")
            return {'FINISHED'}

        targetObj = bb_mixer['target']
        target = targetObj.name

        for bone in bones:
            boneObj = targetObj.pose.bones[bone]
            for C in boneObj.constraints:
                if C.type == motion.props['rotation_controller']:
                    try:
                        setattr(C, self.action, self.space)
                    except:
                        print("Item not compatible with transform - action / space :", self.action, self.space)

        return {'FINISHED'}

class OnigiriMotionMixerInherit(bpy.types.Operator):
    """This enables and disables the type of transform inheritance from the parent.
    There may be very little use for it but you have the option in case you have
    a unique rig setup that requires it"""

    transform : bpy.props.StringProperty(default="")
    state : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.mixer_inherit"
    bl_label = "Inherit parent orientation"

    @classmethod
    def poll(cls, context):
        bb_mixer = bpy.context.window_manager.bb_mixer
        
        if bb_mixer.mixer_ready == False:
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb_mixer = bpy.context.window_manager.bb_mixer

        bones = set([b.name for b in bpy.context.selected_pose_bones])

        if len(bones) == 0:
            print("No bones selected")
            return {'FINISHED'}

        targetObj = bb_mixer['target']
        target = targetObj.name

        if self.state == "True":
            state = True
        elif self.state == "False":
            state = False

        for bone in bones:
            boneObj = targetObj.data.bones[bone]
            if self.transform == "location":
                boneObj.use_local_location = state
            elif self.transform == "rotation":
                boneObj.use_inherit_rotation = state

        return {'FINISHED'}

class OnigiriMotionMixerAddBones(bpy.types.Operator):
    """Choose bones on the source rigs that will influence the target, allowing
a link to be established, where the target will acquire the resulting mixed
animation"""

    bl_idname = "onigiri.mixer_add_bones"
    bl_label = "Add selected bones to the influence"

    def execute(self, context):
        obj = bpy.data.objects
        bb_mixer = bpy.context.window_manager.bb_mixer
        bones = [o for o in bpy.context.selected_pose_bones]

        if bb_mixer.get('maps') == None:
            bb_mixer['maps'] = {}
        if bb_mixer['maps'].get('sources') == None:
            bb_mixer['maps']['sources'] = {}

        targetObj = bb_mixer['target']
        target = targetObj.name

        location, rotation, scale = bb_mixer.mixer_location, bb_mixer.mixer_rotation, bb_mixer.mixer_scale

        for boneObj in bones:
            bone = boneObj.name
            rigObj = boneObj.id_data
            rig = rigObj.name
            for sourceObj in bb_mixer['sources']:
                sourceObj.pose.bones[bone].bone_group = sourceObj.pose.bone_groups[mixer_group_source_inactive_name]
            if rig in bb_mixer['maps']['sources']:
                bb_mixer['maps']['sources'][rig].pop(bone, "")

        rig_data = {}
        for boneObj in bones:
            bone = boneObj.name
            rigObj = boneObj.id_data
            rig = rigObj.name
            
            if rig == target:
                continue

            for sourceObj in bb_mixer['sources']:
                sourceObj.pose.bones[bone].bone_group = sourceObj.pose.bone_groups[mixer_group_source_inactive_name]

            if rig not in bb_mixer['maps']['sources']:
                
                bb_mixer['maps']['sources'][rig] = {}
            if bone not in bb_mixer['maps']['sources'][rig]:
                bb_mixer['maps']['sources'][rig][bone] = {}
                bb_mixer['maps']['sources'][rig][bone]['transforms'] = {
                    "location": location,
                    "rotation": rotation,
                    "scale": scale,
                    }
            
            if bone not in rig_data:
                rig_data[bone] = {}
                rig_data[bone]['source'] = rigObj

        bpy.context.view_layer.objects.active = targetObj
        for bone in rig_data:
            armObj = rig_data[bone]['source']
            arm = armObj.name
            targetObj.pose.bones[bone].bone_group = targetObj.pose.bone_groups[mixer_group_source_active_name]
            obj[arm].pose.bones[bone].bone_group = obj[arm].pose.bone_groups[mixer_group_source_active_name]
            constraints = targetObj.pose.bones[bone].constraints
            for c in constraints:
                if c.type == 'COPY_LOCATION':
                    c.target = obj[arm]
                    c.subtarget = bone
                    targetObj.pose.bones[bone].constraints[c.name].target_space = motion.props['target_space']
                    targetObj.pose.bones[bone].constraints[c.name].owner_space = motion.props['owner_space']
                    targetObj.pose.bones[bone].constraints[c.name].influence = location
                if c.type == 'COPY_ROTATION':
                    c.target = obj[arm]
                    c.subtarget = bone
                    targetObj.pose.bones[bone].constraints[c.name].target_space = motion.props['target_space']
                    targetObj.pose.bones[bone].constraints[c.name].owner_space = motion.props['owner_space']
                    targetObj.pose.bones[bone].constraints[c.name].mix_mode = motion.props['mix_mode']
                    targetObj.pose.bones[bone].constraints[c.name].influence = rotation
                if c.type == 'COPY_SCALE':
                    c.target = obj[arm]
                    c.subtarget = bone
                    targetObj.pose.bones[bone].constraints[c.name].target_space = motion.props['target_space']
                    targetObj.pose.bones[bone].constraints[c.name].owner_space = motion.props['owner_space']
                    targetObj.pose.bones[bone].constraints[c.name].influence = scale

        return {'FINISHED'}

class OnigiriMotionMixerRemoveBones(bpy.types.Operator):
    """Remove the selected bones from the influence, you can also do this bone by
bone in the list if you expand it"""

    name : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.mixer_remove_bones"
    bl_label = "Remove selected bones from influence"

    def execute(self, context):
        obj = bpy.data.objects
        bb_mixer = bpy.context.window_manager.bb_mixer

        if self.name != "":
            print("Remove single bone:", self.name)
            for boneObj in bpy.context.selected_pose_bones:
                dBone = boneObj.bone
                dBone.select = False
            
            armObj = bpy.context.active_object
            armObj.data.bones[self.name].select = True

        if bb_mixer.get('maps') == None:
            bb_mixer['maps'] = {}
        if bb_mixer['maps'].get('sources') == None:
            bb_mixer['maps']['sources'] = {}

        bones = [o for o in bpy.context.selected_pose_bones] 
        bone_names = set([o.name for o in bones]) 

        targetObj = bb_mixer['target']
        target = targetObj.name

        for bone in bone_names:
            for sourceObj in bb_mixer['sources']:
                sourceObj.pose.bones[bone].bone_group = sourceObj.pose.bone_groups[mixer_group_source_inactive_name]
            targetObj.pose.bones[bone].bone_group = targetObj.pose.bone_groups[mixer_group_target_inactive_name]

            for arm in bb_mixer['maps']['sources']:
                bb_mixer['maps']['sources'][arm].pop(bone, "")

            constraints = targetObj.pose.bones[bone].constraints
            for c in constraints:
                if c.type == 'COPY_LOCATION':
                    c.target = None
                    targetObj.pose.bones[bone].constraints[c.name].influence = 0
                if c.type == 'COPY_ROTATION':
                    c.target = None
                    targetObj.pose.bones[bone].constraints[c.name].influence = 0
                if c.type == 'COPY_SCALE':
                    c.target = None
                    targetObj.pose.bones[bone].constraints[c.name].influence = 0

        for rig in bb_mixer['maps']['sources']:
            if len (bb_mixer['maps']['sources'][rig]) == 0:
                del bb_mixer['maps']['sources'][rig]

        if 'mPelvis' in bone_names:
            print("Bone removal included the anchor")
            bb_mixer.mixer_anchor_name = ""

        self.name = ""

        return {'FINISHED'}

class OnigiriMotionMixerSetLocation(bpy.types.Operator):
    """Toggle location influence for this bone"""

    name : bpy.props.StringProperty(default="")
    influence : bpy.props.IntProperty(default=0)

    bl_idname = "onigiri.mixer_set_location"
    bl_label = "Enable location influence"

    def execute(self, context):
        obj = bpy.data.objects
        bb_mixer = bpy.context.window_manager.bb_mixer

        globals.bb_mixer['constraints'][self.name]['location'].influence = self.influence

        if self.name == 'mPelvis':
            if self.influence:
                arm = globals.bb_mixer['constraints'][self.name]['location'].target.name
                bb_mixer.mixer_anchor_name = arm
            else:
                bb_mixer.mixer_anchor_name = ""

        self.name = ""

        return {'FINISHED'}

class OnigiriMotionMixerSetRotation(bpy.types.Operator):
    """Toggle rotation influence for this bone"""

    name : bpy.props.StringProperty(default="")
    influence : bpy.props.IntProperty(default=0)

    bl_idname = "onigiri.mixer_set_rotation"
    bl_label = "Enable rotation influence"

    def execute(self, context):
        obj = bpy.data.objects
        bb_mixer = bpy.context.window_manager.bb_mixer

        globals.bb_mixer['constraints'][self.name]['rotation'].influence = self.influence

        self.name = ""

        return {'FINISHED'}

class OnigiriMotionMixerSetScale(bpy.types.Operator):
    """Toggle scale influence for this bone"""

    name : bpy.props.StringProperty(default="")
    influence : bpy.props.IntProperty(default=0)

    bl_idname = "onigiri.mixer_set_scale"
    bl_label = "Enable scale influence"

    def execute(self, context):
        obj = bpy.data.objects
        bb_mixer = bpy.context.window_manager.bb_mixer

        globals.bb_mixer['constraints'][self.name]['scale'].influence = self.influence

        self.name = ""

        return {'FINISHED'}

class OnigiriMotionSpliceProperties(bpy.types.PropertyGroup):

    def update_splice_blank(self, context):
        
        self["splice_blank"] = False
    splice_blank : bpy.props.BoolProperty(
        name = "",
        description = "",
        default = False,
        update = update_splice_blank
        )
    splice_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description = "Expand the motion splicer features",
        default = False
        )
    def update_splice_target_locked(self, context):
        
        bb_splice = self
        if bb_splice.splice_target_locked == True:
            if len(bpy.context.selected_objects) != 1:
                bb_splice["splice_target_locked"] = False
                bb_splice.splice_message = "Splice target needs a single rig"
                print("Choose the rig you'll apply all of the actions to and click this button, only 1 rig")
                return
            armObj = bpy.context.selected_objects[0]
            if armObj.type != 'ARMATURE':
                bb_splice["splice_target_locked"] = False
                return
            if bb_splice.splice_disable_onigiri_check == False:
                if armObj.get('onigiri') == None:
                    print("Onigiri check disallows foreign rigs from being used in this fashion.")
                    print("If you really want to do this then use (Disable Onigiri Check).")
                    bb_splice["splice_target_locked"] = False
                    bb_splice.splice_message = "Onigiri only, see console"
                    return
            
            bpy.ops.object.mode_set(mode='EDIT')
            for boneObj in armObj.data.edit_bones:
                boneObj.use_connect = False
            bpy.ops.object.mode_set(mode='OBJECT')

            utils.get_state()
            bb_splice.splice_target_name = armObj.name
            bb_splice.splice_message = "Pick source"
            return
        else:
            bb_splice.splice_message = "Select a target rig"
            return

    splice_message : bpy.props.StringProperty(
        name = "",
        description = "",
        default = "Look here for messages"
        )

    splice_target_locked : bpy.props.BoolProperty(
        name = "",
        description =            "Click this to lock the target.  The target is where your animations will end up.  If your target already "            "has an animation then the new source will be appended, which is essentially the function of this tool.  "            "After you enable this you'll pick a source rig, one that contains an animation you want to append to the "            "existing one on this rig and then disable this button to perform tha action.  Use the (Gap) property to "            "tell the splicer how many frames to skip before adding the next action/animation.",
        default = False,
        update = update_splice_target_locked
        )
    splice_target_name : bpy.props.StringProperty(
        name = "",
        description = "--internal",
        default = ""
        )
    
    def update_splice_type(self, context):
        if self.splice_keys == False and self.splice_motion == False:
            self["splice_motion"] = True
    splice_keys : bpy.props.BoolProperty(
        name = "",
        description =            "You  must have (keys) and/or (motion) enabled"            "\n\n"            "If there are animation keys on the source you may want to capture those.  You can capture those as well as "            "motion.  Capturing keys allows for keys to be generated for joints that do not move but are still keyed, which "            "can be beneficial if you are attempting to prevent a joint from moving at some point.",
        default = False,
        update = update_splice_type
        )
    splice_motion : bpy.props.BoolProperty(
        name = "",
        description =            "You  must have (keys) and/or (motion) enabled"            "\n\n"            "This detects motion from the source and keys those transforms onto the target rig.",
        default = True,
        update = update_splice_type
        )
    splice_gap_insert : bpy.props.BoolProperty(
        name = "",
        description =            "If you enable this then the new, source, animation will be inserted into the timeline where your animation "            "cursor currently is.  The gaps will be used to tell the splicer how to place this source animation.",
        default = False
        )
    splice_gap_start : bpy.props.IntProperty(
        name = "",
        description =            "This is how far away from your existing animation, in frames, you will like to place the new clip.  If (Gap Insert) "            "is enabled then this is how far away from the animation cursor that you want to insert the new clip.  Using "            "negative numbers will have some interesting effects but a value of 1 for both, Gap Start and Gap End, will leave no "            "space and does not overwrite any keys.",
        default = 1
        )
    splice_gap_end : bpy.props.IntProperty(
        name = "",
        description =            "This has no use unless (Insert) is enabled"            "\n\n"            "Place your animation cursor somewhere, enable (Gap Insert).  Your animation will be inserted into the existing one on "            "the target and there will be empty space on either side of the new clip, unless you had a different purpose.  Setting the "            "values to gap 1 is no space, using any other values you can achieve interesting results.",
        default = 1
        )
    splice_spread_enabled : bpy.props.BoolProperty(
        name = "",
        description = "Enable this to fine tune the area of capture or the entire action will be recorded",
        default = False
        )
    splice_spread_start : bpy.props.IntProperty(
        name = "",
        description =            "The start and stop frames allow you to choose a portion of your source animation for appending rather than "            "the entire thing.  Enable the feature and then adjust these values.",
        default = 1
        )
    splice_spread_end : bpy.props.IntProperty(
        name = "",
        description =            "The start and stop frames allow you to choose a portion of your source animation for appending rather than "            "the entire thing.  Enable the feature and then adjust these values.",
        default = 1
        )
    splice_disable_onigiri_check : bpy.props.BoolProperty(
        name = "",
        description =            "Disable this to work with foreign rigs, it should work fine, but this is enabled by default to to keep the "            "the head scratching low when animations don't do anything in SL.",
        default = False
        )

class OnigiriMotionSpliceSync(bpy.types.Operator):

    bl_idname = "onigiri.splice_sync"
    bl_label = "Sync action range with spread"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.animation_data == None:
            return False
        if o.animation_data.action == None:
            return False
        return True

    def execute(self, context):
        bb_splice = bpy.context.scene.bb_splice
        armObj = bpy.context.selected_objects[0]
        spread_start, spread_end = armObj.animation_data.action.frame_range
        bb_splice.splice_spread_start = int(spread_start)
        bb_splice.splice_spread_end = int(spread_end)

        return {'FINISHED'}

class OnigiriMotionSpliceReset(bpy.types.Operator):

    bl_idname = "onigiri.splice_reset"
    bl_label = "Reset the splicer"

    def execute(self, context):
        
        bb_splice = bpy.context.scene.bb_splice
        state = utils.get_state()

        for prop in bpy.context.scene["bb_splice"]:
            try:
                bb_splice.property_unset(prop)
            except:
                print("Property", prop, "cannot be unsetted, if that's even a word.  We'll lets make it a word \o/")

        utils.set_state(state)
        return {'FINISHED'}

class OnigiriMotionSpliceCapture(bpy.types.Operator):

    bl_idname = "onigiri.splice_capture"
    bl_label = "Capture the segment"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        
        bb_splice = bpy.context.scene.bb_splice

        armObj = bpy.context.selected_objects[0]

        state = utils.get_state()

        if armObj.name == bb_splice.splice_target_name:
            print("Target and source cannot be the same, if you want to insert or append the same animation")
            print("from target TO target then make a copy of the rig and then use the copy as source")
            bb_splice.splice_message = "Error - source = target"
            popup("The source and target are the same, see console", "Error", "ERROR")
            return {'FINISHED'}

        target = bb_splice.splice_target_name
        for boneObj in armObj.data.bones:
            if boneObj.name not in obj[target].data.bones:
                print("The rigs are not compatible, did you choose the wrong animation source?  It has to be a BB rig.")
                popup("Not a BB rig, wrong source", "Error", "ERROR")
                return {'FINISHED'}

        gap_insert = bb_splice.splice_gap_insert
        gap_start = bb_splice.splice_gap_start
        gap_end = bb_splice.splice_gap_end
        spread_enabled = bb_splice.splice_spread_enabled
        spread_start = bb_splice.splice_spread_start
        spread_end = bb_splice.splice_spread_end
        splice.props['camera'] = True
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

        result = splice.main(
            target=bb_splice.splice_target_name, source=armObj.name,
            keys=bb_splice.splice_keys, motion=bb_splice.splice_motion,
            gap_insert=gap_insert, gap_start=gap_start, gap_end=gap_end,
            spread_enabled=spread_enabled, spread_start=spread_start, spread_end=spread_end,
            )
        splice.props['camera'] = False

        if result != False:
            bb_splice.splice_message = "Finished!"
        else:
            bb_splice.splice_message = "Error!"

        state = utils.activate(bb_splice.splice_target_name, safe=True)

        return {'FINISHED'}

class OnigiriCleanControllers(bpy.types.Operator):
    """This removes error prone controllers from the scene, which causes Blender to
generate errors that slow down your work-flow"""

    bl_idname = "onigiri.clean_controllers"
    bl_label = "Remove unused controllers"

    def execute(self, context):
        obj = bpy.data.objects
        candidates = []
        for o in obj:
            if o.type == 'ARMATURE':
                if o.get('avastar', None) != None:
                    candidates.append(o.name)
        rigs_good = []
        rigs_bad = []
        for rig in candidates:
            result = rigutils.clean_controllers(armature=rig)
            if result == False:
                rig_bad.append(rig)
            else:
                rigs_good.append(rig)

        if len(rigs_bad) > 0:
            print("The following rigs could not be cleaned:", rigs_bad)
            popup("Unknown error when cleaning at least 1 rig", "Error", "ERROR")
        if len(rigs_good) > 0:
            print("The following rigs were processed:", rigs_good)

        return {'FINISHED'}

class OnigiriRemoveKeys(bpy.types.Operator):
    """Remove animation keys from the selected pose bones"""

    bl_idname = "onigiri.remove_animation_keys"
    bl_label = "bb_remove_animation_keys"

    @classmethod
    def poll(cls, context):
        for arm in bpy.context.selected_objects:
            if arm.type == 'ARMATURE':
                if bpy.context.mode == 'POSE':
                    if len(bpy.context.selected_pose_bones) > 0:
                        return True
        return False

    def execute(self, context):
        for bone in bpy.context.selected_pose_bones:
            print("Clear keyframe from pose bone:", bone.name)

        bpy.ops.anim.keyframe_clear_v3d()

        try:
            bpy.ops.anim.keyframe_insert()
            bpy.ops.anim.keyframe_delete()
        except:
            print("OnigiriRemoveKeys reports: no active action on the rig, that's ok, this is not a bug")

        return {'FINISHED'}

class OnigiriExportAnimationMapped(bpy.types.Operator, ExportHelper):
    """Export a bvh for Second Life from your mapped rig"""

    bl_idname = "onigiri.export_animation_mapped"
    bl_label = "Export Animation"

    filename_ext = ".bvh"
    filter_glob : bpy.props.StringProperty(
        default='*.bvh',
        options={'HIDDEN'}
    )

    @classmethod
    def poll(cls, context):
        if len(context.selected_objects) != 1:
            return False
        for obj in context.selected_objects:
            if obj.type != 'ARMATURE':
                return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb = bpy.context.scene.onigiri

        print("Exporting animation for", bpy.context.active_object.name)

        animation_fps = getattr(bpy.context.scene.onigiri, 'animation_fps')
        
        animation_scale = bb_const['meters_to_inches']
        animation_start_frame = getattr(bpy.context.scene.onigiri, 'animation_start_frame')
        animation_end_frame = getattr(bpy.context.scene.onigiri, 'animation_end_frame')

        print(

            "\n animation_fps", animation_fps,
            "\n animation_start_frame", animation_start_frame,
            "\n animation_end_frame", animation_end_frame,

            "\n file", self.properties.filepath)

        armObj = bpy.context.active_object

        if context.mode == 'EDIT_ARMATURE':
            
                old_mode = 'EDIT'
        else:
            old_mode = context.mode

        if context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')

        armObj.select_set(True)
        bpy.ops.object.duplicate()
        arm = bpy.context.selected_objects[0]
        animation_arm = arm.name

        print("captured source rig name", animation_arm)

        bpy.ops.object.delete()

        armObj.select_set(True)
        bpy.ops.object.duplicate()

        print("Animation rig:", bpy.context.selected_objects)

        delete_me = []
        for arm in bpy.context.selected_objects:
            if arm.name == animation_arm:
                continue
            delete_me.append(arm.name)
        bpy.ops.object.select_all(action='DESELECT')

        if bpy.data.objects[animation_arm].get('onigiri_control_rig') == 1:
            bpy.data.objects[animation_arm].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects[animation_arm]

            bpy.context.object.data.layers[bb_vbones_layer] = True
            bpy.context.object.data.layers[bb_mbones_layer] = True
            bpy.context.object.data.layers[bb_base_layer] = True

            print("bake disabled for control rig")
            if 1 == 0:
                bpy.ops.object.mode_set(mode='POSE')
                
                print("Control rig found", animation_arm)
                bpy.ops.nla.bake(
                    frame_start=animation_start_frame,
                    frame_end=animation_end_frame,
                    step=1,
                    only_selected=False,
                    visual_keying=True,
                    clear_constraints=False,
                    clear_parents=False,
                    use_current_action=False,
    
                    bake_types={'POSE'}
                    )
                
                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.ops.object.select_all(action='DESELECT')

        else:
            print("No control rig")

        if bpy.data.objects[animation_arm].get('fly_paper') != None:
            if bpy.data.objects[animation_arm].get('fly_paper') != "":
                fly_paper = bpy.data.objects[animation_arm]['fly_paper']
                
                if fly_paper in bpy.data.objects:
                    bpy.data.objects[fly_paper].hide_set(False)
                    bpy.data.objects[fly_paper].hide_select = False

        if bb.bake_animation == True:
            print("Bake is true but armature has not been prepared yet!  THIS WILL NOT WORK!")

            bpy.data.objects[animation_arm].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects[animation_arm]
            bpy.ops.object.mode_set(mode='POSE')
            print("Baking animation")
            bpy.ops.nla.bake(
                frame_start=animation_start_frame,
                frame_end=animation_end_frame,
                step=1,
                only_selected=False,
                visual_keying=True,

                clear_constraints=False,
                clear_parents=False,
                use_current_action=False,

                bake_types={'POSE'}
                )
            
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.select_all(action='DESELECT')

        for arm in delete_me:
            obj = bpy.data.objects[arm]
            obj.select_set(True)

            rotate_toggle(animation_arm)
            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.armature_apply()
            bpy.ops.object.mode_set(mode='OBJECT')

        obj = bpy.data.objects[animation_arm]
        obj.select_set(True)

        bpy.ops.object.select_all(action='DESELECT')

        bpy.data.objects[animation_arm].select_set(True)
        bpy.context.view_layer.objects.active = bpy.data.objects[animation_arm]
        
        if bpy.data.objects[animation_arm].get('onigiri_control_rig') == 1:
            
            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.select_all(action = 'SELECT')
            bpy.ops.pose.constraints_clear()

            bpy.ops.object.mode_set(mode='EDIT')
            for bone in bpy.data.objects[animation_arm].data.edit_bones:
                if bone.name in cr_bones_hash:
                    bpy.data.objects[animation_arm].data.edit_bones.remove(bone)
            bpy.ops.object.mode_set(mode='OBJECT')
            del bpy.data.objects[animation_arm]['onigiri_control_rig']
            print("Removed control rig from:", bpy.context.active_object.name)

        if bpy.context.scene.onigiri.bvh_to_sl == True:
            set_bvh_names(animation_arm)

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.export_anim.bvh(
            filepath=self.properties.filepath,
            check_existing=True,
            filter_glob="*.bvh",
            global_scale=animation_scale,
            frame_start=animation_start_frame,
            frame_end=animation_end_frame,
            rotate_mode='NATIVE',
            root_transform_only = bpy.context.scene.bb_anim_props.exclude_pelvis
        )

        bpy.ops.object.select_all(action='DESELECT')

        if bpy.data.objects[animation_arm].get('fly_paper') != None:
            if bpy.data.objects[animation_arm].get('fly_paper') != "":
                fly_paper = bpy.data.objects[animation_arm]['fly_paper']
                
                if fly_paper in bpy.data.objects:
                    bpy.data.objects[fly_paper].hide_set(True)

        if 1 == 1:
            for obj in delete_me:
                bpy.data.objects[obj].select_set(True)
            bpy.data.objects[animation_arm].select_set(True)
            bpy.ops.object.delete()
 
        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")

        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriExportAnimation(bpy.types.Operator, ExportHelper):
    """Export Animation using Onigiri.  This is for Onigiri and may not work on other rigs"""

    bl_idname = "onigiri.export_animation"
    bl_label = "Export Animation"

    filename_ext = ".bvh"
    filter_glob : bpy.props.StringProperty(
        default='*.bvh',
        options={'HIDDEN'}
    )

    @classmethod
    def poll(cls, context):
        if len(context.selected_objects) != 1:
            return False
        for obj in context.selected_objects:
            if obj.type != 'ARMATURE':
                return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb = bpy.context.scene.onigiri

        print("Exporting animation for", bpy.context.active_object.name)

        animation_fps = getattr(bpy.context.scene.onigiri, 'animation_fps')
        
        animation_scale = bb_const['meters_to_inches']
        animation_start_frame = getattr(bpy.context.scene.onigiri, 'animation_start_frame')
        animation_end_frame = getattr(bpy.context.scene.onigiri, 'animation_end_frame')

        print(

            "\n animation_fps", animation_fps,
            "\n animation_start_frame", animation_start_frame,
            "\n animation_end_frame", animation_end_frame,

            "\n file", self.properties.filepath)

        armObj = bpy.context.active_object

        if context.mode == 'EDIT_ARMATURE':
            
                old_mode = 'EDIT'
        else:
            old_mode = context.mode

        if context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')

        armObj.select_set(True)
        bpy.ops.object.duplicate()
        arm = bpy.context.selected_objects[0]
        animation_arm = arm.name

        print("captured source rig name", animation_arm)

        bpy.ops.object.delete()

        armObj.select_set(True)
        bpy.ops.object.duplicate()

        print("Animation rig:", bpy.context.selected_objects)

        delete_me = []
        for arm in bpy.context.selected_objects:
            if arm.name == animation_arm:
                continue
            delete_me.append(arm.name)
        bpy.ops.object.select_all(action='DESELECT')

        if bpy.data.objects[animation_arm].get('onigiri_control_rig') == 1:
            bpy.data.objects[animation_arm].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects[animation_arm]

            bpy.context.object.data.layers[bb_vbones_layer] = True
            bpy.context.object.data.layers[bb_mbones_layer] = True
            bpy.context.object.data.layers[bb_base_layer] = True

            print("bake disabled for control rig")
            if 1 == 0:
                bpy.ops.object.mode_set(mode='POSE')
                
                print("Control rig found", animation_arm)
                bpy.ops.nla.bake(
                    frame_start=animation_start_frame,
                    frame_end=animation_end_frame,
                    step=1,
                    only_selected=False,
                    visual_keying=True,
                    clear_constraints=False,
                    clear_parents=False,
                    use_current_action=False,
    
                    bake_types={'POSE'}
                    )
                
                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.ops.object.select_all(action='DESELECT')

        else:
            print("No control rig")

        if bpy.data.objects[animation_arm].get('fly_paper') != None:
            if bpy.data.objects[animation_arm].get('fly_paper') != "":
                fly_paper = bpy.data.objects[animation_arm]['fly_paper']
                
                if fly_paper in bpy.data.objects:
                    bpy.data.objects[fly_paper].hide_set(False)
                    bpy.data.objects[fly_paper].hide_select = False

        if bb.bake_animation == True:
            print("Bake is true but armature has not been prepared yet!  THIS WILL NOT WORK!")

            bpy.data.objects[animation_arm].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects[animation_arm]
            bpy.ops.object.mode_set(mode='POSE')
            print("Baking animation")
            bpy.ops.nla.bake(
                frame_start=animation_start_frame,
                frame_end=animation_end_frame,
                step=1,
                only_selected=False,
                visual_keying=True,

                clear_constraints=False,
                clear_parents=False,
                use_current_action=False,

                bake_types={'POSE'}
                )
            
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.select_all(action='DESELECT')

        for arm in delete_me:
            obj = bpy.data.objects[arm]
            obj.select_set(True)

            rotate_toggle(animation_arm)
            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.armature_apply()
            bpy.ops.object.mode_set(mode='OBJECT')

        obj = bpy.data.objects[animation_arm]
        obj.select_set(True)

        bpy.ops.object.select_all(action='DESELECT')

        bpy.data.objects[animation_arm].select_set(True)
        bpy.context.view_layer.objects.active = bpy.data.objects[animation_arm]
        
        if bpy.data.objects[animation_arm].get('onigiri_control_rig') == 1:
            
            bpy.ops.object.mode_set(mode='POSE')
            bpy.ops.pose.select_all(action = 'SELECT')
            bpy.ops.pose.constraints_clear()

            bpy.ops.object.mode_set(mode='EDIT')
            for bone in bpy.data.objects[animation_arm].data.edit_bones:
                if bone.name in cr_bones_hash:
                    bpy.data.objects[animation_arm].data.edit_bones.remove(bone)
            bpy.ops.object.mode_set(mode='OBJECT')
            del bpy.data.objects[animation_arm]['onigiri_control_rig']
            print("Removed control rig from:", bpy.context.active_object.name)

        if bpy.context.scene.onigiri.bvh_to_sl == True:
            set_bvh_names(animation_arm)

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.export_anim.bvh(
            filepath=self.properties.filepath,
            check_existing=True,
            filter_glob="*.bvh",
            global_scale=animation_scale,
            frame_start=animation_start_frame,
            frame_end=animation_end_frame,
            rotate_mode='NATIVE',
            root_transform_only = bpy.context.scene.bb_anim_props.exclude_pelvis
        )

        bpy.ops.object.select_all(action='DESELECT')

        if bpy.data.objects[animation_arm].get('fly_paper') != None:
            if bpy.data.objects[animation_arm].get('fly_paper') != "":
                fly_paper = bpy.data.objects[animation_arm]['fly_paper']
                
                if fly_paper in bpy.data.objects:
                    bpy.data.objects[fly_paper].hide_set(True)

        if 1 == 1:
            for obj in delete_me:
                bpy.data.objects[obj].select_set(True)
            bpy.data.objects[animation_arm].select_set(True)
            bpy.ops.object.delete()
 
        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")

        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriDummyAnimation(bpy.types.Operator):
    """You need to use (Bake Animation) to get the retargeted motion before you can
export it and then you can export with either BVH, Anim format or even my very own
XML format in the Advanced Tools"""

    bl_idname = "onigiri.dummy_animation"
    bl_label = "dummy animation operator"

    @classmethod
    def poll(cls, context):
        pass
        return False
    def execute(self, context):
        print("This will never print")
        return {'FINISHED'}

class OnigiriTeflon(bpy.types.Operator):
    """Baking the animation is a quick way to jump over animation source rig glitches but
you can try exporting directly without baking, most times it works fine.  This will reset
the character mapper after baking"""

    bl_idname = "onigiri.teflon"
    bl_label = "teflon operator"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            o = bpy.context.selected_objects[0]
            if o.type != 'ARMATURE':
                return False
        return True
    def execute(self, context):
        bb_anim = bpy.context.scene.bb_anim
        armObj = bpy.context.selected_objects[0]
        print("Baking keys for", armObj.name, "with sample [" + str(bb_anim.bake_frame_step) + "]")

        bb_anim.bake_animation_label = "Baking animation ..."
        bb_anim.bake_animation_alert = True
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

        rigutils.teflon(armObj.name)

        bb_anim.property_unset("bake_animation_label")
        bb_anim.bake_animation_alert = False

        bpy.ops.onigiri.mapper_reset()

        return {'FINISHED'}

class OnigiriExportBVHSL(bpy.types.Operator, ExportHelper):
    """Export full features, including volume bone animations, motion and rotations.
Use this if you want BVH imports to SL, this gives you the ability to preview the
animation before upload, unlike .anim but anim is a prefered choice"""

    bl_idname = "onigiri.export_bvh_sl"
    bl_label = "Export SL Animation - BVH"

    filename_ext = ".bvh"
    filter_glob : bpy.props.StringProperty(
        default='*.bvh',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")

        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        if len(context.selected_objects) != 1:
            return False
        o = context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):

        obj = bpy.data.objects
        bb = bpy.context.scene.onigiri
        bba = bpy.context.scene.bb_anim_props
        armObj = bpy.context.selected_objects[0]

        if bb.export_onigiri_disabled != True:
            if armObj.get('onigiri') == None:
                print("2 Onigiri rig check is enabled but the rig is not Onigiri.  Disable the check in (Extended Options) to override.")
                txt = "\n"
                txt += "\n"
                txt += "\n"
                txt += "\n"
                txt += "Onigiri rig checking prevents export.  You can disable this feature or    \n"
                txt += "choose a Bento buddy rig that's desiged for animation export.                 \n"
                txt += "\n"
                txt += "\n"
                txt += "\n"
                txt += "\n"
                txt += "\n"

                utils.popup(txt, "Info", "INFO")

                return {'FINISHED'}

        if bb.export_sl_limitations_check_disabled != True:
            if bb.animation_time > 60.0:
                print("Skipping animation time check")
                
        bpy.app.timers.register(cleanup)

        bba.export_sl_bvh_label = bba.export_sl_bvh_label_busy
        
        bba.export_sl_bvh_label_short = bba.export_sl_bvh_label
        bba.export_sl_bvh_alert = True
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

        if context.mode == 'EDIT_ARMATURE':
            
                old_mode = 'EDIT'
        else:
            old_mode = context.mode

        if context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        print("Kludge started for BVH export without attachment bones")
        
        state = utils.get_state()
        armObj.select_set(True)
        utils.activate(armObj)
        old_rig = armObj
        bpy.ops.object.duplicate()
        bpy.ops.object.mode_set(mode='EDIT')
        armObj = bpy.context.object
        delete_these = []
        for boneObj in armObj.data.edit_bones:
            bone = boneObj.name
            if bone in skel.avatar_skeleton:
                if skel.avatar_skeleton[bone]['type'] == "attachment":
                    delete_these.append(boneObj)
        for boneObj in delete_these:
            armObj.data.edit_bones.remove(boneObj)
        bpy.ops.object.mode_set(mode='OBJECT')
        
        if armObj.get('fly_paper') != None and armObj.get('fly_paper') != "":
            rotate_these = list()
            
            rotate_these.append(armObj.name)
            rotate_these.append(armObj['fly_paper'])
            
            rotate_these.extend(armObj['targets'])
            rotated = utils.sl_orientation(rotate_these)
            status = slbvh.sl_bvh_export(
                armature=armObj.name,
                mbones = rotated['mbones'][0],
                vbones = rotated['vbones'][0],
                mrotate = False,
                vrotate = False,
                buffer=True,
                file=self.properties.filepath,
                translations=bba.disable_location_offsets,
                context=context)
            
            for o in bpy.context.selected_objects:
                o.select_set(False)
            for bone_set in rotated:
                for name in rotated[bone_set]:
                    obj[name].select_set(True)
            
            bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]
            
            bpy.ops.object.delete()

        else:
            status = slbvh.sl_bvh_export(
                armature=armObj.name,
                mbones = armObj.name,
                vbones = armObj.name,
                mrotate = True,
                vrotate = True,
                buffer=True,
                file=self.properties.filepath,
                translations=bba.disable_location_offsets,
                context=context)
        
        for o in bpy.context.selected_objects:
            o.select_set(False)
        armObj.select_set(True)
        utils.activate(armObj)
        bpy.ops.object.delete()
        armObj = old_rig
        utils.set_state(state)
        print("Kludge ends")
        
        armObj.select_set(True)
        bpy.context.view_layer.objects.active = armObj

        bpy.ops.object.mode_set(mode=old_mode)

        bba.property_unset("export_sl_bvh_label")
        bba.property_unset("export_sl_bvh_label_short")
        bba.export_sl_bvh_alert = False

        if status == True:
            print("BVH export finished")
        else:
            print("BVH export appears to have failed")

        return {'FINISHED'}
        
        buffer = True

        bad_bones = list()
        print("Examining deformable joint names...")
        for boneObj in armObj.data.bones:
            if boneObj.use_deform == True:
                if boneObj.name not in skel.avatar_skeleton:
                    bad_bones.append(boneObj.name)
        if len(bad_bones) > 0:
            print("There are", str(len(bad_bones)), "joints that cannot be exported to SL.  This function cannot continue.")
            print(bad_bones)
            popup("Incompatible joints found, see console for details.", "Error", "ERROR")
            
            bad_bones.clear()
            return {'FINISHED'}

        print("Exporting animation for", bpy.context.active_object.name)
        animation_scale = 39.3701
        animation_fps = bb.animation_fps
        animation_start_frame = bb.animation_start_frame
        animation_end_frame = bb.animation_end_frame
        
        print(
            "\n animation_fps", animation_fps,
            "\n animation_start_frame", animation_start_frame,
            "\n animation_end_frame", animation_end_frame,
            "\n file", self.properties.filepath)

        if context.mode == 'EDIT_ARMATURE':
            
                old_mode = 'EDIT'
        else:
            old_mode = context.mode

        if context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.view_layer.objects.active = armObj

        loc, rot, scale = armObj.matrix_world.decompose()
        smat = mathutils.Matrix()
        for i in range(3):
            smat[i][i] = scale[i]

        eu = mathutils.Euler(map(radians, (-90, 0, 0)), 'XYZ')
        mat = mathutils.Matrix.Translation(loc) @ eu.to_matrix().to_4x4() @ smat
        armObj.matrix_world = mat

        bpy.ops.object.transform_apply( rotation=True, location=False, scale=False )

        mbones_buf = bvh.save(
            context=context,
            filepath=self.properties.filepath,
            global_scale=animation_scale,
            frame_start=animation_start_frame,
            frame_end=animation_end_frame,
            rotate_mode='NATIVE',
            root_transform_only=bba.disable_location_offsets,
            
            buffer=buffer,
            )
        
        armObj.matrix_world = mat.inverted()
        bpy.ops.object.transform_apply( rotation=True, location=False, scale=False )

        bvh_temp_name = tempfile.gettempdir() + "/onigiri_" + get_unique_name_short() + ".bv_"

        eu = mathutils.Euler(map(radians, (0, 0, 90)), 'XYZ')
        mat = mathutils.Matrix.Translation(loc) @ eu.to_matrix().to_4x4() @ smat
        armObj.matrix_world = mat
        bpy.ops.object.transform_apply( rotation=True, location=False, scale=False )

        vbones_buf = bvh.save(
            context=context,
            filepath=bvh_temp_name,
            global_scale=animation_scale,
            frame_start=animation_start_frame,
            frame_end=animation_end_frame,
            rotate_mode='NATIVE',
            root_transform_only=bba.disable_location_offsets,
            
            buffer=buffer,
            )

        eu = mathutils.Euler(map(radians, (0, 0, -90)), 'XYZ')
        mat = mathutils.Matrix.Translation(loc) @ eu.to_matrix().to_4x4() @ smat
        armObj.matrix_world = mat
        bpy.ops.object.transform_apply( rotation=True, location=False, scale=False )

        if buffer == True:
            bvh_out = bvht.merge(
                vbones=vbones_buf,
                mbones=mbones_buf,
                swap_offsets=False,
                swap_endsites=False,
                swap_motion=True,
                return_type="bvh",
                buffer=buffer,
            )
        else:
            bvh_out = bvht.merge(
                vbones=bvh_temp_name,
                mbones=self.properties.filepath,
                swap_offsets=False,
                swap_endsites=False,
                swap_motion=True,
                return_type="bvh",
                buffer=buffer,
            )

        if bvh_out:
            try:
                bvh_file = open(self.properties.filepath, "w", newline="", encoding='UTF8')
                
                bvh_file.write(bvh_out)
                bvh_file.close()

            except Exception as e:
                txt = traceback.format_exc()
                print("some error occurred trying to write the merged bvh")
                print(txt)
        else:
            print("nothing to alter for now, parser is turned off")

        if buffer != True:
            try:
                os.remove(bvh_temp_name)
                print("BB BVH Cleanup...")
            except:
                print("BB Warning: unable to remove temporary file:", bvh_temp_name)

        bpy.ops.object.mode_set(mode=old_mode)
        
        bba.property_unset("export_sl_bvh_label")
        bba.property_unset("export_sl_bvh_label_short")
        bba.export_sl_bvh_alert = False

        print("BVH export finished")

        return {'FINISHED'}

class OnigiriExportRetargetedAnimation(bpy.types.Operator, ExportHelper):
    """ Export retargetted and normal bones

Use this if you're exporting a retargetted animation from the Character Mapper.
Use the "BVH for SL" exporter if you're animating volume bones.  Use a clean rig
if you experience issues"""

    bl_idname = "onigiri.export_retargeted_animation"
    bl_label = "Export Animation"

    filename_ext = ".bvh"
    filter_glob : bpy.props.StringProperty(
        default='*.bvh',
        options={'HIDDEN'}
    )

    @classmethod
    def poll(cls, context):
        if len(context.selected_objects) != 1:
            return False
        for obj in context.selected_objects:
            if obj.type != 'ARMATURE':
                return False
        return True

    def execute(self, context):
        obj = bpy.data.objects
        bb = bpy.context.scene.onigiri
        bba = bpy.context.scene.bb_anim_props

        bbm = bpy.context.window_manager.bb_mapper

        bpy.app.timers.register(cleanup)

        bpy.context.view_layer.update()
        frame_now = bpy.context.scene.frame_current
        bpy.context.scene.frame_set(0)

        bba.export_standard_bvh_label = bba.export_standard_bvh_label_busy
        bba.export_standard_bvh_alert = True
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

        print("Exporting animation for", bpy.context.active_object.name)

        animation_fps = getattr(bpy.context.scene.onigiri, 'animation_fps')
        
        animation_scale = bb_const['meters_to_inches']
        animation_start_frame = getattr(bpy.context.scene.onigiri, 'animation_start_frame')
        animation_end_frame = getattr(bpy.context.scene.onigiri, 'animation_end_frame')

        print(

            "\n animation_fps", animation_fps,
            "\n animation_start_frame", animation_start_frame,
            "\n animation_end_frame", animation_end_frame,

            "\n file", self.properties.filepath)

        armObj = bpy.context.active_object

        original_selection = armObj.name

        if context.mode == 'EDIT_ARMATURE':
            
                old_mode = 'EDIT'
        else:
            old_mode = context.mode

        if context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')

        armObj.select_set(True)
        bpy.ops.object.duplicate()
        arm = bpy.context.selected_objects[0]
        animation_arm = arm.name

        print("captured source rig name", animation_arm)

        bpy.ops.object.delete()

        for target in bbm['targets']:

            print("New collector found target:", target)

        has_targets = list()
        for target in armObj.bb_targets:
            has_targets.append(target.name)
        if len(has_targets) == 0:
            print("WARNING: Target property on armature container appears to be unused")
        else:
            print("Processed [" + str(len(has_targets)) + "] targets")
            print(has_targets)

        for target in armObj.bb_targets:
            print("found target:", target.name)
            bpy.data.objects[target.name].select_set(True)

        armObj.select_set(True)
        bpy.ops.object.duplicate()

        print("Objects ready for animation export:", bpy.context.selected_objects)

        delete_me = []
        for arm in bpy.context.selected_objects:
            if arm.name == animation_arm:
                continue
            delete_me.append(arm.name)

        print("Got these armatures for animation:", delete_me)
        if armObj.get('fly_paper') == None:
            print("Rotate toggle on:", animation_arm)
            rotate_toggle(animation_arm)

        bpy.ops.object.select_all(action='DESELECT')

        if bpy.data.objects[animation_arm].get('fly_paper') != None:
            if bpy.data.objects[animation_arm].get('fly_paper') != "":
                fly_paper = bpy.data.objects[animation_arm]['fly_paper']
                
                if fly_paper in bpy.data.objects:
                    bpy.data.objects[fly_paper].hide_set(False)
                    bpy.data.objects[fly_paper].hide_select = False

        if bb.bake_animation == True:
            bpy.data.objects[animation_arm].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects[animation_arm]
            bpy.ops.object.mode_set(mode='POSE')
            print("Baking animation")
            bpy.ops.nla.bake(
                frame_start=animation_start_frame,
                frame_end=animation_end_frame,
                step=1,
                only_selected=False,
                visual_keying=True,

                clear_constraints=False,
                clear_parents=False,
                use_current_action=False,

                bake_types={'POSE'}
                )
            
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.select_all(action='DESELECT')

        for arm in delete_me:
            obj = bpy.data.objects[arm]
            obj.select_set(True)

            rotation_mode = obj.rotation_mode
            obj.rotation_mode = 'XYZ'

            print("ROTATION: obj.rotation_euler:", obj.rotation_euler)

            rot_x = obj.rotation_euler.x
            rot_final = -1.5708 + rot_x

            obj.rotation_euler = (rot_final, 0.0, 0.0)

            obj.rotation_mode = rotation_mode
            bpy.ops.object.select_all(action='DESELECT')

        obj = bpy.data.objects[animation_arm]
        obj.select_set(True)

        print("obj.rotation_euler original:", obj.rotation_euler)

        bpy.ops.object.select_all(action='DESELECT')

        bpy.data.objects[animation_arm].select_set(True)
        bpy.context.view_layer.objects.active = bpy.data.objects[animation_arm]
        
        if bpy.context.scene.onigiri.bvh_to_sl == True:
            set_bvh_names(animation_arm)

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.export_anim.bvh(
            filepath=self.properties.filepath,
            check_existing=True,
            filter_glob="*.bvh",
            global_scale=animation_scale,
            frame_start=animation_start_frame,
            frame_end=animation_end_frame,
            rotate_mode='NATIVE',
            root_transform_only = bpy.context.scene.bb_anim_props.exclude_pelvis
        )

        bpy.ops.object.select_all(action='DESELECT')

        if bpy.data.objects[animation_arm].get('fly_paper') != None:
            if bpy.data.objects[animation_arm].get('fly_paper') != "":
                fly_paper = bpy.data.objects[animation_arm]['fly_paper']
                
                if fly_paper in bpy.data.objects:
                    bpy.data.objects[fly_paper].hide_set(True)

        if 1 == 1:
            for obj in delete_me:
                bpy.data.objects[obj].select_set(True)
            bpy.data.objects[animation_arm].select_set(True)
            bpy.ops.object.delete()
 
        bpy.context.scene.frame_set(frame_now)

        armObj = bpy.data.objects[original_selection]
        armObj.select_set(True)
        bpy.context.view_layer.objects.active = armObj
        bpy.ops.object.mode_set(mode=old_mode)

        bba.property_unset("export_standard_bvh_label")
        bba.export_standard_bvh_alert = False

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")

        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriAnimKeepBoneTransforms(bpy.types.Operator):
    """Exclude bones from the cleanup process.  This is an override setting for the entire
range, choose Rotation or Location, or both.  With this enabled all specific key frame
transform flags will be ignored but not removed"""

    action : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.anim_keep_bone_transforms"
    bl_label = "Add / Remove bone to/from cleaning"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        
        selected = [b.bone for b in bpy.context.selected_pose_bones]
        action = self.action

        armObj = bpy.context.object

        for dBone in selected:
            if dBone.get('cleaner') == None:
                dBone['cleaner'] = {}
            if dBone['cleaner'].get('bone') == None:
                dBone['cleaner']['bone'] = {}
            if dBone['cleaner']['bone'].get('rot') == None:
                dBone['cleaner']['bone']['rot'] = False
                dBone['cleaner']['bone']['rot_text'] = 'False'
            if dBone['cleaner']['bone'].get('loc') == None:
                dBone['cleaner']['bone']['loc'] = False
                dBone['cleaner']['bone']['loc_text'] = 'False'

        if action == "":
            print(" ---------------------------")
            for dBone in selected:
                print("", dBone.name + ":")
                print("   - rot =", dBone['cleaner']['bone']['rot_text'])
                print("   - loc =", dBone['cleaner']['bone']['loc_text'])
            popup(
                "Details of selected bones were printed to the System Console", 
                "Info",  "INFO"
                )
            return {'FINISHED'}

        if action == "add_rot":
            for dBone in selected:
                dBone['cleaner']['bone']['rot'] = True
                dBone['cleaner']['bone']['rot_text'] = 'True'
                print("Rotation transform for", dBone.name, "will be excluded from cleaning")
        if action == "add_loc":
            for dBone in selected:
                dBone['cleaner']['bone']['loc'] = True
                dBone['cleaner']['bone']['loc_text'] = 'True'
                print("Location transform for", dBone.name, "will be excluded from cleaning")

        if action == "sub_rot":
            for dBone in selected:
                dBone['cleaner']['bone']['rot'] = False
                dBone['cleaner']['bone']['rot_text'] = 'False'
                print("Rotation transform for", dBone.name, "will be included in cleaning")
        if action == "sub_loc":
            for dBone in selected:
                dBone['cleaner']['bone']['loc'] = False
                dBone['cleaner']['bone']['loc_text'] = 'False'
                print("Location transform for", dBone.name, "will be included in cleaning")

        if action == "sub_all":
            for dBone in armObj.data.bones:
                dBone['cleaner']['bone']['rot'] = False
                dBone['cleaner']['bone']['rot_text'] = 'False'
                dBone['cleaner']['bone']['loc'] = False
                dBone['cleaner']['bone']['loc_text'] = 'False'

        self.action = ""

        return {'FINISHED'}

class OnigiriAnimKeepKeyTransforms(bpy.types.Operator):
    """Exclude specific keys from the cleanup process.  This is an override setting for a
transform on selected bones at the current frame.  If you indent to use this make sure you've
disabled the override for the bone or this simply has no effect at all"""

    action : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.anim_keep_key_transforms"
    bl_label = "Add / Remove keys to/from cleaning"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        
        selected = [b.bone for b in bpy.context.selected_pose_bones]
        
        bpy.context.view_layer.update()
        frame_current = str( int( bpy.context.scene.frame_current ) )

        armObj = bpy.context.object

        action = self.action

        for dBone in selected:
            if dBone.get('cleaner') == None:
                dBone['cleaner'] = {}
            if dBone['cleaner'].get('frames') == None: 
                dBone['cleaner']['frames'] = {}
            if  dBone['cleaner']['frames'].get(frame_current) == None:
                dBone['cleaner']['frames'][frame_current] = {}
            if dBone['cleaner']['frames'][frame_current].get('rot') == None:
                dBone['cleaner']['frames'][frame_current]['rot'] = False
                dBone['cleaner']['frames'][frame_current]['rot_text'] = "False"
            if dBone['cleaner']['frames'][frame_current].get('loc') == None:
                dBone['cleaner']['frames'][frame_current]['loc'] = False
                dBone['cleaner']['frames'][frame_current]['loc_text'] = "False"

        if action == "":
            print(" ---------------------------")
            for dBone in selected:
                print("", dBone.name + ":")
                print(" frame:", frame_current)
                print("   - rot =", dBone['cleaner']['frames'][frame_current]['rot_text'])
                print("   - loc =", dBone['cleaner']['frames'][frame_current]['loc_text'])
            popup(
                "Details of selected bones were printed to the System Console", 
                "Info",  "INFO"
                )
            return {'FINISHED'}

        if action == "add_rot":
            for dBone in selected:
                dBone['cleaner']['frames'][frame_current]['rot'] = True
                dBone['cleaner']['frames'][frame_current]['rot_text'] = 'True'
                print("Rotation transform for", dBone.name, "on frame", frame_current, "will be excluded from cleaning")
        if action == "add_loc":
            for dBone in selected:
                dBone['cleaner']['frames'][frame_current]['loc'] = True
                dBone['cleaner']['frames'][frame_current]['loc_text'] = 'True'
                print("Location transform for", dBone.name, "on frame", frame_current, "will be excluded from cleaning")

        if action == "sub_rot":
            for dBone in selected:
                dBone['cleaner']['frames'][frame_current]['rot'] = False
                dBone['cleaner']['frames'][frame_current]['rot_text'] = 'False'
                print("Rotation transform for", dBone.name, "on frame", frame_current, "will be included in cleaning")
        if action == "sub_loc":
            for dBone in selected:
                dBone['cleaner']['frames'][frame_current]['loc'] = False
                dBone['cleaner']['frames'][frame_current]['loc_text'] = 'False'
                print("Location transform for", dBone.name, "on frame", frame_current, "will be included in cleaning")

        if action == "sub_all":
            for dBone in armObj.data.bones:
                dBone['cleaner']['frames'][frame_current]['rot'] = False
                dBone['cleaner']['frames'][frame_current]['rot_text'] = 'False'
                dBone['cleaner']['frames'][frame_current]['loc'] = False
                dBone['cleaner']['frames'][frame_current]['loc_text'] = 'False'

        self.action = ""

        return {'FINISHED'}

class OnigiriExportMesh(bpy.types.Operator, ExportHelper):
    """OLD"""

    bl_idname = "onigiri.export_mesh"
    bl_label = "Export Mesh"

    filename_ext = ".dae"
    filter_glob : bpy.props.StringProperty(
        default='*.dae',
        options={'HIDDEN'}
    )

    @classmethod
    def poll(cls, context):
        for obj in bpy.context.selected_objects:
            if obj.type == 'MESH':
                return True
        return False

    def execute(self, context):
        selected = {}
        active_arm = "" 

        active_obj = None

        if bpy.context.active_object is not None:
            active_obj = bpy.context.active_object.name
        
        for obj in bpy.context.selected_objects:
            if obj.type =='MESH':
                for mod in obj.modifiers:
                    if mod.type == 'ARMATURE':
                        
                        print("checking if there's already an ARMATURE modifier for", obj.name)

                        if obj.name in selected:
                            txt = "One of your selected mesh objects has more than one armature modifier: " + obj.name
                            print(txt)
                            popup(txt, "Error", "ERROR")
                            return {'FINISHED'}
                        
                        selected[obj.name] = obj.modifiers[mod.name].object.name
                        
                        if obj.modifiers[mod.name].object.name != active_arm and active_arm != "":
                            txt = "Multiple armature targets are present in your meshes, please choose only meshes with the same armature"
                            print(txt, obj.name)
                            popup(txt, "Error", "ERROR")
                            return {'FINISHED'}
                        active_arm = selected[obj.name]

        if len(selected) == 0:
            print("No qualifying mesh objects were selected")
            popup("No mesh objects qualify for this type of export")
            return {'FINISHED'}

        armObj = bpy.data.objects[active_arm].copy()
        armObj.data = bpy.data.objects[active_arm].data.copy()
        bpy.context.scene.collection.objects.link(armObj)
        
        for mesh in selected:
            meshObj = bpy.data.objects[mesh].copy()
            meshObj.data = bpy.data.objects[mesh].data.copy()
            bpy.context.scene.collection.objects.link(meshObj)

            for m in meshObj.modifiers:
                if m.type == 'ARMATURE':
                    meshObj.modifiers[m.name].object = armObj
                    break

        if active_obj is not None:
            bpy.context.view_layer.objects.active = bpy.data.objects[active_obj]

        return {'FINISHED'}

        if 1 == 0:
            obj_new = bpy.data.objects[mesh].copy()
            obj_new.data = bpy.data.objects[mesh].data.copy()
            bpy.context.scene.collection.objects.link(obj_new)
            set_mode(obj_new.name, "object")
            obj_new.rotation_mode = 'XYZ'
            obj_new.rotation_euler = (0.0, 0.0, 1.5708)
            bpy.ops.object.transform_apply( rotation = True )

        for mesh in selected:
            bpy.data.objects[mesh].select_set(True)
        
        return {'FINISHED'}

class OnigiriExportAnimesh(bpy.types.Operator, ExportHelper):
    """Important:  Mapped rigs do not have proper bone names and that's why this feature exists.
    Export your custom mesh / character for SL / OS, this does not support fitted mesh.  Select your mesh / characters
    that you previously mapped.  You can export a single or multiple Animesh."""

    bl_idname = "onigiri.export_animesh"
    bl_label = "Export Animesh"

    filename_ext = ".dae"
    filter_glob : bpy.props.StringProperty(
        default='*.dae',
        options={'HIDDEN'}
    )

    @classmethod
    def poll(cls, context):
        
        if context.scene.bone_source == "":
            return False
        if bpy.context.window_manager.bb_mapper.mapper_source_name not in bpy.data.objects:
            return False
 
        for obj in bpy.context.selected_objects:
            if obj.type == 'MESH':
                return True
        return False

    def execute(self, context):

        if context.mode == 'EDIT_MESH':
            
                old_mode = 'EDIT'
        else:
            old_mode = context.mode

        selected = {}

        active_obj = None
        if bpy.context.active_object is not None:
            active_obj = bpy.context.active_object.name

        for obj in bpy.context.selected_objects:
            if obj.type =='MESH':
                for mod in obj.modifiers:
                    if mod.type == 'ARMATURE':
                        
                        print("checking if there's already an ARMATURE modifier for", obj.name)
                        if obj.name in selected:
                            txt = "One of your selected mesh objects has more than one armature modifier: " + obj.name
                            print(txt)
                            popup(txt, "Error", "ERROR")
                            return {'FINISHED'}

                        selected[obj.name] = obj.modifiers[mod.name].object.name

        print("selected", selected)

        if len(selected) == 0:
            print("No qualifying mesh objects were selected")
            popup("No mesh objects qualify for this type of export.  Are your mesh objects parented to their respective armatures?", "Armature Error", "INFO")
            return {'FINISHED'}

        arm_src = bpy.context.window_manager.bb_mapper.mapper_source_name

        if bpy.data.objects[arm_src] is None:
            print("The object in the Bone source is not accessible")
            popup("The object in the Choose bone source rig dropdown list is not accessable", "Error", "ERROR")
            return {'FINISHED'}
        if bpy.data.objects[arm_src].hide_viewport == True:
            print("Your object is hidden from the view so it is not usable as a bone source")
            popup("Your object is hidden from the view so it is not usable as a bone source", "Error", "ERROR")
            return {'FINISHED'}

        armObj = bpy.data.objects[arm_src].copy()
        armObj.data = bpy.data.objects[arm_src].data.copy()
        bpy.context.scene.collection.objects.link(armObj)

        bpy.ops.object.select_all(action='DESELECT')

        new_mesh = []
        new_rigs = [] 

        for mesh in selected:
            
            bpy.ops.object.select_all(action='DESELECT')

            arm = selected[mesh]

            bpy.data.objects[arm].select_set(True)
            bpy.data.objects[mesh].select_set(True)
            bpy.ops.object.duplicate()

            print("WARNING: Possible selection bug when armature is not the parent of the mesh object")

            for obj in bpy.context.selected_objects:
                if obj.type == 'ARMATURE':
                    proxy_arm = obj.name
                    
                    obj.animation_data_clear()
                else:
                    proxy_mesh = obj.name

            bpy.ops.object.select_all(action='DESELECT')
            bpy.data.objects[proxy_arm].select_set(True)

            bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
            new_rigs.append(proxy_arm) 

            bpy.ops.object.select_all(action='DESELECT')
            bpy.data.objects[proxy_mesh].select_set(True)
            bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)

            meshObj = bpy.data.objects[proxy_mesh]

            new_mesh.append(meshObj.name)

            meshObj.parent = armObj

            for m in meshObj.modifiers:
                if m.type == 'ARMATURE':
                    meshObj.modifiers[m.name].object = armObj
                    break

        set_mode(armObj.name, "pose")
        bpy.ops.pose.select_all(action = 'SELECT')
        bpy.ops.pose.constraints_clear()

        bpy.ops.object.mode_set(mode='OBJECT')
        armObj.rotation_mode = 'XYZ'
        armObj.rotation_euler = (0.0, 0.0, 1.5708)

        bpy.ops.object.transform_apply( rotation = True )
        armObj.select_set(False)

        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')

        for mesh in new_mesh:
            bpy.data.objects[mesh].select_set(True)
        bpy.ops.object.transform_apply( rotation = True )

        bb_mesh = bpy.context.scene.bb_mesh

        bpy.ops.wm.collada_export(
            filepath = self.properties.filepath,
            check_existing = True,
            apply_modifiers = bb_mesh.export_apply_modifiers,
            selected = True,
            include_children = False,
            include_armatures = True,
            include_shapekeys = False,
            include_animations=False,
            deform_bones_only = True,
            triangulate = False,
            use_object_instantiation = False,
            use_blender_profile = True,
            sort_by_name = True,

            export_object_transformation_type_selection = 'matrix',
            open_sim = True,
            )

        bpy.ops.object.select_all(action='DESELECT')
        armObj.select_set(True)
        bpy.ops.object.delete()

        for mesh in new_mesh:
            
            bpy.data.objects[mesh].select_set(True)
            bpy.ops.object.delete()

        for arm in new_rigs:
            bpy.data.objects[arm].select_set(True)
            bpy.ops.object.delete()

        bpy.ops.object.select_all(action='DESELECT')
        
        for mesh in selected:
            bpy.data.objects[mesh].select_set(True)

        if active_obj is not None:
            bpy.context.view_layer.objects.active = bpy.data.objects[active_obj]

        return {'FINISHED'}

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

class OnigiriDeleteEmptyGroups(bpy.types.Operator):
    """Remove unused vertex groups"""

    bl_idname = "onigiri.remove_unused_groups"
    bl_label = "bb_remove_unused_groups"

    method : bpy.props.StringProperty(default="best")

    @classmethod
    def poll(cls, context):
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):
        obj = bpy.data.objects

        old_mode = bpy.context.mode
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'

        selected = bpy.context.selected_objects
        active_object = bpy.context.active_object

        state = utils.get_state()

        process = list()
        issue = False
        rm_state = False

        for o in selected:
            process.append(o.name)

        for mesh in process:
            o = obj[mesh]
            if o.type == 'MESH':
                o.select_set(True)
                bpy.context.view_layer.objects.active = o

                if self.method == "best":
                    
                    meshutils.remove_empty_groups(o.name)

                elif self.method == "old":
                    
                    rm_state = remove_empty_groups()

                elif self.method == "new":
                    
                    meshutils.clean_groups(o.name)
                    o.select_set(False)
                else:
                    print("This shouldn't happen, no method was given to the group remover")
                    return {'FINISHED'}

        if issue == True:
            popup("At least one group needed to be removed", "Info", "INFO")

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriMoveWeights(bpy.types.Operator):
    """If there are weights associated with control bones, instead of the functional bones, this tool is for you.
It will create the good groups or combine those that exist with the unusable control bone weights"""

    bl_idname = "onigiri.move_weights"
    bl_label = "bb_move_weights"

    @classmethod
    def poll(cls, context):
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):
        obj = bpy.data.objects

        print("save_state disabled, never used.")
        
        selected = [o for o in bpy.context.selected_objects]
        active = bpy.context.active_object
        old_mode = bpy.context.mode
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        else:
            old_mode = None

        mesh_rigs = dict()
        for o in bpy.context.selected_objects:
            
            if o.type == 'MESH':
                arm = meshutils.get_mesh_armature(o.name)
                if arm == False:
                    print("skipping mesh without rig target:", o.name)
                    continue
                mesh_rigs[o.name] = arm

            o.select_set(False)

        if len(mesh_rigs) == 0:
            print("none of the selected mesh had any rig targets to process")
            return {'FINISHED'}

        mesh_group_names = dict()
        unknown = dict()
        for mesh in mesh_rigs:
            arm = mesh_rigs[mesh]
            print("Processing mesh", mesh, "for rig", arm)
            armObj = obj[arm]
            groups = obj[mesh].vertex_groups
            
            for g in groups:
                if g.name not in armObj.data.bones:
                    if unknown.get(arm) == None:
                        unknown[arm] = list()
                    unknown[arm].append(g.name)

                else:
                    if mesh_group_names.get(mesh) == None:
                        mesh_group_names[mesh] = list()
                    mesh_group_names[mesh].append(g.name)

        if len(unknown) > 0:
            popup("Unknown vertex groups, see console", "Unknown Groups", "INFO")
            print("Found vertex groups not associated with skinning:")
            for a in unknown:
                print(a, "-", unknown[a])
        del unknown
        
        del groups

        good_groups = dict()
        for mesh in mesh_group_names:
            for gname in mesh_group_names[mesh]:
                
                if gname not in skel.avatar_skeleton and                    "m" + gname not in skel.avatar_skeleton: 

                    if gname == "PelvisInv":
                        good_groups[mesh].append(gname)
                        print("added PelvisInv to groups to process")
                    print("Found an unusual bone association in vertex groups:", gname)

                else:
                    if good_groups.get(mesh) == None:
                        good_groups[mesh] = list()
                    good_groups[mesh].append(gname)

        for mesh in good_groups:
            
            meshObj = obj[mesh]
            meshObj.select_set(True)
            bpy.context.view_layer.objects.active = meshObj

            group_names = good_groups[mesh]
            group_objects = meshObj.vertex_groups

            for g in group_names:
                
                if g == "PelvisInv":
                    g_target = "mPelvis"
                    tmp_grp = g + "_" + get_unique_name_short()
                
                elif "m" + g in skel.avatar_skeleton:
                    print("MARK ------------------------------------------------------------")
                    print("g", g)

                    g_target = "m" + g
                    tmp_grp = g + "_" + get_unique_name_short()
                else:
                    
                    continue
                
                grp_lst = [g]
                meshutils.combine_weights(tmp_grp, grp_lst, g_target)
                
                if 1 == 0:
                    grp_del = meshObj.vertex_groups[g]
                    meshObj.vertex_groups.remove(grp_del)
                    grp_del = meshObj.vertex_groups[g_target]
                    meshObj.vertex_groups.remove(grp_del)
                    meshObj.vertex_groups[tmp_grp].name= g_target

            meshObj.select_set(False)

        print("restore_state disabled")

        if old_mode != None:
            for o in selected:
                o.select_set(True)
                bpy.ops.object.mode_set(mode=old_mode)
        bpy.context.view_layer.objects.active = active

        return {'FINISHED'}

class OnigiriConvertToFitmesh(bpy.types.Operator):
    """If this is a Second Life compatible rig you can convert it to a fitmesh.  This will transfer
weight data from the standard bone to the volume bone where a slider associated with that volume bone
should be able to affect it as expected"""

    bl_idname = "onigiri.convert_to_fitmesh"
    bl_label = "Convert to fitmesh"

    @classmethod
    def poll(cls, context):
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):
        bb_misc = bpy.context.window_manager.bb_misc
        obj = bpy.data.objects

        selected = [o for o in bpy.context.selected_objects]
        active = bpy.context.active_object

        mesh_rigs = dict()
        mesh_group_names = dict()
        unknown = dict()
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                arm = meshutils.get_mesh_armature(o.name)
                if arm == False:
                    print("skipping mesh without rig target:", o.name)
                    continue
                mesh_rigs[o.name] = arm

        if len(mesh_rigs) == 0:
            print("none of the selected mesh had any rig targets to process")
            return {'FINISHED'}

        for mesh in mesh_rigs:
            arm = mesh_rigs[mesh]
            print("Processing mesh", mesh, "for rig", arm)
            armObj = obj[arm]
            groups = obj[mesh].vertex_groups
            
            for g in groups:
                if g.name not in armObj.data.bones:
                    if unknown.get(arm) == None:
                        unknown[arm] = list()
                    unknown[arm].append(g.name)
                else:
                    if mesh_group_names.get(mesh) == None:
                        mesh_group_names[mesh] = list()
                    mesh_group_names[mesh].append(g.name)

        print("mesh_rigs:", mesh_rigs)
        print("mesh_group_names:", mesh_group_names)

        bpost = utils.get_temp_name()

        old_vbones = dict()
        old_mbones = dict()
        
        missing_target_bones = dict() 

        for mesh in mesh_group_names:
            print("mesh in mesh_group_names:", mesh)
            for group in mesh_group_names[mesh]:
                print("group in mesh of mesh_group_names:", group)
                if group in volumes.vol_joints:
                    
                    if group not in mbones_to_fitmesh_rev: 
                        continue
                    new_vbone = group + "_" + bpost
                    old_vbones[group] = new_vbone
                    
                    obj[mesh].vertex_groups[group].name = new_vbone
                
                if group in mbones_to_fitmesh:
                    new_mbone = group + "_" + bpost
                    old_mbones[group] = new_mbone
                    obj[mesh].vertex_groups[group].name = new_mbone

            for mbone in old_mbones:
                combine = list()
                vbone = mbones_to_fitmesh[mbone]
                
                if vbone in old_vbones:
                    combine = [old_mbones[mbone], old_vbones[vbone]]
                    
                    meshutils.combine_weights(vbone, [ old_vbones[vbone] ], old_mbones[mbone])
                else:
                    bone = old_mbones[mbone] 
                    obj[mesh].vertex_groups[bone].name = vbone

        if 1 == 1:
            
            arms = dict()
            for mesh in mesh_rigs:
                arm = mesh_rigs[mesh]
                if arm not in arms:
                    arms[arm] = dict()
                arms[arm][mesh] = ""

            for o in bpy.context.selected_objects:
                o.select_set(False)
            
            if bb_misc.to_full_rig == True:
                for arm in arms:
                    obj[arm].select_set(True)
                    bpy.context.view_layer.objects.active = obj[arm]
                    
                    bpy.ops.onigiri.convert_to_full_rig()

        if bb_misc.to_full_rig == False:
            for o in selected:
                o.select_set(True)
            bpy.context.view_layer.objects.active = active

        return {'FINISHED'}

class OnigiriLimitWeights(bpy.types.Operator):
    """Limit the amount of bones that each vertex can be influenced by.  Please use
(Remove Empty Vertex Groups) first or you may be left with useless groups
after this operation"""

    bl_idname = "onigiri.limit_weights"
    bl_label = "bb limit weights"

    @classmethod
    def poll(cls, context):
        obj = bpy.context.object
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):

        txt = "This feature is no longer available and has become obsolete.  The SL\n"
        txt += "uploader seems to be handling your extra weights just fine but if you\n"
        txt += "believe you need this feaure just enable (Normalize Weights)\n"
        txt += "in the (Mesh Export) panel under (Expand rig and kit Options)."
        utils.popup(txt, "Info", "INFO")
        return {'FINISHED'}

        bbm = bpy.context.window_manager.bb_misc
        obj = bpy.context.object

        selected_mesh = list()
        for o in bpy.context.selected_objects:
            if len(o.vertex_groups) == 0:
                continue
            selected_mesh.append(o.name)
        if len(selected_mesh) == 0:
            print("None of the selected mesh contained vertex groups, nothing to do")
            popup("No qualified mesh, see system console", "No Groups", "INFO")
            return {'FINISHED'}

        for m in selected_mesh:
            print("prosessing", m)
            
            limit_weights(mesh=m, limit=bbm.limit_weights)
            
        popup("Finished!  Check console for details", "Info", "INFO")
        return {'FINISHED'}

class OnigiriRemoveWeightsFromSelected(bpy.types.Operator):
    """Remove all joint influences from the selected vertices"""
    bl_idname = "onigiri.remove_weights"
    bl_label = "Remove Weights"

    @classmethod
    def poll(cls, context):
        if bpy.context.mode != 'EDIT_MESH':
            return False
        if bpy.context.object.type != 'MESH':
            return False
        return True

    def execute(self, context):
        meshObj = bpy.context.object

        bpy.ops.object.vertex_group_remove_from(use_all_groups=True)

        return {'FINISHED'}

class OnigiriRemoveSelectUnweighted(bpy.types.Operator):
    """Select vertices that have no weights associated with them.  This condition
causes your uploaded mesh to have no option for weights.  You'll have to weight
these yourself"""

    bl_idname = "onigiri.select_unweighted"
    bl_label = "Select Unweighted"

    @classmethod
    def poll(cls, context):
        
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):

        selected = bpy.context.selected_objects
        state = utils.get_state()

        utils.update()

        mesh = []
        for o in selected:
            if o.type == 'MESH':
                
                o.select_set(True)
                utils.activate(o)
                bpy.ops.object.mode_set(mode='EDIT')
                bpy.ops.mesh.select_all(action='DESELECT')
                bpy.ops.object.mode_set(mode='OBJECT')
                mesh.append(o)
                o.select_set(False)

        qualified_mesh = {}
        for o in mesh:
            verts = []
            for v in o.data.vertices:
                if len(v.groups) == 0:
                    verts.append(v)
                    v.select = True
            if len(verts) > 0:
                qualified_mesh[o] = verts
        if len(qualified_mesh) > 0:
            print("Found zero weighted vertices")
            total = 0
            for o in qualified_mesh:
                o.select_set(True)
                total += len(qualified_mesh[o])
            utils.activate(o)
            bpy.ops.object.mode_set(mode='EDIT')
            txt = "There are " + str(total) + " vertices without weights associated with them in " + str(len(qualified_mesh)) + " mesh"
            popup(txt, "Unweighted vertex report", "INFO")

            del mesh
            del qualified_mesh
            return {'FINISHED'}
        else:
            print("No unweighted vertices found")
            popup("No unweighted vertices found in your mesh selection", "Info", "INFO")
            utils.set_state(state)

        return {'FINISHED'}

class OnigiriNormalizeWeights(bpy.types.Operator):
    """
"""

    bl_idname = "onigiri.normalize_weights"
    bl_label = "Normalize Weights"

    @classmethod
    def poll(cls, context):
        
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):

        selected = bpy.context.selected_objects
        for o in selected:
            if o.type == 'MESH':
                meshutils.normalize_weights(o)
                print("Normalized weights on", o.name)
            else:
                print("Skipping non mesh object:", o.name)

        return {'FINISHED'}

class OnigiriRefreshWeights(bpy.types.Operator):
    """This may not be useful for anything at all but it was one of my test tools
in order to examine issues on some mesh.  This just records all of the weight
data, removes it all, then puts it back in reverse order"""

    bl_idname = "onigiri.refresh_weights"
    bl_label = "Refresh Weights"

    @classmethod
    def poll(cls, context):
        
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):

        selected = bpy.context.selected_objects
        for o in selected:
            if o.type == 'MESH':
                meshutils.refresh_weights(o)
                print("Refreshed weights on", o.name)
            else:
                print("Skipping non mesh object:", o.name)

        return {'FINISHED'}

class OnigiriSkinAttachmentBones(bpy.types.Operator):
    """Skin attachment bones, toggle.  Green means it's enabled.  Only the bones
that can be skinned are affected"""

    bl_idname = "onigiri.skin_attachment_bones"
    bl_label = "Skin Attachments"

    @classmethod
    def poll(cls, context):
        armObj = rigutils.is_armature()
        if armObj == False:
            return False
        return True

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        armObj = bpy.context.selected_objects[0]
        state = utils.get_state()
        armObj.select_set(True)
        utils.activate(armObj)
        skin_attachments = armObj.get('bb_skin_attachments', False)
        
        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in armObj.data.edit_bones:
            bone = boneObj.name
            if bone in skel.avatar_skeleton:
                if skel.avatar_skeleton[bone]['type'] == "attachment":
                    boneObj.use_deform = not skin_attachments

        bpy.ops.object.mode_set(mode='OBJECT')
        armObj['bb_skin_attachments'] = not skin_attachments
        utils.set_state(state)

        print("Finished setting attachment skin option to", not skin_attachments)

        return {'FINISHED'}

class OnigiriSkinSmoothEnable(bpy.types.Operator):
    """Smooth vertex weights.  Enable this to actively smooth your skin weights and
see an updated preview of your changes.  You'll need to disable this to make the
changes permanent or strange things will happen"""

    bl_idname = "onigiri.skin_smooth_enable"
    bl_label = "Enable Smooth weights"

    @classmethod
    def poll(cls, context):
        obj = bpy.context.object
        if len(bpy.context.selected_objects) != 1:
            return False
        for o in bpy.context.selected_objects:
            
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.context.object

        meshObj = bpy.context.selected_objects[0]

        qualified = False
        qualified = False
        if len(meshObj.vertex_groups) > 0:
            qualified = True
        if qualified == False:
            print("Enable says: No vertex groups on the object", meshObj.name)
            popup("There are no vertex groups to apply smooth to", "Error", "ERROR")
            return {'FINISHED'}

        old_mode = bpy.context.mode
        
        bpy.context.view_layer.objects.active = meshObj
        
        meshObj['skin_smooth_enabled'] = True

        smooth_selected_vertices = bb_skin.skin_smooth_selected_vertices
        smooth_selected_group = bb_skin.skin_smooth_selected_group
        smooth_factor = bb_skin.skin_smooth_factor
        smooth_repeat = bb_skin.skin_smooth_repeat
        smooth_area = bb_skin.skin_smooth_area

        paint_mask = bpy.context.object.data.use_paint_mask
        paint_mask_vertex = bpy.context.object.data.use_paint_mask_vertex
        
        paint_mask = False
        paint_mask_vertex = smooth_selected_vertices

        smooth_groups = [] 
        smooth_count = [] 
        smooth_weights = [] 

        for v in meshObj.data.vertices:
            vi = v.index
            
            gcount = 0
            for g in meshObj.data.vertices[vi].groups:
                gcount +=1
                gi = g.group
                gname = meshObj.vertex_groups[gi].name
                smooth_groups.append(gname)
                smooth_weights.append(g.weight)
            smooth_count.append(gcount)

        meshObj['skin_smooth_groups'] = smooth_groups
        meshObj['skin_smooth_weights'] = smooth_weights
        meshObj['skin_smooth_count'] = smooth_count

        print("E: len smooth_groups:", len(smooth_groups))
        print("E: len smooth_weights:", len(smooth_weights))

        del smooth_groups
        del smooth_count
        del smooth_weights

        return {'FINISHED'}

class OnigiriSkinSmoothUpdate(bpy.types.Operator):
    """
-- internal
"""

    bl_idname = "onigiri.skin_smooth_update"
    bl_label = "Smooth weights Updater"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        obj = bpy.context.object
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type == 'MESH':
            return True
        return False

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.context.object

        old_mode = bpy.context.mode
        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'
        if old_mode == 'PAINT_WEIGHT':
            old_mode = 'WEIGHT_PAINT' 

        smooth_selected_vertices = bb_skin.skin_smooth_selected_vertices
        smooth_selected_group = bb_skin.skin_smooth_selected_group
        smooth_factor = bb_skin.skin_smooth_factor
        smooth_repeat = bb_skin.skin_smooth_repeat
        smooth_area = bb_skin.skin_smooth_area

        paint_mask = bpy.context.object.data.use_paint_mask
        paint_mask_vertex = bpy.context.object.data.use_paint_mask_vertex
        
        paint_mask = False
        paint_mask_vertex = smooth_selected_vertices

        meshObj = bpy.context.selected_objects[0]
        bpy.context.view_layer.objects.active = meshObj

        if self.action == "disable":
            print("Disabling skin smoother")
            if len(bpy.context.selected_objects) == 0:
                print("OnigiriSkinSmoothUpdate reports: nothing selected, this is a bug")
            else:
                result = meshObj.pop('skin_smooth_enabled', "")
                meshObj.pop('skin_smooth_enabled', "")
                
                meshObj.pop('skin_smooth_weights', "")
                meshObj.pop('skin_smooth_groups', "")
                meshObj.pop('skin_smooth_count', "")

            print("Skin smooth disabled")
            return {'FINISHED'}

        if meshObj.get('skin_smooth_enabled') != None:

            smooth_groups = meshObj['skin_smooth_groups'] 
            smooth_weights = meshObj['skin_smooth_weights'].to_list() 
            smooth_count = meshObj['skin_smooth_count'].to_list()

            for g in meshObj.vertex_groups:
                meshObj.vertex_groups.remove(g)

            groups = set(smooth_groups) 
            for gname in groups:
                meshObj.vertex_groups.new(name=gname)

            print("U: len smooth_groups:", len(smooth_groups))
            print("U: len smooth_weights:", len(smooth_weights))

            start = 0
            for v in meshObj.data.vertices:
                vi = v.index
                spread = smooth_count[vi]
                stride = start + spread
                groups = smooth_groups[start:stride]
                weights = smooth_weights[start:stride]
                start = stride

                for gi in range(len(groups)):
                    gname = groups[gi] 
                    g = meshObj.vertex_groups[gname] 
                    w = weights[gi]
                    g.add([vi], w, 'REPLACE')

        bpy.ops.object.mode_set(mode='WEIGHT_PAINT')

        group_select_mode = 'ALL'
        if smooth_selected_group == True:
            group_select_mode = 'ACTIVE'

        bpy.ops.object.vertex_group_smooth(group_select_mode=group_select_mode, factor=smooth_factor, repeat=smooth_repeat, expand=smooth_area)

        bpy.ops.object.mode_set(mode=old_mode)

        bpy.context.object.data.use_paint_mask = paint_mask
        bpy.context.object.data.use_paint_mask_vertex = paint_mask_vertex

        return {'FINISHED'}

class OnigiriSkinSmoothManualUpdate(bpy.types.Operator):
    """Update using the current settings.  If you changed one of the toggles and it
didn't update your mesh then hit this button"""

    bl_idname = "onigiri.skin_smooth_manual_update"
    bl_label = "Manual Update"

    @classmethod
    def poll(cls, context):
        obj = bpy.context.object
        if len(bpy.context.selected_objects) != 1:
            return False
        for o in bpy.context.selected_objects:
            
            if o.type != 'MESH':
                return False
        
        if o.get('skin_smooth_enabled') == None:
            return False
        return True

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.context.object

        meshObj = bpy.context.selected_objects[0]
        bpy.context.view_layer.objects.active = meshObj

        qualified = False
        if len(meshObj.vertex_groups) > 0:
            qualified = True
        if qualified == False:
            print("Undo says: No vertex groups on the object", meshObj.name)
            popup("There are no vertex groups to apply smooth to", "Error", "ERROR")
            return {'FINISHED'}

        bpy.ops.onigiri.skin_smooth_update()

        return {'FINISHED'}

class OnigiriSkinSmoothUndo(bpy.types.Operator):
    """Undo the previous (Smooth Weights) operation"""

    bl_idname = "onigiri.skin_smooth_undo"
    bl_label = "Undo last weight smooth"

    @classmethod
    def poll(cls, context):
        obj = bpy.context.object
        if len(bpy.context.selected_objects) != 1:
            return False
        for o in bpy.context.selected_objects:
            
            if o.type != 'MESH':
                return False
        
        if o.get('skin_smooth_enabled') == None:
            return False
        return True

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.context.object

        meshObj = bpy.context.selected_objects[0]
        bpy.context.view_layer.objects.active = meshObj

        qualified = False
        if len(meshObj.vertex_groups) > 0:
            qualified = True
        if qualified == False:
            print("Undo says: No vertex groups on the object", meshObj.name)
            popup("There are no vertex groups to apply smooth to", "Error", "ERROR")
            return {'FINISHED'}

        if meshObj.get('skin_smooth_enabled') != None:
            print("skin data exists, recovering...")
            smooth_groups = meshObj['skin_smooth_groups'] 
            smooth_weights = meshObj['skin_smooth_weights'].to_list() 
            smooth_count = meshObj['skin_smooth_count'].to_list()

            for g in meshObj.vertex_groups:
                meshObj.vertex_groups.remove(g)

            groups = set(smooth_groups) 
            for gname in groups:
                meshObj.vertex_groups.new(name=gname)

            start = 0
            for v in meshObj.data.vertices:
                vi = v.index
                spread = smooth_count[vi]
                stride = start + spread
                groups = smooth_groups[start:stride]
                weights = smooth_weights[start:stride]
                start = stride

                for gi in range(len(groups)):
                    gname = groups[gi] 
                    g = meshObj.vertex_groups[gname] 
                    w = weights[gi]
                    g.add([vi], w, 'REPLACE')

        print("Undo finished, removing old data...")
        meshObj.pop('skin_smooth_enabled', "")
        meshObj.pop('skin_smooth_vertices', "")
        meshObj.pop('skin_smooth_weights', "")
        meshObj.pop('skin_smooth_groups', "")
        meshObj.pop('skin_smooth_count', "")
        bb_skin.property_unset("skin_smooth_enabled")
        print("smoother disabled")

        return {'FINISHED'}

class OnigiriMeshSmoothNormals(bpy.types.Operator):
    """Smooth normals on your mesh.  If you see light and dark artifacts you might want to try this.  Marvelous Designer is
notorious for exporting this way."""

    bl_idname = "onigiri.smooth_normals"
    bl_label = "bb smooth normals"

    action : bpy.props.StringProperty(default="simple")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):
        obj = bpy.data.objects
        bb_mesh = bpy.context.scene.bb_mesh

        selected = [o for o in bpy.context.selected_objects]
        active = bpy.context.active_object

        old_mode = bpy.context.mode
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        if old_mode == 'EDIT_MESH':
            old_mode = 'EDIT'

        for o in selected:
            o.select_set(False)

        mesh_objects = []
        for o in selected:
            if o.type == 'MESH':
                mesh_objects.append(o)

        if bb_mesh.smooth_normals_simple == True:
            for o in mesh_objects:
                o.select_set(True)
                bpy.context.view_layer.objects.active = o
                bpy.ops.object.mode_set(mode='EDIT')
                bpy.ops.mesh.average_normals(average_type='FACE_AREA')
                bpy.ops.object.mode_set(mode='OBJECT')
                o.select_set(False)

        elif bb_mesh.smooth_normals_advanced == True:
            prec = bb_mesh.smooth_normals_precision

            obj_id = {} 
            verts_selected = {}
            for o in mesh_objects:
                
                verts_selected[o.name] = set() 
                for v in o.data.vertices:
                    if v.select == True:
                        verts_selected[o.name].add(v.index)

                mesh_name = o.data.id_data.name
                obj_id[mesh_name] = o.name 
                o.select_set(True)
                bpy.context.view_layer.objects.active = o

                bpy.data.meshes[mesh_name].use_auto_smooth = True
                
                o.data.normals_split_custom_set([(0, 0, 0) for l in o.data.loops])
                bpy.ops.object.mode_set(mode = 'EDIT') 
                
                bpy.ops.mesh.select_all(action='SELECT')
                bpy.ops.mesh.select_mode(type="VERT")
                
                bpy.ops.mesh.select_all(action = 'DESELECT')
                bpy.ops.object.mode_set(mode = 'OBJECT')
                o.select_set(False)

            vert_data = {} 
            all_normals = {} 
            vert_matches = {} 
            for o in mesh_objects:
                
                omw = o.matrix_world.copy()
                all_normals[o.name] = []
                for v in o.data.vertices:
                    all_normals[o.name].append(v.normal) 
                    
                    vw = omw @ v.undeformed_co 
                    c = tuple(( [round(fl, prec) for fl in vw] ))

                    if c in vert_data:
                        
                        if c not in vert_matches:
                            vert_matches[c] = list()
                            
                            vert_matches[c].append(vert_data[c])

                        vert_matches[c].append(v)
                    
                    else:
                        vert_data[c] = v 

            for coord in vert_matches:
                vertObjs = vert_matches[coord]
                normals = list()
                for v in vertObjs:
                    
                    normals.append(v.normal)

                for v in vertObjs:
                    
                    v_owner = v.id_data.name
                    
                    o_name = obj_id[v_owner]
                    
                    i = v.index

                    if bb_mesh.smooth_normals_selected == True:
                        if i not in verts_selected[o_name]:
                            continue

                    all_normals[o_name][i] = normals[0]

            for o in mesh_objects:
                o.select_set(True)
                bpy.context.view_layer.objects.active = active
                normals = all_normals[o.name]
                o.data.normals_split_custom_set_from_vertices(normals)

            bpy.ops.object.mode_set(mode = 'OBJECT')
            for o in selected:
                o.select_set(False)

            for m in verts_selected:
                for v in verts_selected[m]:
                    obj[m].data.vertices[v].select = True

        else:
            print("Unknown smoothing type")

        for o in selected:
            o.select_set(True)
        bpy.context.view_layer.objects.active = active
        bpy.ops.object.mode_set(mode=old_mode)

        self.action = "" 

        return {'FINISHED'}

class OnigiriMeshFreeze(bpy.types.Operator):
    """If your mesh is parented to an object then it has inherited that parent's
transforms.  This will propagate to the child object when the parent is removed.
To fix this choose the mesh, or mutliple, and click this button"""

    bl_idname = "onigiri.mesh_freeze"
    bl_label = "Freeze Mesh"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):
        obj = bpy.data.objects
        selected = bpy.context.selected_objects
        active = bpy.context.active_object

        mesh = []
        for o in selected:
            if o.type == 'MESH':
                mesh.append(o)
            o.select_set(False)

        for o in mesh:
            print("fixing", o.name)
            Object = o
            mat = Object.matrix_world
            loc, rot, sca = mat.decompose()
            mat_loc = mathutils.Matrix.Translation(loc)
            mat_rot = rot.to_matrix().to_4x4()
            mat_sca = mathutils.Matrix.Identity(4)
            mat_sca[0][0], mat_sca[1][1], mat_sca[2][2] = sca
            mat_out = mat_loc @ mat_rot @ mat_sca
            mat_h = mat_out.inverted() @ mat
            
            if Object.parent:
                parentObj = Object.parent
                bpy.ops.object.parent_clear(type='CLEAR_KEEP_TRANSFORM')
                parentObj.select_set(True)
                utils.activate(parentObj)
                bpy.ops.object.transform_apply(location=True, rotation=True, scale=False)
                parentObj.select_set(False)
                Ps = parentObj.scale.copy()
                Cs = Object.scale.copy()
                parentObj.scale = mathutils.Vector((1,1,1))
                Object.scale = mathutils.Vector((1,1,1))
                parentObj.scale = Ps
                
            for v in Object.data.vertices:
                v.co = mat_h @ v.co
            
            Object.parent = parentObj

        for o in selected:
            o.select_set(True)
        utils.activate(active)

        return {'FINISHED'}

class OnigiriMeshEdit(bpy.types.Operator):
    """Smooth UVWs, Remove Doubles, Smooth Mesh/vertices"""

    bl_idname = "onigiri.mesh_edit"
    bl_label = "Edit Mesh"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):
        obj = bpy.data.objects
        bb_mesh = bpy.context.scene.bb_mesh
        old_mode = bpy.context.mode
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        if old_mode == 'EDIT_ARMATURE':
            old_mode = 'EDIT'
        if old_mode == 'EDIT_MESH':
            old_mode = 'EDIT'

        selected = [o for o in bpy.context.selected_objects]
        active = bpy.context.active_object

        good_mesh = []
        for o in selected:
            if o.type == 'MESH':
                good_mesh.append(o)
            o.select_set(False)
        if len(good_mesh) == 0:
            print("No qualifying mesh")
            popup("There are no qualifying mesh in your selection for this operation")
            for o in selected:
                o.select_set(True)
            if active != None:
                bpy.context.view_layer.objects.active = active
            bpy.ops.object.mode_set(mode=old_mode)
            return {'FINISHED'}

        bpy.context.view_layer.objects.active = good_mesh[0]

        if self.action == "uvw":
            
            for o in good_mesh:
                o.select_set(True)
                bpy.context.view_layer.objects.active = o
                bpy.ops.object.mode_set(mode = 'EDIT') 
                bpy.ops.mesh.select_mode(type="EDGE")
                if old_mode == 'OBJECT':
                    bpy.ops.mesh.select_all(action = 'SELECT')
                    bpy.ops.mesh.mark_sharp(clear=True)
                    bpy.ops.mesh.select_all(action = 'DESELECT')
                else:
                    
                    bpy.ops.mesh.mark_sharp(clear=True)

                bpy.ops.object.mode_set(mode='OBJECT')
                o.select_set(False)

        elif self.action == "doubles":
            for o in good_mesh:
                o.select_set(True)
                bpy.context.view_layer.objects.active = o
                bpy.ops.object.mode_set(mode = 'EDIT') 
                bpy.ops.mesh.select_mode(type="VERT")
                if old_mode == 'OBJECT':
                    bpy.ops.mesh.select_all(action = 'SELECT')
                    bpy.ops.mesh.remove_doubles(threshold=0.0001)
                    bpy.ops.mesh.select_all(action = 'DESELECT')
                else:
                    bpy.ops.mesh.remove_doubles(threshold=0.0001)
                bpy.ops.object.mode_set(mode='OBJECT')
                o.select_set(False)

        elif self.action == "smooth":
            for o in good_mesh:
                o.select_set(True)
                bpy.context.view_layer.objects.active = o
                bpy.ops.object.mode_set(mode = 'EDIT') 
                bpy.ops.mesh.select_mode(type="VERT")
                if old_mode == 'OBJECT':
                    bpy.ops.mesh.select_all(action = 'SELECT')
                    bpy.ops.mesh.vertices_smooth(factor=0.5, repeat=1, xaxis=True, yaxis=True, zaxis=True)
                    bpy.ops.mesh.select_all(action = 'DESELECT')
                else:
                    bpy.ops.mesh.remove_doubles(threshold=0.0001)
                    bpy.ops.mesh.vertices_smooth(factor=0.5, repeat=1, xaxis=True, yaxis=True, zaxis=True)
                bpy.ops.object.mode_set(mode='OBJECT')
                o.select_set(False)
        else:
            print("Unknown action")

        for o in selected:
            o.select_set(True)
        bpy.context.view_layer.objects.active = active
        bpy.ops.object.mode_set(mode=old_mode)

        self.action = ""

        return {'FINISHED'}

class OnigiriMeshEditCollapseShape(bpy.types.Operator):
    """If you have shape keys that define how your mesh looks at the moment and you
want to freeze it, you can use this tool to collapse them into the existing shape
and the other keys will be removed after this operation"""

    bl_idname = "onigiri.mesh_edit_collapse_shape"
    bl_label = "Collapse Shape"

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):
        obj = bpy.data.objects

        mesh_list = []
        
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                mesh_list.append(o)
        
        state = utils.get_state()

        for meshObj in mesh_list:
            shapeObj = meshObj.shape_key_add(name="ALL", from_mix=True)
            for s in meshObj.data.shape_keys.key_blocks:
                if s != shapeObj:
                    meshObj.shape_key_remove(s)
            
            meshObj.shape_key_remove(shapeObj)

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriSkinProperties(bpy.types.PropertyGroup):

    skin_pose_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Enable skin pose tool, this has very little use since the (Pose) feature of this tool-set has been included in the (Quick Skinning) tool",
        default = False,
        )
    skin_weight_tools_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "A set of tools for adjusting weights, their influences and associated joints",
        default = False,
        )

    def update_skin_smooth(self, context):
        print("skin_smooth_enabled toggled:", self.skin_smooth_enabled)
        if self.skin_smooth_enabled == False:
            bb_skin = bpy.context.window_manager.bb_skin
            bb_skin.property_unset("skin_smooth_enabled") 
            bpy.ops.onigiri.skin_smooth_update(action="disable")
        else:
            
            bpy.ops.onigiri.skin_smooth_update(action="update")

    skin_smooth_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "This feature allows you to test your new values on the unchanged weight data.  It's quite a bit like Blenders (redo) panel but you "            "have to be careful, any changes you make to your weights will be lost while in this mode because the old data is reinstated before "            "implementing your changes.  Disable this if you are actively skinning your mesh.  You'll also want to disable this when you're done "            "testing and then the changes will stay.  There is a single level undo if you goof it up after you disable.  That undo level will vanish "            "when you enable this again so make sure to (Undo) first, if you need it.",
        default = True,
        update = update_skin_smooth
        )

    def update_skin_smooth_selected_vertices(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].type == 'MESH':
                bpy.context.object.data.use_paint_mask_vertex = self.skin_smooth_selected_vertices
    skin_smooth_selected_vertices : bpy.props.BoolProperty(
        name = "",
        description = "Smooth only selected vertices",
        default = False,
        update = update_skin_smooth_selected_vertices 
        )
    skin_smooth_selected_group : bpy.props.BoolProperty(
        name = "",
        description = "Smooth only selected group",
        default = False,
        )

    skin_smooth_factor : bpy.props.FloatProperty(
        name = "",
        description = "Smoothness",
        min = 0.0,
        max = 1.0,
        default = 0.1,
        update = update_skin_smooth
        )
    skin_smooth_area : bpy.props.FloatProperty(
        name = "",
        description =            "Adjust the area that a vertices groups can effect",
            
        min = -1.0,
        max = 1.0,
        default = 0.0,
        update = update_skin_smooth
        )
    skin_smooth_repeat : bpy.props.IntProperty(
        name = "",
        description = "Iterations",
        default = 4,
        update = update_skin_smooth
        )

    skin_smooth_notice : bpy.props.StringProperty(
        name = "",
        description = "--internal",
        default = "",
        )

    def update_skin_pose_legs_axis_x(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_skin = bpy.context.window_manager.bb_skin
        if bb_skin.skin_pose_legs_axis_x == True:
            bb_skin.skin_pose_legs_axis = 'X'
            bb_settings['terminate'] = True
            bb_skin.skin_pose_legs_axis_y = False
            bb_settings['terminate'] = True
            bb_skin.skin_pose_legs_axis_z = False
        
        else:
            bb_skin.property_unset("skin_pose_legs_axis_x")
            bb_skin.property_unset("skin_pose_legs_axis_y")
            bb_skin.property_unset("skin_pose_legs_axis_z")
            
            bb_skin.skin_pose_legs_axis = 'Z'
    def update_skin_pose_legs_axis_y(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_skin = bpy.context.window_manager.bb_skin
        if bb_skin.skin_pose_legs_axis_y == True:
            bb_skin.skin_pose_legs_axis = 'Y'
            bb_settings['terminate'] = True
            bb_skin.skin_pose_legs_axis_x = False
            bb_settings['terminate'] = True
            bb_skin.skin_pose_legs_axis_z = False
        else:
            bb_skin.property_unset("skin_pose_legs_axis_x")
            bb_skin.property_unset("skin_pose_legs_axis_y")
            bb_skin.property_unset("skin_pose_legs_axis_z")
            bb_skin.skin_pose_legs_axis = 'Z'
    def update_skin_pose_legs_axis_z(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_skin = bpy.context.window_manager.bb_skin
        if bb_skin.skin_pose_legs_axis_z == True:
            bb_skin.skin_pose_legs_axis = 'Z'
            bb_settings['terminate'] = True
            bb_skin.skin_pose_legs_axis_x = False
            bb_settings['terminate'] = True
            bb_skin.skin_pose_legs_axis_y = False
        else:
            bb_skin.property_unset("skin_pose_legs_axis_x")
            bb_skin.property_unset("skin_pose_legs_axis_y")
            bb_skin.property_unset("skin_pose_legs_axis_z")
            bb_skin.skin_pose_legs_axis = 'Z'
    
    def update_skin_pose_arms_axis_x(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_skin = bpy.context.window_manager.bb_skin
        if bb_skin.skin_pose_arms_axis_x == True:
            bb_skin.skin_pose_arms_axis = 'X'
            bb_settings['terminate'] = True
            bb_skin.skin_pose_arms_axis_y = False
            bb_settings['terminate'] = True
            bb_skin.skin_pose_arms_axis_z = False
        
        else:
            bb_skin.property_unset("skin_pose_arms_axis_x")
            bb_skin.property_unset("skin_pose_arms_axis_y")
            bb_skin.property_unset("skin_pose_arms_axis_z")
            
            bb_skin.skin_pose_arms_axis = 'X'
    def update_skin_pose_arms_axis_y(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_skin = bpy.context.window_manager.bb_skin
        if bb_skin.skin_pose_arms_axis_y == True:
            bb_skin.skin_pose_arms_axis = 'Y'
            bb_settings['terminate'] = True
            bb_skin.skin_pose_arms_axis_x = False
            bb_settings['terminate'] = True
            bb_skin.skin_pose_arms_axis_z = False
        else:
            bb_skin.property_unset("skin_pose_arms_axis_x")
            bb_skin.property_unset("skin_pose_arms_axis_y")
            bb_skin.property_unset("skin_pose_arms_axis_z")
            bb_skin.skin_pose_arms_axis = 'X'
    def update_skin_pose_arms_axis_z(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_skin = bpy.context.window_manager.bb_skin
        if bb_skin.skin_pose_arms_axis_z == True:
            bb_skin.skin_pose_arms_axis = 'Z'
            bb_settings['terminate'] = True
            bb_skin.skin_pose_arms_axis_x = False
            bb_settings['terminate'] = True
            bb_skin.skin_pose_arms_axis_y = False
        else:
            bb_skin.property_unset("skin_pose_arms_axis_x")
            bb_skin.property_unset("skin_pose_arms_axis_y")
            bb_skin.property_unset("skin_pose_arms_axis_z")
            bb_skin.skin_pose_arms_axis = 'X'
    
    def update_skin_correction_source(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bb_skin = bpy.context.window_manager.bb_skin
        if bb_skin.skin_correction_source == False:
            bpy.ops.onigiri.skin_correction_source(action="disable")

    skin_correction_source : bpy.props.BoolProperty(
        name = "",
        description =
            "Click to disable"            "\n\n"            "The name of the mesh that you chose for a skin source has been saved as indicated by this property being enabled.  "            "You can disable this operator and start over by clicking it.",
        default = False,
        update = update_skin_correction_source
        )

    def update_skin_pose_lock_sources(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        if bb_skin.skin_pose_lock_sources == False:
            bpy.ops.onigiri.skin_pose_clean(action="sources")
    def update_skin_pose_lock_targets(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        if bb_skin.skin_pose_lock_targets == False:
            bpy.ops.onigiri.skin_pose_clean(action="targets")

    skin_pose_export_wait : bpy.props.BoolProperty(default = False)
    skin_pose_import_wait : bpy.props.BoolProperty(default = False)

    skin_pose_lock_sources : bpy.props.BoolProperty(
        name = "",
        description =            "Click this button to release the skin weight product.  The proxy will be removed from the scene and the pose ui reset.",
        default = False,
        update = update_skin_pose_lock_sources
        )
    skin_pose_lock_targets : bpy.props.BoolProperty(
        name = "",
        description =            "Click this button to release the skin pose products.  The proxy will be removed from the scene and the pose ui reset.",
        default = False,
        update = update_skin_pose_lock_targets
        )

    skin_pose_clean_proxy : bpy.props.BoolProperty(
        name = "",
        description =            "This will clean up common problems that prevent this type of binding.  This only effects the duplicate/proxy skin "            "sources and will not effect your source material or garments.  However, this can actually damage the weight transfer "            "if there are complicated surfaces or unknown edge cases or a very dense mesh.",
        default = False,
        )

    skin_pose_legs_axis : bpy.props.StringProperty(
        name = "",
        description = "-- internal",
        default = 'Z',
        )
    skin_pose_legs_axis_x : bpy.props.BoolProperty(
        name = "",
        description = "x axis spread",
        default = False,
        update = update_skin_pose_legs_axis_x
        )
    skin_pose_legs_axis_y : bpy.props.BoolProperty(
        name = "",
        description = "y axis spread",
        default = False,
        update = update_skin_pose_legs_axis_y
        )
    skin_pose_legs_axis_z : bpy.props.BoolProperty(
        name = "",
        description = "z axis spread",
        default = True,
        update = update_skin_pose_legs_axis_z
        )
    skin_pose_legs_angle : bpy.props.FloatProperty(
        name = "",
        description = "angle in degrees",
        default = 15.0
        )
    
    skin_pose_arms_axis : bpy.props.StringProperty(
        name = "",
        description = "-- internal",
        default = 'X',
        )
    skin_pose_arms_axis_x : bpy.props.BoolProperty(
        name = "",
        description = "x axis spread",
        default = True,
        update = update_skin_pose_arms_axis_x
        )
    skin_pose_arms_axis_y : bpy.props.BoolProperty(
        name = "",
        description = "y axis spread",
        default = False,
        update = update_skin_pose_arms_axis_y
        )
    skin_pose_arms_axis_z : bpy.props.BoolProperty(
        name = "",
        description = "z axis spread",
        default = False,
        update = update_skin_pose_arms_axis_z
        )
    skin_pose_arms_angle : bpy.props.FloatProperty(
        name = "",
        description = "angle in degrees",
        default = 0.0
        )

    def update_skin_lock_garment(s,c):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        bbs = bpy.context.window_manager.bb_skin
        if bbs.skin_lock_garment == True:
            
            if len(bpy.context.selected_objects) == 0:
                bbs.skin_message = "Must have at least 1 mesh selected"
                bb_settings['terminate'] = True
                bbs.skin_lock_garment = False
                return
            bbs['skin_targets'] = list()
            skin_targets = list() 
            for o in bpy.context.selected_objects:
                if o.type == 'MESH':
                    skin_targets.append(o.name)
            if len(skin_targets) == 0:
                bbs.skin_message = "None of the selected objects are skinnable"
                del bbs['skin_targets']
                bb_settings['terminate'] = True
                bbs.skin_lock_garment = False
                return
            
            bbs.skin_count = len(skin_targets)
            if bbs.skin_count == 1:
                bbs.skin_garment_name = skin_targets[0]
            else:
                bbs.skin_garment_name = str(bbs.skin_count)
            bbs.skin_message = "Locked Garment"
            
            bbs['skin_targets'] = skin_targets
        else:
            if bbs.get('skin_targets') != None:
                del bbs['skin_targets']
            bbs.skin_count = 0
            bbs.skin_message = "[Look here for messages]"
            bbs.skin_garment_name = ""
            bbs.skin_lock_avatar = False
        return

    def update_skin_lock_avatar(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        obj = bpy.data.objects
        bbs = bpy.context.window_manager.bb_skin
        if bbs.skin_lock_avatar == True:
            if len(bpy.context.selected_objects) == 0:
                bbs.skin_message = "Must have at least 1 mesh selected"
                bb_settings['terminate'] = True
                bbs.skin_lock_avatar = False
                return

            if len(bpy.context.selected_objects) == 1:
                if bpy.context.selected_objects[0].type == 'ARMATURE':
                    arm = bpy.context.selected_objects[0].name
                    for o in bpy.context.selected_objects:
                        o.select_set(False)
                    for mesh in bbs['skin_targets']:
                        if mesh in obj:
                            obj[mesh].select_set(True)
                            if bbs.skin_reskin == True:
                                for g in obj[mesh].vertex_groups:
                                    obj[mesh].vertex_groups.remove(g)
                            for m in obj[mesh].modifiers:
                                if m.type == 'ARMATURE':
                                    obj[mesh].modifiers.remove(m)
                        else:
                            print("Missing skin target, aborting:", mesh)
                            bbs.skin_message = "Error: Missing object, see console"
                            bb_settings['terminate'] = True
                            bbs.skin_lock_avatar = False
                            bb_settings['terminate'] = True
                            bbs.skin_lock_garment = False
                            bbs.source_count = 0
                            bbs.skin_avatar_name = ""
                            del bbs['skin_targets']
                            bbs.skin_garment_name = ""
                            bbs.skin_avatar_name = ""
                            bbs.skin_count = 0
                            return
                    bbs.skin_avatar_name = arm
                    obj[arm].select_set(True)
                    
                    bpy.context.view_layer.objects.active = bpy.data.objects[arm]
                    bpy.ops.object.parent_set(type='ARMATURE_AUTO')

                    self.skin_lock_garment = False
                    self.skin_message = "Finished!"
                    return

            selected = list()
            for o in bpy.context.selected_objects:
                
                if o.name not in bbs['skin_targets']:
                    if len(o.vertex_groups) > 0:
                        selected.append(o.name)
                    else:
                        print("Skipping skin source with no vertex groups:", o.name)
                else:
                    print("Garment can't be chosen as skin source:", o.name)
            if len(selected) == 0:
                print("The selected mesh were not eligible skin sources.")
                bb_settings['terminate'] = True
                bbs.skin_lock_avatar = False
                bbs.skin_message = "Error: No skin source, see console"
                return

            arm, skin_sources = meshutils.get_one_armature(objects=selected)
            if arm == False:
                bb_settings['terminate'] = True
                bbs.skin_lock_avatar = False
                bbs.skin_message = "Error: See console"
                return
            
            if len(skin_sources) == 0:
                bb_settings['terminate'] = True
                bbs.skin_lock_avatar = False
                bbs.skin_message = "Error: See console"
                return

            bbs['skin_rig'] = arm 
            bbs['skin_sources'] = skin_sources
            bbs.source_count = len(skin_sources)
            bbs.skin_message = "Locked Avatar"

            if bbs.source_count > 1:
                bbs.skin_avatar_name = str(bbs.source_count)
            else:
                bbs.skin_avatar_name = skin_sources[0]
        else:

            bbs.source_count = 0
            bbs.skin_message = "[Look here for messages]"
            bbs.skin_avatar_name = ""
        return

    skin_message : bpy.props.StringProperty(
        description = "-- internal",
        default = "[Look here for messages]",
        )
    
    skin_count : bpy.props.IntProperty(
        description = "-- internal",
        default = 0,
        )
    
    source_count : bpy.props.IntProperty(
        description = "-- internal",
        default = 0,
        )
    skin_lock_garment : bpy.props.BoolProperty(
        description =            "Choose one or more garments or characters (mesh) to skin, then click this button.  For convenience you are allowed "            "to select even your weight source and sort it out with the (lock avatar) button, then that object will be removed "            "from your weight targets so pretty much you can select the entire mass of your character and Lock, then the next "            "feature will sift your weight sources out of your mesh.",
        default = False,
        update = update_skin_lock_garment
        )
    skin_lock_avatar : bpy.props.BoolProperty(
        description =            "This tool has been updated to accept a rig as a skin source when starting from scratch"            "\n\n"            "Choose the source mesh for weights (Avatar) then click this button.  You can select multiple sources.  The source mesh "            "will be tested to make sure they hold a single armature, a single armature modifier, have weight groups and are not listed "            "in the garments/targets.  Onigiri will silently avoid issues but if there's no rig or no weights there's nothing to do",
        default = False,
        update = update_skin_lock_avatar
        )
    skin_garment_name : bpy.props.StringProperty(
        description = "This is the garment name to skin",
        default = "",
        )
    skin_avatar_name : bpy.props.StringProperty(
        description = "This is the source weights, for instance an Avatar / Character",
        default = "",
        )
    skin_remove_empty_groups : bpy.props.BoolProperty(
        name = "",        description = ""            "Remove Empty Weight Groups"            "\n\n"            "Removing empty groups is almost always what you want but if you're expert at this then you may "            "want to do it manually, or use the (Remove empty vertex groups) button.  In any case, the main reason "            "that this is an option and not automatic is because Blender gets it wrong sometimes",
        default = False,
        )
    skin_reskin : bpy.props.BoolProperty(
        name = "",        description = ""            "Remove All Skinning Data"            "\n\n"            "With this enabled all skinning data will be destroyed before applying new weights",
        default = False,
        )
    skin_pose_mode : bpy.props.BoolProperty(
        name = "",        description = ""            "Assume Pose Mode After Skinning"            "\n\n"            "Convenience option.  Assume pose mode on the armature after "            "transferring weights so you can test right away.",
        default = True,
        )
    skin_keep_proxy : bpy.props.BoolProperty(
        name = "",        description = ""            "Keep the skin proxy duplicate"            "\n\n"            "Your skin source objects are copied and then combined in order to give you a smooth weight transition without a lot of fuss.  "            "This object is reusable for skinning and is a single mesh.  If you want to keep this object in the scene after skinning just "            "enable this feature.  Please note that keeping this feature enabled while continuing to skin will generate a new proxy for each "            "occurrence.  You can always keep this disabled, see how the skinning goes, and if you like the results you can skin one more time "            "keeping the proxy for later use.  The proxy object will be named (weight_proxy_) with a unique suffix.",
        default = False,
        )
    skin_use_skin_pose : bpy.props.BoolProperty(
        name = "",        description = ""            "Assume existing pose is the rest pose"            "\n\n"            "This performs a similar function as the (Skin Pose) tool but after maybe a year of feed back it seems as though this is the "            "less confusing method to offer this option.  The existing pose will be used as the skinning shape, giving most people what "            "they expect.  Just like with the skin pose tool you'll need to do some cleanup work after, maybe even more so when using "            "this feature instead of the skin pose tool, but it's less confusing, quick, and I believe it's what most creators are "            "expecting",
        default = False,
        )

    use_object_transform : bpy.props.BoolProperty(default=True)

    use_max_distance : bpy.props.BoolProperty(default=False)
    max_distance : bpy.props.FloatProperty(default=1.0)

    use_auto_transform : bpy.props.BoolProperty(default=False)
    mix_factor : bpy.props.FloatProperty(default=1.000)
    
    vert_mapping : bpy.props.StringProperty(default='NEAREST')

class OnigiriTransferWeights(bpy.types.Operator):
    """The three options here are for transferring weights, which will create an armature modifier on your garments for
the task, parent object to the armature which is a simple hierarchy or parent an armature modifier to the rig from your
mesh"""

    bl_idname = "onigiri.transfer_weights"
    bl_label = "bb transfer weights"

    action : bpy.props.StringProperty(default = "")

    @classmethod
    def poll(cls, context):
        obj = bpy.data.objects
        bbs = bpy.context.window_manager.bb_skin
        if bbs.skin_lock_garment == True and bbs.skin_lock_avatar == True:
            return True
        return False

    def execute(self, context):
        
        obj = bpy.data.objects
        bbs = bpy.context.window_manager.bb_skin

        if bbs.get('skin_sources') == None:
            txt = "Skin sources are mesh, if you used a rig instead\n"
            txt += "then your mesh is already skinned to that rig"
            print(txt)
            utils.popup(txt, "Skin Source Missing", "INFO")
            return {'FINISHED'}

        for oName in bbs['skin_targets']:
            if oName not in obj:
                print("garment missing", oName)
                txt = "Garment missing:" + oName
                popup(txt, "Error", "ERROR")
                return {'FINISHED'}
        for oName in bbs['skin_sources']:
            if oName not in obj:
                print("Skin source missing", oName)
                txt = "Skin source missing:" + oName
                popup(txt, "Error", "ERROR")
                return {'FINISHED'}

        print("views::save_state disabled")
        
        if bpy.context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        for o in bpy.context.selected_objects:
            o.select_set(False)

        arm = bbs['skin_rig']

        for st in bbs['skin_targets']:
            if utils.can_select(object=st) == False:
                print("An object in your set is not accessible:", st)
                print("All objects must be accessible in order to perform this task.")
                popup("Inaccessible object, see system console", "Error", "ERROR")
                return {'FINISHED'}
        if utils.can_select(object=arm) == False:
            print("The armature is not accessible:", arm)
            print("All objects must be accessible in order to perform this task.")
            popup("Inaccessible armature, see system console", "Error", "ERROR")
            return {'FINISHED'}

        if self.action == "parent_object":
            for oName in bbs['skin_targets']:
                obj[oName].parent = obj[arm]
            print("views::restore_state disabled")
            
            return {'FINISHED'}

        elif self.action == "parent_armature":
            
            for st in bbs['skin_targets']:
                obj[st].select_set(True)
            
            obj[arm].select_set(True)
            bpy.context.view_layer.objects.active = obj[arm]
            bpy.ops.object.parent_set(type='ARMATURE_NAME')
            obj[arm].select_set(False)
            print("views::restore_state disabled")
            
        elif self.action == "transfer":
            
            if bbs.skin_reskin == True:
                for st in bbs['skin_targets']:
                    for vg in obj[st].vertex_groups:
                        obj[st].vertex_groups.remove(vg)

            for st in bbs['skin_targets']:
                for mod in obj[st].modifiers:
                    if mod.type == 'ARMATURE':
                        obj[st].modifiers.remove(mod)

            bpy.context.view_layer.update()

            for o in bpy.context.selected_objects:
                o.select_set(False)

            src_str = ""
            for ss in bbs['skin_sources']:
                obj[ss].select_set(True)
                src_str += ss + " "

            bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]
            bpy.ops.object.duplicate()
            
            bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]
            bpy.ops.object.join()
            skinObj = bpy.context.object

            bpy.context.view_layer.update()

            if bbs.skin_use_skin_pose == True:
                armObj = obj[arm]
                targets = []
                for n in bbs['skin_targets']:
                    targets.append(obj[n])
                
                armObj.select_set(True)
                
                state = utils.get_state()
                
                armObj.select_set(True)
                utils.activate(armObj)
                bpy.ops.object.duplicate()
                proxyObj = bpy.context.object
                for modObj in skinObj.modifiers:
                    if modObj.type == 'ARMATURE':
                        modObj.object = proxyObj
                        
                        modObj.use_deform_preserve_volume = False

                skinObj.parent = proxyObj

                print("skinObj.name:", skinObj.name)
                print("proxyObj.name:", proxyObj.name)

                print("--------------------------------------------------")
                print("1 proxyObj.name:", proxyObj.name)
                print("--------------------------------------------------")

                result = rigutils.rebind(proxyObj, report=True)
                if result == False:
                    print("Could not rebind armature")
                    popup("Rebind failure, your mesh did not process!  See system console")
                    return {'FINISHED'}

                utils.set_state(state)

                for st in bbs['skin_targets']:
                    obj[st].select_set(True)
                
                proxyObj.select_set(True)
                utils.activate(proxyObj)
                bpy.ops.object.parent_set(type='ARMATURE_NAME')
                bpy.context.view_layer.update()
                proxyObj.select_set(False)

            else:

                for st in bbs['skin_targets']:
                    obj[st].select_set(True)
                
                obj[arm].select_set(True)
                bpy.context.view_layer.objects.active = obj[arm]
                bpy.ops.object.parent_set(type='ARMATURE_NAME')

                bpy.context.view_layer.update()

                obj[arm].select_set(False)

                for o in bpy.context.selected_objects:
                    o.select_set(False)

            for st in bbs['skin_targets']:
                obj[st].select_set(True)
            utils.activate(skinObj)

            print("selected objects:")
            for o in bpy.context.selected_objects:
                print(" -", o.name)
            print("active object:", bpy.context.active_object.name)

            use_object_transform = bbs.use_object_transform
            use_max_distance = bbs.use_max_distance
            max_distance = bbs.max_distance
            use_auto_transform = bbs.use_auto_transform
            mix_factor = bbs.mix_factor
            vert_mapping = bbs.vert_mapping

            utils.update()

            bpy.ops.object.data_transfer(
                data_type='VGROUP_WEIGHTS',
                layers_select_src='ALL',
                layers_select_dst='NAME',
                use_object_transform=use_object_transform,
                max_distance=max_distance,
                use_auto_transform=use_auto_transform,
                use_max_distance=use_max_distance,
                mix_factor=1,
                use_create=True,
                ray_radius=0,
                vert_mapping=vert_mapping,
                )

            if bbs.skin_use_skin_pose == True:
                
                for boneObj in proxyObj.pose.bones:
                    bone = boneObj.name
                    boneObj.matrix = armObj.data.bones[bone].matrix_local.copy()
                    utils.update()
                
                result = rigutils.rebind(proxyObj, report=True)
                if result == False:
                    print("Could not rebind armature after transfer")
                    popup("Rebind failure, your mesh did not process!  See system console")
                    return {'FINISHED'}
                
                for st in bbs['skin_targets']:
                    obj[st].parent = armObj
                    for modObj in obj[st].modifiers:
                        if modObj.type == 'ARMATURE':
                            modObj.object = armObj
                
                print("--------------------------------------------------")
                print("2 proxyObj.name:", proxyObj.name)
                print("--------------------------------------------------")
                utils.get_state()
                proxyObj.select_set(True)
                utils.activate(proxyObj)
                bpy.ops.object.delete()
                utils.set_state(state)

            for o in bpy.context.selected_objects:
                o.select_set(False)

            if bbs.skin_keep_proxy == True:
                skinObj.name = "weight_proxy_" + get_unique_name_short()
            else:
                skinObj.select_set(True)
                utils.activate(skinObj)
                bpy.ops.object.delete()

            if 1 == 0:
                if bbs.skin_remove_empty_groups == True:
                    issue = False
                    rm_state = False

                    for st in bbs['skin_targets']:
                        obj[st].select_set(True)
                        bpy.context.view_layer.objects.active = obj[st]
                        print("cleaning group:", st)

                        utils.remove_empty_groups(st)

                        obj[st].select_set(False)
            else:
                obj[st].select_set(True)
                bpy.context.view_layer.objects.active = obj[st]

        else:
            print("Unknown action:", self.action)

        if bbs.skin_pose_mode == True:
            bpy.ops.object.mode_set(mode='OBJECT')
            for o in bpy.context.selected_objects:
                o.select_set(False)
            obj[arm].select_set(True)
            if obj[arm].select_get() == False:
                print("Rig is not in view for pose mode when attempting to select it")
                popup("Rig is not selecable or not in view or both, check console", "Error", "ERROR")
                bbs.skin_message = "Rig not accessible!"
            else:
                bpy.context.view_layer.objects.active = obj[arm]
                bpy.ops.object.mode_set(mode='POSE')
                bpy.ops.pose.select_all(action = 'DESELECT')

        self.action = ""

        bbs.skin_lock_garment = False
        bbs.skin_message = "Finished!"

        return {'FINISHED'}

class OnigiriRemoveSkinSource(bpy.types.Operator):
    """Click the black X to remove this source from the list"""

    source : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.remove_skin_source"
    bl_label = "remove skin source"
    def execute(self, context):
        bbs = bpy.context.window_manager.bb_skin

        sources = bbs['skin_sources']
        sources.remove(self.source)
        bbs.source_count -= 1

        print("removed skin source:", self.source, "remaining count:", bbs.source_count)

        if len(sources) == 0:
            bbs.skin_lock_avatar = False
        
        elif len(sources) == 1:
            bbs.skin_avatar_name = sources[0]
        else:
            bbs['skin_sources'] = sources
        return {'FINISHED'}

class OnigiriSkinPoseLockSources(bpy.types.Operator):
    """Select one or more mesh items that you want to transfer skin weights from"""
    bl_idname = "onigiri.skin_pose_lock_sources"
    bl_label = "Skin Pose Sources"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                if len(o.vertex_groups) > 0:
                    return True
        return False

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.data.objects
        sources = []

        if bb_skin.get('skin_pose') == None:
            bb_skin['skin_pose'] = {}
        if bb_skin['skin_pose'].get('sources') == None:
            bb_skin['skin_pose']['sources'] = []
        if bb_skin['skin_pose'].get('targets') == None:
            bb_skin['skin_pose']['targets'] = []

        source_rigs = {}
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                if o.name in bb_skin['skin_pose']['targets']:
                    print("Found source in targets, skipping:", o.name)
                    continue
                
                arm = get_mesh_armature(mesh=o.name)
                if arm == False:
                    continue
                print("Found skin source:", o.name)
                
                source_rigs[arm] = o.name
                sources.append(o.name)
        if len(sources) == 0:
            print("There were no qualifying skin sources, all of the selected objects failed type or rig check")
            popup("No qualifying mesh, see System Console", "Error", "ERROR")
            return {'FINISHED'}
        if len(source_rigs) > 1:
            print("There were more than one rigs associated with your source mesh, we can only handle one set at a time")
            print("You can have as many mesh as you like but they must all be skinned to the same rig.")
            popup("There was a rig error, see System Console for details", "Error", "ERROR")
            return {'FINISHED'}

        bb_skin['skin_pose']['sources'] = sources
        bb_skin.skin_pose_lock_sources = True

        left_leg = 'HipLeft'
        right_leg = 'HipRight'
        left_arm = 'ShoulderLeft'
        right_arm = 'ShoulderRight'

        if left_leg not in obj[arm].data.bones:
            left_leg = "m" + left_leg
            right_leg = "m" + right_leg
            left_arm = "m" + left_arm
            right_arm = "m" + right_arm

        props = {}
        props['legs_axis'] = bb_skin.skin_pose_legs_axis
        props['legs_angle'] = bb_skin.skin_pose_legs_angle
        props['arms_axis'] = bb_skin.skin_pose_arms_axis
        props['arms_angle'] = bb_skin.skin_pose_arms_angle

        legs_axis = props['legs_axis']
        legs_angle = props['legs_angle']
        arms_axis = props['arms_axis']
        arms_angle = props['arms_angle']

        rigutils.reset_pose(armature=arm, rotation=True, location=False, scale=False, space="rig")

        if left_arm in obj[arm].pose.bones:
            rigutils.pose_bone(boneObj=obj[arm].pose.bones[left_arm], axis=arms_axis, angle=arms_angle) 
        if right_arm in obj[arm].pose.bones:
            rigutils.pose_bone(boneObj=obj[arm].pose.bones[right_arm], axis=arms_axis, angle=arms_angle)
        if left_leg in obj[arm].pose.bones:
            rigutils.pose_bone(boneObj=obj[arm].pose.bones[left_leg], axis=legs_axis, angle=-legs_angle) 
        if right_leg in obj[arm].pose.bones:
            rigutils.pose_bone(boneObj=obj[arm].pose.bones[right_leg], axis=legs_axis, angle=legs_angle)

        return {'FINISHED'}

class OnigiriSkinPoseLockTargets(bpy.types.Operator):
    """Select one or more mesh items that you want to transfer skin weights to"""
    bl_idname = "onigiri.skin_pose_lock_targets"
    bl_label = "Skin Pose Targets"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.data.objects
        targets = []

        if bb_skin.get('skin_pose') == None:
            bb_skin['skin_pose'] = {}
        if bb_skin['skin_pose'].get('sources') == None:
            bb_skin['skin_pose']['sources'] = []
        if bb_skin['skin_pose'].get('targets') == None:
            bb_skin['skin_pose']['targets'] = []

        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                if o.name in bb_skin['skin_pose']['sources']:
                    print("Found target in sources, skipping:", o.name)
                else:
                    print("Adding skin target:", o.name)
                    targets.append(o.name)
        if len(targets) == 0:
            print("There were no qualifying mesh targets.  Either they were part of the source list already or there's a bug")
            popup("No qualifying mesh, see System Console", "Error", "ERROR")
            return {'FINISHED'}

        bb_skin['skin_pose']['targets'] = targets
        bb_skin.skin_pose_lock_targets = True

        return {'FINISHED'}

class OnigiriSkinPoseTransfer(bpy.types.Operator):
    """This will transfer the weights from the skin sources to the target garments
and setup your pose properly back to where it was where the skin is bound to the
armature in its proper position without disturbing the rig"""

    bl_idname = "onigiri.skin_pose_transfer"
    bl_label = "Skin Pose Transfer"

    @classmethod
    def poll(cls, context):
        bb_skin = bpy.context.window_manager.bb_skin
        if bb_skin.skin_pose_lock_sources == False:
            return False
        if bb_skin.skin_pose_lock_targets == False:
            return False
        return True

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.data.objects

        if bpy.context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
            
        active = bpy.context.active_object
        for o in bpy.context.selected_objects:
            o.select_set(False)

        targets = bb_skin['skin_pose']['targets']
        sources = bb_skin['skin_pose']['sources']

        for skin in sources:
            arm = get_mesh_armature(mesh=skin)
            if arm == False:
                print("A redundant check failed when processing", skin, "the rig is invalid")
                popup("Fatal Error, rig inconsistency, see System Console", "Error", "ERROR")
                return {'FINISHED'}

        left_leg = 'HipLeft'
        right_leg = 'HipRight'
        left_arm = 'ShoulderLeft'
        right_arm = 'ShoulderRight'

        if left_leg not in obj[arm].data.bones:
            left_leg = "m" + left_leg
            right_leg = "m" + right_leg
            left_arm = "m" + left_arm
            right_arm = "m" + right_arm

        props = {}
        props['legs_axis'] = bb_skin.skin_pose_legs_axis
        props['legs_angle'] = bb_skin.skin_pose_legs_angle
        props['arms_axis'] = bb_skin.skin_pose_arms_axis
        props['arms_angle'] = bb_skin.skin_pose_arms_angle

        legs_axis = props['legs_axis']
        legs_angle = props['legs_angle']
        arms_axis = props['arms_axis']
        arms_angle = props['arms_angle']

        rigutils.reset_pose(armature=arm, rotation=True, location=False, scale=False, space="rig")

        if left_arm in obj[arm].pose.bones:
            rigutils.pose_bone(boneObj=obj[arm].pose.bones[left_arm], axis=arms_axis, angle=arms_angle) 
        if right_arm in obj[arm].pose.bones:
            rigutils.pose_bone(boneObj=obj[arm].pose.bones[right_arm], axis=arms_axis, angle=arms_angle)
        if left_leg in obj[arm].pose.bones:
            rigutils.pose_bone(boneObj=obj[arm].pose.bones[left_leg], axis=legs_axis, angle=-legs_angle) 
        if right_leg in obj[arm].pose.bones:
            rigutils.pose_bone(boneObj=obj[arm].pose.bones[right_leg], axis=legs_axis, angle=legs_angle)

        bpy.ops.onigiri.skin_pose_restore()

        for mesh in targets:
            if obj[mesh].get('skin_pose') == None:
                    obj[mesh]['skin_pose'] = {}
            if obj[mesh]['skin_pose'].get('shape') == None:
                shape = [v.co for v in obj[mesh].data.vertices]
                obj[mesh]['skin_pose'] = {}
                obj[mesh]['skin_pose']['shape'] = shape
                del shape

        bpy.context.view_layer.update()

        for o in bpy.context.selected_objects:
            o.select_set(False)

        for skin in sources:
            obj[skin].select_set(True)
        
        bpy.context.view_layer.objects.active = obj[skin]
        bpy.ops.object.duplicate()

        print("about to join")
        print("objects selected:", [o.name for o in bpy.context.selected_objects])

        if len(sources) > 1:
            bpy.ops.object.join()

        proxy = bpy.context.object.name

        bpy.context.view_layer.update()

        if bb_skin.skin_pose_clean_proxy == True:
            print("Mesh cleanup before binding for:", proxy)
            print(proxy + " : transforms apply, excluding location data...")
            bpy.ops.object.transform_apply(scale=True, rotation=True, location=False)

            utils.remove_empty_groups(proxy)
            meshutils.limit_weights(mesh=proxy, limit=4)

            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_all(action='SELECT')
            print(proxy + " : remove doubles by 0.0001 distance")
            bpy.ops.mesh.remove_doubles(threshold=0.0001)
            bpy.ops.mesh.select_all(action='DESELECT')
            bpy.ops.object.mode_set(mode='OBJECT')
            
            bpy.ops.object.modifier_add(type='TRIANGULATE')
            tri_mod = obj[proxy].modifiers.new(name="BB_TRI", type='TRIANGULATE')

            print("Cleaned")

        bpy.context.view_layer.update()

        obj[proxy].select_set(False)

        for mesh in targets:
            obj[mesh].select_set(True)
        obj[arm].select_set(True)
        bpy.context.view_layer.objects.active = obj[arm]
        bpy.ops.object.parent_set(type='ARMATURE_NAME')
        obj[arm].select_set(False)

        obj[proxy].select_set(True)
        bpy.context.view_layer.objects.active = obj[proxy]

        use_object_transform = True
        use_max_distance = False
        max_distance = 1.0
        use_auto_transform = False
        mix_factor = 1.0

        vert_mapping = 'POLYINTERP_NEAREST'

        bpy.ops.object.data_transfer(
            data_type='VGROUP_WEIGHTS',
            layers_select_src='ALL',
            layers_select_dst='NAME',
            use_object_transform=use_object_transform,
            max_distance=max_distance,
            use_auto_transform=use_auto_transform,
            use_max_distance=use_max_distance,
            mix_factor=1,
            use_create=True,
            ray_radius=0,
            vert_mapping=vert_mapping,
            )

        bpy.context.view_layer.update()

        skin_data = {}

        for mesh in targets:
            for m in obj[mesh].modifiers:
                if m.type == 'ARMATURE':
                    obj[mesh].modifiers[m.name].show_viewport = False

        for mesh in targets:
            obj[mesh].select_set(True)
            bpy.context.view_layer.objects.active = obj[mesh]

            sd_mod = obj[mesh].modifiers.new(name="SD", type='SURFACE_DEFORM')
            
            obj[mesh].modifiers[sd_mod.name].target = obj[proxy]
            obj[mesh].modifiers[sd_mod.name].falloff = 4.0
            bpy.context.view_layer.update()
            mod_name = sd_mod.name

            bpy.ops.object.surfacedeform_bind(modifier=mod_name)

            if obj[mesh].modifiers[mod_name].is_bound == False:

                print("The process failed.  Please restore your mesh and try without (clean proxy)", mesh)
                popup("At least one of your mesh failed to bind, disable (Clean Proxy) and try again", "Error", "ERROR")
                
                obj[mesh].modifiers.remove(sd_mod)

            obj[mesh].select_set(False)

        rigutils.reset_pose(armature=arm, rotation=True, location=False, scale=False, space="rig")

        dg = bpy.context.evaluated_depsgraph_get()

        for mesh in targets:
            
            bm = bmesh.new()
            bm.from_object( obj[mesh], dg )
            bm.verts.ensure_lookup_table()
            shape = []
            for v in bm.verts:
                v_co = v.co.copy()
                shape.append(v_co)
            bm.free()

            bpy.context.view_layer.update()

            for m in obj[mesh].modifiers:
                if m.type == 'SURFACE_DEFORM':
                    obj[mesh].modifiers.remove(m)

            for v in range(len(shape)):
                obj[mesh].data.vertices[v].co = shape[v]

            bpy.context.view_layer.update()

        for mesh in targets:
            for m in obj[mesh].modifiers:
                if m.type == 'ARMATURE':
                    obj[mesh].modifiers[m.name].show_viewport = True

        for o in bpy.context.selected_objects:
            o.select_set(False)

        obj[proxy].select_set(True)
        bpy.context.view_layer.objects.active = obj[proxy]
        bpy.ops.object.delete()

        for mesh in targets:
            obj[mesh].select_set(True)
        
        bpy.context.view_layer.objects.active = obj[mesh]

        del targets

        return {'FINISHED'}

class OnigiriSkinPoseRestore(bpy.types.Operator):
    """This will remove the weights and association with the sources as well as
restore the shape of the garment to its original condition"""

    bl_idname = "onigiri.skin_pose_restore"
    bl_label = "Skin Pose Restore"

    mesh : bpy.props.StringProperty(default="")

    def execute(self, context):
        
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.data.objects

        if bb_skin.get('skin_pose') == None:
            print("No skin_pose property")
            return {'FINISHED'}
        if bb_skin['skin_pose'].get('targets') == None:
            print("No shape property")
            return {'FINISHED'}

        targets = bb_skin['skin_pose']['targets']

        for target in targets:
            if target not in obj:
                print("Fatal error, target missing from scene:", target)
                popup("Fatal error, target missing from scene", "Error", "ERRO")
                return {'FINISHED'}

        for mesh in targets:
            for m in obj[mesh].modifiers:
                if m.type == 'ARMATURE':
                    obj[mesh].modifiers.remove(m)
            for g in obj[mesh].vertex_groups:
                obj[mesh].vertex_groups.remove(g)
            obj[mesh].parent = None

        for mesh in targets:
            if obj[mesh].get('skin_pose') == None:
                print("Missing property skin_pose", mesh)
            else:
                if obj[mesh]['skin_pose'].get('shape') == None:
                    print("Missing property shape", mesh)
                else:
                    shape = obj[mesh]['skin_pose']['shape']
                    if len(obj[mesh].data.vertices) != len(shape):
                        del o['skin_pose']['shape']
                        print("Stored shape is not compatible with its own mesh, did you alter the mesh?", mesh)
                        popup("Stored shape is incompatible, can't restore", "Info", "INFO")
                    else:
                        
                        for v in range(len(shape)):
                            obj[mesh].data.vertices[v].co = shape[v]

                    del shape
                    
        return {'FINISHED'}

class OnigiriSkinPoseClean(bpy.types.Operator):
    """-- internal --"""
    bl_idname = "onigiri.skin_pose_clean"
    bl_label = "Skin Pose Clean"

    action : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.data.objects

        for o in bpy.context.selected_objects:
            o.select_set(False)

        proxy = bb_skin['skin_pose'].get('proxy')
        if proxy != None:
            if proxy in obj:
                obj[proxy].select_set(True)
                bpy.context.view_layer.objects.active = obj[proxy]
                bpy.ops.object.delete()

        print("pose_clean::called with:", self.action)

        del bb_skin['skin_pose']

        bb_skin.property_unset("skin_pose_lock_sources")
        bb_skin.property_unset("skin_pose_lock_targets")

        return {'FINISHED'}

class OnigiriSkinPoseExport(bpy.types.Operator, ExportHelper):
    """This is a convenience tool that exports an OBJ file with some error checking,
in order to have a more stream-lined work-flow when sending a devkti body to
Marvelous Designer and bringing your garment back"""

    bl_idname = "onigiri.skin_pose_export"
    bl_label = "Export OBJ"

    filename_ext = ".obj"
    filter_glob : bpy.props.StringProperty(
        default='*.obj',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        if bpy.context.window_manager.bb_skin.get('obj_export_folder') != None:
            save_path = bpy.context.window_manager.bb_skin['obj_export_folder']
        else:
            save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        if bpy.context.window_manager.bb_skin.skin_pose_lock_sources == False:
            return False
        return True

    def execute(self, context):
        
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.data.objects

        sources = bb_skin['skin_pose']['sources']

        if bpy.context.active_object == None:
            bpy.context.view_layer.objects.active = sources[0]

        selected = [o for o in bpy.context.selected_objects]
        active = bpy.context.active_object

        old_mode = bpy.context.mode

        if old_mode == 'EDIT_ARMATURE':
            print("Can't export in edit armature mode")
            popup("Change modes to export mesh", "Edit Mode", "ERROR")
            return {'FINISHED'}
        if old_mode == 'POSE':
            print("Can't export in pose mode")
            popup("Change modes to export mesh", "Pose Mode", "ERROR")
            return {'FINISHED'}

        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        if old_mode == 'EDIT_MESH':
            old_mode = 'EDIT'

        for o in selected:
            o.select_set(False)

        exportable = []
        for skin in sources:
            if skin in obj:
                exportable.append(skin)

        if len(exportable) == 0:
            print("The objects contained in ['sources'] are not valid", sources)
            popup("Sources invalid, see System Console", "Error", "ERROR")
            return {'FINISHED'}

        for mesh in exportable:
            obj[mesh].select_set(True)
        
        bpy.context.view_layer.objects.active = obj[mesh]
        bpy.ops.object.duplicate()

        new_mesh = [o.name for o in bpy.context.selected_objects]

        rig_pose = {}
        for mesh in new_mesh:
            arm = mod_functions.get_mesh_armature(mesh=mesh)
            if arm == False:
                continue
            rig_pose[arm] = {}
        if len(rig_pose) > 0:
            for arm in rig_pose:
                for boneObj in obj[arm].pose.bones:
                    rig_pose[arm][boneObj.name] = boneObj.matrix_basis.copy()

        for mesh in new_mesh:
            bpy.context.view_layer.objects.active = obj[mesh]
            if obj[mesh].data.shape_keys:
                bpy.ops.object.shape_key_add(from_mix=False)
                for k in obj[mesh].data.shape_keys.key_blocks:
                    obj[mesh].shape_key_remove(k)
            for m in obj[mesh].modifiers:
                bpy.ops.object.modifier_apply(modifier=m.name)

        bb_skin.skin_pose_export_wait = True
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

        filepath = self.properties.filepath
        bb_skin['obj_export_folder'] = filepath

        bpy.ops.export_scene.obj(
            filepath=filepath, check_existing=True, use_selection=True, use_mesh_modifiers=True,
            use_edges=True, use_smooth_groups=False, use_smooth_groups_bitflags=False, use_normals=True,
            use_uvs=True, use_materials=True, use_triangles=False, use_nurbs=False, use_vertex_groups=False,
            use_blen_objects=True, group_by_object=False, group_by_material=False, keep_vertex_order=True,
            global_scale=1.0, path_mode='AUTO', axis_forward='-Z', axis_up='Y')

        bpy.ops.object.delete()

        if len(rig_pose) > 0:
                for boneObj in obj[arm].pose.bones:
                    m = rig_pose[arm][boneObj.name]
                    boneObj.matrix_basis = m

        for o in selected:
            o.select_set(True)
        bpy.context.view_layer.objects.active = active

        bpy.ops.object.mode_set(mode=old_mode)

        bb_skin.skin_pose_export_wait = False

        return {'FINISHED'}

class OnigiriSkinPoseImport(bpy.types.Operator, ImportHelper):
    """This convenience importer will simply place you into the same folder where you
exported your model so that you have a quicker workflow as well as set sane import
options.  You have the option, however, to split your mesh in import as described"""

    bl_idname = "onigiri.skin_pose_import"
    bl_label = "Import OBJ"

    filename_ext = ".obj"
    filter_glob : bpy.props.StringProperty(
        default='*.obj',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        if bpy.context.window_manager.bb_skin.get('obj_export_folder') != None:
            load_path = bpy.context.window_manager.bb_skin['obj_export_folder']
        else:
            load_path = bpy.path.abspath("//")
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.data.objects

        bb_skin.skin_pose_import_wait = True
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

        filepath = self.properties.filepath

        use_split_objects = True
        use_split_groups = False
        use_smooth_groups = True
        use_groups_as_vgroups = False
        use_image_search = False 
        split_mode = 'OFF' 

        bpy.ops.import_scene.obj(
            filepath=filepath, use_edges=True, use_smooth_groups=use_smooth_groups,
            use_split_objects=use_split_objects, use_split_groups=use_split_groups,
            use_groups_as_vgroups=use_groups_as_vgroups, use_image_search=use_image_search,
            split_mode=split_mode, axis_forward='-Z', axis_up='Y')
            
        bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]

        bb_skin.skin_pose_import_wait = False

        return {'FINISHED'}

class OnigiriSkinCorrectionSource(bpy.types.Operator):
    """The calculator needs to know the skin source.  This is probably a character/avatar (devkit mesh).
Select your skin source in the viewport and click this button.  If you have several sources it's ok to
select them all"""

    bl_idname = "onigiri.skin_correction_source"
    bl_label = "Skin Correction Source"

    action : bpy.props.StringProperty(default="")

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.data.objects

        if self.action == 'enable':
            bb_skin.skin_correction_source = True

            skins = []
            arms = {} 
            for o in bpy.context.selected_objects:
                if o.type == 'MESH':
                    
                    arm = get_mesh_armature(mesh=o.name)
                    if arm == False:
                        continue
                    print("Found skin source:", o.name)
                    skins.append(o.name)
                    arms[arm] = o.name

            if len(skins) == 0:
                print("There were no qualifying skin sources, all of the selected objects failed type or rig check")
                popup("No qualifying mesh, see System Console", "Error", "ERROR")
                bb_skin.property_unset("skin_correction_source")
                return {'FINISHED'}
            
            if len(arms) > 1:
                print("There were more than one armatures associated with your selected mesh, this cannot be processed.")
                popup("Choose mesh with the same armature association, see console", "Error", "ERROR")
                bb_skin.property_unset("skin_correction_source")
                return {'FINISHED'}

            bb_skin['skin_correction'] = {}
            bb_skin['skin_correction']['sources'] = skins
            bb_skin['skin_correction'] ['armature'] = arm

        elif self.action == 'disable':
            
            bpy.ops.onigiri.skin_correction_finish()

        else:
            print("OnigiriSkinCorrectionSource reports: unknown action")

        self.action = ""

        return {'FINISHED'}

class OnigiriSkinCorrectionSetup(bpy.types.Operator):
    """Choose the problem garment then click this button.  If your mesh isn't skinned/rigged
yet, and you are using a custom pose for better weight transfer, use the (Skin Pose) group
instead of this tool"""

    bl_idname = "onigiri.skin_correction_setup"
    bl_label = "Skin Correction Setup"

    @classmethod
    def poll(cls, context):
        if bpy.context.window_manager.bb_skin.skin_correction_source == False:
            return False
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'MESH':
            return False
        if len(bpy.context.selected_objects[0].vertex_groups) == 0:
            return False
        return True

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.data.objects
        o = bpy.context.selected_objects[0]
        bpy.context.view_layer.objects.active = o

        if bb_skin.get('skin_correction') == None:
            print("Something went wrong, base data missing.")
            popup("Internal Error, missing base data, see System Console", "Error", "ERROR")
            return {'FINISHED'}
        if bb_skin['skin_correction'].get('sources') == None:
            print("Skin source missing, this should not happen.")
            popup("Internal Error, missing skin source, see System Console", "Error", "ERROR")
            return {'FINISHED'}
        for mesh in bb_skin['skin_correction']['sources']:
            if mesh not in obj:
                print("Skin source missing from scene:", mesh)
                popup("At least one skin source is missing, see System Console", "Error", "ERROR")
                return {'FINISHED'}
            if mesh == o.name:
                print("This object is already part of the skin sources.")
                print("If you want to edit it then reset the panel NOW using (Finish) or (Disable).")
                popup("Can't use skin source as a garment, see System Console", "Error", "ERROR")
                return {'FINISHED'}

        arm = mod_functions.get_mesh_armature(mesh=o.name)
        if arm == False:
            print("get_mesh_armature returns False")
            popup("Armature error, see System Console", "Error", "ERROR")
            return {'FINISHED'}

        mod = mod_functions.get_mesh_armature_modifier(mesh=o.name)

        if mod == False:
            print("programmers dum detected dumbness, no modifer name was returned")
            return {'FINISHED'}

        if  o.get('skin_correction') != None:
            print("Skinning correction tool is already engaged on this object, click (Finish) to reset it")
            popup("Skinning tool already engaged, click (Finish)", "Info", "INFO")
            return {'FINISHED'}

        o['skin_correction'] = {}
        bpy.context.view_layer.update()
        o['skin_correction']['frame_current'] = bpy.context.scene.frame_current
        o['skin_correction']['pose'] = {}

        left_leg = 'HipLeft'
        right_leg = 'HipRight'
        left_arm = 'ShoulderLeft'
        right_arm = 'ShoulderRight'

        if left_leg not in obj[arm].data.bones:
            left_leg = "m" + left_leg
            right_leg = "m" + right_leg
            left_arm = "m" + left_arm
            right_arm = "m" + right_arm

        if left_arm in obj[arm].pose.bones:
            o['skin_correction']['pose'][left_arm] = obj[arm].pose.bones[left_arm].matrix.copy()
        if right_arm in obj[arm].pose.bones:
            o['skin_correction']['pose'][right_arm] = obj[arm].pose.bones[right_arm].matrix.copy()

        if left_leg in obj[arm].pose.bones:
            o['skin_correction']['pose'][left_leg] = obj[arm].pose.bones[left_leg].matrix.copy()
        if right_leg in obj[arm].pose.bones:
            o['skin_correction']['pose'][right_leg] = obj[arm].pose.bones[right_leg].matrix.copy()

        o['skin_correction']['show_in_edit_mode'] = o.modifiers[mod].show_in_editmode
        o['skin_correction']['show_on_cage'] = o.modifiers[mod].show_on_cage
        o.modifiers[mod].show_in_editmode = True
        o.modifiers[mod].show_on_cage = True

        bpy.context.scene.frame_set(1)

        legs_axis = bb_skin.skin_pose_legs_axis
        legs_angle = bb_skin.skin_pose_legs_angle
        arms_axis = bb_skin.skin_pose_arms_axis
        arms_angle = bb_skin.skin_pose_arms_angle

        if left_arm in obj[arm].pose.bones:
            rigutils.pose_bone(boneObj=obj[arm].pose.bones[left_arm], axis=arms_axis, angle=arms_angle) 
        if right_arm in obj[arm].pose.bones:
            rigutils.pose_bone(boneObj=obj[arm].pose.bones[right_arm], axis=arms_axis, angle=arms_angle)
        if left_leg in obj[arm].pose.bones:
            rigutils.pose_bone(boneObj=obj[arm].pose.bones[left_leg], axis=legs_axis, angle=-legs_angle) 
        if right_leg in obj[arm].pose.bones:
            rigutils.pose_bone(boneObj=obj[arm].pose.bones[right_leg], axis=legs_axis, angle=legs_angle)

        shape = [v.co for v in o.data.vertices]
        o['skin_correction']['shape'] = shape
        del shape

        bpy.ops.object.mode_set(mode = 'EDIT') 
        bpy.ops.mesh.select_mode(type="VERT")
        bpy.ops.mesh.select_all(action = 'DESELECT')

        bb_skin['skin_correction']['target'] = o.name

        return {'FINISHED'}

class OnigiriSkinCorrectionFinish(bpy.types.Operator):
    """Clean up the skinning correction preparation.  This is a scene wide sweep but it's
necessary in order to keep things from being cluttered.  Use this when you're finished"""

    bl_idname = "onigiri.skin_correction_finish"
    bl_label = "Skin Correction Finish"

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.data.objects

        if bpy.context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode = 'OBJECT') 

        for o in bpy.context.selected_objects:
            o.select_set(False)

        for o in obj:
            if o.type == 'MESH':
                if o.get('skin_correction') != None:

                    frame_current = o['skin_correction']['frame_current']
                    bpy.context.scene.frame_set(frame_current)
                    arm = mod_functions.get_mesh_armature(mesh=o.name)
                    if arm != False:
                        for bone in o['skin_correction']['pose']:
                            if bone in obj[arm].pose.bones:
                                m = mathutils.Matrix(o['skin_correction']['pose'][bone])
                                obj[arm].pose.bones[bone].matrix = m
                    mod = mod_functions.get_mesh_armature_modifier(mesh=o.name)
                    if mod != False:
                        
                        o.modifiers[mod].show_in_editmode = o['skin_correction']['show_in_edit_mode']
                        o.modifiers[mod].show_on_cage = o['skin_correction']['show_on_cage']
                    
                    shape = o['skin_correction'].get('shape')
                    if shape != None:
                        
                        if len(o.data.vertices) == len(shape):
                            for v in range(len(shape)):
                                o.data.vertices[v].co = shape[v]

                    del o['skin_correction']
        if bb_skin.get('skin_correction') != None:
            del bb_skin['skin_correction']

        bb_skin.property_unset("skin_correction_source")

        return {'FINISHED'}

class OnigiriSkinCorrection(bpy.types.Operator):
    """In edit mode select a number of vertices that are not cooperating and click
(Recalculate).  This fix is for what you might think of as sticky leg syndrome"""

    action : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.skin_correction"
    bl_label = "Skin Correction"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'MESH':
            return False
        if len(bpy.context.selected_objects[0].vertex_groups) == 0:
            return False
        if bpy.context.mode != 'EDIT_MESH':
            return False

        bb_skin = bpy.context.window_manager.bb_skin
        if bb_skin.get('skin_correction') == None:
            return False
        if bb_skin['skin_correction'].get('sources') == None:
            return False
        
        return True

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.data.objects
        o = bpy.context.selected_objects[0]
        bpy.context.view_layer.objects.active = o

        if bpy.context.mode != 'EDIT_MESH':
            print("Not in edit mode")
            return {'FINISHED'}
        if self.action == "select_more":
            bpy.ops.mesh.select_more(use_face_step=False)
            return {'FINISHED'}
        if self.action == "select_less":
            bpy.ops.mesh.select_less(use_face_step=False)
            return {'FINISHED'}
        if self.action == "recalc":
            
            arm = bb_skin['skin_correction']['armature']
            if arm not in obj:
                print("Armature is missing:", arm)
                popup("Missing armature", "Error", "ERROR")
                return {'FINISHED'}

            bpy.ops.object.mode_set(mode = 'OBJECT') 
            
            if len(bpy.context.selected_objects) > 1:
                print("Detected multiple selected objects, this is not a correct state")
            for o in bpy.context.selected_objects:
                o.select_set(False)

            for ss in bb_skin['skin_correction']['sources']:
                print("Adding skin source to selection:", ss)
                obj[ss].select_set(True)
            bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]
            bpy.ops.object.duplicate()

            if len(bpy.context.selected_objects) == 1:
                print("Single weight source")
            else:
                
                bpy.ops.object.join()

            proxy = bpy.context.object.name
            bpy.context.view_layer.update()
            
            bpy.context.view_layer.objects.active = obj[proxy]
            print("Created skin proxy:", proxy)

            groups = {}
            groups['index'] = {}
            groups['name'] = {}

            for g in obj[proxy].vertex_groups:
                groups['index'][g.index] = g.name
                groups['name'][g.name] = g.index

            from .presets import bone_sides

            bpy.ops.object.mode_set(mode = 'EDIT') 
            bpy.ops.mesh.select_mode(type="VERT")
            bpy.ops.mesh.select_all(action = 'DESELECT')

            mw = obj[arm].matrix_world.copy()
            (hip_x, hip_y, hip_z) = obj[arm].data.bones['mHipLeft'].head_local.copy()
            (LEG_x, LEG_y, LEG_z) = obj[arm].data.bones['L_UPPER_LEG'].head_local.copy()

            top_z = LEG_z + ( (hip_z - LEG_z) / 2 )

            print("hip_z:", hip_z)
            print("LEG_z:", LEG_z)
            print("top_z:", top_z)

            bpy.ops.object.mode_set(mode = 'OBJECT') 
            for v in obj[proxy].data.vertices:
                    (v_x, v_y, v_z) = mw @ v.co
                    if v_z < top_z:
                        v.select = True
                    
                    if 1 == 0:
                        for g in v.groups:
                            gname = groups['index'][g.group]
                            if gname == 'mHipLeft' or gname == 'L_UPPER_LEG' or gname == 'HipLeft':
                                v.select = True

            if 1 == 0:
                for v in obj[proxy].data.vertices:
                    for g in v.groups:
                        gname = groups['index'][g.group]
                        if gname not in bone_sides.bones_left:
                            continue
                        v.select = True

            bpy.ops.object.mode_set(mode = 'EDIT') 

            if 1 == 0:
                for g in groups['name']:
                    if g not in bone_sides.bones_left:
                        continue
                    obj[proxy].vertex_groups.active_index = groups['name'][g]
                    bpy.ops.object.vertex_group_select()

        print("shell for skin correction")

        return {'FINISHED'}

class OnigiriSkinPose(bpy.types.Operator):
    """Select an avatar to pose.  This is so that you can export your character for
use in Marvelous Designer or other cloth making application, maybe ZBrush"""

    bl_idname = "onigiri.skin_pose"
    bl_label = "Skin Pose"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        
        if len(bpy.context.selected_objects) == 0:
            return False

        return True

    def execute(self, context):
        bb_skin = bpy.context.window_manager.bb_skin
        obj = bpy.data.objects

        arm = None
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                arm = o.name
                print("Found an armature selection:", arm)
        if arm == None:
            for o in bpy.context.selected_objects:
                if o.type == 'MESH':
                    
                    arm = mod_functions.get_mesh_armature(mesh=o.name)
                    if arm == False:
                        print("get_mesh_armature returns False")
                        popup("Armature error, see System Console", "Error", "ERROR")
                        return {'FINISHED'}
                    
                    mod = mod_functions.get_mesh_armature_modifier(mesh=o.name)
                    break 

        left_leg = 'HipLeft'
        right_leg = 'HipRight'
        left_arm = 'ShoulderLeft'
        right_arm = 'ShoulderRight'

        if left_leg not in obj[arm].data.bones:
            left_leg = "m" + left_leg
            right_leg = "m" + right_leg
            left_arm = "m" + left_arm
            right_arm = "m" + right_arm

        arm_bones = [left_arm, right_arm]
        leg_bones = [left_leg, right_leg]

        legs_axis = bb_skin.skin_pose_legs_axis
        legs_angle = bb_skin.skin_pose_legs_angle
        arms_axis = bb_skin.skin_pose_arms_axis
        arms_angle = bb_skin.skin_pose_arms_angle

        idq = mathutils.Quaternion((0, 0, 0), 1 )
        if self.action == "arms":
            bones = arm_bones
        elif self.action == "legs":
            bones = leg_bones
        elif self.action == "reset":
            bones = leg_bones
            bones.extend(arm_bones)
        else:
            bones = [] 

        for bone in bones:
            rotation_mode = obj[arm].pose.bones[bone].rotation_mode
            obj[arm].pose.bones[bone].rotation_mode = 'QUATERNION'
            obj[arm].pose.bones[bone].rotation_quaternion = idq
            obj[arm].pose.bones[bone].rotation_mode = rotation_mode

        if self.action == "reset":
            return {'FINISHED'}

        if self.action == "arms":
            if left_arm in obj[arm].pose.bones:
                rigutils.pose_bone(boneObj=obj[arm].pose.bones[left_arm], axis=arms_axis, angle=arms_angle) 
            if right_arm in obj[arm].pose.bones:
                rigutils.pose_bone(boneObj=obj[arm].pose.bones[right_arm], axis=arms_axis, angle=arms_angle)
        elif self.action == "legs":
            if left_leg in obj[arm].pose.bones:
                rigutils.pose_bone(boneObj=obj[arm].pose.bones[left_leg], axis=legs_axis, angle=-legs_angle) 
            if right_leg in obj[arm].pose.bones:
                rigutils.pose_bone(boneObj=obj[arm].pose.bones[right_leg], axis=legs_axis, angle=legs_angle)
        else:
            print("Unknown action:", self.action)

        return {'FINISHED'}

class OnigiriPaintProperties(bpy.types.PropertyGroup):

    paint_menu_enabled : bpy.props.BoolProperty(
        name = "", 
        description = "Show weight painting menu",
        default = False,
        )
    
    def update_paint_active(self, context):
        
        print("paint_active toggled:", self.paint_active)
        if self.paint_active == False:
            bpy.ops.onigiri.paint_enable(state=False)

    def update_paint_back_face(self, context):
        bb_paint = bpy.context.scene.bb_paint
        print("paint_back_face toggled:", self.paint_back_face)
        if self.paint_back_face == False:
            bpy.ops.onigiri.paint_back_face(state=self.paint_back_face)
            
    paint_active : bpy.props.BoolProperty(
        name = "",
        description = "Click to accept changes and disable paint mode.",
        default = False,
        update = update_paint_active
        )
    paint_back_face : bpy.props.BoolProperty(
        name = "",
        description = "Disable paint through mesh",
        default = False,
        update = update_paint_back_face
        )
    
class OnigiriPaintEnabled(bpy.types.Operator):
    """Select 1 or more mesh to paint and click this button.  If the mesh is associated
with a rig it will be included as well and if an armature modifier is needed it will
be placed automatically.  Don't forget to choose a bone (shift + click)"""

    state : bpy.props.BoolProperty(default=False)

    bl_idname = "onigiri.paint_enable"
    bl_label = "Turn on weight painting for this mesh."

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                return True
        return False

    def execute(self, context):
        obj = bpy.data.objects
        bb_paint = bpy.context.scene.bb_paint

        utils.cleanup()

        if self.state == True:
            
            selected = bpy.context.selected_objects
            
            state = utils.get_state()
            
            active_mesh = []
            active_arms = []
            for o in selected:
                if o.type == 'MESH':
                    active_mesh.append(o)
                elif o.type == 'ARMATURE':
                    active_arms.append(o)

            arm_targets = set()
            for o in active_mesh:
                for modObj in o.modifiers:
                    if modObj.type == 'ARMATURE':
                        if modObj.object != None:
                            arm_targets.add(modObj.object)

            if len(arm_targets) > 1:
                utils.set_state(state)
                print("Your mesh are pointing to different armatures.  Fix this before continuing or choose a different set.")
                print("Armatures:", [o.name for o in arm_targets])
                popup("Too many armature targets, see System Console", "Error", "ERROR")
                return {'FINISHED'}

            elif len(arm_targets) == 0:
                if len(active_arms) == 0:
                    utils.set_state(state)
                    print("There are no target armatures qualified for use in your selection and any existing modifiers, if they exists")
                    print("do not point to armatures, there's nothing to do.  Select an armature with your mesh in order to process these.")
                    popup("No armature targets to process, see System Console", "Error", "ERROR")
                    return {'FINISHED'}
                
                if len(active_arms) > 1:
                    utils.set_state(state)
                    print("If you have armature modifiers on your mesh they do not point to armatures and I cannot use the armatures")
                    print("in your selection because there are too many, choose your qualified mesh along with a single armature.")
                    popup("Too many armatures selected, see System Console", "Error", "ERROR")
                    return {'FINISHED'}

                for o in active_mesh:
                    for modObj in o.modifiers:
                        if modObj.type == 'ARMATURE':
                            o.modifiers.remove(modObj)
                for o in active_mesh:
                    
                    o.select_set(True)
                    bpy.context.view_layer.objects.active = o
                    armMod = o.modifiers.new(type='ARMATURE', name='Armature')
                    armMod.use_vertex_groups = True
                    armMod.object = active_arms[0]
                    o.parent = active_arms[0]
                    result = utils.move_to_top(object=o.name, modifier=armMod.name)
                    if result == False:
                        utils.set_state(state)
                        print("0: Something strange happened when reorganizing the armature modifier and I can't continue.")
                        print("This error left your mesh in an unclean state, check the modifiers and the object parents.")
                        popup("Unknown modifier error, see System Console", "Error", "ERROR")
                        return {'FINISHED'}
                    o.select_set(False)
                
                armObj = active_arms[0]

            else:
                
                armObj = list(arm_targets)[0]

                for o in active_mesh:
                    for modObj in o.modifiers:
                        if modObj.type == 'ARMATURE':
                            o.modifiers.remove(modObj)
                for o in active_mesh:
                    
                    o.select_set(True)
                    bpy.context.view_layer.objects.active = o
                    armMod = o.modifiers.new(type='ARMATURE', name='Armature')
                    armMod.use_vertex_groups = True
                    armMod.object = armObj
                    o.parent = armObj
                    result = utils.move_to_top(object=o.name, modifier=armMod.name)
                    if result == False:
                        utils.set_state(state)
                        print("1: Something strange happened when reorganizing the armature modifier and I can't continue.")
                        print("This error left your mesh in an unclean state, check the modifiers and the object parents.")
                        popup("Unknown modifier error, see System Console", "Error", "ERROR")
                        return {'FINISHED'}
                    o.select_set(False)

            for o in bpy.context.selected_objects:
                o.select_set(False)

            delete_me = []

            for o in active_mesh:
                o['bb_name'] = o.name

            for o in active_mesh:
                o.select_set(True)
            bpy.context.view_layer.objects.active = o

            bpy.ops.object.duplicate()

            clones = [o for o in bpy.context.selected_objects]
            active_clone = bpy.context.active_object

            bpy.ops.object.duplicate()

            bpy.ops.object.join()
            
            weightObj = bpy.context.object

            for o in bpy.context.selected_objects:
                o.select_set(False)

            bpy.context.view_layer.objects.active = active_clone

            mesh_index = 0
            mesh_map = {}
            bmesh_cleanup = [] 
            for o in clones:
                bm = bmesh.new()
                bm.from_mesh(o.data)
                vert_id = bm.verts.layers.int.new('vert')
                
                mesh_id = bm.verts.layers.int.new('mesh')
                bm.verts.ensure_lookup_table()
                for v in o.data.vertices:
                    index = v.index
                    bm.verts[index][vert_id] = index
                    bm.verts[index][mesh_id] = mesh_index
                mesh_map[mesh_index] = o['bb_name'] 
                mesh_index += 1
                bm.to_mesh(o.data)
                bmesh_cleanup.append(bm)

            for o in clones:
                o.select_set(True)

            bpy.ops.object.join()
            trashObj = bpy.context.object
            delete_me.append(trashObj)

            vertex_map = {}
            bm = bmesh.new()
            bm.from_mesh(trashObj.data)
            bm.verts.ensure_lookup_table()
            vert_id = bm.verts.layers.int.get('vert')
            mesh_id = bm.verts.layers.int.get('mesh')

            for v in trashObj.data.vertices:
                index = v.index
                
                index_string = str(index)
                source_vert = bm.verts[index][vert_id]
                source_mesh = bm.verts[index][mesh_id]
                mesh_name = mesh_map[source_mesh] 

                vertex_map[index_string] = {}
                vertex_map[index_string][mesh_name] = source_vert
                
            bm.free()
            for bm in bmesh_cleanup:
                bm.free()

            weight_verts = []
            mesh_verts = []
            source_verts = []
            for w in vertex_map:
                (m, v), = vertex_map[w].items()
                weight_verts.append(w)
                mesh_verts.append(m)
                source_verts.append(v)

            weightObj['weight_verts'] = weight_verts
            weightObj['mesh_verts'] = mesh_verts
            weightObj['source_verts'] = source_verts
            del weight_verts
            del mesh_verts
            del source_verts
            del vertex_map

            weightObj['onigiri_weights'] = True
            weightObj['source_mesh'] = active_mesh

            for o in bpy.context.selected_objects:
                o.select_set(False)
            for o in delete_me:
                print("deleting:", o.name)
                o.select_set(True)
            bpy.context.view_layer.objects.active = o
            bpy.ops.object.delete()

            for o in active_mesh:
                o.hide_viewport = True
            del active_mesh

            bb_paint['weight_object'] = weightObj

            weightObj.select_set(True)
            bpy.context.view_layer.objects.active = weightObj
            armObj.select_set(True)
            bpy.ops.object.mode_set(mode='WEIGHT_PAINT')

            bb_paint['falloff_shape'] =  bpy.data.brushes["Draw"].falloff_shape
            bb_paint['use_frontface'] = bpy.data.brushes["Draw"].use_frontface
            bb_paint['use_frontface_falloff'] = bpy.data.brushes["Draw"].use_frontface_falloff
            bb_paint.paint_active = True

        else:
            
            weightObj = bb_paint['weight_object']
            source_mesh = weightObj['source_mesh']

            weight_verts = weightObj['weight_verts'] 
            mesh_verts = weightObj['mesh_verts'] 
            source_verts = weightObj['source_verts'] 

            source_mesh_groups = {}
            for meshObj in source_mesh:
                for g in meshObj.vertex_groups:
                    meshObj.vertex_groups.remove(g)

            mesh_groups = {}
            for meshObj in source_mesh:
                mesh = meshObj.name
                mesh_groups[mesh] = {}
            
            weight_map = {}
            for i in range(len(mesh_verts)):
                mesh = mesh_verts[i]

                if mesh not in weight_map:
                    weight_map[mesh] = {}
                vert = source_verts[i]
                
                weight_map[mesh][vert] = {}

            for v in weightObj.data.vertices:
                index = v.index
                for g in v.groups:
                    
                    gi = g.group
                    
                    w = g.weight
                    
                    gname = weightObj.vertex_groups[gi].name
                    
                    mesh = mesh_verts[index]
                    
                    si = source_verts[index]
                    
                    weight_map[mesh][si][gname] = w
                    if gname not in mesh_groups[mesh]:
                        mesh_groups[mesh][gname] = []
                    mesh_groups[mesh][gname].append(si)

            indices = []
            for meshObj in source_mesh:
                mesh = meshObj.name

                for gname in mesh_groups[mesh]:
                    group = meshObj.vertex_groups.new(name=gname)

                    indices = mesh_groups[mesh][gname]
                    
                    group.add(indices, 0.0, 'REPLACE')

                    for i in indices:
                        for g in meshObj.data.vertices[i].groups:
                            gname = meshObj.vertex_groups[g.group].name
                            g.weight = weight_map[mesh][i][gname] 

            bpy.data.brushes["Draw"].falloff_shape = bb_paint['falloff_shape']
            bpy.data.brushes["Draw"].use_frontface = bb_paint['use_frontface']
            bpy.data.brushes["Draw"].use_frontface_falloff = bb_paint['use_frontface_falloff']
            
            bpy.ops.object.mode_set(mode='OBJECT')
            for o in bpy.context.selected_objects:
                o.select_set(False)
            
            del bb_paint['weight_object'] 
            weightObj.select_set(True)
            bpy.ops.object.delete()
            for o in source_mesh:
                o.hide_viewport = False
                o.select_set(True)
            bpy.context.view_layer.objects.active = o

        return {'FINISHED'}

class OnigiriPaintBackFace(bpy.types.Operator):
    """Toggle painting through the mesh to affect the back facing vertices as well.
The combination of tool settings required to enable this feature is not intuitive
so I bring you this quick button"""

    state : bpy.props.BoolProperty(default=False)

    bl_idname = "onigiri.paint_back_face"
    bl_label = "Paint through mesh"

    def execute(self, context):
        obj = bpy.data.objects
        bb_paint = bpy.context.scene.bb_paint

        if self.state == True:
            bb_paint.paint_back_face = True
            bpy.data.brushes["Draw"].falloff_shape = 'PROJECTED'
            bpy.data.brushes["Draw"].use_frontface = False
            bpy.data.brushes["Draw"].use_frontface_falloff = False
        else:
            bpy.data.brushes["Draw"].falloff_shape = 'SPHERE'
            bpy.data.brushes["Draw"].use_frontface = True
            bpy.data.brushes["Draw"].use_frontface_falloff = False
        return {'FINISHED'}

class OnigiriCreateMeshDeformer(bpy.types.Operator, ExportHelper):
    """A mesh alternative to the pose deformer.  Choose a rig for a full deformer,
or go into pose mode and chose 1 or more bones for spot deformers"""

    bl_idname = "onigiri.create_mesh_deformer"
    bl_label = "Create a mesh deformer"

    filename_ext = ".dae"
    filter_glob : bpy.props.StringProperty(
        default='*.dae',
        options={'HIDDEN'}
    )

    def invoke(self, context, event):
        save_path = bpy.path.abspath("//")
        self.filepath = save_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
                return False
        return True

    def execute(self, context):
        
        armObj = bpy.context.selected_objects[0]
        bpy.context.view_layer.objects.active = armObj
        active = bpy.context.active_object
        old_mode = bpy.context.mode

        obj = bpy.data.objects
        bb_misc = bpy.context.window_manager.bb_misc
        bb_mesh = bpy.context.scene.bb_mesh
        mesh_deformer_separate = bb_misc.mesh_deformer_separate
        mesh_to_middle = bb_misc.mesh_to_middle

        if old_mode == 'POSE':
            pose_bones = [b.name for b in bpy.context.selected_pose_bones]
            if len(pose_bones) == 0:
                print("Your rig is in pose mode which suggests that you want a bone deformer but there are")
                print("no bones selected.  Select 1 or more pose bones and try this again.")
                popup("No pose bones selected, see System Console", "Error", "ERROR")
                return {'FINISHED'}

        state = utils.get_state()
        armObj.select_set(True)
        utils.activate(armObj)

        bpy.ops.object.duplicate()
        proxyObj = bpy.context.object

        proxyObj.name = "DEFORMER_RIG"

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')

        if old_mode == 'OBJECT':
            for boneObj in proxyObj.data.bones:
                boneObj.select = True

        bpy.ops.object.mode_set(mode='POSE')
        pose_bones = []
        for boneObj in bpy.context.selected_pose_bones:
            pose_bones.append(boneObj.name)

        mesh_list = meshutils.bones_to_mesh(armature=proxyObj.name, bones=pose_bones, separate=mesh_deformer_separate, middle=mesh_to_middle)
        bpy.context.view_layer.objects.active = obj[ mesh_list[0] ]

        proxyObj.select_set(False)
        for mesh in mesh_list:
            obj[mesh].select_set(True)

        export_path_to_pelvis = bb_mesh.export_path_to_pelvis
        export_full_rig = bb_mesh.export_full_rig
        use_safe_settings = bb_mesh.use_safe_settings
        use_offset_location = bb_mesh.use_offset_location
        use_offset_rotation = bb_mesh.use_offset_rotation
        use_rig_data = bb_mesh.use_rig_data
        rotate_for_sl = bb_mesh.rotate_for_sl

        bb_mesh.export_path_to_pelvis = True
        bb_mesh.export_full_rig = False
        bb_mesh.use_safe_settings = False
        bb_mesh.use_offset_location = True
        bb_mesh.use_offset_rotation = True
        bb_mesh.use_rig_data = True
        bb_mesh.rotate_for_sl = True

        bpy.ops.onigiri.collada_export(filepath=self.filepath)

        for o in bpy.context.selected_objects:
            o.select_set(False)

        proxyObj.select_set(True)
        for mesh in mesh_list:
            obj[mesh].select_set(True)
        bpy.context.view_layer.objects.active = proxyObj
        bpy.ops.object.delete()

        utils.set_state(state)

        bb_mesh.export_path_to_pelvis = export_path_to_pelvis
        bb_mesh.export_full_rig = export_full_rig
        bb_mesh.use_safe_settings = use_safe_settings
        bb_mesh.use_offset_location = use_offset_location
        bb_mesh.use_offset_rotation = use_offset_rotation
        bb_mesh.use_rig_data = use_rig_data
        bb_mesh.rotate_for_sl = rotate_for_sl

        return {'FINISHED'}

        if 1 == 0:
            for boneObj in proxyObj.data.bones:
                bone = boneObj.name
                name = bone.replace(" ", "_")
                boneObj.name = name
            utils.update()

        file_path = tempfile.gettempdir() + "/onigiri_" + utils.get_temp_name() + ".dae"
        bpy.ops.wm.collada_export(
            filepath = file_path,
            check_existing = True,
            apply_modifiers = False,
            selected = True,
            include_children = bb_mesh.export_include_children,
            include_armatures = bb_mesh.export_include_armatures,
            include_shapekeys = bb_mesh.export_include_shapekeys,
            include_animations = bb_mesh.export_include_animations,
            deform_bones_only = bb_mesh.export_deform_bones_only,
            triangulate = False,
            use_object_instantiation = bb_mesh.export_use_object_instantiation,
            use_blender_profile = bb_mesh.export_use_blender_profile,
            sort_by_name = bb_mesh.export_sort_by_name,
            open_sim = bb_mesh.export_open_sim,
            export_object_transformation_type_selection = 'matrix',
            export_global_forward_selection='-X',
            export_global_up_selection='Z',
            apply_global_orientation=True,
            )
        file_in = file_path
        file_out = self.properties.filepath
        
        collada.write_collada(armature=proxyObj.name, real_armature=proxyObj.name, write=True, file_in=file_in, file_out=file_out)
        try:
            os.remove(file_path)
            print("BB dae cleanup")
        except:
            print("BB Warning: unable to remove temporary file:", file_path)

        bb_mesh.export_path_to_pelvis = export_path_to_pelvis
        bb_mesh.export_full_rig = export_full_rig
        bb_mesh.use_safe_settings = use_safe_settings
        bb_mesh.use_offset_location = use_offset_location
        bb_mesh.use_offset_rotation = use_offset_rotation
        bb_mesh.use_rig_data = use_rig_data
        bb_mesh.rotate_for_sl = rotate_for_sl

        utils.get_state()

        proxyObj.select_set(True)
        for mesh in mesh_list:
            obj[mesh].select_set(True)
        bpy.context.view_layer.objects.active = proxyObj
        bpy.ops.object.delete()

        armObj.select_set(True)
        bpy.context.view_layer.objects.active = armObj
        if old_mode != None:
            bpy.ops.object.mode_set(mode=old_mode)

        return {'FINISHED'}

class OnigiriCreateMeshFromBones(bpy.types.Operator):
    """ This creates skinned mesh to the bones that are chosen, it will only produce
mesh for those selected bones or, if enabled, mapped bones only"""

    bl_idname = "onigiri.mesh_from_bones"
    bl_label = "Mesh from Bones"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        
        return True

    def execute(self, context):
        armObj = bpy.context.selected_objects[0]

        obj = bpy.data.objects
        bb_misc = bpy.context.window_manager.bb_misc
        bb_mesh = bpy.context.scene.bb_mesh
        mesh_deformer_separate = bb_misc.mesh_deformer_separate
        mesh_from_mapped_bones = bb_misc.mesh_from_mapped_bones
        split_mash_for_sl = bb_misc.split_mesh_for_sl
        mesh_to_middle = bb_misc.mesh_to_middle

        pose_bones = [b.name for b in bpy.context.selected_pose_bones]
        if mesh_from_mapped_bones == True:
            print("The feature (mesh_from_mapped_bones) was enabled")
            if armObj.get("bb_onemap_rename") != None:
                print("Found a map on the rig, collecting...")
                rename_map = armObj['bb_onemap_rename'].to_dict()
                
                pose_bones = []
                for bone in rename_map:
                    if bone not in armObj.data.bones:
                        continue
                    pose_bones.append(bone)
            else:
                print("No map on the rig, reverted to selected bones only")

        if len(pose_bones) == 0:
            print("After filtering there were no pose bones left to process")
            popup("After filtering there were no renaiming pose bones to process", "Error", "ERROR")
            return {'FINISHED'}

        state = utils.get_state()
        armObj.select_set(True)
        utils.activate(armObj)

        bpy.ops.object.duplicate()
        proxyObj = bpy.context.object

        proxyObj.name = "MESH_BONES_RIG"

        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')

        mesh_list = meshutils.bones_to_mesh(armature=proxyObj.name, bones=pose_bones, separate=mesh_deformer_separate, middle=mesh_to_middle)

        for o in bpy.context.selected_objects:
            o.select_set(False)
        proxyObj.select_set(True)
        utils.activate(proxyObj)
        bpy.ops.object.delete()

        if len(mesh_list) == 0:
            print("No mesh returned")
            popup("No mesh returned", "Error", "ERROR")
        else:
            
            for mesh in mesh_list:
                obj[mesh].select_set(True)
            meshObj = obj[mesh]
            utils.activate(meshObj)

            for mesh in mesh_list:
                meshObj = obj[mesh]
                meshObj.parent = armObj
                for modObj in meshObj.modifiers:
                    if modObj.type == 'ARMATURE':
                        modObj.object = armObj

            if split_mash_for_sl == True:
                bpy.ops.onigiri.split_mesh()

            bpy.ops.onigiri.remove_unused_groups(method='best')

        return {'FINISHED'}

class OnigiriCreateMeshDeformer_DISABLED(bpy.types.Operator):
    """A mesh alternative to the pose deformer.  Choose a rig for a full deformer,
choose a mesh, or any number of mesh, for a partial deformer related to just those
mesh.  Box selecting your entire setup will filter just to the mesh"""

    bl_idname = "onigiri.create_mesh_deformer_DISABLED"
    bl_label = "Create a mesh deformer DISABLED"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        
        for o in bpy.context.selected_objects:
            if o.type == 'MESH' or o.type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        obj = bpy.data.objects

        bb_misc = bpy.context.window_manager.bb_misc
        mesh_deformer_separate = bb_misc.mesh_deformer_separate

        old_mode = bpy.context.mode
        if old_mode == 'POSE':
            pose_bones = [b for b in bpy.context.selected_pose_bones]
            if len(pose_bones) == 0:
                print("Your rig is in pose mode which suggests that you want a bone deformer but there are")
                print("no bones selected.  Select 1 or more pose bones and try this again.")
                popup("No pose bones selected, see System Console", "Error", "ERROR")
                return {'FINISHED'}
        if old_mode.startswith('EDIT'):
            old_mode = 'EDIT'
        if old_mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        selected = [o for o in bpy.context.selected_objects]

        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].type == 'ARMATURE':

                armObj = bpy.context.selected_objects[0]

                proxyObj = rigutils.build_rig(rig_class="pos", rotate=True)
                if proxyObj == False:
                    print("An error occurred when generating a proxy rig for this purpose")
                    popup("Error generating proxy rig for deformer", "Error", "ERROR")
                    return {'FINISHED'}

                proxyObj.name = "DEFORMER_RIG"

                for o in bpy.context.selected_objects:
                    o.select_set(False)
                proxyObj.select_set(True)
                bpy.context.view_layer.objects.active = armObj
                bpy.ops.object.mode_set(mode='EDIT')
                edit_bones = {}
                for boneObj in armObj.data.edit_bones:
                    bone = boneObj.name
                    edit_bones[bone] = {}
                    edit_bones[bone]['head'] = boneObj.head.copy()
                    edit_bones[bone]['tail'] = boneObj.tail.copy()
                    edit_bones[bone]['roll'] = boneObj.roll
                bpy.ops.object.mode_set(mode='OBJECT')
                armObj.select_set(False)

                proxyObj.select_set(True)
                bpy.context.view_layer.objects.active = proxyObj

                bpy.ops.object.mode_set(mode='EDIT')
                for boneObj in proxyObj.data.edit_bones:
                    boneObj.use_connect = False
                
                for boneObj in proxyObj.data.edit_bones:
                    bone = boneObj.name
                    if bone not in armObj.data.bones:
                        continue
                    boneObj.head = edit_bones[bone]['head']
                    boneObj.tail = edit_bones[bone]['tail']
                    boneObj.roll = edit_bones[bone]['roll']

                bpy.ops.object.mode_set(mode='OBJECT')

                deformer = meshutils.bones_to_mesh(armature=proxyObj.name, target=None, separate=mesh_deformer_separate)
                
                if len(deformer) == 0: 
                    for o in bpy.context.selected_objects:
                        o.select_set(False)
                    armObj.select_set(True)
                    bpy.context.view_layer.objects.active = obj[arm]
                    bpy.ops.object.mode_set(mode=old_mode)
                    print("the utility bones_to_mesh returned empty, this is a failure")
                    popup("An error occurred when attempting to produce a new mesh, see Console.", "Error", "ERROR")
                
                else:
                    
                    if mesh_deformer_separate == False:
                        
                        mesh = deformer[0]
                        s = meshutils.split_mesh(mesh=mesh, group_limit=110)
                        
                        if len(s) == 0:
                            print("meshutils::split_mesh reported errors and cannot continue")
                            return {'FINISHED'}
                        else:
                            
                            obj[mesh].select_set(True)
                            bpy.context.view_layer.objects.active = obj[mesh]
                            bpy.ops.object.delete()
                            
                            for m in s:
                                utils.remove_empty_groups(m)
                            for m in s:
                                obj[m].select_set(True)
                            bpy.context.view_layer.objects.active = obj[m]

                selected = [o for o in bpy.context.selected_objects]
                active = bpy.context.active_object
                for o in bpy.context.selected_objects:
                    o.select_set(False)
                proxyObj.select_set(True)
                bpy.context.view_layer.objects.active = proxyObj
                bpy.ops.object.delete()
                for o in selected:
                    o.select_set(True)
                bpy.context.view_layer.objects.active = active

                return {'FINISHED'}

        qualified_mesh = {}
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                
                arm = get_mesh_armature(o.name)
                if arm != False:
                    qualified_mesh[o.name] = arm
                else:
                    print("Skipping mesh:", o.name)
        
        if len(qualified_mesh) == 0:
            print("No qualified mesh were selected")
            popup("There were no qualified mesh in your selection", "Error", "ERROR")
            return {'FINISHED'}

        arms = set()
        for mesh in qualified_mesh:
            arm = qualified_mesh[mesh] 
            arms.add(arm)
        
        if len(arms) > 1:
        
            print("The chosen mesh have passed a preliminary test but those that remain have different armatures")
            popup("Each mesh must have the same armature, check System Console.", "Error", "ERROR")
            return {'FINISHED'}

        print("==========================================================")
        print("The code about to run reads the mesh and excludes all bones")
        print("defined therein.  It then finds the next parent bone of those")
        print("defined in the mesh and walks it to the pelvis to reduce the")
        print("amount of bones contained in the mesh deformer.")
        print("NOTE: This serves no practical function, yet.  Use the armature for deformers")
        print("==========================================================")

        result = meshutils.get_exportable_mesh(objects=selected, report=True)
        if result == False:
            print("get_exportable_mesh returned False, this is an error")
            return {'FINISHED'}
        arm = result['armature']
        mesh = result['mesh']

        if 1 == 0:
            clones = meshutils.clone_mesh(mesh=mesh, new_rig=True)
            new_arm = clones['armature']
            new_mesh = clones['mesh']
            
            for o in bpy.context.selected_objects:
                o.select_set(False)
            for o in clones['mesh']:
                o.select_set(True)
            clones['armature'].select_set(True)
            bpy.context.view_layer.objects.active = clones['armature']

        groups = []
        for mesh in qualified_mesh:
            g = [g.name for g in obj[mesh].vertex_groups]
            groups.extend(g)

        groups = set(groups)

        bone_path = set()

        for bone in groups:
            
            bone_type = skel.avatar_skeleton[bone]['type']
            if bone_type != 'collision' and bone_type != 'bone':
                continue

            next_bone = bone
            while(True):
                parent = skel.avatar_skeleton[next_bone]['parent']
                if parent != "":
                    bone_path.add(parent)
                    next_bone = parent
                
                else:
                    break
        
        bone_path.add('mPelvis')

        sourceObj = rigutils.build_rig(rig_class="pos", rotate=True, )
        
        rigutils.snap_to(source=sourceObj.name, target=arm)

        for o in bpy.context.selected_objects:
            o.select_set(False)

        sourceObj.select_set(True)
        bpy.context.view_layer.objects.active = sourceObj

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in sourceObj.data.edit_bones:
            if boneObj.name not in bone_path:
                sourceObj.data.edit_bones.remove(boneObj)
        bpy.ops.object.mode_set(mode='OBJECT')

        deformer = meshutils.bones_to_mesh(armature=sourceObj.name, target=None, separate=mesh_deformer_separate)

        if deformer == False:
            print("the utility bones_to_mesh returned False, this is a failure")
            popup("An error occurred when attempting to produce a new mesh, see Console.", "Error", "ERROR")
            return {'FINISHED'}

        print("returning early for testing")
        return {'FINISHED'}

        for o in bpy.context.selected_objects:
            o.select_set(False)

        armObj.select_set(True)
        bpy.context.view_layer.objects.active = armObj
        bpy.ops.object.delete()

        for mesh in deformer:
            obj[mesh].select_set(True)
        
        bpy.context.view_layer.objects.active = obj[mesh]

        return {'FINISHED'}

class OnigiriMeshFromArmature(bpy.types.Operator):
    """Create a mesh from an armature, good for a quick animation test or for seeing
how your rig looks in Second Life fully articulated"""

    bl_idname = "onigiri.mesh_from_armature"
    bl_label = "bb_mesh_from_armature"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].type == 'ARMATURE':
                return True
        return False

    def execute(self, context):
        obj = bpy.data.objects
        armObj = bpy.context.selected_objects[0]
        bpy.context.view_layer.objects.active = armObj
        bb_misc = bpy.context.window_manager.bb_misc

        if bb_misc.mesh_from_attachment_bones == True:
            deform_states = {}
            for boneObj in armObj.data.bones:
                bone = boneObj.name
                if bone in skel.avatar_skeleton:
                    if skel.avatar_skeleton[bone]['type'] == 'attachment':
                        deform_states[boneObj.name] = boneObj.use_deform
                        boneObj.use_deform = True

        if bb_misc.mesh_from_mapped_bones == True and armObj.get('bb_onemap_rename') != None:
            rename_map = armObj['bb_onemap_rename'].to_dict()
            utils.activate(armObj)
            bpy.ops.object.duplicate()
            proxyObj = bpy.context.object
            delete = []
            for boneObj in proxyObj.data.bones:
                if boneObj.name not in rename_map:
                    delete.append(boneObj.name)
            bpy.ops.object.mode_set(mode='EDIT')
            for bone in delete:
                boneObj = proxyObj.data.edit_bones[bone]
                proxyObj.data.edit_bones.remove(boneObj)
            bpy.ops.object.mode_set(mode='OBJECT')
            mesh = meshutils.mesh_from_rig(armature=proxyObj.name)
            if mesh != False:
                meshObj = obj[mesh]
                meshObj.select_set(False)
                proxyObj.select_set(True)
                utils.activate(proxyObj)
                bpy.ops.object.delete()
            meshObj.parent = armObj
            for m in meshObj.modifiers:
                if m.type == 'ARMATURE':
                    m.object = armObj
            meshObj.select_set(True)
            utils.activate(meshObj)
        else:
            mesh = meshutils.mesh_from_rig(armature=armObj.name)

        if mesh != False:
            for o in bpy.context.selected_objects:
                o.select_set(False)

            obj[mesh]['onigiri_mesh_rig'] = 1 

            obj[mesh].select_set(True)
            bpy.context.view_layer.objects.active = obj[mesh]

            print("got mesh:", mesh)

            if bb_misc.split_mesh_for_sl == True:
                bpy.ops.onigiri.split_mesh()

        else:
            print("Something went wrong with the mesh creation, the product returne is:", mesh)
            popup("Mesh creation error", mesh, "ERROR")

        if bb_misc.mesh_from_attachment_bones == True:
            for bone in deform_states:
                armObj.data.bones[bone].use_deform = deform_states[bone]

        return {'FINISHED'}

class OnigiriMeshIntegrityCheck(bpy.types.Operator):
    """This checks various things about the skinned mesh and reports back what it found.  There is
always some data to see so open up the System Console and have a look after using this tool.
There will be a simple popup when it finishes"""

    bl_idname = "onigiri.mesh_integrity_check"
    bl_label = "Mesh Itegrity Check"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) > 0:
            for o in bpy.context.selected_objects:
                if o.type == 'MESH':
                    return True
        return False

    def execute(self, context):
        obj = bpy.data.objects
        bbm = bpy.context.window_manager.bb_misc
        
        group_limit = 110
        error_count = 0

        active = bpy.context.active_object
        selected = [a for a in bpy.context.selected_objects]

        if bpy.context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        bad_limit = [] 
        mesh_names = []
        for o in selected:
            if o.type == 'MESH':
                mesh_names.append(o.name)
                if len(o.vertex_groups) > group_limit:
                    error_count += 1
                    bad_limit.append(o.name)
                    print("")
                    print("- Found mesh exceeding vertex group limit -")
                    print("  Mesh  :", o.name)
                    print("  Groups:", len(o.vertex_groups))
                    print("  Limit :", group_limit)
                    print("")
            o.select_set(False)

        arms = list()
        for mesh in [o.name for o in selected]:
            
            status = get_mesh_armature(mesh=mesh)
            if status == False:
                print("Mesh did not pass armature validation test:", mesh)
            if status not in arms:
                arms.append(status)
        if len(arms) > 1:
            print("A collection of mesh associated with various armatures is not supported at this time, the test cannot continue.")
            popup("Multiple armatures associated with selected mesh, the test cannot continue.", "Error", "ERROR")
            return {'FINISHED'}
        if len(arms) == 0:
            print("There are no valid mesh to examine")
            popup("There are no valid mesh to examine", "Error", "ERROR")
            return {'FINISHED'}

        arm = arms[0]
        for mesh in mesh_names:
            
            bad_verts = [] 
            bad_groups = {} 
            bad_amount = [] 

            bpy.ops.object.mode_set(mode = 'EDIT') 
            bpy.ops.mesh.select_mode(type="VERT")
            bpy.ops.mesh.select_all(action = 'DESELECT')
            bpy.ops.object.mode_set(mode = 'OBJECT')

            for v in obj[mesh].data.vertices:
                if len(v.groups) == 0:
                    bad_verts.append(v.index)
                    v.select = True
                elif len(v.groups) > 4:
                    bad_amount.append(v.index)
                for ig in v.groups:
                    vertex_index = v.index
                    vertex_loc = v.co.copy()
                    group_index = ig.group
                    group_name = obj[mesh].vertex_groups[ig.group].name
                    
                    if group_name not in obj[arm].data.bones:
                        bad_groups[group_name] = ""
                    weight = ig.weight

            print("Examining vertex data for:", mesh)
            if len(bad_amount) > 0:
                error_count += 1
                print(
                    "    There were", len(bad_amount),
                    "vertices weighted to more than 4 bones, use the (Limit bone influences) tool to correct it"
                    )
            if len(bad_verts) > 0:
                error_count += 1
                uv = len(bad_verts)
                print("    Unweighted vertices:", uv)
                print("The unweighted vertices have been selected so that you can see them in edit mode")
            if len(bad_groups) > 0:
                error_count += 1
                print("    Unmatched group names, no bone association:", [ a for a in bad_groups ])

        if error_count > 0:
            txt = "    There were " + str(error_count) + " "
            txt += "errors that would prevent your mesh from working properly in Second Life, check console."
        else:
            print("")
            print("    No errors where found")
            txt = "    The integrity check found no errors preventing your mesh from working in Second Life, check console."

        popup(txt, "Info", "INFO")

        for o in selected:
            o.select_set(True)
        bpy.context.view_layer.objects.active = active

        return {'FINISHED'}

class OnigiriSplitMesh(bpy.types.Operator):
    """Split the mesh up into a number of groups compliant with the target system
This can only work with (mesh from rig) objects"""

    bl_idname = "onigiri.split_mesh"
    bl_label = "Split Mesh"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) > 0:
            for o in bpy.context.selected_objects:
                if o.type == 'MESH':
                    return True
        return False

    def execute(self, context):
        obj = bpy.data.objects
        bbm = bpy.context.window_manager.bb_misc
        bb_mesh = bpy.context.scene.bb_mesh
        group_limit = bbm.group_count_limit

        selected = [a for a in bpy.context.selected_objects]

        if bpy.context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')

        mesh_names = list()
        for o in selected:
            if o.type == 'MESH':
                if o.get('onigiri_mesh_rig') == None:
                    print("Skipping foreign mesh, not a mesh from rig:", o.name)
                else:
                    mesh_names.append(o.name)
            o.select_set(False)

        if len(mesh_names) == 0:
            print("None of the selected objects were split candidates")
            popup("None of the mesh qualify, see system console", "Error", "ERROR")
            return {'FINISHED'}

        arms = list()
        for mesh in mesh_names:
            
            status = get_mesh_armature(mesh=mesh)
            if status == False:
                print("A qualified mesh for splitting failed the armature test")
                popup("There was a problem with at least one of your mesh, see console for details.", "Error", "ERROR")
                return {'FINISHED'}
            if status not in arms:
                arms.append(status)

        if len(arms) > 1:
            print("A collection of mesh associated with various armatures is not supported at this time.")
            popup("Only one rig set is supported, multiple armatures were detected", "Error", "ERROR")
            return {'FINISHED'}
        if len(arms) == 0:
            print("There were no qualified armatures in the selected mesh")
            popup("There does not appear to be any usable armature data in the selected mesh", "Error", "ERROR")
            return {'FINISHED'}

        arm = arms[0]

        bad_mesh = [] 
        good_mesh = [] 
        for mesh in mesh_names:
            total_groups = len(obj[mesh].vertex_groups)
            if total_groups > group_limit:
                print("Mesh", mesh, "fails group total test, allotment is", group_limit, "while the existing total is", total_groups)
                if bb_mesh.remove_empty_groups == True:
                    print("Removing empty groups for mesh:", mesh)
                    obj[mesh].select_set(True)
                    bpy.context.view_layer.objects.active = bpy.data.objects[mesh]
                    utils.remove_empty_groups(mesh)
                    total_groups = len(obj[mesh].vertex_groups)
                    if total_groups > group_limit:
                        print("Repair failed, there are", total_groups, "groups remaining.  The mesh", mesh, "will be split")
                        bad_mesh.append(mesh)
                    else:
                        good_mesh.append(mesh)
                    obj[mesh].select_set(False)

        if len(bad_mesh) == 0:
            for mesh in mesh_names:
                obj[mesh].select_set(True)
                if len(mesh_names) != 0:
                    utils.activate(obj[mesh_names[0]])
            print("There were no mesh in your selection with vertex groups exceeding the limit or they were repaired and need no processing")
            return {'FINISHED'}

        for mesh in bad_mesh:
            
            result = meshutils.mesh_integrity_check(mesh=mesh, armature=arm)
            if len(result) > 0:
                print("Mesh integrity check failed, the mesh", mesh, "cannot be processed.")
                print("If this is a multi part selection you can exclude this mesh from the selection and try again")
                print("If this mesh is needed then use the error report above to clean up the mesh before trying again")
                for r in result:
                    print("  - " + r + ":" + result[r])
                popup("Fatal mesh integrity test error, see system console for details", "Error", "ERROR")
                return {'FINISHED'}
            print("Examined mesh:", mesh)
        
        finished_mesh = []
        for mesh in bad_mesh:
            
            s = meshutils.split_mesh(mesh=mesh, group_limit=group_limit)
            
            if len(s) == 0:
                print("split_mesh reported errors and cannot continue")
                return {'FINISHED'}
            finished_mesh.extend(s)

        for o in bpy.context.selected_objects:
            o.select_set(False)
        for mesh in finished_mesh:
            utils.remove_empty_groups(mesh)
            total_groups = len(obj[mesh].vertex_groups)
            if total_groups > group_limit:
                print("The offending mesh were processed correctly, it would seem, but the group limit issue was not corrected.")
                print("After attempting to remove the resulting empty groups that were expected a sanity check discovered an issue")
                print("with the following mesh:", mesh, "and aborted the process.  The total was", total_groups, "which is")
                print("unexpected and should never happen.  The expected total should have been at or below", group_limit)
                print("The objects have been left in the scene for examination.  The following is a list of returned objects:")
                print(finished_mesh)
                popup("Unexpected results from properly processed mesh, group limit still exceeded, see system console")
                return {'FINISHED'}

        for o in bpy.context.selected_objects:
            o.select_set(False)

        if bbm.split_mesh_keep_originals == False:
            for mesh in bad_mesh:
                obj[mesh].select_set(True)
            bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]
            bpy.ops.object.delete()
            
        for mesh in good_mesh:
            obj[mesh].select_set(True)
        for mesh in finished_mesh:
            obj[mesh].select_set(True)
        
        bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]

        return {'FINISHED'}

class OnigiriRefitDuplicate(bpy.types.Operator):
    """Reshape and resize your item to fit your other avatar shapes"""

    bl_idname = "onigiri.refit_duplicate"
    bl_label = "bb_reshape_duplicates"

    def execute(self, context):
        
        obj = bpy.data.objects
        bbm = bpy.context.window_manager.bb_misc

        if bbm.refit_garment_source_name not in obj:
            bbm.refit_message = "Error: Missing garment source"
            
            return {'FINISHED'}
        if bbm.refit_avatar_source_name not in obj:
            bbm.refit_message = "Error: Missing avatar source"
            
            return {'FINISHED'}

        vcount = len(obj[bbm.refit_avatar_source_name].data.vertices)

        for o in bbm['refit_targets']:
            if o not in obj:
                bbm.refit_message = "Error: Missing target - " + o
                print("Missing avatar target", o)
                
                return {'FINISHED'}
            if vcount != len(obj[o].data.vertices):
                bbm.refit_message = "Error: wrong vertex count - " + o
                print("Wrong vertex count when comparing avatar source to target:", o)
                
                return {'FINISHED'}

        garment = bbm.refit_garment_source_name
        avatar = bbm.refit_avatar_source_name

        if bpy.context.active_object != None:
            bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')

        obj[garment]['refit_name'] = garment
        obj[avatar]['refit_name'] = avatar

        for target in bbm['refit_targets']:
            
            if obj[garment].parent != None:
                gp = obj[garment].parent
                gp_hide_select = gp.hide_select 
                gp_hide_set = gp.hide_get()
                gp.hide_select = False
                gp.hide_set(False)
                gp.select_set(True)
            if obj[avatar].parent != None:
                ap = obj[avatar].parent
                ap_hide_select = ap.hide_select 
                ap_hide_set = ap.hide_get()
                ap.hide_select = False
                ap.hide_set(False)
                ap.select_set(True)

            obj[garment].select_set(True)
            obj[avatar].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects[garment]
            bpy.ops.object.duplicate()

            if obj[garment].parent != None:
                gp.hide_select = gp_hide_select
                gp.hide_set(gp_hide_set)
            if obj[avatar].parent != None:
                ap.hide_select = ap_hide_select
                ap.hide_set(ap_hide_set)

            for o in bpy.context.selected_objects:
                if o.get('refit_name') == None:
                    print("skipping object, no refit_name:", o.name)
                    continue
                if o['refit_name'] == garment:
                    o.name = garment + "_for_" + avatar
                    garment_new = o.name
                elif o['refit_name'] == avatar:
                    avatar_new = o.name

            for o in bpy.context.selected_objects:
                o.select_set(False)

            if obj[garment_new].parent != None:
                p = obj[garment_new].parent
                p.select_set(True)
                bpy.context.view_layer.objects.active = p
                bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)
                p.select_set(False)
                
                obj[garment_new].select_set(True)
                bpy.context.view_layer.objects.active = obj[garment_new]
                bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)
                obj[garment_new].select_set(False)
                p.select_set(True)
                
                bpy.ops.object.delete()
            if obj[avatar_new].parent != None:
                p = obj[avatar_new].parent
                p.select_set(True)
                bpy.context.view_layer.objects.active = p
                bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)
                p.select_set(False)
                
                obj[avatar_new].select_set(True)
                bpy.context.view_layer.objects.active = obj[avatar_new]
                bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)
                obj[avatar_new].select_set(False)
                p.select_set(True)
                
                bpy.ops.object.delete()

            obj[garment_new].select_set(True)
            bpy.context.view_layer.objects.active = obj[garment_new]
            bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)
            obj[garment_new].select_set(False)

            obj[avatar_new].select_set(True)
            bpy.context.view_layer.objects.active = obj[avatar_new]
            bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)
            obj[avatar_new].select_set(False)

            for o in bpy.context.selected_objects:
                o.select_set(False)
            obj[garment_new].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects[garment_new]

            for m in obj[garment_new].modifiers:
                
                if 1 == 1:
                    try:
                        print("Attempting to apply modifiers...")
                        bpy.ops.object.modifier_apply(apply_as='DATA', modifier=m.name)
                    except:
                        print("failed, attempting alternative for Blender 2.9")
                        try:
                            bpy.ops.object.modifier_apply(modifier=m.name)
                            print("Success for Blender 2.9")
                        except:
                            print("Internal Error 507 - Blender 2.9 alternative didn't work, this should not happen")
                            popup("Internal Error 507, contact support with the contents of the console window", "Fatal Error", "ERROR")
                            print("modifier error, removing:", m.name)
                            obj[garment_new].modifiers.remove(m)

                else:
                    print("Attempting to apply modifiers...")
                    bpy.ops.object.modifier_apply(apply_as='DATA', modifier=m.name)
                    
            print("If you're seeing this and your refit failed try adding a (Triangulate) modifier to")
            print("all of your wrap objects, NOT the garment.")

            sd_mod = obj[garment_new].modifiers.new(name="SD", type='SURFACE_DEFORM')

            obj[garment_new].modifiers[sd_mod.name].target = obj[avatar_new]
            obj[garment_new].modifiers[sd_mod.name].falloff = bbm.refit_falloff

            bpy.ops.object.surfacedeform_bind(modifier=sd_mod.name)

            print("If there is an error above about (Target contains concave polygons) then follow instructions")
            print("in the text prior to it.")

            s_mw = obj[avatar_new].matrix_world
            
            t_mw_i = obj[target].matrix_world.inverted().copy()
            
            t_mw = obj[target].matrix_world.copy()
            s_mw = obj[avatar_new].matrix_world.copy()
            s_mw_i = obj[avatar_new].matrix_world.inverted().copy()
            
            s_loc, s_rot, s_sca = obj[avatar_new].matrix_world.decompose()
            
            sverts = { obj[avatar].data.vertices[i].index: obj[avatar].data.vertices[i].co for i in range(vcount) }

            tverts = { obj[target].data.vertices[i].index: obj[target].data.vertices[i].co for i in range(vcount) }

            obj[garment_new].select_set(False)
            obj[avatar_new].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects[avatar_new]
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_all(action='DESELECT')

            bpy.context.tool_settings.mesh_select_mode = (True, False, False)

            me = obj[avatar_new].data
            bm = bmesh.from_edit_mesh(me)
            verts = bm.verts

            bm.verts.ensure_lookup_table()
            
            for v in verts:
                i = v.index
                
                v.co = t_mw @ tverts[i] @ s_mw_i

            bpy.ops.object.mode_set(mode='OBJECT')

            if bbm.refit_assume_pose == True:
                
                source_arm_mod = get_mesh_armature_modifier(mesh=avatar_new)
                target_arm_mod = get_mesh_armature_modifier(mesh=target)
                target_arm = get_mesh_armature(mesh=target)

                if source_arm_mod != False and target_arm_mod != False and target_arm != False:
                    
                    vgroups = obj[avatar_new].vertex_groups.keys()
                    
                    error = 0
                    for vg in vgroups:
                        if vg not in obj[target].vertex_groups.keys():
                            print("Missing vertex group in target, skipping pose!")
                            error = 1
                            break
                    
                    if error == 0:
                        mod = obj[avatar_new].modifiers[source_arm_mod].object = obj[target_arm]

            obj[avatar_new].select_set(False)
            obj[garment_new].select_set(True)
            bpy.context.view_layer.objects.active = bpy.data.objects[garment_new]

            try:
                print("Attempting to apply modifiers...")
                bpy.ops.object.modifier_apply(apply_as='DATA', modifier=sd_mod.name)
            except:
                print("failed, attempting alternative for Blender 2.9")
                try:
                    bpy.ops.object.modifier_apply(modifier=sd_mod.name)
                    print("Success for Blender 2.9")
                except:
                    print("Internal Error 508 - Blender 2.9 alternative didn't work, this should not happen")
                    popup("Internal Error 508, contact support with the contents of the console window", "Fatal Error", "ERROR")

            obj[garment_new].select_set(False)

            obj[avatar_new].select_set(True)

            bpy.ops.object.delete()

        return {'FINISHED'}

class OnigiriRefitReset(bpy.types.Operator):
    """Disable locks and reset the properties fresh"""

    bl_idname = "onigiri.refit_reset"
    bl_label = "bb_refit_reset"

    def execute(self, context):
        obj = bpy.data.objects
        bbm = bpy.context.window_manager.bb_misc

        bbm.refit_lock_avatar_targets = False
        bbm.refit_lock_avatar_source = False
        bbm.refit_lock_garment_source = False
        bbm.refit_message = "[Look here for messages]"
        return {'FINISHED'}

class OnigiriPanelMeshExport(bpy.types.Panel):
    """Mesh Export"""

    bl_idname = "OBJECT_PT_bento_buddy_mesh_export"
    bl_label = "Mesh Export"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        bb_devkit = bpy.context.scene.bb_devkit
        bb = bpy.context.scene.onigiri
        row = self.layout.row(align=True)

        devkit_poll_state = bb_devkit.devkit_poll

        if bb_devkit.export_menu_enabled == True:
            export_menu_enabled_icon = "menu_opened"
        else:
            export_menu_enabled_icon = "menu_closed"

        row = self.layout.row(align=True)
        row.operator(
            "onigiri.collada_export",
            text="Export Mesh For SL / OpenSim",
            icon_value = ico.custom_icons["export_mesh"].icon_id
            )

        row = self.layout.row(align=True)
        row.prop(
            bb_devkit,
            "export_menu_enabled",
            toggle = True,
            text="Expand rig and kit Options",
            icon_value = ico.custom_icons[export_menu_enabled_icon].icon_id
            )

        if bb_devkit.export_menu_enabled == True:

            layout = self.layout
            box = layout.box()

            col = box.column(align = True)
            row = col.row(align=True)

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb,
                "devkit_run_code",
                toggle = True,
                text="",
                icon_value = ico.custom_icons["script"].icon_id
                )
            row.operator(
                "onigiri.devkit_preset_load",
                text="Load Preset",

                )
            row.operator(
                "onigiri.devkit_preset_save",
                text="Save Preset",
                icon_value = ico.custom_icons["save"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.devkit_preset_save_defaults",
                text="Save Defaults",
                icon_value = ico.custom_icons["sliders"].icon_id
                )
            row.operator(
                "onigiri.devkit_reset_all",
                text="Reset All",
                icon_value = ico.custom_icons["nuke"].icon_id
                )
            
            devkit_state_text = " "
            devkit_state_icon = "code_disabled"
            
            armObj = utils.has_armature()
            if armObj != False:
                devkit_state = armObj.get('bb_collada_unsaved')
                if devkit_state != None:
                    devkit_state_text = "Unsaved Devkit!"
                    devkit_state_icon = "code"
                elif armObj.get('bb_collada_matrices') != None:
                    devkit_state_text = "Preset Ready!"
                    devkit_state_icon = "code"
            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "devkit_state",
                toggle = True,
                text=devkit_state_text,
                icon_value = ico.custom_icons[devkit_state_icon].icon_id
                )
            row.operator(
                "onigiri.collada_data_remove",
                text="",
                icon_value = ico.custom_icons["x_red"].icon_id
                )
            row = col.row(align=True)
            devkit_preset_name = devkit.props['preset_name']
            if devkit_preset_name == "":
                devkit_preset_name = "Vincent (TM)"
            else:
                devkit_preset_name = " Last Preset: " + devkit_preset_name
            row.prop(
                bb_devkit,
                "blank",
                toggle = True,
                text= devkit_preset_name,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "rotate_for_sl",
                toggle = True,
                text="Rotate For SL",
                icon_value = ico.custom_icons["rotate"].icon_id
                )

            row.prop(
                bb_devkit,
                "normalize_bones",
                toggle = True,
                text="Normalize bones",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            
            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "export_real_shape",
                toggle = True,
                text="Export Real Shape",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            
            row.prop(
                bb_devkit,
                "export_normalized_weights",
                toggle = True,
                text="Normalize Weights",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row = col.row(align=True)

            row.prop(
                bb_devkit,
                "preserve_empty_counterparts",
                toggle = True,
                text="",
                icon_value = ico.custom_icons["symmetric"].icon_id
                )
            row.prop(
                bb_devkit,
                "remove_empty_groups",
                toggle = True,
                text="Remove Empty Groups",
                icon_value = ico.custom_icons["blank"].icon_id
                )

            row.prop(
                bb_devkit,
                "export_copies",
                toggle = True,
                text="",
                icon_value = ico.custom_icons["copy"].icon_id
                )
            row.prop(
                bb_devkit,
                "export_copies",
                toggle = True,
                text="Export Copies",
                )

            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "apply_rig_scale",
                toggle = True,
                text="Apply Rig Scale",
                icon_value = ico.custom_icons["scale"].icon_id
                )
            row.prop(
                bb_devkit,
                "use_bind_pose",
                toggle = True,
                text="Use Bind Pose",
                icon_value = ico.custom_icons["blank"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "export_path_to_pelvis",
                toggle = True,
                text="Export Path To Pelvis",
                icon_value = ico.custom_icons["anchor"].icon_id
                )

            row.prop(
                bb_devkit,
                "export_full_rig",
                toggle = True,
                text="Export Full Rig",
                icon_value = ico.custom_icons["full"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "export_joints",
                toggle = True,
                text="Export Joints",
                icon_value = ico.custom_icons["joint"].icon_id
                )
            row.prop(
                bb_devkit,
                "project_rig",
                toggle = True,
                text="Project full rig",
                icon_value = ico.custom_icons["project"].icon_id
                )

            if 1 == 0:
                row = col.row(align=True)
                row.prop(
                    bb_devkit,
                    "process_attachment_bones",
                    toggle = True,
                    text="Use Attach Points",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                unsupported_enabled_icon = "blank"
                if bb_devkit.process_attachment_bones == True and bb_devkit.process_unsupported_bones == True:
                    unsupported_enabled_icon = "dot_green"
                elif bb_devkit.process_attachment_bones == True and bb_devkit.process_unsupported_bones == False:
                    unsupported_enabled_icon = "dot_yellow"
                elif bb_devkit.process_attachment_bones == False:
                    unsupported_enabled_icon = "dot_red"
                row.prop(
                    bb_devkit,
                    "process_unsupported_bones",
                    toggle = True,
                    text="Use Unsupported Points",
                    icon_value = ico.custom_icons[unsupported_enabled_icon].icon_id
                    )
                row = col.row(align=True)

            if 1 == 0:
                row = col.row(align=True)
                row.prop(
                    bb_devkit,
                    "export_blank",
                    toggle = True,
                    text="Apply custom bind data",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row = col.row(align=True)
                row.prop(
                    bb_devkit,
                    "use_offset_location",
                    toggle = True,
                    text="Position",
                    icon_value = ico.custom_icons["location"].icon_id
                    )
                row.prop(
                    bb_devkit,
                    "use_offset_rotation",
                    toggle = True,
                    text="Rotation",
                    icon_value = ico.custom_icons["rotation"].icon_id
                    )
                row.prop(
                    bb_devkit,
                    "use_offset_scale",
                    toggle = True,
                    text="Scale",
                    icon_value = ico.custom_icons["scale"].icon_id
                    )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "export_blank",
                toggle = True,
                text="Apply transforms on export",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "apply_location",
                toggle = True,
                text="Location",
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            row.prop(
                bb_devkit,
                "apply_rotation",
                toggle = True,
                text="Rotation",
                icon_value = ico.custom_icons["dot_yellow"].icon_id
                )
            row.prop(
                bb_devkit,
                "apply_scale",
                toggle = True,
                text="Scale",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "export_blank",
                toggle = True,
                text="Joint and Bind data source",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "use_rig_data",
                toggle = True,
                text="Use Rig Data",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bb_devkit,
                "use_bind_data",
                toggle = True,
                text="Use Bind Data",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            
            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "use_app_compatible_data",
                toggle = True,
                text="Use App Data",
                icon_value = ico.custom_icons["code"].icon_id
                )
            row.prop(
                bb_devkit,
                "use_sl_compatible_data",
                toggle = True,
                text="Use SL Data",
                icon_value = ico.custom_icons["sl"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "export_blank",
                toggle = True,
                text="Rig Classes",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bb_devkit,
                "rig_class_default",
                toggle = True,
                text="Default",
                )
            row.prop(
                bb_devkit,
                "rig_class_neutral",
                toggle = True,
                text="Neutral",
                )
            row.prop(
                bb_devkit,
                "rig_class_male_default",
                toggle = True,
                text="Default (M)",
                )
            row.prop(
                bb_devkit,
                "rig_class_male_neutral",
                toggle = True,
                text="Neutral (M)",
                )

            if bb_devkit.export_advanced == True:
                export_advanced_icon = "menu_opened"
            else:
                export_advanced_icon = "menu_closed"
            row = self.layout.row(align=True)
            row.prop(
                bb_devkit,
                "export_advanced",
                toggle = True,
                text="Advanced Export Options",
                icon_value = ico.custom_icons[export_advanced_icon].icon_id
                )
            row.operator(
                "onigiri.devkit_reset_collada",
                text="",
                icon_value = ico.custom_icons["reset"].icon_id
                )

            if bb_devkit.export_advanced == True:
                for export_option in bb_settings['dae_export_options']:
                    
                    row = self.layout.row(align=True)
                    row.prop(
                        bb_devkit,
                        export_option,
                        toggle = True,
                        text = bb_settings['dae_export_options'][export_option],
                        )
        
        bb_snap = bpy.context.window_manager.bb_snap
        layout = self.layout
        box = layout.box()
        col = box.column(align = True)

        row = col.row(align=True)
        row.label(
            text = "For mapped mesh only: ",
            )
        row = col.row(align=True)
        row.operator(
            "onigiri.snap_apply_map",
            text="Load Map",
            icon_value = ico.custom_icons["load"].icon_id
            )
        row.operator(
            "onigiri.snap_destroy",
            text="",
            icon_value = ico.custom_icons["x_red"].icon_id
            )
        snap_has_map_text = "No map present "
        snap_has_map_icon = "bone_black"
        selected = bpy.context.selected_objects
        if len(selected) > 0:
            for snap_selected in  selected:
                if snap_selected.type == 'MESH':
                    snap_has_armature = utils.has_armature(object=snap_selected)
                    if snap_has_armature != False:
                        if snap_has_armature.get('bb_onemap_rename') != None:
                            snap_has_map_text = "Associated rig has a map"
                            snap_has_map_icon = "bone_black_red"
                            break
        row = col.row(align=True)
        row.prop(
            bb_snap,
            "snap_blank",
            toggle = True,
            text = snap_has_map_text,
            icon_value = ico.custom_icons[snap_has_map_icon].icon_id
            )
        row = col.row(align=True)
        row.prop(
            bb_snap,
            "snap_export_mapped_old",
            toggle = True,
            text = "",
            icon_value = ico.custom_icons["export_mesh"].icon_id
            )

        row.operator(
            "onigiri.snap_export_mesh",
            text="Export Mapped Mesh",
            icon_value = ico.custom_icons["blank"].icon_id
            )
        
class OnigiriPanelMeshTools(bpy.types.Panel):
    """Mesh Tools"""
    bl_idname = "OBJECT_PT_bento_buddy_mesh_tools"
    bl_label = "Mesh Tools"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        bbm = bpy.context.window_manager.bb_misc
        bb_mesh = bpy.context.scene.bb_mesh

        layout = self.layout

        bb = bpy.context.scene.onigiri

        box = layout.box()
        col = box.column(align = True)

        row = col.row(align=True)
        all_selected = bpy.context.selected_objects
        mesh_selected = []
        for o in all_selected:
            if o.type == 'MESH':
                mesh_selected.append(o)
        if len(mesh_selected) == 0:
            row.label(
                text = "- No mesh selected -",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )
        else:
            
            row.prop(
                bb,
                "blank",
                text = "Total Mesh Selected: " + str(len(mesh_selected)),
                toggle = True,
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            for o in mesh_selected:

                row = col.row(align=True)

                ms_name = o.name
                ms_verts = str(len(o.data.vertices))
                ms_tris = str(sum([(len(p.vertices) - 2) for p in o.data.polygons]))
                ms_faces = str(len(o.material_slots))
                ms_polys = str(len(o.data.polygons))
                row.prop(
                    bb,
                    "blank",
                    text = "- " + ms_name + " -",
                    toggle = True,
                    icon_value = ico.custom_icons["dot_red"].icon_id
                    )
                row = col.row(align=True)
                row.prop(
                    bb,
                    "blank",
                    text = "Vertices: " + ms_verts,
                    toggle = True,
                    icon_value = ico.custom_icons["dot_white"].icon_id
                    )
                row.prop(
                    bb,
                    "blank",
                    text = "Trianges: " + ms_tris,
                    toggle = True,
                    icon_value = ico.custom_icons["dot_white"].icon_id
                    )
                row = col.row(align=True)
                row.prop(
                    bb,
                    "blank",
                    text = "Faces / Mats: " + ms_faces,
                    toggle = True,
                    icon_value = ico.custom_icons["dot_white"].icon_id
                    )
                row.prop(
                    bb,
                    "blank",
                    text = "Polygons: " + ms_polys,
                    toggle = True,
                    icon_value = ico.custom_icons["dot_white"].icon_id
                    )

        box = layout.box()
        col = box.column(align = True)

        row = col.row(align=True)
        row.prop(
            bbm,
            "split_mesh_keep_originals",
            text="",
            toggle = True,
            icon_value = ico.custom_icons["split"].icon_id
            )
        row.operator(
            "onigiri.split_mesh",
            text="Split Mesh To Groups",
            )
        row.scale_x = 0.25
        row.prop(
            bbm,
            "group_count_limit",
            text="",
            toggle = True,
            )
        row.scale_x = 1
        row.prop(
            bbm,
            "to_full_rig",
            text="",
            toggle = True,
            icon_value = ico.custom_icons["sliders"].icon_id
            )
        row.prop(
            bbm,
            "from_default_class",
            text="",
            toggle = True,
            icon_value = ico.custom_icons["default"].icon_id
            )

        col = box.column(align = True)
        row = col.row(align=True)
        row.operator(
            "onigiri.mesh_from_armature",
            text="Create mesh from armature",
            icon_value = ico.custom_icons["rig_to_mesh"].icon_id
            )
        row.prop(
            bbm,
            "mesh_from_attachment_bones",
            text="",
            toggle = True,
            icon_value = ico.custom_icons["bone_mixed"].icon_id
            )
        row = col.row(align=True)
        row.operator(
            "onigiri.mesh_from_bones",
            text="Create mesh from bones",
            icon_value = ico.custom_icons["bones_to_mesh"].icon_id
            )
        row = col.row(align=True)
        row.prop(
            bbm,
            "mesh_from_mapped_bones",
            text="From Mapped Bones Only",
            toggle = True,
            icon_value = ico.custom_icons["map"].icon_id
            )
        row = col.row(align=True)
        row.prop(
            bbm,
            "split_mesh_for_sl",
            text="Split Mesh to SL Segments",
            toggle = True,
            icon_value = ico.custom_icons["split"].icon_id
            )
        row = col.row(align=True)
        row.prop(
            bbm,
            "mesh_to_middle",
            text="Generate mesh between head/tail",
            toggle = True,
            icon_value = ico.custom_icons["center"].icon_id
            )

        col = box.column(align = True)
        row = col.row(align=True)
        row.operator(
            "onigiri.create_mesh_deformer",
            text="Create Mesh Deformer",
            icon_value = ico.custom_icons["undeform"].icon_id
            )
        row.prop(
            bbm,
            "mesh_deformer_separate",
            text="",
            toggle = True,
            icon_value = ico.custom_icons["cut"].icon_id
            )

        col = box.column(align = True)
        row = col.row(align=True)
        row.operator(
            "onigiri.mesh_integrity_check",
            text="Mesh Integrity Check",
            icon_value = ico.custom_icons["mesh"].icon_id
            )

        row = self.layout.row(align=True)
        edit_mesh_menu_enabled_icon = "menu_closed"
        if bb_mesh.edit_mesh_menu_enabled == True:
            edit_mesh_menu_enabled_icon = "menu_opened"
        row.prop(
            bb_mesh,
            "edit_mesh_menu_enabled",
            text="Edit Mesh",
            icon_value = ico.custom_icons[edit_mesh_menu_enabled_icon].icon_id
            )
        if bb_mesh.edit_mesh_menu_enabled == True:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)
            row.label(
                text="Normals:",
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.smooth_normals",
                text="Smooth normals",
                icon_value = ico.custom_icons["smooth"].icon_id
              )
            row.prop(
                bb_mesh,
                "smooth_normals_selected",
                text="",
                toggle=True,
                icon_value = ico.custom_icons["selection"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bb_mesh,
                "smooth_normals_simple",
                text="Simple",
                toggle=True,
                )
            row.prop(
                bb_mesh,
                "smooth_normals_advanced",
                text="Advanced",
                toggle=True,
                )
            row.scale_x = 0.25
            row.prop(
                bb_mesh,
                "smooth_normals_precision",
                text="",
                )
            row.scale_x = 1
            row = col.row(align=True)

            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)
            row.label(
                text="Mesh Ops:",
                )

            if 1 == 0:
                row = col.row(align=True)
                row.operator(
                    "onigiri.mesh_freeze",
                    text="Freeze Mesh",
                  )

            row = col.row(align=True)
            row.operator(
                "onigiri.mesh_edit",
                text="Smooth UVW Edges",
              ).action = "uvw"

            row = col.row(align=True)
            row.operator(
                "onigiri.mesh_edit",
                text="Fix Split Vertices",
              ).action = "doubles"
            row = col.row(align=True)
            row.operator(
                "onigiri.mesh_edit",
                text="Smooth Mesh",
              ).action = "smooth"
            row = col.row(align=True)
            row.operator(
                "onigiri.mesh_edit_collapse_shape",
                text="Collapse Shape to Current",
              )

        row = self.layout.row(align=True)
        row.prop(
            bbm,
            "refit_enabled",
            text="Enable Mesh Refit",
            icon_value = ico.custom_icons["reshape"].icon_id
            )
        
        if bbm.refit_enabled == True:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)

            row.label(
                text = bbm.refit_message,
                icon = "INFO"
                )

            row = col.row(align=True)
            row.operator(
                "onigiri.refit_reset",
                text="Reset refitter",
               )
            row = col.row(align=True)
            row.prop(
                bbm,
                "refit_lock_garment_source",
                text="Lock Garment Source",
                toggle = True,
                )
            row.prop(
                bbm,
                "refit_garment_source_name",
                text="",
                icon_value = ico.custom_icons["dot_white"].icon_id
                )
            if bbm.refit_lock_garment_source == True:
                row = col.row(align=True)
                row.prop(
                    bbm,
                    "refit_lock_avatar_source",
                    text="Lock Wrap Object",
                    toggle = True,
                    )
                row.prop(
                    bbm,
                    "refit_avatar_source_name",
                    text="",
                    icon_value = ico.custom_icons["dot_yellow"].icon_id
                    )
            row = col.row(align=True)
            if bbm.refit_lock_avatar_source == True:
                row.prop(
                    bbm,
                    "refit_lock_avatar_targets",
                    text="Lock Targets",
                    toggle = True,
                    )
                
                if bbm.get('refit_targets') == None or bbm.get('refit_targets') == 0:
                    row.prop(
                        bbm,
                        "refit_avatar_target_name",
                        text=""
                        )
                    for m in bpy.context.selected_objects:
                        if m.type == 'MESH':
                            
                            vc = "" 
                            if m.name == bbm.refit_garment_source_name:
                                    alert_icon = "dot_white"
                            elif m.name == bbm.refit_avatar_source_name:
                                    alert_icon = "dot_yellow"
                                    vc = " - v:" + str(len(bpy.data.objects[bbm.refit_avatar_source_name].data.vertices))
                            elif len(m.data.vertices) != len(bpy.data.objects[bbm.refit_avatar_source_name].data.vertices):
                                    alert_icon = "dot_red"
                                    vc = " - v:" + str(len(m.data.vertices))
                            else:
                                alert_icon = "dot_green"
                                vc = " - v:" + str(len(m.data.vertices))
                            row = self.layout.row(align=True)
                            row.label(
                                text = m.name + vc,
                                icon_value = ico.custom_icons[alert_icon].icon_id
                                )

                else:
                    row.label(
                        text = str(len(bbm['refit_targets']))
                        )
                    row = col.row(align=True)
                    row.prop(
                        bbm,
                        "refit_falloff",
                        text="Falloff:",
                        )
                    row = col.row(align=True)
                    row.prop(
                        bbm,
                        "refit_assume_pose",
                        text="",
                        toggle = True,
                        icon_value = ico.custom_icons["assume_pose"].icon_id
                        )
                    row.operator(
                        "onigiri.refit_duplicate",
                        text="Copy and refit",
                       )

class OnigiriSkinningPanel(bpy.types.Panel):
    """Skinning"""
    bl_idname = "OBJECT_PT_bento_buddy_skinning"
    bl_label = "Skinning / Weights"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        bb_skin = bpy.context.window_manager.bb_skin

        layout = self.layout
        box = layout.box()
        col = box.column(align = True)

        row = col.row(align=True)
        skin_attachment_bones_icon = "dot_red"
        armObj = rigutils.is_armature()
        if armObj != False:
            skin_attachment_bones = armObj.get('bb_skin_attachments', False)
            if skin_attachment_bones == True:
                skin_attachment_bones_icon = "dot_green"
        row.operator(
            "onigiri.skin_attachment_bones",
            text="Skin to Attachments - on / off",
            icon_value = ico.custom_icons[skin_attachment_bones_icon].icon_id
           )
        
        layout = self.layout
        box = layout.box()
        col = box.column(align = True)

        row = col.row(align=True)
        row.label(
            text = "Quick Skinning:",
            )
        row = col.row(align=True)
        row.label(
            text = bb_skin.skin_message,
            icon = "INFO"
            )
        row = col.row(align=True)
        row.prop(
            bb_skin,
            "skin_lock_garment",
            text="Lock Mesh(s)",
            toggle = True
            )

        if bb_skin.skin_count > 1:
            row.label(
                text = str(bb_skin.skin_count),
                )
        else:
            row.prop(
                bb_skin,
                "skin_garment_name",
                text="",
                )
        
        if 1 == 1:
            row = col.row(align=True)
            row.enabled = bb_skin.skin_lock_garment
            row.prop(
                bb_skin,
                "skin_lock_avatar",
                text="Lock Weight Sources",
                toggle = True
                )
            if bb_skin.source_count > 1:
                row.label(
                    text = str(bb_skin.source_count)
                )
            else:
                row.prop(
                    bb_skin,
                    "skin_avatar_name",
                    text="",
                    )
            
            if 1 == 1:
                row = col.row(align=True)

                row.prop(
                    bb_skin,
                    "skin_reskin",
                    text="Reskin",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )

                row.prop(
                    bb_skin,
                    "skin_pose_mode",
                    text="Pose Mode",
                    icon_value = ico.custom_icons["apply_pose"].icon_id
                    )
                row.prop(
                    bb_skin,
                    "skin_keep_proxy",
                    text="Keep Proxy",
                    icon_value = ico.custom_icons["proxy"].icon_id
                    )
                row.prop(
                    bb_skin,
                    "skin_use_skin_pose",
                    text="Skin Pose",
                    icon_value = ico.custom_icons["walking_red"].icon_id
                    )

                col = box.column(align = True)
                row = col.row(align=True)
                row.prop(
                    bb_skin,
                    "use_object_transform",
                    text="Object Transform",
                    toggle=True
                )
                row.prop(
                    bb_skin,
                    "use_auto_transform",
                    text="Auto Transform",
                    toggle=True
                )
                row.prop(
                    bb_skin,
                    "use_max_distance",
                    text="Auto Distance",
                    toggle=True
                )

                row = col.row(align=True)
                row.prop(
                    bb_skin,
                    "max_distance",
                    text="Distance",
                )
                row.prop(
                    bb_skin,
                    "mix_factor",
                    text="Mix Factor"
                )

                col = box.column(align = True)
                row = col.row(align=True)
                row.operator(
                    "onigiri.transfer_weights",
                    text="Transfer Weights",
                   ).action = "transfer"

                row = col.row(align=True)
                row.operator(
                    "onigiri.transfer_weights",
                    text="Parent Object Only",
                   ).action = "parent_object"
                row = col.row(align=True)
                row.operator(
                    "onigiri.transfer_weights",
                    text="Parent Armature Only",
                   ).action = "parent_armature"

                if bb_skin.source_count > 1:
                    
                    for skin_source in bb_skin['skin_sources']:
                        row = col.row(align=True)
                        row.operator(
                            "onigiri.remove_skin_source",
                            text="",
                            icon_value = ico.custom_icons["x_black"].icon_id
                            ).source=skin_source
                        row.label(
                            text = skin_source,
                            )

        row = self.layout.row(align=True)
        skin_pose_menu_enabled_icon = "menu_closed"
        if bb_skin.skin_pose_menu_enabled == True:
            skin_pose_menu_enabled_icon = "menu_opened"
        row.prop(
            bb_skin,
            "skin_pose_menu_enabled",
            text="Skin Pose",
            toggle = True,
            icon_value = ico.custom_icons[skin_pose_menu_enabled_icon].icon_id
            )

        if bb_skin.skin_pose_menu_enabled == True:
            bb_skin = bpy.context.window_manager.bb_skin
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            skin_pose_export_text = "Export"
            skin_pose_import_text = "Import"
            if bb_skin.skin_pose_export_wait == True:
                skin_pose_export_text = "Exporting ..."
            if bb_skin.skin_pose_import_wait == True:
                skin_pose_import_text = "Importing ..."

            row = col.row(align=True)
        
            if bb_skin.skin_pose_lock_sources == False:
                row.operator(
                    "onigiri.skin_pose_lock_sources",
                    text="Record Weight Sources",
                   )
            else:
                row.prop(
                    bb_skin,
                    "skin_pose_lock_sources",
                    text="Sources Recorded",
                    toggle = True
                )
            if bb_skin.skin_pose_lock_targets == False:
                row.operator(
                    "onigiri.skin_pose_lock_targets",
                    text="Record Target Garments",
                   )
            else:
                row.prop(
                    bb_skin,
                    "skin_pose_lock_targets",
                    text="Targets Recorded",
                    toggle = True
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.skin_pose_transfer",
                text="Transfer",
                icon_value = ico.custom_icons["transfer"].icon_id
               )
            row.prop(
                bb_skin,
                "skin_pose_clean_proxy",
                text="Clean Proxy",
                toggle = True,
                icon_value = ico.custom_icons["clean"].icon_id
            )
            row = col.row(align=True)
            row.operator(
                "onigiri.skin_pose_restore",
                text="Restore",
                icon_value = ico.custom_icons["reset"].icon_id
               )
            row = col.row(align=True)
            row.alert = bb_skin.skin_pose_export_wait
            row.operator(
                "onigiri.skin_pose_export",
                text=skin_pose_export_text,
                icon_value = ico.custom_icons["save"].icon_id
               )
            row.alert = bb_skin.skin_pose_import_wait
            row.operator(
                "onigiri.skin_pose_import",
                text=skin_pose_import_text,
                icon_value = ico.custom_icons["load"].icon_id
               )

            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.skin_pose",
                text="Pose Arms",
               ).action = "arms"
            row.prop(
                bb_skin,
                "skin_pose_arms_axis_x",
                text="X",
                toggle = True
            )
            row.prop(
                bb_skin,
                "skin_pose_arms_axis_y",
                text="Y",
                toggle = True
            )
            row.prop(
                bb_skin,
                "skin_pose_arms_axis_z",
                text="Z",
                toggle = True
            )
            row.prop(
                bb_skin,
                "skin_pose_arms_angle",
                text="",
                toggle = True
            )
            row = col.row(align=True)
            row.operator(
                "onigiri.skin_pose",
                text="Pose Legs",
               ).action = "legs"

            row.prop(
                bb_skin,
                "skin_pose_legs_axis_x",
                text="X",
                toggle = True
            )
            row.prop(
                bb_skin,
                "skin_pose_legs_axis_y",
                text="Y",
                toggle = True
            )
            row.prop(
                bb_skin,
                "skin_pose_legs_axis_z",
                text="Z",
                toggle = True
            )
            row.prop(
                bb_skin,
                "skin_pose_legs_angle",
                text="",
                toggle = True
            )
            row = col.row(align=True)
            row.operator(
                "onigiri.skin_pose",
                text="Reset Pose",
               ).action = "reset"

        row = self.layout.row(align=True)
        skin_weight_tools_menu_enabled_icon = "menu_closed"
        if bb_skin.skin_weight_tools_menu_enabled:
            skin_weight_tools_menu_enabled_icon = "menu_opened"
        row.prop(
            bb_skin,
            "skin_weight_tools_menu_enabled",
            text="Weight Tools",
            toggle = True,
            icon_value = ico.custom_icons[skin_weight_tools_menu_enabled_icon].icon_id
            )
        if bb_skin.skin_weight_tools_menu_enabled:

            if 1 == 0:
                col = box.column(align = True)
                row = col.row(align=True)
                row.label(
                    text = "Skin Correction:",
                    )
                row = col.row(align=True)
                if bb_skin.skin_correction_source == True:
                    row.prop(
                        bb_skin,
                        "skin_correction_source",
                        text="Click To Disable",
                        toggle = True
                    )
                else:
                    row.operator(
                        "onigiri.skin_correction_source",
                        text="Choose Weight Source",
                       ).action = "enable"
                row = col.row(align=True)
                row.operator(
                    "onigiri.skin_correction_setup",
                    text="Choose Sticky",
                    icon_value = ico.custom_icons["tools"].icon_id
                   )
                row.operator(
                    "onigiri.skin_correction",
                    text="Recalculate",
                    icon_value = ico.custom_icons["calc"].icon_id
                   ).action = "recalc"
                row = col.row(align=True)
                row.operator(
                    "onigiri.skin_correction",
                    text="Select More",
                    icon_value = ico.custom_icons["add"].icon_id
                   ).action = "select_more"
                row.operator(
                    "onigiri.skin_correction",
                    text="Select Less",
                    icon_value = ico.custom_icons["subtract"].icon_id
                   ).action = "select_less"
                row = col.row(align=True)
                row.operator(
                    "onigiri.skin_correction_finish",
                    text="Finish",
                   )

            bb_paint = bpy.context.scene.bb_paint
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)
            row.label(
                text = "Paint Weights:",
                )
            row = col.row(align=True)
            if bb_paint.paint_active == False:
                row.operator(
                    "onigiri.paint_enable",
                    text="Enable Weight Painting",
                    icon_value = ico.custom_icons["paint_disabled"].icon_id
                   ).state = True
            else:
                row.prop(
                    bb_paint,
                    "paint_active",
                    text = "Disable Weight Painting",
                    icon_value = ico.custom_icons["paint_enabled"].icon_id
                    )
                
            paint_back_face_icon = "back_face_disabled"
            if bb_paint.paint_back_face == True:
                paint_back_face_icon = "back_face_enabled"

            if bb_paint.paint_back_face == False:
                row.operator(
                    "onigiri.paint_back_face",
                    text="",
                    icon_value = ico.custom_icons[paint_back_face_icon].icon_id
                   ).state = True
            else:
                row.prop(
                    bb_paint,
                    "paint_back_face",
                    text = "",
                    icon_value = ico.custom_icons[paint_back_face_icon].icon_id
                    )

            bbm = bpy.context.window_manager.bb_misc
            bb_misc = bbm
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)
            row.label(
                text = "Skin Maintenance:",
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.move_weights",
                text="Move weights from control rig",
                icon_value = ico.custom_icons["arrow_right_green"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.convert_to_fitmesh",
                text="Convert to fitmesh",
                icon_value = ico.custom_icons["fitmesh"].icon_id
                )

            row = col.row(align=True)
            row.prop(
                bpy.context.scene.bb_devkit,
                "preserve_empty_counterparts",
                toggle = True,
                text="",
                icon_value = ico.custom_icons["symmetric"].icon_id
                )

            groups_total = 0
            groups_text = "Remove empty vertex groups"
            if len(bpy.context.selected_objects) == 1:
                if bpy.context.selected_objects[0].type == 'MESH':
                    groups_total = len(bpy.context.selected_objects[0].vertex_groups)
            if groups_total > 0:
                groups_text = "[" + str(groups_total) + "] Remove Empty Vertex Groups"
                row.operator(
                    "onigiri.remove_unused_groups",
                    text = groups_text,
                    ).method = "best"
            else:
                row.operator(
                    "onigiri.remove_unused_groups",
                    text = groups_text,
                    icon_value = ico.custom_icons["dot_yellow"].icon_id
                    ).method = "best"

            if 1 == 0:
                row.operator(
                    "onigiri.remove_unused_groups",
                    text="Remove empty vertex groups",
                    ).method = "old"
                row.operator(
                    "onigiri.remove_unused_groups",
                    text="Remove empty vertex groups",
                    ).method = "new"

            row = col.row(align=True)
            row.operator(
                "onigiri.limit_weights",
                text="Limit bone influences",
                icon_value = ico.custom_icons["no_bone"].icon_id
               )
            row.scale_x = 0.25
            row.prop(
                bbm,
                "limit_weights",
                text="",
                )
            row.scale_x = 1

            row = col.row(align=True)
            row.operator(
                "onigiri.remove_weights",
                text="Remove Weights from Selection",
               )
            row = col.row(align=True)
            row.operator(
                "onigiri.select_unweighted",
                text="Select vertices that have no weights",
               )

            row = col.row(align=True)
            row.operator(
                "onigiri.normalize_weights",
                text="Normalize Weights",
               )
            row.operator(
                "onigiri.refresh_weights",
                text="Refresh Weights",
               )

            bb = bpy.context.scene.onigiri
            bbm = bpy.context.window_manager.bb_misc
            bb_misc = bbm
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)
            row.label(
                text = "Skin Smoothing:",
                )
            row = col.row(align=True)

            col = box.column(align = True)
            row = col.row(align=True)

            skin_smooth_enabled = False
            if len(bpy.context.selected_objects) == 1:
                if bpy.context.selected_objects[0].type == 'MESH':
                    if bpy.context.selected_objects[0].get('skin_smooth_enabled'):
                        skin_smooth_enabled = True
            if skin_smooth_enabled == True:
                row.prop(
                    bb_skin,
                    "skin_smooth_enabled",
                    toggle = True,
                    text="Disable Skin Smooth",
                    icon_value = ico.custom_icons["smooth"].icon_id
                    )
            else:
                row.operator(
                    "onigiri.skin_smooth_enable",
                    text="Enable Skin Smooth",
                    icon_value = ico.custom_icons["smooth"].icon_id
                   )

            row.operator(
                "onigiri.skin_smooth_undo",
                text="Undo",
                icon_value = ico.custom_icons["reset"].icon_id
               )
            if skin_smooth_enabled == True:
                row = col.row(align=True)
                row.prop(
                    bb_skin,
                    "skin_smooth_selected_vertices",
                    text="Selected Vertices",
                    toggle = True,
                    
                    )
                row.prop(
                    bb_skin,
                    "skin_smooth_selected_group",
                    text="Selected Group",
                    toggle = True,
                    
                    )
                row.operator(
                    "onigiri.skin_smooth_manual_update",
                    text="Manual Update",
                    
                   )

                row = col.row(align=True)
                row.prop(
                    bb_skin,
                    "skin_smooth_factor",
                    text="Factor:",
                    )
                row.prop(
                    bb_skin,
                    "skin_smooth_area",
                    text="Area:",
                    )
                row.prop(
                    bb_skin,
                    "skin_smooth_repeat",
                    text="Repeat:",
                    )
                row = col.row(align=True)
                row.prop(
                    bb,
                    "blank",
                    text = " " + bb_skin.skin_smooth_notice,
                    toggle = True,
                    icon_value = ico.custom_icons["alert"].icon_id
                    )

class OnigiriRigCreationPanel(bpy.types.Panel):
    """Rigs"""
    bl_idname = "OBJECT_PT_bento_buddy_rig_creation"
    bl_label = "Rig Creation"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        brp = bpy.context.window_manager.bb_rigprops
        bb_rig = bpy.context.window_manager.bb_rig
        obj = bpy.data.objects

        row = self.layout.row(align=True)

        row = self.layout.row(align=True)
        row.operator(
            "onigiri.create_pos_rig",
            text="Add Safe Rig (pos/neutral)",
            icon_value = ico.custom_icons["star_green"].icon_id
            )
        row.prop(
            bb_rig,
            "rig_rotate",
            toggle = True,
            text = "",
            icon_value = ico.custom_icons["rotate"].icon_id
            )
        row = self.layout.row(align=True)
        row.prop(
            brp,
            "rigs_enabled",
            toggle = True,
            text = "Enable additional choices",
            )
        if brp.rigs_enabled == True:
            row = self.layout.row(align=True)
            row.operator(
                "onigiri.attach_proxy_rig",
                text="Attach Control Rig",
                )
            row.prop(
                bb_rig,
                "rig_clean",
                toggle = True,
                text = "",
                icon_value = ico.custom_icons["clean"].icon_id
                )

            row = self.layout.row(align=True)
            row.operator(
                "onigiri.create_pivot_rig",
                text="Add Pivot Rig",
                icon_value = ico.custom_icons["star_black"].icon_id
                )
            row.prop(
                bb_rig,
                "rig_rotate",
                toggle = True,
                text = "",
                icon_value = ico.custom_icons["rotate"].icon_id
                )
            row = self.layout.row(align=True)
            row.operator(
                "onigiri.create_devkit_rig",
                text="Add Female Neutral Devkit Rig",
                icon_value = ico.custom_icons["alert"].icon_id
                ).rig_class = "female_neutral"
            row = self.layout.row(align=True)
            row.operator(
                "onigiri.create_devkit_rig",
                text="Add Female Default Devkit Rig",
                icon_value = ico.custom_icons["alert"].icon_id
                ).rig_class = "female_default"
            row = self.layout.row(align=True)
            row.operator(
                "onigiri.create_devkit_rig",
                text="Add Male Neutral Devkit Rig",
                icon_value = ico.custom_icons["alert"].icon_id
                ).rig_class = "male_neutral"
            row = self.layout.row(align=True)
            row.operator(
                "onigiri.create_devkit_rig",
                text="Add Male Default Devkit Rig",
                icon_value = ico.custom_icons["alert"].icon_id
                ).rig_class = "male_default"
            row = self.layout.row(align=True)
            row.operator(
                "onigiri.create_old_rig",
                text="Add old (basic) Rig",
                icon_value = ico.custom_icons["alert"].icon_id
                )

class OnigiriAnimeshPanel(bpy.types.Panel):
    """Onigiri works with Avastar or its own internal skeleton to help you prototype
and build custom characters, animations and Animesh quickly"""
    bl_idname = "OBJECT_PT_bento_buddy_animesh"
    bl_label = "Character Tools"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        obj = bpy.data.objects
        ani = bpy.context.window_manager.bb_animesh
        bmp = bpy.context.window_manager.bb_mapper
        bba = bpy.context.scene.bb_anim_props
 
        row = self.layout.row(align=True)

        if bmp.mapper_menu_enabled == True:
            mapper_menu_enabled_icon = "menu_opened"
        else:
            mapper_menu_enabled_icon = "menu_closed"

        row.prop(
            bmp,
            "mapper_menu_enabled",
            toggle = True,
            text = "Character Mapper / Retargeter",
            icon_value = ico.custom_icons[mapper_menu_enabled_icon].icon_id,
            )

        if bmp.mapper_menu_enabled == True:

            row = self.layout.row(align=True)
            row.prop(
                bmp,
                "mapper_lock_source",
                toggle = True,
                text = "Lock Source",
                )
            row.prop(
                bmp,
                "mapper_source_name",
                text = "",
                )
            
            if bmp.mapper_targets > 0:
                row = self.layout.row(align=True)
                row.label(
                    text = "Targets Chosen: " + str(bmp.mapper_targets),
                    )
    
            if bmp.mapper_target_name == "":
                row = self.layout.row(align=True)
                row.prop(
                    bmp,
                    "mapper_lock_target",
                    toggle = True,
                    text = "Lock Target(s)",
                    )
                row.prop(
                    bmp,
                    "mapper_target_name",
                    text = "",
                    )
            
            else:
                row = self.layout.row(align=True)
                if bmp.mapper_lock_source == False:
                    row.label(
                        text = "Armatures found in template: (Lock source first!)",
                        )
                    row = self.layout.row(align=True)
                    row.label(
                        text = "Note: you can remove the targets if you like",
                        icon_value = ico.custom_icons["x_mixed"].icon_id,
                        )
                else:
                    if bmp.get('targets_waiting') != None and len(bmp['targets_waiting']) > 0:
                        row.label(
                            text = "Chose a target in scene and click one below:",
                            )
                        row = self.layout.row(align=True)
                        row.label(
                            text = "Note: you can remove the targets if you like",
                            icon_value = ico.custom_icons["x_mixed"].icon_id,
                            )
                targets_waiting = bmp.get('targets_waiting', []) 
                for tarm in targets_waiting:
                    row = self.layout.row(align=True)
                    row.operator(
                        "onigiri.mapper_remove_target",
                        text="",
                        icon_value = ico.custom_icons["x_mixed"].icon_id,
                        ).target = tarm
                    row.operator(
                        "onigiri.mapper_target",
                        text=tarm,
                        ).target = tarm

            row = self.layout.row(align=True)
            row.operator(
                "onigiri.mapper_load",
                text="Load Template",
                icon_value = ico.custom_icons["load"].icon_id
                )
            row.prop(
                bmp,
                "mapper_template_path",
                text = "",
                )
            row = self.layout.row(align=True)
            row.prop(
                bmp,
                "mapper_restore_pose",
                text = "",
                icon_value = ico.custom_icons["fix_pose"].icon_id
                )
            row.operator(
                "onigiri.mapper_reset",
                text="Reset the mapper",
                )
            row.operator(
                "onigiri.mapper_restore",
                text="Restore Bones",
                icon_value = ico.custom_icons["reset"].icon_id
                )
            row = self.layout.row(align=True)
            row.operator(
                "onigiri.mapper_detach",
                text="Detach Mapped Items",
                icon_value = ico.custom_icons["detach"].icon_id
                )
            row = self.layout.row(align=True)
            row.label(
                text = bmp.mapper_message,
                icon = "INFO"
                )
            
            if 1 == 0:
                if bmp.get('targets_waiting') != None:
                    for tarm in bmp['targets_waiting']:
                        row = self.layout.row(align=True)
                        row.operator(
                            "onigiri.mapper_remove_target",
                            text="",
                            icon_value = ico.custom_icons["x_mixed"].icon_id,
                            ).target = tarm
                        row.operator(
                            "onigiri.mapper_target",
                            text=tarm,
                            ).target = tarm

            row = self.layout.row(align=True)
            row.prop(
                bmp,
                "mapper_retarget_only",
                text="Retarget Only",
                toggle = True,
                icon_value = ico.custom_icons["retarget"].icon_id
                )

            row = self.layout.row(align=True)
            if bmp.mapper_retarget_only == True:
                row.prop(
                    bmp,
                    "mapper_anchor_enabled",
                    text = "",
                    icon_value = ico.custom_icons["anchor"].icon_id
                    )
                row.prop(
                    bmp,
                    "mapper_anchor_source_name",
                    text = "",
                    )

                retargetter_ready = False
    
                if bmp.mapper_source_name != "":
                    if bmp.mapper_source_name in obj and obj[bmp.mapper_source_name].get('locked') == 1:
                        retargetter_ready = True
                if retargetter_ready == True:
                
                    row = self.layout.row(align=True)
                    row.prop(
                        bmp,
                        "enable_pelvis_rotation_x",
                        text="rX",
                        toggle = True,
                        
                        )
                    row.prop(
                        bmp,
                        "enable_pelvis_rotation_y",
                        text="rY",
                        toggle = True,
                        
                        )
                    row.prop(
                        bmp,
                        "enable_pelvis_rotation_z",
                        text="rZ",
                        toggle = True,
                        
                        )
                    row = self.layout.row(align=True)
                    row.prop(
                        bmp,
                        "enable_pelvis_location_x",
                        text="lX",
                        toggle = True,
                        
                        )
                    row.prop(
                        bmp,
                        "enable_pelvis_location_y",
                        text="lY",
                        toggle = True,
                        
                        )
                    row.prop(
                        bmp,
                        "enable_pelvis_location_z",
                        text="lZ",
                        toggle = True,
                        
                        )

                if 1 == 0:
                    row = self.layout.row(align=True)
                    row.prop(
                        bmp,
                        "mapper_proxy_objects",
                        text="Use Proxy Objects",
                        toggle = True,
                        icon_value = ico.custom_icons["proxy"].icon_id
                        )
                row = self.layout.row(align=True)
                row.prop(
                    bmp,
                    "mapper_edit_targets",
                    text="Edit Targets",
                    toggle = True,
                    icon_value = ico.custom_icons["edit"].icon_id
                    )
                row = self.layout.row(align=True)
                if bmp.mapper_edit_targets == True:
                    row.label(
                        text = "Remove From Animation:",
                        )
                    row = self.layout.row(align=True)
                    row.operator(
                        "onigiri.mapper_retarget_save",
                        text="Save altered template",
                        icon_value = ico.custom_icons["save"].icon_id
                        )
                    row = self.layout.row(align=True)
                    if bmp.mapper_template_ready == True:
                        for boneObj in bpy.data.objects[bmp.mapper_source_name].pose.bones:
                            for pbC in boneObj.constraints:
                                row = self.layout.row(align=True)
                                row.operator(
                                    "onigiri.mapper_remove_retarget_link",
                                    text="",
                                    icon_value = ico.custom_icons["x_black"].icon_id
                                    ).bone = boneObj.name
                                row.label(
                                    text = boneObj.name
                                    )
                                break
                    row = self.layout.row(align=True)

            if 1 == 1:
                row = self.layout.row(align=True)
                row.prop(
                    bmp,
                    "mapper_morph_pose",
                    text = "Morph Pose",
                    toggle = True,
                    icon_value = ico.custom_icons["shape_shifter"].icon_id
                    )

            row = self.layout.row(align=True)
            row.operator(
                "onigiri.mapper_template",
                text="Template Map",
                )

            row.operator(
                "onigiri.mapper_match",
                text="Match Map",
                )
            row.prop(
                bmp,
                "mapper_auto_fix_bvh",
                text="",
                toggle = True,
                icon_value = ico.custom_icons["glue"].icon_id
                )

            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)

            row.operator(
                "onigiri.mapper_auto",
                text="Auto Map",
                )

            col = box.column(align = True)

            row = col.row(align=True)
            row.prop(
                bmp,
                "mapper_force_pelvis_map",
                text = "Pelvis",
                toggle = True,
                icon_value = ico.custom_icons["anchor"].icon_id
                )
            row.prop(
                bmp,
                "mapper_allow_volume_bones",
                text = "Volume Bones",
                toggle = True,
                icon_value = ico.custom_icons["volume_bones"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bmp,
                "mapper_allow_all_bones",
                text = "All Bones",
                toggle = True,
                icon_value = ico.custom_icons["all_bones"].icon_id
                )
            row.prop(
                bmp,
                "mapper_safe_bones",
                text = "Safe Bones",
                toggle = True,
                icon_value = ico.custom_icons["safe"].icon_id
                )

            row = self.layout.row(align=True)
            row.prop(
                bmp,
                "mapper_stabilize",
                text = "",
                toggle = True,
                icon_value = ico.custom_icons["stabilize"].icon_id
                )
            row.operator(
                "onigiri.mapper_attach",
                text="Attach",
                )
            row.prop(
                bmp,
                "mapper_attach_from_start",
                text = "",
                icon_value = ico.custom_icons["animation_start"].icon_id
                )

            row = self.layout.row(align=True)
            row.prop(
                bmp,
                "mapper_fitted",
                text = "",
                icon_value = ico.custom_icons["export_mesh"].icon_id
                )
            row.operator(
                "onigiri.mapper_export",
                text="Export Mapped Mesh",
                )
            row.prop(
                context.scene.bb_mesh,
                "remove_empty_groups",
                toggle = True,
                text="",
                icon_value = ico.custom_icons["x_red"].icon_id
                )

            bb_anim = bpy.context.scene.bb_anim
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)
            row.label(
                text = "Animation export / processing: (see Animation Panel)",
                )

            col = box.column(align = True)
            
            if 1 == 0:
                row = col.row(align=True)
                row.operator(
                    "onigiri.export_animation_mapped",
                    text="Export Mapped BVH",
                    icon_value = ico.custom_icons["experiment"].icon_id
                    )
                col = box.column(align = True)
                row = col.row(align=True)
                row.operator(
                    "onigiri.export_animation",
                    text="Export Onigiri BVH",
                    icon_value = ico.custom_icons["experiment"].icon_id
                    )

            row = col.row(align=True)
            row.alert = bb_anim.bake_animation_alert
            row.operator(
                "onigiri.teflon",
                
                text = bb_anim.bake_animation_label,
                icon_value = ico.custom_icons["bake"].icon_id
                )
            row.scale_x = 0.3
            row.prop(
                bb_anim,
                "bake_frame_step",
                text = "",
                )

            if 1== 0:
                if bmp.mapper_enabled == True:
                    col.separator()
                    row = col.row(align=True)
                    row.operator(
                        "onigiri.dummy_animation",
                        
                        text = bba.export_sl_bvh_label_short,
                        icon_value = ico.custom_icons["export_animation"].icon_id
                        )
                    row.operator(
                        "onigiri.dummy_animation",
                        
                        text = bb_anim.export_sl_anim_label_short,
                        icon_value = ico.custom_icons["running_guy"].icon_id
                        )
                else:
                    col.separator()
                    row = col.row(align=True)
                    row.alert = bba.export_sl_bvh_alert
                    row.operator(
                        "onigiri.export_bvh_sl",
                        
                        text = bba.export_sl_bvh_label_short,
                        icon_value = ico.custom_icons["export_animation"].icon_id
                        )
                    row.alert = bb_anim.export_sl_anim_alert
                    row.operator(
                        "onigiri.export_sl_anim",
                        
                        text = bb_anim.export_sl_anim_label_short,
                        icon_value = ico.custom_icons["running_guy"].icon_id
                        )
 
            if 1 == 1:
                col.separator()
                row = col.row(align=True)
                row.alert = bba.export_sl_bvh_alert
                row.operator(
                    "onigiri.export_bvh_sl",
                    
                    text = bba.export_sl_bvh_label_short,
                    icon_value = ico.custom_icons["export_animation"].icon_id
                    )
                row.alert = bb_anim.export_sl_anim_alert
                row.operator(
                    "onigiri.export_sl_anim",
                    
                    text = bb_anim.export_sl_anim_label_short,
                    icon_value = ico.custom_icons["running_guy"].icon_id
                    )

            row = self.layout.row(align=True)
            row.label(
                text = "Extended Features: Custom Characters and Animesh",
                )
            row = self.layout.row(align=True)
            row.prop(
                bmp,
                "mapper_pack_bones",
                text = "",
                icon = "TOOL_SETTINGS"
                )
            row.operator(
                "onigiri.mapper_pack_bones",
                text="Pack Bones",
                )
            if bmp.mapper_pack_bones == True:
                layout = self.layout
                box = layout.box()
                col = box.column(align = True)
                row = col.row(align=True)
                row.operator(
                    "onigiri.mapper_pack_options_load",
                    text="Load options",
                    icon_value = ico.custom_icons["load"].icon_id
                    )
                row.operator(
                    "onigiri.mapper_pack_options_save",
                    text="Save options",
                    icon_value = ico.custom_icons["save"].icon_id
                    )
                row.operator(
                    "onigiri.mapper_pack_options_reset",
                    text="Reset options",
                    icon_value = ico.custom_icons["reset"].icon_id
                    )
                col.separator()
                row = col.row(align=True)
                row.prop(
                    bmp,
                    "mapper_pack_bones_length",
                    text = "Length:",
                    )
                row.prop(
                    bmp,
                    "mapper_pack_bones_array",
                    text = "Array:",
                    )
                row.prop(
                    bmp,
                    "mapper_pack_bones_gap",
                    text = "Gap:",
                    )
                row = col.row(align=True)
                row.label(
                    text = "Origin:",
                    )
                row = col.row(align=True)
                row.prop(
                    bmp,
                    "mapper_pack_bones_origin_x",
                    text = "x:",
                    )
                row.prop(
                    bmp,
                    "mapper_pack_bones_origin_y",
                    text = "y:",
                    )
                row.prop(
                    bmp,
                    "mapper_pack_bones_origin_z",
                    text = "z:",
                    )
                row = col.row(align=True)
                row.label(
                    text = "Spacing:",
                    )
                row = col.row(align=True)
                row.prop(
                    bmp,
                    "mapper_pack_bones_spacing_x",
                    text = "x:",
                    )
                row.prop(
                    bmp,
                    "mapper_pack_bones_spacing_y",
                    text = "y:",
                    )
                row.prop(
                    bmp,
                    "mapper_pack_bones_spacing_z",
                    text = "z:",
                    )

            row = self.layout.row(align=True)
            row.prop(
                bmp,
                "mapper_custom_stabilizer",
                text = "",
                icon = "INFO"
               )
            row.operator(
                "onigiri.mapper_custom_stabilizer",
                text="Create Custom Stabilizer Mesh",
                )

        layout = self.layout
        row = self.layout.row(align=True)

        if ani.animesh_menu_enabled == True:
            animesh_menu_enabled_icon = "menu_opened"
        else:
            animesh_menu_enabled_icon = "menu_closed"

        row.prop(
            ani,
            "animesh_menu_enabled",
            toggle = True,
            text = "Template Workshop (superfluous)",
            icon_value = ico.custom_icons[animesh_menu_enabled_icon].icon_id
            )

        if ani.animesh_menu_enabled == True:
            row = self.layout.row(align=True)
            row.operator(
                "onigiri.animesh_get_current",
                text="Get Map from Mapper",
                icon_value = ico.custom_icons["arrow_up"].icon_id
                )
            layout = self.layout
            box = layout.box()
            box.label(
                text = "Character Template Creator:"
                )
            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.animesh_load",
                text="Load Template",
                icon_value = ico.custom_icons["load"].icon_id
                )
            row.operator(
                "onigiri.animesh_save",
                text="Save Template",
                icon_value = ico.custom_icons["save"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.animesh_add_target",
                text="Add Rig",
                icon_value = ico.custom_icons["add"].icon_id
                )
            row.operator(
                "onigiri.animesh_store",
                text="Store Data",
                icon_value = ico.custom_icons["store"].icon_id
                )
            row = col.row(align=True)

            row = col.row(align=True)
            row.operator(
                "onigiri.animesh_apply",
                text="Apply",
                icon_value = ico.custom_icons["thumb_up"].icon_id
                )
            row.operator(
                "onigiri.animesh_restore",
                text="Restore",
                icon_value = ico.custom_icons["thumb_down"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                ani,
                "animesh_lock_source",
                toggle = True,
                text = "Lock Source"
                )
            if ani.animesh_source_name != "":
                row.label(
                    text = ani.animesh_source_name
                    )
            else:
                row.prop(
                    ani,
                    "animesh_source_name",
                    text = ""
                    )

            row = col.row(align=True)
            row.prop(
                ani,
                "animesh_lock_target",
                toggle = True,
                text = "Lock Target(s)"
                )

            if ani.animesh_targets > 0:
                
                row.label(
                    text = str(ani.animesh_targets)
                    )
            else:
                
                row.prop(
                    ani,
                    "animesh_target_name",
                    text = ""
                    )
            
            if ani.animesh_mapper_enabled == True:

                col = box.column(align = True)
                row = col.row(align=True)
                row.prop(
                    ani,
                    "animesh_suspend",
                    text = "Suspend",
                    toggle = True
                    )
                
                row.operator(
                    "onigiri.animesh_reset",
                    text = "Reset",
                    )

            if ani.get('targets_waiting') != None:
                for tarm in ani['targets_waiting']:
                    
                    row = col.row(align=True)
                    row.operator(
                        "onigiri.animesh_remove_target",
                        text="",
                        icon_value = ico.custom_icons["x_mixed"].icon_id,
                        ).target = tarm

                    row.operator(
                        "onigiri.animesh_set_target",
                        text=tarm,
                        ).target = tarm

            col = box.column(align = False)
            row = col.row(align = False)
            row.label(
                text = ani.animesh_message
                )

            if ani.animesh_mapper_enabled == True:
                row = col.row(align = False)
                row.operator(
                    "onigiri.animesh_remove_selected_bones",
                    
                    text=ani.animesh_remove_bones_label,
                    icon_value = ico.custom_icons["x"].icon_id
                    )
                
                smap = obj[ani.animesh_source_name]['bone_map'].to_dict()
                for sbone in smap:
                    
                    (target, tbone), = smap[sbone].items()

                    row = col.row(align=True)
                    row.operator(
                        "onigiri.animesh_remove_bone",
                        text="",
                        icon_value = ico.custom_icons["x_black"].icon_id
                        ).bone = sbone
                    row.label(
                        text = sbone + " -> " + target + " [" + tbone + "]"
                        )

class OnigiriCharacterPanel(bpy.types.Panel):
    """Onigiri works with Avastar or its own internal skeleton to help you prototype and
build custom characters, animations and Animesh quickly"""
    bl_idname = "OBJECT_PT_bento_buddy_animesh"
    bl_label = "Character Tools"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        obj = bpy.data.objects
        ani = bpy.context.window_manager.bb_animesh
        bmp = bpy.context.window_manager.bb_mapper
        bba = bpy.context.scene.bb_anim_props

        layout = self.layout

        row = self.layout.row(align=True)
        bb_inherit = bpy.context.window_manager.bb_inherit
        if bb_inherit.inherit_menu_enabled == True:
            inherit_menu_enabled_icon = "menu_opened"
        else:
            inherit_menu_enabled_icon = "menu_closed"
        
        row.prop(
            bb_inherit,
            "inherit_menu_enabled",
            toggle = True,
            text = "Inherit Animation",
            icon_value = ico.custom_icons[inherit_menu_enabled_icon].icon_id
            )

        if bb_inherit.inherit_menu_enabled == True:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)
            row.operator(
                "onigiri.motion_load_map",
                text="Load Map",
                icon_value = ico.custom_icons["load"].icon_id
                )
            row.operator(
                "onigiri.motion_match_map",
                text="Match Map",
                icon_value = ico.custom_icons["match"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.motion_clean_map",
                text="Clean Maps",
                icon_value = ico.custom_icons["clean"].icon_id
                )
            row.operator(
                "onigiri.inherit_reset",
                text="Reset",
                icon_value = ico.custom_icons["reset"].icon_id
                )

            inherit_map_text = " "
            inherit_map_icon = "bone_black"
            inherit_row_enabled = False
            inherit_rename_map = {} 

            inherit_prefix_icon = "blank"
            inherit_prefix = ""

            selected = bpy.context.selected_objects
            arms = []
            for o in selected:
                if o.type == 'ARMATURE':
                    arms.append(o)
            if len(arms) == 1:
                if arms[0].get('bb_onemap_rename') != None:
                    inherit_map_text = "This rig contains a map!"
                    inherit_map_icon = "bone_black_red"
                    
                    inherit_rename_map = arms[0]['bb_onemap_rename'].to_dict()
                
                inherit_prefix = rigutils.get_bone_prefix()
                if inherit_prefix != "":
                    inherit_prefix_icon = "prefix"

                inherit_row_enabled = True

            row = col.row(align=True)
            row.prop(
                bb_inherit,
                "inherit_blank",
                text=inherit_map_text,
                toggle = True,
                icon_value = ico.custom_icons[inherit_map_icon].icon_id
                )
            
            if inherit_prefix != "":
                row.prop(
                    bb_inherit,
                    "inherit_prefix",
                    text= "",
                    toggle = True,
                    icon_value = ico.custom_icons["prefix"].icon_id
                    )
            else:
                row.prop(
                    bb_inherit,
                    "inherit_blank",
                    text="",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )

            row = col.row(align=True)
            row.enabled = inherit_row_enabled
            row.prop(
                bb_inherit,
                "inherit_target_lock",
                text = "Lock Target",
                icon_value = ico.custom_icons["target"].icon_id
                )
            row.operator(
                "onigiri.inherit_animation",
                text="Transfer",
                icon_value = ico.custom_icons["running_guy"].icon_id
                )

            row = col.row(align=True)
            row.prop(
                bb_inherit,
                "inherit_view_map",
                text = "View Map",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            if bb_inherit.inherit_view_map == True:
                row = col.row(align=True)
                
                if len(inherit_rename_map) > 0:
                    row.prop(
                        bb_inherit,
                        "inherit_blank",
                        text = "- " + arms[0].name + " -",
                        icon_value = ico.custom_icons["follow"].icon_id
                        )
                    row.operator(
                        "onigiri.inherit_reverse_map",
                        text="",
                        icon_value = ico.custom_icons["to_actor"].icon_id
                        )
                row = col.row(align=True)
                for sbone in inherit_rename_map:
                    tbone = inherit_rename_map[sbone]
                    row.prop(
                        bb_inherit,
                        "inherit_blank",
                        text = sbone,
                        icon_value = ico.custom_icons["bone_blue"].icon_id
                        )
                    row.prop(
                        bb_inherit,
                        "inherit_blank",
                        text = tbone,
                        icon_value = ico.custom_icons["bone_red"].icon_id
                        )
                    row = col.row(align=True)

        row = self.layout.row(align=True)
        bb_motion = bpy.context.window_manager.bb_motion
        if bb_motion.motion_menu_enabled == True:
            motion_menu_enabled_icon = "menu_opened"
        else:
            motion_menu_enabled_icon = "menu_closed"

        row.prop(
            bb_motion,
            "motion_menu_enabled",
            toggle = True,
            text = "Retarget Motion",
            icon_value = ico.custom_icons[motion_menu_enabled_icon].icon_id
            )
        if bb_motion.motion_menu_enabled == True:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)
            row.operator(
                "onigiri.motion_load_map",
                text="Load Map",
                icon_value = ico.custom_icons["load"].icon_id
                )
            row.operator(
                "onigiri.motion_save_map",
                text="Save Map",
                icon_value = ico.custom_icons["save"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.motion_clean_map",
                text="Clean Maps",
                icon_value = ico.custom_icons["clean"].icon_id
                )

            row.operator(
                "onigiri.motion_match_map",
                text="Match Map",
                icon_value = ico.custom_icons["match"].icon_id
                )

            row = col.row(align=True)
            row.prop(
                bb_motion,
                "motion_to_animation",
                text = "Send To Animation",
                icon_value = ico.custom_icons["arrow_up"].icon_id
                )
            row.prop(
                bb_motion,
                "motion_prepare_actor",
                text = "Prepare Actor",
                icon_value = ico.custom_icons["sliders"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bb_motion,
                "motion_stabilize",
                toggle = True,
                text = "Stabilizer",
                icon_value = ico.custom_icons["stabilize"].icon_id
                )
            row.prop(
                bb_motion,
                "motion_glue",
                toggle = True,
                text = "Glue (Custom Rig)",
                icon_value = ico.custom_icons["glue"].icon_id
                )
            
            row = col.row(align=True)
            bb_motion_rename_text = " "
            bb_motion_rename_icon = "bone_black"
            selected = bpy.context.selected_objects
            arms = []
            for o in selected:
                if o.type == 'ARMATURE':
                    arms.append(o)
            if len(arms) == 1:
                
                if arms[0].get('bb_onemap_rename') != None:
                    bb_motion_rename_text = "Director contains a map!"
                    bb_motion_rename_icon = "bone_black_red"

            row.prop(
                bb_motion,
                "motion_blank",
                text=bb_motion_rename_text,
                toggle = True,
                icon_value = ico.custom_icons[bb_motion_rename_icon].icon_id
                )
            row = col.row(align=True)

            row.operator(
                "onigiri.snap_convert",
                text="Director to Actor",
                icon_value = ico.custom_icons["follow"].icon_id
                )
            row.operator(
                "onigiri.snap_convert_undo",
                text="Undo D2A",
                icon_value = ico.custom_icons["reset"].icon_id
                )

            row = col.row(align=True)
            row.prop(
                bb_motion,
                "motion_use_shapes",
                toggle = True,
                text = "Use Shapes",
                icon_value = ico.custom_icons["bone_bent"].icon_id
                )

            row.operator(
                "onigiri.onemap_reverse",
                text="Reverse Map",
                icon_value = ico.custom_icons["to_actor"].icon_id
                )

            row = col.row(align=True)
            row.operator(
                "onigiri.motion_action",
                text="Action!",
                icon_value = ico.custom_icons["action"].icon_id
                )
            row.operator(
                "onigiri.motion_reset",
                text="Reset Stage",
                icon_value = ico.custom_icons["reset"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.snap_mesh",
                text="Hide Mesh",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "hide"
            row.operator(
                "onigiri.snap_mesh",
                text="Show Mesh",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "show"
            row = col.row(align=True)
            row.operator(
                "onigiri.motion_view_bones",
                text="Hide Unmapped Bones",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "hide"
            row.operator(
                "onigiri.motion_view_bones",
                text="View All Bones",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "show"
            row = col.row(align=True)
            row.operator(
                "onigiri.motion_hide_target",
                text="Hide Target Bones",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.operator(
                "onigiri.motion_remove_lock",
                text="Remove Lock map",
                icon_value = ico.custom_icons["blank"].icon_id
                )

            row = col.row(align=True)
            row.operator(
                "onigiri.motion_apply_scale",
                text="Apply Scale",
                icon_value = ico.custom_icons["scale"].icon_id
                )
            row.prop(
                bb_motion,
                "motion_distance",
                text = "Dist.",
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_motion,
                "motion_blank",
                toggle = True,
                text = "Anchor / Pelvis / Root",
                icon_value = ico.custom_icons["anchor"].icon_id
                )
            row.prop(
                bb_motion,
                "motion_constrain_location",
                toggle = True,
                text = "",
                icon_value = ico.custom_icons["global"].icon_id
                )

            row = col.row(align=True)
            row.prop(
                bb_motion,
                "motion_blank",
                toggle = True,
                text = "Loc",
                icon_value = ico.custom_icons["location"].icon_id
                )

            anchor_axis_state = motion.get_anchor_state()

            anchor_location_x = anchor_axis_state['location'][0]
            anchor_location_y = anchor_axis_state['location'][1]
            anchor_location_z = anchor_axis_state['location'][2]
            motion_anchor = row.operator(
                "onigiri.motion_anchor",
                text = "X",
                icon_value = ico.custom_icons[anchor_location_x].icon_id
                )
            motion_anchor.axis = "x"
            motion_anchor.transform = "location"

            motion_anchor = row.operator(
                "onigiri.motion_anchor",
                text = "Y",
                icon_value = ico.custom_icons[anchor_location_y].icon_id
                )
            motion_anchor.axis = "y"
            motion_anchor.transform = "location"

            motion_anchor = row.operator(
                "onigiri.motion_anchor",
                text = "Z",
                icon_value = ico.custom_icons[anchor_location_z].icon_id
                )
            motion_anchor.axis = "z"
            motion_anchor.transform = "location"

            row = col.row(align=True)
            row.prop(
                bb_motion,
                "motion_blank",
                toggle = True,
                text = "Rot",
                icon_value = ico.custom_icons["rotation"].icon_id
                )
            anchor_rotation_x = anchor_axis_state['rotation'][0]
            anchor_rotation_y = anchor_axis_state['rotation'][1]
            anchor_rotation_z = anchor_axis_state['rotation'][2]
            motion_anchor = row.operator(
                "onigiri.motion_anchor",
                text = "X",
                icon_value = ico.custom_icons[anchor_rotation_x].icon_id
                )
            motion_anchor.axis = "x"
            motion_anchor.transform = "rotation"

            motion_anchor = row.operator(
                "onigiri.motion_anchor",
                text = "Y",
                icon_value = ico.custom_icons[anchor_rotation_y].icon_id
                )
            motion_anchor.axis = "y"
            motion_anchor.transform = "rotation"

            motion_anchor = row.operator(
                "onigiri.motion_anchor",
                text = "Z",
                icon_value = ico.custom_icons[anchor_rotation_z].icon_id
                )
            motion_anchor.axis = "z"
            motion_anchor.transform = "rotation"

            col = box.column(align = True)
            row = col.row(align=True)

            motion_interactive_menu_enabled_icon = "menu_closed"
            if bb_motion.motion_interactive_menu_enabled == True:
                motion_interactive_menu_enabled_icon = "menu_opened"

            row.prop(
                bb_motion,
                "motion_interactive_menu_enabled",
                toggle = True,
                text = "Interactive Retarget Mapping",
                icon_value = ico.custom_icons[motion_interactive_menu_enabled_icon].icon_id
                )
            if bb_motion.motion_interactive_menu_enabled == True:
                row = col.row(align=True)
                if len(bpy.context.selected_objects) == 0:
                    return None
                if bpy.context.mode != 'POSE':
                    return None
                
                inRig = motion.get_director(bpy.context.active_object.name)
                if inRig == False:
                    return None
                outRig = inRig['bb_motion_actor']

                col = box.column(align = True)
                row = col.row(align=True)

                row.prop(
                    bb_motion,
                    "motion_blank",
                    toggle = True,
                    text = " " + inRig.name,
                    icon_value = ico.custom_icons["director"].icon_id
                    )
                row.prop(
                    bb_motion,
                    "motion_blank",
                    toggle = True,
                    text = " " + outRig.name,
                    icon_value = ico.custom_icons["running_guy"].icon_id
                    )
                director_bone = ""
                actor_bone = ""
                if len(bpy.context.selected_pose_bones) == 1:
                    pBone = bpy.context.selected_pose_bones[0]
                    if pBone.id_data == inRig:
                        motion.props['director_bone'] = pBone.name
                    if pBone.id_data == outRig:
                        motion.props['actor_bone'] = pBone.name
                    director_bone = motion.props['director_bone']
                    actor_bone = motion.props['actor_bone']
                row = col.row(align=True)
                row.prop(
                    bb_motion,
                    "motion_blank",
                    toggle = True,
                    text = " " + director_bone,
                    icon_value = ico.custom_icons["bone_blue"].icon_id
                    )
                row.prop(
                    bb_motion,
                    "motion_blank",
                    toggle = True,
                    text = " " + actor_bone,
                    icon_value = ico.custom_icons["bone_red"].icon_id
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.motion_map_add",
                    text="Add Bones",
                    icon_value = ico.custom_icons["map"].icon_id
                    )
                row.operator(
                    "onigiri.motion_map_remove",
                    text="Remove Bones",
                    icon_value = ico.custom_icons["nuke"].icon_id
                    )

                col = box.column(align = True)
                row = col.row(align=True)
                row.prop(
                    bb_motion,
                    "motion_blank",
                    toggle = True,
                    text = "Transform Locks (selected bones)",
                    
                    )
                
                row = col.row(align=True)
                lock_transform_rotation = row.operator(
                    "onigiri.motion_lock_selected",
                    text="Lock Rotation",
                    icon_value = ico.custom_icons["locked_black"].icon_id
                    )
                lock_transform_rotation.action = "lock"
                lock_transform_rotation.transform = "rotation"
                lock_transform_location = row.operator(
                    "onigiri.motion_lock_selected",
                    text="Lock Location",
                    icon_value = ico.custom_icons["locked_black"].icon_id
                    )
                lock_transform_location.action = "lock"
                lock_transform_location.transform = "location"
                
                row = col.row(align=True)
                unlock_transform_rotation = row.operator(
                    "onigiri.motion_lock_selected",
                    text="Unlock Rotation",
                    icon_value = ico.custom_icons["unlocked_black"].icon_id
                    )
                unlock_transform_rotation.action = "unlock"
                unlock_transform_rotation.transform = "rotation"
                unlock_transform_location = row.operator(
                    "onigiri.motion_lock_selected",
                    text="Unlock Location",
                    icon_value = ico.custom_icons["unlocked_black"].icon_id
                    )
                unlock_transform_location.action = "unlock"
                unlock_transform_location.transform = "location"

                col = box.column(align = True)
                row = col.row(align=True)
                motion_view_map_menu_enabled_icon = "menu_closed"
                if bb_motion.motion_view_map_menu_enabled == True:
                    motion_view_map_menu_enabled_icon = "menu_opened"
                row.prop(
                    bb_motion,
                    "motion_view_map_menu_enabled",
                    toggle = True,
                    text = "View map",
                    icon_value = ico.custom_icons[motion_view_map_menu_enabled_icon].icon_id
                    )
                if bb_motion.motion_view_map_menu_enabled == True:
                    motion_rename_map = inRig.get('bb_onemap_rename')
                    if motion_rename_map == None:
                        return None

                    for in_bone in motion_rename_map:
                        row = col.row(align=True)
                        out_bone = motion_rename_map[in_bone]
                        row.operator(
                            "onigiri.motion_map_select",
                            text = in_bone,
                            icon_value = ico.custom_icons["bone_blue"].icon_id
                            ).in_bone = in_bone
                        row.operator(
                            "onigiri.motion_map_select",
                            text = out_bone,
                            icon_value = ico.custom_icons["bone_red"].icon_id
                            ).out_bone = out_bone

        bb_mapper = bpy.context.window_manager.bb_mapper
        
        if bb_mapper.bone_control_menu_enabled == True:
            bone_control_menu_enabled_icon = "menu_opened"
        else:
            bone_control_menu_enabled_icon = "menu_closed"

        layout = self.layout
        row = self.layout.row(align=True)
        row.prop(
            bb_mapper,
            "bone_control_menu_enabled",
            toggle = True,
            text = "Bone Control",
            icon_value = ico.custom_icons[bone_control_menu_enabled_icon].icon_id
            )
        if bb_mapper.bone_control_menu_enabled == True:
            layout = self.layout

            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)
            bb_joints = bpy.context.window_manager.bb_joints
            joints_selected = 0
            joints_selected_list = []
            joints_selected_objects = bpy.context.selected_objects
            if len(bpy.context.selected_objects) == 1:
                selected_object = bpy.context.selected_objects[0]
                if selected_object.type == 'ARMATURE':
                    for boneObj in selected_object.data.bones:
                        if boneObj.get('bb_joint_export'):
                            joints_selected += 1
                            joints_selected_list.append(boneObj.name)
            row.prop(
                bb_joints,
                "joints_blank",
                text = "Joint Export Flag - Set / Clear : (" + str(joints_selected) + ")",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.bone_control_export_set",
                text="Bone Export (set)",
                )
            row.operator(
                "onigiri.bone_control_export_clear",
                text="Bone Export (clear)",
                )
            row = col.row(align=True)
            row.prop(
                bb_joints,
                "joints_show",
                text = "Show Exportable Joints",
                toggle = True,
                icon_value = ico.custom_icons["joint"].icon_id
                )

            if bb_joints.joints_show == True:
                row = col.row(align=True)
                for bone in joints_selected_list:
                    row.prop(
                        bb_joints,
                        "joints_blank",
                        text = bone,
                        toggle = True,
                        icon_value = ico.custom_icons["bone_black"].icon_id
                        )
                    row.operator(
                        "onigiri.bone_control_export_remove",
                        text="",
                        icon_value = ico.custom_icons["x_red"].icon_id
                        ).name = bone
                    row = col.row(align=True)
            
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)

            row.prop(
                bb_mapper,
                "mapper_pack_bones",
                text = "",
                icon = "TOOL_SETTINGS"
                )
            row.operator(
                "onigiri.mapper_pack_bones",
                text="Pack Bones",
                )
            row.prop(
                bb_mapper,
                "mapper_rebuild_rig",
                text = "",
                icon_value = ico.custom_icons["sl"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bb_mapper,
                "mapper_pack_compress",
                text = "Compress",
                toggle = True,
                )
            row.prop(
                bb_mapper,
                "mapper_pack_selected",
                text = "To Selected",
                toggle = True,
                )

            if bb_mapper.mapper_rebuild_rig == True:
                row = col.row(align=True)
                row.prop(
                    bb_mapper,
                    "mapper_rebuild_rig_attachment",
                    text = "Att. Bones",
                    toggle = True,
                    )
                row.prop(
                    bb_mapper,
                    "mapper_rebuild_rig_volume",
                    text = "Vol. Bones",
                    toggle = True,
                    )
                row.prop(
                    bb_mapper,
                    "mapper_pack_pelvis",
                    text = "Pelvis",
                    toggle = True,
                    )

            if bb_mapper.mapper_pack_bones == True:
                
                col = box.column(align = True)
                row = col.row(align=True)
                row.operator(
                    "onigiri.mapper_pack_options_load",
                    text="Load options",
                    icon_value = ico.custom_icons["load"].icon_id
                    )
                row.operator(
                    "onigiri.mapper_pack_options_save",
                    text="Save options",
                    icon_value = ico.custom_icons["save"].icon_id
                    )
                row.operator(
                    "onigiri.mapper_pack_options_reset",
                    text="Reset options",
                    icon_value = ico.custom_icons["reset"].icon_id
                    )
                col.separator()
                row = col.row(align=True)
                row.prop(
                    bb_mapper,
                    "mapper_pack_bones_length",
                    text = "Length:",
                    )
                row.prop(
                    bb_mapper,
                    "mapper_pack_bones_array",
                    text = "Array:",
                    )
                row.prop(
                    bb_mapper,
                    "mapper_pack_bones_gap",
                    text = "Gap:",
                    )
                row = col.row(align=True)
                row.label(
                    text = "Origin:",
                    )
                row = col.row(align=True)
                row.prop(
                    bb_mapper,
                    "mapper_pack_bones_origin_x",
                    text = "x:",
                    )
                row.prop(
                    bb_mapper,
                    "mapper_pack_bones_origin_y",
                    text = "y:",
                    )
                row.prop(
                    bb_mapper,
                    "mapper_pack_bones_origin_z",
                    text = "z:",
                    )
                row = col.row(align=True)
                row.label(
                    text = "Spacing:",
                    )
                row = col.row(align=True)
                row.prop(
                    bb_mapper,
                    "mapper_pack_bones_spacing_x",
                    text = "x:",
                    )
                row.prop(
                    bb_mapper,
                    "mapper_pack_bones_spacing_y",
                    text = "y:",
                    )
                row.prop(
                    bb_mapper,
                    "mapper_pack_bones_spacing_z",
                    text = "z:",
                    )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_mapper,
                "mapper_custom_stabilizer",
                text = "",
                icon = "INFO"
               )
            row.operator(
                "onigiri.mapper_custom_stabilizer",
                text="Create Grid Stabilizer",
                )

            bb_align_bones = bpy.context.window_manager.bb_align_bones
            layout = self.layout
            row = self.layout.row(align=True)
            box = layout.box()

            align_first_icon = "x_black"
            align_last_icon = "x_black"
            align_first_text = "First"
            align_last_text = "Last"
            
            if bpy.context.mode == 'POSE':
                if bb_align_bones.first != True:
                    if len(bpy.context.selected_pose_bones) == 1:
                        align_first_icon = "dot_red"
                else:
                    align_first_text = globals.align_bones['first'].name
                if bb_align_bones.last != True:
                    if len(bpy.context.selected_pose_bones) == 1:
                        align_last_icon = "dot_red"
                else:
                    align_last_text = globals.align_bones['last'].name

            if bb_align_bones.first == True:
                align_first_icon = "dot_green"
            if bb_align_bones.last == True:
                align_last_icon = "dot_green"
            col = box.column(align = True)

            row = col.row(align=True)
            row.prop(
                bb_align_bones,
                "align_bones_info",
                toggle = True,
                text = "Straighten Bone Segment",

                )
            row = col.row(align=True)
            row.prop(
                bb_align_bones,
                "first",
                toggle = True,
                text = align_first_text,
                icon_value = ico.custom_icons[align_first_icon].icon_id
                )
            row.prop(
                bb_align_bones,
                "last",
                toggle = True,
                text = align_last_text,
                icon_value = ico.custom_icons[align_last_icon].icon_id
                )

            if 1 == 0:
                row = col.row(align=True)
                row.prop(
                    bb_align_bones,
                    "animate",
                    toggle = True,
                    text = "Animate",
                    icon_value = ico.custom_icons["running_guy"].icon_id
                    )
            row = col.row(align=True)
            row.prop(
                bb_align_bones,
                "move",
                toggle = True,
                text = "Move",
                icon_value = ico.custom_icons["location"].icon_id
                )
            row = col.row(align=True)
            
            if 1 == 0:
                row.prop(
                    bb_align_bones,
                    "rebind",
                    toggle = True,
                    text = "Rebind",
                    icon_value = ico.custom_icons["sync"].icon_id
                    )
                row.prop(
                    bb_align_bones,
                    "offsets",
                    toggle = True,
                    text = "Preserve Offset",
                    icon_value = ico.custom_icons["sample"].icon_id
                    )

            row = col.row(align=True)
            row.operator(
                "onigiri.align_bones",
                text="Align Bones",
                icon_value = ico.custom_icons["align_bones"].icon_id
                )
            
            if 1 == 0:
                row.operator(
                    "onigiri.align_keep",
                    text="Freeze Pose",
                    icon_value = ico.custom_icons["freeze"].icon_id
                    )

        bb_motion = bpy.context.window_manager.bb_motion
        if bb_motion.clean_motion_menu_enabled == True:
            clean_motion_menu_enabled_icon = "menu_opened"
        else:
            clean_motion_menu_enabled_icon = "menu_closed"

        row = self.layout.row(align=True)
        row.prop(
            bb_motion,
            "clean_motion_menu_enabled",
            toggle = True,
            text = "Clean Motion",
            icon_value = ico.custom_icons[clean_motion_menu_enabled_icon].icon_id
            )
        if bb_motion.clean_motion_menu_enabled == True:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)
            row.operator(
                "onigiri.motion_remove_object_animation",
                text="Remove Object Animation",
                icon_value = ico.custom_icons["blank"].icon_id
                )

            row = col.row(align=True)
            row.operator(
                "onigiri.motion_apply_transforms",
                text="Apply Transforms",
                icon_value = ico.custom_icons["blank"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_motion,
                "motion_blank",
                toggle = True,
                text = "Remove Transforms",
                icon_value = ico.custom_icons["blank"].icon_id
                )

            row = col.row(align=True)
            row.operator(
                "onigiri.motion_remove_transforms",
                text="Scale",
                icon_value = ico.custom_icons["x_red"].icon_id
                ).action = "scale"
            row.operator(
                "onigiri.motion_remove_transforms",
                text="Location",
                icon_value = ico.custom_icons["x_red"].icon_id
                ).action = "trans"
            row = col.row(align=True)
            row.operator(
                "onigiri.motion_remove_transforms",
                text="Euler",
                icon_value = ico.custom_icons["x_red"].icon_id
                ).action = "euler"
            row.operator(
                "onigiri.motion_remove_transforms",
                text="Quats",
                icon_value = ico.custom_icons["x_red"].icon_id
                ).action = "quats"

            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.motion_cycle_rig",
                text="Cycle Rig",
                icon_value = ico.custom_icons["blank"].icon_id
                )

            if 1 == 0:
                row = col.row(align=True)
                row.prop(
                    bb_motion,
                    "clean_motion_location",
                    toggle = True,
                    text = "Apply Location",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_motion,
                    "clean_motion_rotation",
                    toggle = True,
                    text = "Apply Rotation",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row = col.row(align=True)
                row.prop(
                    bb_motion,
                    "clean_motion_bake",
                    toggle = True,
                    text = "Bake in transit",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_motion,
                    "clean_motion_mesh",
                    toggle = True,
                    text = "Apply to mesh",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )

            if 1 == 0: 
                col = box.column(align = True)
                row = col.row(align=True)
                row.prop(
                    bb_motion,
                    "motion_blank",
                    toggle = True,
                    text = "Hip Correction",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_motion,
                    "motion_blank",
                    toggle = True,
                    text = "Hip Correction",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )

        bb_shape = bpy.context.window_manager.bb_shape
        bb = bpy.context.scene.onigiri
        if bb_shape.shape_menu_enabled == True:
            shape_menu_enabled_icon = "menu_opened"
        else:
            shape_menu_enabled_icon = "menu_closed"

        if 1 == 0:
            row = self.layout.row(align=True)
            row.prop(
                bb_shape,
                "shape_menu_enabled",
                toggle = True,
                text = "Shape Configuration",
                icon_value = ico.custom_icons[shape_menu_enabled_icon].icon_id
                )
            if bb_shape.shape_menu_enabled == True:

                layout = self.layout
                box = layout.box()
                col = box.column(align = True)
                row = col.row(align=True)

                row.operator(
                    "onigiri.shape_load",
                    text="Load SL Shape",
                    icon_value = ico.custom_icons["load"].icon_id
                    )
                row.operator(
                    "onigiri.shape_save",
                    text="Save SL Shape",
                    icon_value = ico.custom_icons["save"].icon_id
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.shape_reset",
                    text="Reset",
                    icon_value = ico.custom_icons["reset"].icon_id
                    )
                row.operator(
                    "onigiri.shape_remove",
                    text="Remove",
                    icon_value = ico.custom_icons["x_black"].icon_id
                    )
                row = col.row(align=True)

                shape_loaded_text = " "
                shape_loaded_icon = "dot_red"
                selected = bpy.context.selected_objects
                if len(selected) == 1:
                    if selected[0].get('bb_shape_name'):
                        shape_loaded_text = selected[0]['bb_shape_name']
                        shape_loaded_icon = "dot_green"
                row.prop(
                    bb,
                    "blank",
                    text = "loaded: " + shape_loaded_text,
                    toggle = True,
                    icon_value = ico.custom_icons[shape_loaded_icon].icon_id
                    )

                if shape.props['enabled'] != False:
    
                    rig_has_shape_data = False
                    selected = bpy.context.selected_objects
                    if len(selected) == 1:
                        if selected[0].type == 'ARMATURE':
                            if selected[0].get('bb_shape_data') != None:
                                rig_has_shape_data = True
                    
                    if rig_has_shape_data:
                        row.prop(
                            bb_shape,
                            "shape_tab_body",
                            text = "Body",
                            toggle = True,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row.prop(
                            bb_shape,
                            "shape_tab_head",
                            text = "Head",
                            toggle = True,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row.prop(
                            bb_shape,
                            "shape_tab_eyes",
                            text = "Eyes",
                            toggle = True,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row = col.row(align=True)
                        row.prop(
                            bb_shape,
                            "shape_tab_ears",
                            text = "Ears",
                            toggle = True,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row.prop(
                            bb_shape,
                            "shape_tab_nose",
                            text = "Nose",
                            toggle = True,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row.prop(
                            bb_shape,
                            "shape_tab_mouth",
                            text = "Mouth",
                            toggle = True,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row = col.row(align=True)
                        row.prop(
                            bb_shape,
                            "shape_tab_chin",
                            text = "Chin",
                            toggle = True,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row.prop(
                            bb_shape,
                            "shape_tab_torso",
                            text = "Torso",
                            toggle = True,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row.prop(
                            bb_shape,
                            "shape_tab_legs",
                            text = "Legs",
                            toggle = True,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )

        if 1 == 1:

            row = self.layout.row(align=True)

            row.scale_x = 1
            row.scale_y = 1

            bb_sliders = bpy.context.scene.bb_sliders
            sliders_menu_enabled_icon = "menu_closed"
            if bb_sliders.sliders_menu_enabled == True:
                sliders_menu_enabled_icon = "menu_opened"

            row.prop(
                bb_sliders,
                "sliders_menu_enabled",
                text = "Body Shop",
                toggle = True,
                icon_value = ico.custom_icons[sliders_menu_enabled_icon].icon_id
                )

            if bb_sliders.sliders_menu_enabled == True:

                box = layout.box()
                col = box.column(align = True)
                row = col.row(align=True)

                row.operator(
                    "onigiri.sliders_store",
                    text="Store",
                    icon_value = ico.custom_icons["store"].icon_id
                    )
                row.operator(
                    "onigiri.sliders_restore",
                    text="Restore",
                    icon_value = ico.custom_icons["reset_warning"].icon_id
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.sliders_apply",
                    text="Apply Shape",
                    icon_value = ico.custom_icons["freeze"].icon_id
                    )
                row.operator(
                    "onigiri.sliders_clean",
                    text="Cleanup",
                    icon_value = ico.custom_icons["clean"].icon_id
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.sliders_reset_selected",
                    text="Reset Selected",
                    icon_value = ico.custom_icons["selected_bones"].icon_id
                    )
                row.operator(
                    "onigiri.sliders_reset_all",
                    text="Reset All",
                    icon_value = ico.custom_icons["all_bones"].icon_id
                    )

                sliders.props['this_selection'] = bpy.context.selected_objects
                if sliders.props['this_selection'] != sliders.props['last_selection']:
                    sliders.props['last_selection'] = sliders.props['this_selection']
                    
                    POLL = bb_sliders.sliders_restore_rig 

                    if len(bpy.context.selected_objects) == 1:
                        if bpy.context.selected_objects[0].type == 'ARMATURE':
                            
                            sliders.props['this_rig'] = bpy.context.selected_objects[0]
                            POLL = bb_sliders.sliders_set_rig

                rig_is_selected = False
                sliders_bones = []
                if len(bpy.context.selected_objects) == 1:
                    if bpy.context.selected_objects[0].type == 'ARMATURE':
                        rig_is_selected = True
                        sliders_rig = bpy.context.selected_objects[0]
                if rig_is_selected:
                    if bb_sliders.sliders_show_all == True:
                        for boneObj in sliders_rig.pose.bones:
                            sliders_bones.append(boneObj)
                    else:
                        
                        if bpy.context.mode == 'POSE':
                            for boneObj in bpy.context.selected_pose_bones:
                                sliders_bones.append(boneObj)

                row = col.row(align=True)
                row.prop(
                    data=bb_sliders,
                    property="sliders_blank",
                    toggle=True,
                    text= "",
                    icon_value = ico.custom_icons["sliders"].icon_id
                    )
                row.prop(
                    data=bb_sliders,
                    property="sliders_show_all",
                    toggle=True,
                    text= "Show All Sliders",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    data=bb_sliders,
                    property="sliders_rig_display_stick",
                    toggle=True,
                    text= "",
                    icon_value = ico.custom_icons["all_types"].icon_id
                    )
                row.operator(
                    "onigiri.sliders_show_all_bones",
                    text="Show All Bones",
                    )

                col = box.column(align = True)
                row = col.row(align=True)
                row.prop(
                    data=bb_sliders,
                    property="sliders_location",
                    text = "Position",
                    toggle = True,
                    icon_value = ico.custom_icons["location"].icon_id
                    )
                row.prop(
                    data=bb_sliders,
                    property="sliders_scale",
                    text = "Scale",
                    toggle = True,
                    icon_value = ico.custom_icons["scale"].icon_id
                    )

                slider_bone_icon = "bone_mixed"
                for boneObj in sliders_bones:
                    if boneObj.name in skel.avatar_skeleton:
                        if skel.avatar_skeleton[boneObj.name]['type'] == "bone":
                            slider_bone_icon = "bone_blue"
                        elif skel.avatar_skeleton[boneObj.name]['type'] == "collision":
                            slider_bone_icon = "bone_black"
                        elif skel.avatar_skeleton[boneObj.name]['type'] == "attachment":
                            slider_bone_icon = "bone_red"

                    col = box.column(align = True)
                    row = col.row(align=True)

                    slider_size = 1

                    row.prop(
                        data=bb_sliders,
                        property="sliders_blank",
                        toggle=True,
                        text= "[" + boneObj.name + "]",
                        icon_value = ico.custom_icons[slider_bone_icon].icon_id
                        )
                    row = col.row(align=True)
                    if bb_sliders.sliders_location == True:
                            row = col.row(align=True)
                            row.prop(
                                data=bb_sliders,
                                property="sliders_blank",
                                toggle=True,
                                text= "",
                                icon_value = ico.custom_icons["axis_x"].icon_id
                                )
                            row.prop(
                                data=boneObj,
                                property="bb_sliders_location_x",
                                slider=True,
                                text= "",
                                )
                            row = col.row(align=True)
                            row.prop(
                                data=bb_sliders,
                                property="sliders_blank",
                                toggle=True,
                                text= "",
                                icon_value = ico.custom_icons["axis_y"].icon_id
                                )
                            row.prop(
                                data=boneObj,
                                property="bb_sliders_location_y",
                                slider=True,
                                text= "",
                                )
                            row = col.row(align=True)
                            row.prop(
                                data=bb_sliders,
                                property="sliders_blank",
                                toggle=True,
                                text= "",
                                icon_value = ico.custom_icons["axis_z"].icon_id
                                )
                            row.prop(
                                data=boneObj,
                                property="bb_sliders_location_z",
                                slider=True,
                                text= "",
                                )
                    elif bb_sliders.sliders_scale == True:
                            row = col.row(align=True)
                            row.scale_x = slider_size
                            row.scale_y = slider_size
                            row.prop(
                                data=boneObj,
                                property="bb_sliders_scale_x_lock",
                                toggle=True,
                                text= "",
                                icon_value = ico.custom_icons["axis_x"].icon_id
                                )
                            row.prop(
                                data=boneObj,
                                property="bb_sliders_scale_x",
                                slider=True,
                                text= "",
                                )

                            row = col.row(align=True)
                            row.scale_x = slider_size
                            row.scale_y = slider_size
                            row.prop(
                                data=boneObj,
                                property="bb_sliders_scale_y_lock",
                                toggle=True,
                                text= "",
                                icon_value = ico.custom_icons["axis_y"].icon_id
                                )
                            row.prop(
                                data=boneObj,
                                property="bb_sliders_scale_y",
                                slider=True,
                                text= "",
                                )
                            row = col.row(align=True)
                            row.scale_x = slider_size
                            row.scale_y = slider_size
                            row.prop(
                                data=boneObj,
                                property="bb_sliders_scale_z_lock",
                                toggle=True,
                                text= "",
                                icon_value = ico.custom_icons["axis_z"].icon_id
                                )
                            row.prop(
                                data=boneObj,
                                property="bb_sliders_scale_z",
                                slider=True,
                                text= "",
                                )

class OnigiriInheritProperties(bpy.types.PropertyGroup):

    def update_inherit_blank(self, context):
        self["inherit_blank"] = False
        self["inherit_prefix"] = False
    inherit_blank : bpy.props.BoolProperty(
        default=False,
        update = update_inherit_blank
        )
    inherit_prefix : bpy.props.BoolProperty(
        name = "",
        description =            "This armature contains a bone name prefix, this can often times cause issues with your conversion or "            "make it completely incompatible with the provided map.  A prefix from a CC3 rig is usually already mapped "            "in so it should be ok.  Anything else aught to be removed."            "\n\n"            "To remove the prefix go over to the (Rig Tools) panel and look at (Bone Prefix) group.  If you see any text "            "of note beside it then clicking the provided button will remove it.  You can replace the prefix with another, "            "or partial, to repair a prefix for further processing, which is an advanced concept and not explained here and "            "usually not needed",
        default=False,
        update = update_inherit_blank
        )

    inherit_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Inherit Animation"            "\n\n"            "NOTE: This does not inherit motion, it is for actual keyed animations only.  Constraints and Drivers will be ignored."            "\n\n"            "Copy animated keys from a source armature to your target.  Choose your target armature first and lock it with the "            "(Lock Target) button.  Choose the animated rig and click (Inherit Animation).  The animated keys will land onto your "            "target rig.",
        default=False,
        )

    def update_inherit_target_lock(self, context):
        if self.inherit_target_lock == True:
            selected = bpy.context.selected_objects
            if len(selected) !=1:
                print("Total selected objects must be 1")
                self["inherit_target_lock"] = False
                return
            if selected[0].type != 'ARMATURE':
                print("Not an armature")
                self["inherit_target_lock"] = False
                return
            self['target'] = armObj = selected[0]
            print("Target locked:", armObj.name)
        else:
            self.pop('target', "")
            self.inherit_target_name = ""

    inherit_target_lock : bpy.props.BoolProperty(
        name = "",
        description =            "Inherit Target"            "\n\n"            "This is your rig, your character, where you want the animation to land.  Select your character rig and enable this.",
        default=False,
        update = update_inherit_target_lock
        )
    
    inherit_target_name : bpy.props.StringProperty(
        name = "",
        description =            "Inherit Target Name -- internal",
        default=""
        )
    
    inherit_view_map : bpy.props.BoolProperty(
        name = "",
        description =            "Click to view the map, useful to see when the map is flipped",
        default=False,
        )

class OnigiriInheritAnimation(bpy.types.Operator):
    """This transfers your motion to another rig.  A map is required to achieve
this so choose your target rig and click (Lock Target) then choose your animation
rig and load a map onto that then (Transfer)"""

    bl_idname = "onigiri.inherit_animation"
    bl_label = "Inherit Animation"

    @classmethod
    def poll(cls, context):
        bb_inherit = bpy.context.window_manager.bb_inherit
        
        if bb_inherit.get('target') == None:
            return False
        name = bb_inherit['target'].name
        if name not in bpy.context.scene.objects:
            bb_inherit.inherit_target_lock = False
            return False
        
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        
        if o == bb_inherit['target']:
            return False
        if o.type != 'ARMATURE':
            return False
        if o.animation_data == None:
            return False
        if o.animation_data.action == None:
            return False
        if o.get('bb_onemap_rename') == None:
            return False
        return True

    def execute(self, context):
        
        bb_inherit = bpy.context.window_manager.bb_inherit
        bb_motion = bpy.context.window_manager.bb_motion
        sarmObj = bpy.context.selected_objects[0]
        if sarmObj.animation_data:
            if sarmObj.animation_data.action:
                actionObj = sarmObj.animation_data.action

        if actionObj:
            print("Found action, baking")
        else:
            print("No action on", sarmObj.name, "so nothing to bake")
            popup("No action to bake", "Error", "ERROR")
            return {'FINISHED'}

        matrix_world = sarmObj.matrix_world.copy()
        sarmObj.location = (0,0,0)

        tarmObj = bb_inherit['target']

        state = utils.get_state()

        delete = []

        tarmObj.select_set(True)
        utils.activate(tarmObj)
        
        tframe_start, tframe_end = animutils.get_frame_range(tarmObj, start=True)
        
        tarmObj.animation_data_clear()
        
        rigutils.apply_pose(tarmObj)

        for boneObj in tarmObj.pose.bones:
            boneObj.rotation_mode = 'QUATERNION'

        bpy.ops.object.duplicate()
        
        parmObj = bpy.context.object
        delete.append(parmObj)

        motion_stabilize = bb_motion.motion_stabilize
        motion_glue = bb_motion.motion_glue
        bb_motion.motion_stabilize = False
        bb_motion.motion_glue = False

        motion.retarget_custom(inRig=sarmObj, outRig=parmObj)

        bb_motion.motion_stabilize = motion_stabilize
        bb_motion.motion_glue = motion_glue

        outRig = sarmObj['bb_motion_actor']
        
        proxyRig = sarmObj['bb_motion_proxy'] 
        delete.append(proxyRig)

        sframe_start, sframe_end = animutils.get_frame_range(sarmObj)
        result = animutils.bake_motion(sarm=parmObj, tarm=tarmObj, frame_start=sframe_start, frame_end=sframe_end)
        if result == False:
            print("The transfer failed")

        for o in bpy.context.selected_objects:
            o.select_set(True)
        utils.activate(None)

        for o in delete:
            o.select_set(True)
            utils.activate(o)
            print("Preparing object for deletion:", o.name)
        bpy.ops.object.delete()

        tarmObj.select_set(True)
        utils.activate(tarmObj)

        sarmObj.matrix_world = matrix_world

        return {'FINISHED'}

class OnigiriInheritReset(bpy.types.Operator):
    """This resets the state, it does not remove the map.  It just removes the
properties that were set as a result of engaging the tool, it does not restore
the animation"""

    bl_idname = "onigiri.inherit_reset"
    bl_label = "Inherit Reset"

    def execute(self, context):
        
        bb_inherit = bpy.context.window_manager.bb_inherit

        bb_inherit.pop('target', "")
        bb_inherit["inherit_target_lock"] = False
        print("Inherit Reset")

        return {'FINISHED'}

class OnigiriInheritReverseMap(bpy.types.Operator):
    """Reverse the map.  This does not work with mapped reskin bones, it will bring
your map out of sync.  This is for retargeting animations only but the updated
Character Converter does a great job of reskinning without doing it manually"""

    bl_idname = "onigiri.inherit_reverse_map"
    bl_label = "Reverse map"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.get('bb_onemap_rename') == None:
            return False
        return True

    def execute(self, context):
        
        bb_inherit = bpy.context.window_manager.bb_inherit

        mapObj = bpy.context.selected_objects[0]
        rename_map = mapObj['bb_onemap_rename'].to_dict()
        rename_rev = {}
        for tbone in rename_map:
            sbone = rename_map[tbone]
            rename_rev[sbone] = tbone
        mapObj['bb_onemap_rename'] = rename_rev

        print("The rename map has been reversed")

        return {'FINISHED'}

class OnigiriMotionProperties(bpy.types.PropertyGroup):

    def update_motion_blank(self, context):
        self["motion_blank"] = False
    motion_blank : bpy.props.BoolProperty(default=False, update=update_motion_blank)

    motion_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Retarget Motion"            "\n\n"            "This is where you retarget animations if any kind.  There are other retargeting tools included with Onigiri "            "that also do this but this one is a replacement for all of them except if you want to retarget multiple avatars at "            "once but that feature is going away for a more simpler approach.",
        default=False,
        )
    motion_distance : bpy.props.FloatProperty(
        name = "",
        description =            "The distance that the generated rig will be from origin on its Y axis.  This is a visual convenience but it "            "could cause location issues where your multiple mesh objects will be out of sync.  Leaving this at 0 is safe "            "if you have a streamlined workfow or set it to around 0.6 for a good visual distance when remapping.",
            default = 0.0
            )
    motion_stabilize : bpy.props.BoolProperty(
        name = "",
        description =            "Bone Stabilizer"            "\n\n"            "This will almost certainly break your avatar in Second Life if you are not using a custom rig setup.  This pins "            "the unused bones down to help prevent wobble when using an unusual hierarchy.  This is what you want if you used "            "an arbitrary bone set in the Visual Snap Mapper.  It also works for well configured bone chains as long as your "            "avatar is using all of the bones present that are glued.",
        default=False,
        )
    motion_glue : bpy.props.BoolProperty(
        name = "",
        description =            "Hard Re-Target"            "\n\n"
            "This glues the mapped target bones onto your animation source bones.  This is a brute force retargeting that can "            "work with very odd rigs or if you are retargeting a non-bipedal entity or using joint location animations on a custom rig.",
        default=False,
        )
    motion_to_animation : bpy.props.BoolProperty(
        name = "",
        description =            "Send details to animation tools"            "\n\n"            "This will send the range of your current animation to the (range) and (loop) settings in the "            "animation export tool.  The alternative is to use the (Acquire) button in the animation exporter "            "to grab the ranges.  Keep in mind that the (Loop) feature must be enabled in order for loop to work.",
        default = True,
        )
    motion_prepare_actor : bpy.props.BoolProperty(
        name = "",
        description =            "The Actor is the rig that mimics your animation.  This mimic rig is responsible for exporting your animation "            "so it must be in a somewhat clean condition.  If the tool is generating a copy of your rig for use then you "            "probably want to enable this to get a sort of mannequin skeleton without transforms or animations.  This "            "setting has no meaning when using (Glue)",
        default = False,
        )
    
    def update_motion_match_map(self, context):
        self["motion_match_map"] = True
    motion_match_map : bpy.props.BoolProperty(
        name = "",
        description =            "A map was generated using the existing rig's bone names.  To use an alternate method use (Clean Maps).  "            "To automatically generate a Second Life rig make sure (Custom Target) is disabled.",
        default = True,
        update = update_motion_match_map
        )
    
    def update_motion_interactive_menu_enabled(self, context):
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            print("Nothing selected")
            self["motion_interactive_menu_enabled"] = False
            return

        if self.motion_interactive_menu_enabled == True:
            inRig = motion.get_director(selected[0])
            if inRig == False:
                print("No director")
                self["motion_interactive_menu_enabled"] = False
                return
            outRig = inRig.get('bb_motion_actor')
            if outRig == None:
                print("No actor")
                self["motion_interactive_menu_enabled"] = False
                return
            for o in selected:
                o.select_set(False)
            inRig.select_set(True)
            outRig.select_set(True)
            utils.activate(inRig)
            bpy.ops.object.mode_set(mode='POSE')
            for boneObj in bpy.context.selected_pose_bones:
                boneObj.bone.select = False
            props['director_bone'] = ""
            props['actor_bone'] = ""

        else:
            
            inRig = motion.get_director(selected[0])
            utils.get_state()
            if inRig !=False:
                outRig = inRig.get('bb_motion_actor')
                if outRig != None:
                    outRig.select_set(True)
                    utils.activate(outRig)
                
                else:
                    print("Retargeter found a director but no actor, defaulting to selected and active director, look into this")
                    inRig.select_set(True)
                    utils.activate(inRig)

    motion_interactive_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "This enables an interactive mapper so that you can map your retarget bones right here in the retargeter for "            "a visual of how the Actor will respond with your animaton.",
        default = False,
        update = update_motion_interactive_menu_enabled
        )

    motion_view_map_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "View the mapped bones",
        default = False,
        )

    def update_motion_anchor_location_x(self, context):
        bpy.ops.onigiri.motion_anchor(transform="location", axis="x", action="disable")
    def update_motion_anchor_location_y(self, context):
        bpy.ops.onigiri.motion_anchor(transform="location", axis="y", action="disable")
    def update_motion_anchor_location_z(self, context):
        bpy.ops.onigiri.motion_anchor(transform="location", axis="z", action="disable")
    def update_motion_anchor_rotation_x(self, context):
        bpy.ops.onigiri.motion_anchor(transform="rotation", axis="x", action="disable")
    def update_motion_anchor_rotation_y(self, context):
        bpy.ops.onigiri.motion_anchor(transform="rotation", axis="y", action="disable")
    def update_motion_anchor_rotation_z(self, context):
        bpy.ops.onigiri.motion_anchor(transform="rotation", axis="z", action="disable")
    motion_anchor_location_x : bpy.props.BoolProperty(default=True, update=update_motion_anchor_location_x)
    motion_anchor_location_y : bpy.props.BoolProperty(default=True, update=update_motion_anchor_location_y)
    motion_anchor_location_z : bpy.props.BoolProperty(default=True, update=update_motion_anchor_location_z)
    motion_anchor_rotation_x : bpy.props.BoolProperty(default=False, update=update_motion_anchor_rotation_x)
    motion_anchor_rotation_y : bpy.props.BoolProperty(default=False, update=update_motion_anchor_rotation_y)
    motion_anchor_rotation_z : bpy.props.BoolProperty(default=False, update=update_motion_anchor_rotation_z)
    
    def update_constrain_location(self, context):
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            print("Nothing selected")
            self["motion_constrain_location"] = False
            return
        inRig = motion.get_director(selected[0])
        if inRig == False:
            print("No director")
            self["motion_constrain_location"] = False
            return
        
        motion.update_map(inRig=inRig)
    motion_constrain_location : bpy.props.BoolProperty(
        name = "",
        description =            "This takes a moment to engage so be patient.  Also, it only works when (Interactive Retargeting) is enabled."            "\n\n"            "Location constraints can be tricky.  It allows relative location motion which is usually not useful "            "when retargeting.  The hip / pelvis usually the only target that can benefit from this when using "            "Second Life but this works as expected so it's here but if you need this and you have a custom rig "            "then you probably want to reset the stage and use (Glue) instead.",
        default = False,
        update = update_constrain_location
        )

    clean_motion_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Clean Motion"            "\n\n"            " * Fix armature <-> animation transforms (you can fix the scale problem here)"            " * Fix hip height, location"            "\n\n",
        default=False,
        )
    clean_motion_hip_start : bpy.props.BoolProperty(
        name = "",
        description =            "start",
        default=False,
        )
    clean_motion_hip_end : bpy.props.BoolProperty(
        name = "",
        description =            "end",
        default=True,
        )
    def update_motion_use_shapes(self, context):
        if len(bpy.context.selected_objects) == 0:
            self["motion_use_shapes"] = False
            return
        armObj = bpy.context.selected_objects[0]
        inRig = motion.get_director(armObj)
        if inRig == False:
            self["motion_use_shapes"] = False
            return
        outRig = inRig['bb_motion_actor']
        outRig.data.show_bone_custom_shapes = self.motion_use_shapes

    motion_use_shapes : bpy.props.BoolProperty(
        name = "",
        description =            "The is a visual only.  It's provided in order to clean up the view when using the lock features while you're not "            "using the Glue feature.  If you're snapping your bones to the source animation rig then you will see some strange "            "configuration that cannot be easily rectified but does not affect the animation outcome.  The purpose of this switch "            "is to just be a more visually readable appearance for your work",
        default=False,
        update = update_motion_use_shapes
        )

class OnigiriMotionRemoveObjectAnimation(bpy.types.Operator):
    """This removes the animation from the object only, not the armature/bone animations"""

    bl_idname = "onigiri.motion_remove_object_animation"
    bl_label = "Remove Object Animation"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.animation_data == None:
            return False
        if o.animation_data.action == None:
            return False
        return True

    def execute(self, context):
        
        bb_motion = bpy.context.window_manager.bb_motion
        armObj = bpy.context.selected_objects[0]
        actionObj = armObj.animation_data.action
        fcurves = actionObj.fcurves
        fcurve_paths = {}
        for boneObj in armObj.data.bones:
            path_key = 'pose.bones["' + boneObj.name + '"]'
            fcurve_paths[path_key] = boneObj.name
        for fc in fcurves:
            dp, idx = fc.data_path, fc.array_index
            bone_path, delimiter, transform_type = dp.rpartition('.')
            if bone_path not in fcurve_paths:
                if bone_path == "":
                    print("Object animation detected, removing fcurve")
                    fcurves.remove(fc)

        return {'FINISHED'}

class OnigiriMotionApplyTransforms(bpy.types.Operator):
    """Choose a rig with an animation on it.  It's assumed that the animation has scale
data applied to it and you want to fix that by applying scale to the rig and also have
the animation function after this.  Other options are available"""

    bl_idname = "onigiri.motion_apply_transforms"
    bl_label = "Apply Transforms"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.animation_data == None:
            return False
        if o.animation_data.action == None:
            return False
        return True

    def execute(self, context):
        
        bb_motion = bpy.context.window_manager.bb_motion

        tarmObj = bpy.context.selected_objects[0]

        result = animutils.apply_transforms(tarmObj, report=True)

        if result == False:
            print("The call to animutils::apply_transforms seems to have failed")
            popup("Motion transfer failed", "Error", "ERROR")
            return {'FINISHED'}

        return {'FINISHED'}

class OnigiriMotionRemoveTransforms(bpy.types.Operator):
    """Remove Scale, Euler (rotation), Quaternion (rotation) or translation
(location) transforms from the animated selected pose bones."""

    bl_idname = "onigiri.motion_remove_transforms"
    bl_label = "Remove Transforms"

    action : bpy.props.StringProperty(default="scale")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        
        if o.animation_data == None:
            return False
        if o.animation_data.action == None:
            return False
        return True

    def execute(self, context):

        if self.action == "scale":
            trs = "scale"
        elif self.action == "euler":
            trs = "rotation_euler"
        elif self.action == "quats":
            trs = "rotation_quaternion"
        elif self.action == "trans":
            trs = "location"

        fcurve_paths = {}
        for boneObj in bpy.context.selected_pose_bones:
            path_key = 'pose.bones["' + boneObj.name + '"]'
            fcurve_paths[path_key] = boneObj.name

        armObj = bpy.context.selected_objects[0]
        actionObj = armObj.animation_data.action
        fcurves = actionObj.fcurves
        for fc in fcurves:
            dp, idx = fc.data_path, fc.array_index
            bone_path, delimiter, transform = dp.rpartition('.')

            if bone_path not in fcurve_paths:
                continue

            if transform == trs:
                fcurves.remove(fc)

        return {'FINISHED'}

class OnigiriMotionCycleRig(bpy.types.Operator):
    """This does a seamless export of the selected rig with it's animation in bvh
file type then imports it back.  This is a way of cleaning up a difficult rig and
associated animation"""

    bl_idname = "onigiri.motion_cycle_rig"
    bl_label = "Cycle Rig"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.animation_data == None:
            return False
        if o.animation_data.action == None:
            return False
        return True

    def execute(self, context):
        
        bb_motion = bpy.context.window_manager.bb_motion

        armObj = bpy.context.selected_objects[0]

        newObj = rigutils.cycle_rig(armObj)
        if newObj == False:
            print("Couldn't recycle rig")
            popup("Cycle failed", "Error", "ERROR")

        return {'FINISHED'}

class OnigiriMotionHipCorrectionStart(bpy.types.Operator):
    """This frame is the frame where your character/rig/animation looks correct,
it is where you would like your avatar to be instead of the broken frame, which
you will pick next.  This adjusts location/translation"""

    bl_idname = "onigiri.motion_hip_correction_start"
    bl_label = "Reference frame"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.animation_data == None:
            return False
        if o.animation_data.action == None:
            return False
        if motion.props['hip_start'] != None:
            return False
        
        if motion.props['hip_rig'] == o:
            return False
        return True

    def execute(self, context):
        bb_motion = bpy.context.window_manager.bb_motion

        armObj = bpy.context.selected_objects[0]
        motion.props['hip_rig'] = armObj
        motion.props['hip_start'] = byp.context.scene.frame_current
        
        motion.props['hip_end'] = None

        return {'FINISHED'}

class OnigiriMotionHipCorrectionEnd(bpy.types.Operator):
    """After choosing the good frame you'll move the time slider to the spot where
your avtar looks wrong.  This and all key frames after, will be position corrected
to bring your animation into the area of the first/good frame"""

    bl_idname = "onigiri.motion_hip_correction_end"
    bl_label = "Bad Frame"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.animation_data == None:
            return False
        if o.animation_data.action == None:
            return False
        if motion.props['hip_start'] == None:
            return False
        return True

    def execute(self, context):
        bb_motion = bpy.context.window_manager.bb_motion

        frame_current = bpy.context.scene.frame_start

        frame_start = motion.props['hip_start']
        frame_end = motion.props['hip_end']

        armObj = bpy.context.selected_objects[0]

        motion.props['hip_start'] = None
        motion.props['hip_end'] = None
        motion.props['hip_rig'] = None

        bpy.context.scene.frame_set(frame_start)

        return {'FINISHED'}

class OnigiriMotionHipCorrectionReset(bpy.types.Operator):
    """Reset to start.  Choosing a different rig and setting a start/reference
frame will reset the hip corrector to the new rig and frame.  This button will
clear it out without doing that to start new"""

    bl_idname = "onigiri.motion_hip_correction_reset"
    bl_label = "Reset"

    def execute(self, context):
        motion.props['hip_start'] = None
        motion.props['hip_end'] = None
        motion.props['hip_rig'] = None
        print("Hip Correction Reset")
        return {'FINISHED'}

class OnigiriMotionMapLoad(bpy.types.Operator, ImportHelper):
    """Load a map to use for your retargeting.  If one isn't available it's assumed
that the target platform is Second Life.  This must be loaded onto the rig that
contains the animation, not the target / actor"""

    bl_idname = "onigiri.motion_load_map"
    bl_label = "Load Map"

    filter_glob : bpy.props.StringProperty(
        default='*.ctm;*.ccm;*bbm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_motion = bpy.context.window_manager.bb_motion

        armObj = bpy.context.selected_objects[0] 

        file_path = self.properties.filepath
        path, name = os.path.split(self.properties.filepath)
        file_prefix = name.split(".")[0]
        ext = name.split(".")[-1]

        try:
            namespace = {}
            exec(open(file_path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}

        template = {}
        for container in namespace:
            
            if container.startswith("__"):
                continue
            template[container] = namespace[container]

        template_map = template.get('template_map', {})
        rename_map = template.get('rename', {})
        
        if len(template_map) == 0 and len(rename_map) == 0:
            print("The map you loaded is unusable")
            popup("Unusable map", "Error", "ERROR")
            return {'FINISHED'}

        rename = {}
        bone_map = {} 
        lock_map = {} 

        if len(rename_map) != 0:
            print("Found CCM")
            for bone in rename_map:
                rename[bone] = rename_map[bone]
            armObj['bb_onemap_rename'] = rename
        elif len(template_map) != 0:
            print("Found CTM")
            for sbone in template_map:
                (tarm, tbone), = template_map[sbone].items()
                bone_map[tbone] = sbone
            armObj['bb_onemap_rename'] = bone_map

        if template.get('lock') != None:
            lock_map = template['lock']
            armObj['bb_onemap_lock'] = lock_map
            print("Lock map loaded!")

        rename_map = armObj['bb_onemap_rename'].to_dict()
        bad_bones = []
        good_bones = []
        for bone in rename_map:
            if bone not in armObj.data.bones:
                bad_bones.append(bone)
            else:
                good_bones.append(bone)
        if len(good_bones) == 0:
            print("There are no mappable bones in the loaded file")
            popup("The file does not match your rig", "Error", "ERROR")
            return {'FINISHED'}
        if len(bad_bones) > 0:
            print("Some bones didn't match your rig:")
            print(bad_bones)

        print("retarget map loaded")

        return {'FINISHED'}

class OnigiriMotionMapSave(bpy.types.Operator, ExportHelper):
    """Retarget maps do not honor reskin methods so be careful when saving this.
If you intended to save a character converter map this is probably not the process
you wanted.  This is for animations, a reskin map is not loaded or saved"""

    bl_idname = "onigiri.motion_save_map"
    bl_label = "Save map"

    filename_ext = ".bbm"

    filter_glob : bpy.props.StringProperty(
        default='*.bbm',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        load_path = script_dir + data_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        inRig = motion.get_director(o)
        if inRig == False:
            return False
        if inRig.get('bb_onemap_rename') == None:
            return False
        return True

    def execute(self, context):
        bb_motion = bpy.context.window_manager.bb_motion
        inRig = bpy.context.selected_objects[0] 

        armObj = motion.get_director(inRig)
        if armObj == False:
            print("No director found for saving the map from")
            popup("No director found", "Error", "ERROR")
            return {'FINISHED'}

        file_path = self.properties.filepath
        path, name = os.path.split(self.properties.filepath)
        file_prefix = name.split(".")[0]
        ext = name.split(".")[-1]
    
        result = snap.save_map(input=armObj, file=self.filepath)
        if result == False:
            print("Something weird happened when saving the map")
            popup("Something strange happened when saving", "Error", "ERROR")

        else:
            print("Map saved!")

        return {'FINISHED'}

class OnigiriMotionMatchMap(bpy.types.Operator):
    """This creates a map for you that will match your existing bones.  This is
useful when you have an existing SL compatible rig that is animated and you are
simply retargeting the animation, i.e. converted character"""

    bl_idname = "onigiri.motion_match_map"
    bl_label = "Match Map"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        
        return True

    def execute(self, context):
        bb_motion = bpy.context.window_manager.bb_motion
        armObj = bpy.context.selected_objects[0] 
        rename_map = {}

        for boneObj in armObj.data.bones:
            bone = boneObj.name
            rename_map[bone] = bone

        armObj['bb_onemap_rename'] = rename_map

        print("Match map assigned!")

        return {'FINISHED'}

class OnigiriMotionMapClean(bpy.types.Operator):
    """Clean out the map"""

    bl_idname = "onigiri.motion_clean_map"
    bl_label = "Clean Map"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if o.get('bb_onemap_rename') == None:
            return False
        return True

    def execute(self, context):
        bb_motion = bpy.context.window_manager.bb_motion

        armObj = bpy.context.selected_objects[0] 

        del armObj['bb_onemap_rename']

        return {'FINISHED'}

class OnigiriMotionReset(bpy.types.Operator):
    """Reset the retargeter.  This will not remove your map"""

    bl_idname = "onigiri.motion_reset"
    bl_label = "Reset the retargeter"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False

        return True

    def execute(self, context):
        bb_motion = bpy.context.window_manager.bb_motion
        armObj = bpy.context.selected_objects[0]

        bpy.ops.object.mode_set(mode='OBJECT')
        utils.activate(armObj)

        inRig = motion.get_director(armObj, report=True)

        if inRig != False:
            
            print("Found director:", inRig.name)
            proxyRig = inRig.get('bb_motion_proxy')
            inRig.pop('bb_onemap_proxy', "")
            inRig.pop('bb_motion_proxy', "")

            inRig.show_in_front = inRig.pop('bb_show_in_front', True)

            if proxyRig != None:
                if proxyRig.name in bpy.context.scene.objects:
                    
                    print("Proxy rig found", proxyRig.name, "marking for deletion")
                    proxyRig.hide_set(False)
                    state = utils.get_state()
                    proxyRig.select_set(True)
                    bpy.ops.object.delete()
                    utils.purge_orphans()
                    utils.set_state(state)
            else:
                print("Missing proxy rig")

            stickyRig = inRig.get('bb_motion_stabilizer')
            inRig.pop('bb_motion_stabilizer', "")
            if stickyRig != None:
                if stickyRig.name in bpy.context.scene.objects:
                    print("Sticky rig found", stickyRig.name, "marking for deletion")
                    stickyRig.hide_set(False)
                    stickyRig.select_set(True)
            else:
                print("Missing sticky rig")
            outRig = inRig['bb_motion_actor']
            outRig.pop('bb_motion_director', "")
            
            if utils.is_valid(outRig):
                
                for o in bpy.context.selected_objects:
                    o.select_set(False)
                outRig.select_set(True)
                utils.activate(outRig)
                
                for boneObj in outRig.pose.bones:
                    for C in boneObj.constraints:
                        boneObj.constraints.remove(C)
            else:
                print("outRig missing:", outRig.name)

            selected = bpy.context.selected_objects
            if len(selected) > 0:
                o = bpy.context.selected_objects[0]
                if o == inRig:
                    o.select_set(False)
                    print("Something weird happened, the inRig was slated for deletion and this should never happen")

            bpy.ops.object.delete()
            inRig.pop('bb_motion_actor', "")
            inRig.pop('bb_motion_glue', "")
            
            for o in bpy.context.selected_objects:
                o.select_set(False)
            inRig.select_set(True)
            utils.activate(inRig)

        pop_items = ['bb_motion_actor', 'bb_motion_director', 'bb_motion_proxy', 'bb_motion_stabilizer']
        for p in pop_items:
            armObj.pop(p, "")

        bb_motion["motion_target"] = False
        bb_motion.motion_target_name = ""

        bb_motion["motion_interactive_menu_enabled"] = False

        print("Motion reset")

        return {'FINISHED'}

class OnigiriMotionAction(bpy.types.Operator):
    """Start the retargeter.  Once engaged you can use (Interactive Retarget Mapping)
to reassign bones"""

    bl_idname = "onigiri.motion_action"
    bl_label = "Start retargeting"

    report : bpy.props.BoolProperty(default=True)

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        
        if o.get('bb_motion_actor') != None or o.get('bb_motion_director') != None:
            return False
        return True

    def execute(self, context):
        bb_motion = bpy.context.window_manager.bb_motion
        inRig = bpy.context.selected_objects[0] 

        state = utils.get_state()
        try:
            print("Resetting snap mapper just in case")
            bpy.ops.onigiri.snap_reset(report=False)
        except:
            print("snap mapper was not engaged")
        utils.set_state(state)
        
        rigutils.get_layer_state(inRig)

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}

        if bb_motion.motion_glue == True:
            result = motion.retarget_hard(inRig)
            if result == False:
                print("An error occurred when attempting to engage the retargeter")
                popup("There was an error, see console", "Error", "ERROR")
                return {'FINISHED'}
            
            inRig['bb_motion_glue'] = True 
        else:
            result = motion.retarget_soft(inRig)
            if result == False:
                print("An error occurred when attempting to engage the retargeter")
                popup("There was an error, see console", "Error", "ERROR")
                return {'FINISHED'}

        for o in bpy.context.selected_objects:
            o.select_set(False)
        outRig = inRig['bb_motion_actor'] 

        if bb_motion.motion_to_animation == True:
            has_action = False
            if inRig.animation_data != None:
                if inRig.animation_data.action != None:
                    has_action = True
                    inRig.select_set(True)
                    utils.activate(inRig)
                    print("Running acquire_animation_details")
                    bpy.ops.onigiri.acquire_animation_details()
            if has_action == False:
                print("No animation to transfer, you can still inherit motion but your time settings must be set manually")
        
        motion.add_groups(inRig=inRig, outRig=outRig)
        
        result = motion.update_map(inRig=inRig) 
        if result == False:
            print("motion update_map returned False, is this a Match Map and you forgot to tick Custom Target when not using an SL rig?")
            bpy.ops.onigiri.motion_reset()
            return {'FINISHED'}

        rigutils.get_layer_state(outRig)

        inRig.select_set(False)
        outRig.select_set(True)
        utils.activate(outRig)

        inRig['bb_show_in_front'] = inRig.show_in_front

        rename_map = inRig['bb_onemap_rename']
        for sbone in rename_map.keys():
            tbone = rename_map[sbone]
            if tbone in outRig.data.bones:
                outRig.data.bones[tbone].hide = False

        if inRig.get('bb_onemap_lock') != None:
            lock_map = inRig['bb_onemap_lock'].to_dict()
            for bone in lock_map:
                if bone not in outRig.data.bones:

                    print("lock bone not in outRig:", bone)

                    continue
                boneObj = outRig.pose.bones[bone]
                for conObj in boneObj.constraints:
                    transform = conObj.type
                    if transform not in lock_map[bone]['constraints']:

                        print("constraint missing:", transform)

                        continue
                    conObj.owner_space = lock_map[bone]['constraints'][transform]['owner_space']
                    conObj.target_space = lock_map[bone]['constraints'][transform]['target_space']
                    conObj.influence = lock_map[bone]['constraints'][transform]['influence']
            print("Locks engaged!")

        state = utils.get_state()
        bpy.ops.mesh.primitive_ico_sphere_add(radius=0.1, enter_editmode=False, align='WORLD', location=(0, 0, 0))
        shapeObj = context.object

        blender3 = False 

        for boneObj in outRig.pose.bones:
            dBone = boneObj.bone
            scale = dBone.length / 2
            boneObj.custom_shape = shapeObj
            boneObj.use_custom_shape_bone_size = True

            try:
                boneObj.custom_shape_scale = 0.5
            
            except:
                blender3 = True
                boneObj.custom_shape_scale_xyz = (0.5,0.5,.05)

        if blender3 == True:
            print("Detected Blender 3 and adjusted property for custom shape scale")

        outRig.data.show_bone_custom_shapes = bb_motion.motion_use_shapes

        shapeObj.select_set(True)
        utils.activate(shapeObj)
        bpy.ops.object.delete()

        print("Toggling map updater 668")
        motion.update_map(inRig=inRig)

        utils.set_state(state)

        print("Motion Action Engaged!")

        return {'FINISHED'}

class OnigiriMotionAnchor(bpy.types.Operator):
    """Control the location and rotation influence of the root/hip/pelvis, this is
a toggle switch"""

    axis : bpy.props.StringProperty(default="")
    transform : bpy.props.StringProperty(default="")

    bl_idname = "onigiri.motion_anchor"
    bl_label = "Load Map"

    def execute(self, context):
        bb_motion = bpy.context.window_manager.bb_motion
        armObj = bpy.context.selected_objects[0]
        inRig = motion.get_director(armObj)
        if inRig == False:
            print("Nothing to do without a set")
            return {'FINISHED'}
        outRig = inRig['bb_motion_actor']

        if self.axis == "x":
            axis = "use_x"
        elif self.axis == "y":
            axis = "use_y"
        elif self.axis == "z":
            axis = "use_z"
        if self.transform == "rotation":
            transform = "COPY_ROTATION"
        elif self.transform == "location":
            transform = "COPY_LOCATION"

        boneObj = outRig.pose.bones[0]
        for C in boneObj.constraints:
            if C.type == transform:
                state = getattr(C, axis)
                state = not state 
                setattr(C, axis, state)

        return {'FINISHED'}

class OnigiriMotionMesh(bpy.types.Operator):
    """Hide or show the mesh associated with the rigs"""

    bl_idname = "onigiri.motion_mesh"
    bl_label = "Mesh Visibility"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False

        return True

    def execute(self, context):
        bb_motion = bpy.context.window_manager.bb_motion
        armObj = bpy.context.selected_objects[0]

        state = False
        if self.action == "hide":
            state = True

        inRig = motion.get_director(armObj)
        if inRig != False:
            mesh = inRig.children
            for m in mesh:
                if m.type == 'MESH':
                    m.hide_set(state)
        mesh = armObj.children
        for m in mesh:
            if m.type == 'MESH':
                m.hide_set(state)

        return {'FINISHED'}

class OnigiriMotionViewBones(bpy.types.Operator):
    """Show / Hide mapped bones"""

    bl_idname = "onigiri.motion_view_bones"
    bl_label = "View or Hide bones"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.selected_objects[0].type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_motion = bpy.context.window_manager.bb_motion
        inRig = motion.get_director(bpy.context.selected_objects[0].name)
        if inRig == False:
            print("The Director rig is not available")
            return {'FINISHED'}
        outRig = inRig['bb_motion_actor']

        rename_map = inRig.get('bb_onemap_rename')

        rigutils.get_layer_state(outRig)

        if self.action == "show":
            for boneObj in outRig.data.bones:
                boneObj.hide = False
        else:
            if rename_map == None:
                print("No map is available")
                return {'FINISHED'}
            
            rename_rev = {}
            for bone in rename_map.keys():
                sbone = rename_map[bone]
                rename_rev[sbone] = bone
            
            for boneObj in outRig.data.bones:
                if boneObj.name not in rename_rev:
                    boneObj.hide = True

        return {'FINISHED'}

class OnigiriMotionHideTarget(bpy.types.Operator):
    """Hides all of the bones in the target, giving you an easier tim selecting
bones in the animation source rig in case you need to arrange for some of them
to be locked or unlocked, use (View All Bones) to revert"""

    bl_idname = "onigiri.motion_hide_target"
    bl_label = "Hide target bones"

    def execute(self, context):
        armObj = bpy.context.selected_objects[0]
        inRig = motion.get_director(armObj)
        if inRig == False:
            print("No director present")
            return {'FINISHED'}
        outRig = inRig['bb_motion_actor']

        for boneObj in outRig.data.bones:
            boneObj.hide = True

        return {'FINISHED'}

class OnigiriMotionMapSelect(bpy.types.Operator):
    """You can select the bone indicated here by clicking this button"""

    bl_idname = "onigiri.motion_map_select"
    bl_label = "Select bones"

    in_bone : bpy.props.StringProperty(default="")
    out_bone : bpy.props.StringProperty(default="")

    def execute(self, context):
        inRig = bpy.context.selected_objects[0]
        
        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}

        rename_map = inRig['bb_onemap_rename']
        outRig = inRig['bb_motion_actor']

        if self.in_bone != "":
            inRig.data.bones[self.in_bone].select = True
        if self.out_bone != "":
            outRig.data.bones[self.out_bone].select = True

        return {'FINISHED'}

class OnigiriMotionMapAdd(bpy.types.Operator):
    """Add the chosen bones to the map"""

    bl_idname = "onigiri.motion_map_add"
    bl_label = "Map bones"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        inRig = motion.get_director(o)
        if inRig == False:
            return False
        return True

    def execute(self, context):
        
        in_bone = motion.props['director_bone']
        out_bone = motion.props['actor_bone']
        if in_bone == "" or out_bone == "":
            print("Nothing to do, slots are not full yet")
            return {'FINISHED'}

        inRig = bpy.context.selected_objects[0]
        
        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}
        outRig = inRig['bb_motion_actor']

        actor_bones = []
        director_bones = []

        rename_map = inRig['bb_onemap_rename']

        rename_rev = {}
        for sbone in rename_map:
            tbone = rename_map[sbone]
            rename_rev[tbone] = sbone
        if out_bone in rename_rev:
            sbone = rename_rev[out_bone]
            rename_map.pop(sbone, "")
        
        if in_bone in rename_map:
            tbone = rename_map[in_bone]
            if tbone in rename_rev:
                sbone = rename_rev[tbone]
                rename_map.pop(sbone, "")
        
        rename_map[in_bone] = out_bone

        motion.update_map(inRig=inRig)

        props['director_bone'] = ""
        props['actor_bone'] = ""

        return {'FINISHED'}

class OnigiriMotionMapRemove(bpy.types.Operator):
    """Remove selected bones from the map"""

    bl_idname = "onigiri.motion_map_remove"
    bl_label = "Remove bones"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        inRig = motion.get_director(o)
        if inRig == False:
            return False
        return True

    def execute(self, context):
        inRig = bpy.context.selected_objects[0]
        
        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}

        rename_map = inRig['bb_onemap_rename']
        outRig = inRig['bb_motion_actor']

        directors = []
        actors = []
        for boneObj in bpy.context.selected_pose_bones:
            if boneObj.id_data == inRig:
                directors.append(boneObj.name)
            elif boneObj.id_data == outRig:
                actors.append(boneObj.name)
            else:
                print("Got an included bone that doesn't match the rigs, [bone/rig]:", boneObj.name, boneObj.id_data.name)

        rename_map = inRig['bb_onemap_rename']
        for bone in directors:
            rename_map.pop(bone, "")
        rename_map_rev = {}
        for sbone in rename_map:
            tbone = rename_map[sbone]
            rename_map_rev[tbone] = sbone
        for bone in actors:
            if bone in rename_map_rev:
                sbone = rename_map_rev[bone]
                rename_map.pop(sbone, "")
            
        inRig['bb_onemap_rename'] = rename_map

        motion.update_map(inRig=inRig)

        for boneObj in inRig.data.bones:
            boneObj.select = False
        for boneObj in outRig.data.bones:
            boneObj.select = False

        motion.props['actor_bone'] = ""
        motion.props['director_bone'] = ""

        return {'FINISHED'}

class OnigiriMotionMapSelect(bpy.types.Operator):
    """You can select the bone indicated here by clicking this button"""

    bl_idname = "onigiri.motion_map_select"
    bl_label = "Select bones"

    in_bone : bpy.props.StringProperty(default="")
    out_bone : bpy.props.StringProperty(default="")

    def execute(self, context):
        inRig = bpy.context.selected_objects[0]
        
        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}

        rename_map = inRig['bb_onemap_rename']
        outRig = inRig['bb_motion_actor']

        if self.in_bone != "":
            inRig.data.bones[self.in_bone].select = True
        if self.out_bone != "":
            outRig.data.bones[self.out_bone].select = True

        return {'FINISHED'}

class OnigiriMotionLockSelected(bpy.types.Operator):
    """Lock / Unlock the transform type of the selected bones.  This allows you to mix
location influences of absolute and relative types with rotation data.  One use for this
is when you are using extra/unused bones in a non-custom character"""

    bl_idname = "onigiri.motion_lock_selected"
    bl_label = "Lock / Unlock Selected"

    action : bpy.props.StringProperty(default="")
    transform : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        inRig = motion.get_director(o)
        if inRig == False:
            return False
        if inRig.get('bb_onemap_rename') == None:
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        return True

    def execute(self, context):
        print("Transform:", self.transform)
        print("Action:", self.action)

        armObj = bpy.context.selected_objects[0]
        inRig = motion.get_director(armObj)

        if inRig == False:
            print("Couldn't find the director")
            popup("No actor/director association", "Error", "ERROR")
            return {'FINISHED'}

        if inRig.get('bb_onemap_rename') == None:
            print("No map available, this tool needs a map in order to enable the transforms")
            popup("No map avaialble, see console", "No map", "INFO")
            return {'FINISHED'}

        if inRig.get('bb_onemap_rename') == None:
            inRig['bb_onemap_rename'] = {}
        outRig = inRig['bb_motion_actor']
        rename_map = inRig['bb_onemap_rename']

        if self.action == "lock":
            transform_state = True
            transform_space = "WORLD"
        else:
            transform_state = False
            transform_space = "LOCAL_WITH_PARENT"

        if self.transform == "rotation":
            transform_type = "COPY_ROTATION"
        elif self.transform == "location":
            transform_type = "COPY_LOCATION"
        else:
            print("Unknown transform type:", self.transform)
            return {'FINISHED'}

        rename_rev = {}
        for sbone in rename_map:
            tbone = rename_map[sbone]
            rename_rev[tbone] = sbone

        bones_list = []
        for boneObj in bpy.context.selected_pose_bones:
            bone = boneObj.name
            if boneObj.id_data == outRig:
                if bone in rename_rev:
                    bones_list.append(boneObj)
            if boneObj.id_data == inRig:
                if bone in rename_map:
                    tbone = rename_map[bone]
                    
                    if tbone in outRig.data.bones:
                        bones_list.append(outRig.pose.bones[tbone])
        if len(bones_list) == 0:
            print("After filtering selected bones there were none left to process, is the map compatible?")
            popup("No actor bones were chosen, see console", "Error", "ERROR")
            return {'FINISHED'}

        for boneObj in bones_list:
            
            for conObj in boneObj.constraints:
                if conObj.type == transform_type:
                    if conObj.target:
                        conObj.influence = transform_state
                        conObj.owner_space = transform_space
                        conObj.target_space = transform_space

        lock_map = {}
        for boneObj in outRig.pose.bones:
            bone = boneObj.name
            for conObj in boneObj.constraints:
                if conObj.type == 'COPY_ROTATION':
                    transform = 'COPY_ROTATION'
                elif conObj.type == 'COPY_LOCATION':
                    transform = 'COPY_LOCATION'
                elif conObj.type == 'COPY_TRANSFORMS':
                    transform = 'COPY_TRANSFORMS'
                else:
                    continue
                influence = conObj.influence
                owner_space = conObj.owner_space
                target_space = conObj.target_space
                if bone not in lock_map:
                    lock_map[bone] = {}
                if 'constraints' not in lock_map[bone]:
                    lock_map[bone]['constraints'] = {}
                lock_map[bone]['constraints'][transform] = {}
                lock_map[bone]['constraints'][transform]['owner_space'] = owner_space
                lock_map[bone]['constraints'][transform]['target_space'] = target_space
                lock_map[bone]['constraints'][transform]['influence'] = influence

        inRig['bb_onemap_lock'] = lock_map

        return {'FINISHED'}

class OnigiriMotionLockRemove(bpy.types.Operator):
    """NOTE: HIT THIS BUTTON NOW, IT'S SAFE!  This feature was not well documented
and can cause issues. : This removes the lock map on the director and prevent the bones
from utilizing it on the next retarget (Action!)"""

    bl_idname = "onigiri.motion_remove_lock"
    bl_label = "Remove Lock Map"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        armObj = bpy.context.selected_objects[0]
        inRig = motion.get_director(armObj)

        if inRig == False:
            print("Couldn't find the director, will cleanup existing rig instead...")
            if armObj.get('bb_onemap_lock') != None:
                del armObj['bb_onemap_lock']
                print("Lock map removed from selected rig!")
            else:
                print("No lock map found on the selected rig")
            return {'FINISHED'}
        else:
            if inRig.get('bb_onemap_lock') == None:
                print("No lock map existed on the director")
            else:
                inRig.pop('bb_onemap_lock')
                print("Lock map removed from director!")

        return {'FINISHED'}

class OnigiriMotionApplyScale(bpy.types.Operator):
    """Apply scale to the Actor rig.  This is designed to only work with the actor for
a reason, you don't want to do this to an animated Director, use the clean tool for that"""

    bl_idname = "onigiri.motion_apply_scale"
    bl_label = "Apply Scale"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        armObj = bpy.context.selected_objects[0]
        inRig = motion.get_director(armObj)

        if inRig == False:
            print("Couldn't find the director")
            popup("No director found", "Error", "ERROR")
            return {'FINISHED'}

        if inRig.get('bb_motion_actor') == None:
            print("not an actor")
            popup("Not an actor", "Error", "ERROR")
            return {'FINISHED'}
        outRig = inRig['bb_motion_actor']
        state = utils.get_state()
        outRig.select_set(True)
        utils.activate(outRig)
        
        bpy.ops.object.transform_apply(location=False, rotation=False, scale=True)
        utils.set_state(state)

        return {'FINISHED'}

class OnigiriAnimationPanel(bpy.types.Panel):
    """This is animation tools"""
    bl_idname = "OBJECT_PT_bento_buddy_retargeting"
    bl_label = "Animation"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        bbr = bpy.context.window_manager.bb_retarget
        bba = bpy.context.scene.bb_anim_props

        bb = bpy.context.scene.onigiri
        bba = bpy.context.scene.bb_anim_props
        bb_anim = bpy.context.scene.bb_anim

        layout = self.layout

        row = self.layout.row(align=True)

        row.label(
            text = "Animation Export / Processing:"
        )
        row = self.layout.row(align=True)
        
        total_animation_frames = 0

        if len(bpy.context.selected_objects) == 1:
            o = bpy.context.selected_objects[0]
            if o.type == 'ARMATURE':
                if o.animation_data != None:
                    if o.animation_data.action != None:
                        animation_start_frame, animation_end_frame = o.animation_data.action.frame_range
                        total_animation_frames = int(animation_end_frame - animation_start_frame + 1)
        row.label(
            text = "Total Animated Frames: " + str(total_animation_frames)
        )
        row = self.layout.row(align=True)
        row.prop(
            context.scene.onigiri,
            "animation_fps",
            text = "fps",
            )
        animation_time = bpy.context.scene.onigiri.animation_time
        row.prop(
            context.scene.onigiri,
            "blank",
            text = "Time: " + str(round(animation_time, 2)),
            toggle = True,
            icon_value = ico.custom_icons["time"].icon_id
            )

        row = self.layout.row(align=True)
        
        row.operator(
            "onigiri.acquire_animation_details",
            text = "Acquire",
            )
        row = self.layout.row(align=True)

        row.prop(
            context.scene.onigiri,
            "animation_start_frame",
            text = "Start Frame",
            )
        row.prop(
            context.scene.onigiri,
            "animation_end_frame",
            text = "End Frame",
            )

        anim = bpy.context.scene.bb_anim
        bb_anim_props = bpy.context.scene.bb_anim_props

        row = self.layout.row(align=True)
        
        if anim.anim_menu_enabled == True:
            menu_state = "menu_opened"
        else:
            menu_state = "menu_closed"
        row.prop(
            anim,
            "anim_menu_enabled",
            toggle = True,
            text="Anim Export Features",
            icon_value = ico.custom_icons[menu_state].icon_id
            )
        if anim.anim_menu_enabled == True:

            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)

            row.label(
                text = "Base Name:",
                )
            row.prop(
                anim,
                "anim_base_name",
                text = "",
                )
            box.prop(
                anim,
                "anim_base_priority",
                text = "Base Priority:",
                )
            col = box.column(align = True)
            row = col.row(align=True)

            row.prop(
                anim,
                "anim_details",
                text = "Embed Anim Details",
                toggle = True,
                icon_value = ico.custom_icons["code"].icon_id
                )
            row = col.row(align=True)
            if anim.anim_details == True:
                row.prop(
                    anim,
                    "anim_details_time",
                    text = "T",
                    toggle = True,
                    )
                row.prop(
                    anim,
                    "anim_details_fps",
                    text = "F",
                    toggle = True,
                    )
                row.prop(
                    anim,
                    "anim_details_loop_enabled",
                    text = "L",
                    toggle = True,
                    )
                row.prop(
                    anim,
                    "anim_details_loop_in",
                    text = "I",
                    toggle = True,
                    )
                row.prop(
                    anim,
                    "anim_details_loop_out",
                    text = "O",
                    toggle = True,
                    )

                row.prop(
                    anim,
                    "anim_details_ease_in",
                    text = "E",
                    toggle = True,
                    )
                row.prop(
                    anim,
                    "anim_details_ease_out",
                    text = "Z",
                    toggle = True,
                    )
                row.prop(
                    anim,
                    "anim_details_priority",
                    text = "P",
                    toggle = True,
                    )

            col = box.column(align = True)
            row = col.row(align=True)

            row.prop(
                anim,
                "anim_loop",
                text = "Loop Animation",
                toggle = True,
                icon_value = ico.custom_icons["loop"].icon_id
                )

            row.prop(
                anim,
                "anim_loop_advanced",
                text = "",
                toggle = True,
                icon_value = ico.custom_icons["configure"].icon_id
                )
            col = box.column(align = True)

            row = col.row(align=True)
            if anim.anim_loop:
                if anim.anim_loop_advanced:
                    row.prop(
                        anim,
                        "anim_loop_in_time",
                        text = "Loop start time:",
                        toggle = True,
                        )
                    row.prop(
                        anim,
                        "anim_loop_out_time",
                        text = "Loop end time:",
                        toggle = True,
                        )
                else:
                    row.prop(
                        anim,
                        "anim_loop_in_frame",
                        text = "Loop start frame:",
                        toggle = True,
                        )
                    row.prop(
                        anim,
                        "anim_loop_out_frame",
                        text = "Loop end frame",
                        toggle = True,
                        )
                col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                anim,
                "anim_ease_in_duration",
                text = "Ease in:",
                )
            row.prop(
                anim,
                "anim_ease_out_duration",
                text = "Ease out:",
                )
            bb_split = bpy.context.window_manager.bb_split
            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_split,
                "split_enabled",
                text = "Split Animation",
                toggle=True,
                icon_value = ico.custom_icons["split"].icon_id
                )

            if bb_split.split_enabled == True:
                row = col.row(align=True)
                row.prop(
                    bb_split,
                    "split_blank",
                    text = "Time Segments",
                    toggle=True,
                    icon_value = ico.custom_icons["time"].icon_id
                    )
                row.prop(
                    bb_split,
                    "split_time",
                    text = "",
                    )
                row = col.row(align=True)
                row.prop(
                    bb_split,
                    "split_blank",
                    text = "Time Overlap",
                    toggle=True,
                    icon_value = ico.custom_icons["merge"].icon_id
                    )
                row.prop(
                    bb_split,
                    "split_overlap",
                    text = "",
                    )
                row = col.row(align=True)
                row.prop(
                    bb_split,
                    "split_blank",
                    text = "Time Delay",
                    toggle=True,
                    icon_value = ico.custom_icons["hourglass"].icon_id
                    )
                row.prop(
                    bb_split,
                    "split_delay",
                    text = "",
                    )

                row = col.row(align=True)
                row.prop(
                    bb_split,
                    "split_debug",
                    toggle = True,
                    text = "debug",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_split,
                    "split_owner",
                    toggle = True,
                    text = "owner",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_split,
                    "split_loop",
                    toggle = True,
                    text = "loop",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row = col.row(align=True)

                row.prop(
                    bb_split,
                    "split_kill",
                    toggle = True,
                    text = "Kill",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_split,
                    "split_touch",
                    toggle = True,
                    text = "Touch",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_split,
                    "split_listen",
                    toggle = True,
                    text = "Listen",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )

                row = col.row(align = True)
                row.prop(
                    bb_split,
                    "split_on_start",
                    toggle = True,
                    text = "On Start",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                col = box.column(align = True)
                row = col.row(align = True)
                row.prop(
                    bb_split,
                    "split_blank",
                    toggle = True,
                    text = "Channel Number",
                    )
                row.prop(
                    bb_split,
                    "split_blank",
                    toggle = True,
                    text = "Start Command",
                    )
                row.prop(
                    bb_split,
                    "split_blank",
                    toggle = True,
                    text = "Stop Command",
                    )
                row = col.row(align = True)
                row.prop(
                    bb_split,
                    "split_channel",
                    toggle = True,
                    text = "",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_split,
                    "split_start",
                    toggle = True,
                    text = "",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_split,
                    "split_stop",
                    toggle = True,
                    text = "",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.save_animation_script",
                    text = "Save Avatar Script",
                    icon_value = ico.custom_icons["script"].icon_id
                    ).target = "avatar"
                row.operator(
                    "onigiri.save_animation_script",
                    text = "Save Animesh Script",
                    icon_value = ico.custom_icons["script"].icon_id
                    ).target = "animesh"

            col = box.column(align = True)
            row = col.row(align=True)

            row.alert = anim.export_sl_anim_alert
            export_sl_anim_label = "Export Animation"
            if anim.export_sl_anim_alert == True:
                export_sl_anim_label = "Exporting, please wait..."
            row.scale_y = 1.4
            row.operator(
                "onigiri.export_sl_anim",
                
                text=export_sl_anim_label,
                icon_value = ico.custom_icons["walking_green"].icon_id
                )
            row.scale_y = 1.4
            row.alert = False
            row.operator(
                "onigiri.export_sl_pose",
                text = "Export Static Pose",
                icon_value = ico.custom_icons["walking_red"].icon_id
                )

            row = col.row(align=True)
            row.operator(
                "onigiri.bake_proxy",
                text = "Bake To Proxy",
                icon_value = ico.custom_icons["walking_blue"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)

            row.prop(
                anim,
                "anim_use_keys_smooth",
                text = "",
                toggle = True,
                icon_value = ico.custom_icons["deviation"].icon_id
                )

            row.prop(
                anim,
                "anim_high_fidelity",
                text = "High Fidelity (Bake)",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                anim,
                "anim_use_keys_linear",
                text = "",
                toggle = True,
                icon_value = ico.custom_icons["linear"].icon_id
                )
            
            if anim.anim_high_fidelity == True:
                row = col.row(align=True)
                row.enabled = anim.anim_high_fidelity
                row.prop(
                    anim,
                    "anim_use_source_keys",
                    text = "Use Source Keys",
                    toggle = True,
                    icon_value = ico.custom_icons["key_blue"].icon_id
                    )
                row.prop(
                    anim,
                    "anim_use_target_keys",
                    text = "Use Target Keys",
                    toggle = True,
                    icon_value = ico.custom_icons["key_red"].icon_id
                    )
                row = col.row(align=True)
                row.enabled = anim.anim_high_fidelity
                row.prop(
                    anim,
                    "anim_use_source_keys_rotation",
                    text = "Rotation",
                    toggle = True,
                    icon_value = ico.custom_icons["rotation_blue"].icon_id
                    )
                row.prop(
                    anim,
                    "anim_use_source_keys_location",
                    text = "Location",
                    toggle = True,
                    icon_value = ico.custom_icons["location_blue"].icon_id
                    )
                row.prop(
                    anim,
                    "anim_use_target_keys_rotation",
                    text = "Rotation",
                    toggle = True,
                    icon_value = ico.custom_icons["rotation_red"].icon_id
                    )
                row.prop(
                    anim,
                    "anim_use_target_keys_location",
                    text = "Location",
                    toggle = True,
                    icon_value = ico.custom_icons["location_red"].icon_id
                    )

                row = col.row(align=True)

                row.prop(
                    anim,
                    "anim_linear",
                    text="Linear Motion",
                    toggle = True,
                    icon_value = ico.custom_icons["linear"].icon_id
                    )

            row = col.row(align=True)
            row.prop(
                anim,
                "export_mapped_animation",
                text="Export Mapped Animation",
                toggle = True,
                icon_value = ico.custom_icons["map_bones"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb,
                "blank",
                text = "Bone Types Motion Exports",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bb,
                "export_volume_motion",
                text = "Volume",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bb,
                "export_attachment_motion",
                text = "Attachment",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )

            if bba.disable_location_offsets == True:
                disable_location_offsets_icon = "check_red"
            else:
                disable_location_offsets_icon = "check_black"
            row = col.row(align=True)
            row.prop(
                bb_anim_props,
                "disable_location_offsets",
                text = "Disable Location Animations",
                toggle = True,
                icon_value = ico.custom_icons[disable_location_offsets_icon].icon_id
                )
            row.prop(
                bb_anim_props,
                "disable_pelvis_location_animation",
                text = "",
                toggle = True,
                icon_value = ico.custom_icons["anchor"].icon_id
                )

            if bb.export_onigiri_disabled == True:
                export_onigiri_disabled_icon = "check_red"
            else:
                export_onigiri_disabled_icon = "check_black"
            row = col.row(align = False)
            row.prop(
                context.scene.onigiri,
                "export_onigiri_disabled",
                text="Disable Onigiri only check",
                icon_value = ico.custom_icons[export_onigiri_disabled_icon].icon_id
                )

            row = col.row(align = True)

            if bb.export_avastar_disabled == True:
                export_avastar_disabled_icon = "check_red"
            else:
                export_avastar_disabled_icon = "check_black"
            row.prop(
                context.scene.onigiri,
                "export_avastar_disabled",
                text="Disable Avastar Rig Checking",
                icon_value = ico.custom_icons[export_avastar_disabled_icon].icon_id
                )

            if bb.export_avastar_deform_bones == True:
                export_avastar_deform_bones_icon = "check_red"
            else:
                export_avastar_deform_bones_icon = "check_black"
            row = col.row(align = True)
            row.prop(
                context.scene.onigiri,
                "export_avastar_deform_bones",
                text="Export Avastar Deform Bones",
                icon_value = ico.custom_icons[export_avastar_deform_bones_icon].icon_id
                )

            anim_unfold_menu_enabled_icon = "menu_closed"
            if anim.anim_unfold_menu_enabled == True:
                anim_unfold_menu_enabled_icon = "menu_opened"
            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                anim,
                "anim_unfold_menu_enabled",
                text = "Expand lots of options",
                toggle = True,
                icon_value = ico.custom_icons[anim_unfold_menu_enabled_icon].icon_id
                )
            
            if anim.anim_unfold_menu_enabled == True:

                col = box.column(align = True)

                row = col.row(align=True)
                
                if 1 == 0:
                    row = col.row(align=True)
                    row.prop(
                        anim,
                        "anim_deviation_detection",
                        text = "",
                        toggle = True,
                        icon_value = ico.custom_icons["deviation"].icon_id
                        )

                    row.prop(
                        anim,
                        "anim_deviation_detection",
                        text = "Smooth Motion",
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )

                if 1 == 0:
                    row.prop(
                        anim,
                        "anim_deviation_rotation",
                        text = "Rot:",
                        toggle = True,
                        )
                    row.prop(
                        anim,
                        "anim_deviation_location",
                        text = "Loc:",
                        toggle = True,
                        )
                    row = col.row(align=True)

                native_features_menu_enabled_icon = "menu_closed"
                if anim.native_features_menu_enabled == True:
                    native_features_menu_enabled_icon = "menu_opened"

                col = box.column(align = True)
                row = col.row(align=True)

                row.prop(
                    anim,
                    "native_features_menu_enabled",
                    text = "Anim Extended Features",
                    icon_value = ico.custom_icons[native_features_menu_enabled_icon].icon_id
                    )

                if anim.native_features_menu_enabled == True:
    
                    row = col.row(align = True)

                    if anim.mark_tol_options == True:
                        mark_tol_options_icon = "menu_opened"
                    else:
                        mark_tol_options_icon = "menu_closed"

                    col = box.column(align = True)
                    row = col.row(align = True)

                    row.alert = anim.export_sl_anim_old_alert
                    export_sl_anim_old_label = "Use old exporter"
                    if anim.export_sl_anim_old_alert == True:
                        export_sl_anim_old_label = "Exporting, please wait..."
                    row.scale_y = 1.3
                    row.operator(
                        "onigiri.export_sl_anim_old",
                        
                        text=export_sl_anim_old_label,
                        icon_value = ico.custom_icons["running_guy"].icon_id
                        )
                    row.scale_y = 1
                    row.alert = False
                    row.prop(
                        anim,
                        "anim_preserve_interpolation",
                        text = "",
                        toggle = True,
                        icon_value = ico.custom_icons["curves"].icon_id
                        )

                    col = box.column(align = True)
                    row = col.row(align = True)

                    row.prop(
                        anim,
                        "mark_tol_options",
                        text = "Key Cleanup Options",
                        icon_value = ico.custom_icons[mark_tol_options_icon].icon_id
                        )
    
                    row = col.row(align=True)
                    if anim.mark_tol_options == True:
                        col = box.column(align = True)
                        row = col.row(align=True)

                        row.prop(
                            context.scene.bb_anim_props,
                            "remove_isolated_keys",
                            toggle = True,
                            text="Remove Isolated Keys",
                            )
                        
                        row = col.row(align=True)

                        row.prop(
                            bb,
                            "blank",
                            text = "",
                            toggle = True,
                            icon_value = ico.custom_icons["tolerance"].icon_id
                            )
                        row.prop(
                            anim,
                            "mark_tol",
                            text = "Tolerance:",
                            toggle = True,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                        row.prop(
                            anim,
                            "mark_tol_rot",
                            text = "Rot:",
                            )
                        row.prop(
                            anim,
                            "mark_tol_loc",
                            text = "Loc:",
                            )

                        if 1 == 0:
                            row = col.row(align=True)
                            row.prop(
                                anim,
                                "anim_resample_auto",
                                text = "",
                                toggle = True,
                                icon_value = ico.custom_icons["sample"].icon_id
                                )
                            row.prop(
                                anim,
                                "anim_resample",
                                text = "Resample:",
                                toggle = True,
                                icon_value = ico.custom_icons["blank"].icon_id
                                )
                            row.prop(
                                anim,
                                "anim_resample_rate_rotation",
                                text = "Rot:",
                                )
                            row.prop(
                                anim,
                                "anim_resample_rate_location",
                                text = "Loc:",
                                )

                        if 1 == 0:
                            
                            col = box.column(align = True)
                            row = col.row(align=True)
                            row.operator(
                                "onigiri.anim_keep_bone_transforms",
                                text = "",
                                icon_value = ico.custom_icons["reset"].icon_id
                                ).action = "sub_all"

                            row.prop(
                                bb,
                                "blank",
                                text = "Protect From Cleanup",
                                toggle = True,
                                icon_value = ico.custom_icons["blank"].icon_id
                                )
                            
                            row.operator(
                                "onigiri.anim_keep_key_transforms",
                                text = "",
                                icon_value = ico.custom_icons["reset"].icon_id
                                ).action = "sub_all"

                            row = col.row(align=True)
                            row.operator(
                                "onigiri.anim_keep_bone_transforms",
                                text = "",
                                icon_value = ico.custom_icons["subtract"].icon_id
                                ).action = "sub_rot"
                            row.operator(
                                "onigiri.anim_keep_bone_transforms",
                                text = "",
                                icon_value = ico.custom_icons["add"].icon_id
                                ).action = "add_rot"
                            row.operator(
                                "onigiri.anim_keep_bone_transforms",
                                text = "Bone Rotation:",
                                )

                            row.operator(
                                "onigiri.anim_keep_key_transforms",
                                text = "Key Rotation:",
                                )
                            row.operator(
                                "onigiri.anim_keep_key_transforms",
                                text = "",
                                icon_value = ico.custom_icons["add"].icon_id
                                ).action = "add_rot"
                            row.operator(
                                "onigiri.anim_keep_key_transforms",
                                text = "",
                                icon_value = ico.custom_icons["subtract"].icon_id
                                ).action = "sub_rot"

                            row = col.row(align=True)

                            row.operator(
                                "onigiri.anim_keep_bone_transforms",
                                text = "",
                                icon_value = ico.custom_icons["subtract"].icon_id
                                ).action = "sub_loc"
                            row.operator(
                                "onigiri.anim_keep_bone_transforms",
                                text = "",
                                icon_value = ico.custom_icons["add"].icon_id
                                ).action = "add_loc"
                            row.operator(
                                "onigiri.anim_keep_bone_transforms",
                                text = "Bone Location:",
                                )

                            row.operator(
                                "onigiri.anim_keep_key_transforms",
                                text = "Key Location:",
                                )
                            row.operator(
                                "onigiri.anim_keep_key_transforms",
                                text = "",
                                icon_value = ico.custom_icons["add"].icon_id
                                ).action = "add_loc"
                            row.operator(
                                "onigiri.anim_keep_key_transforms",
                                text = "",
                                icon_value = ico.custom_icons["subtract"].icon_id
                                ).action = "sub_loc"
                            row = col.row(align=True)

                            selected_bone = "None"
                            selected_bone_overrides = {}
                            frame_current = str(bpy.context.scene.frame_current)
                            bone_rot_text = "Rotation: None"
                            bone_loc_text = "Location: None"
                            key_rot_text = "Rotation: None"
                            key_loc_text = "Location: None"
                            if bpy.context.mode == 'POSE':
                                if len(bpy.context.selected_pose_bones) != 0:
                                    pBone = bpy.context.selected_pose_bones[0]
                                    dBone = pBone.bone
                                    selected_bone = dBone.name
                                    if dBone.get('cleaner') != None and dBone['cleaner'].get('bone') != None:
                                        bone_rot_text = "Rotation: " + dBone['cleaner']['bone']['rot_text']
                                        bone_loc_text = "Location: " + dBone['cleaner']['bone']['loc_text']
                                    if dBone.get('cleaner') != None and dBone['cleaner'].get('frames') != None:
                                        if dBone['cleaner']['frames'].get(frame_current) != None:
                                            key_rot_text = "Rotation: " + dBone['cleaner']['frames'][frame_current]['rot_text']
                                            key_loc_text = "Location: " + dBone['cleaner']['frames'][frame_current]['loc_text']

                                    if len(bpy.context.selected_pose_bones) > 1:
                                        selected_bone = str( len(bpy.context.selected_pose_bones) )

                            col = box.column(align = True)
                            row = col.row(align=True)
                            row.label(text = "- Overrides -")
                            row = col.row(align=True)
                            row.label(text = "Selected Bone(s): " + selected_bone)
                            row = col.row(align=True)
                            row.label(text = "  Bone:")
                            row = col.row(align=True)
                            row.label(text = "    - " + bone_rot_text)
                            row = col.row(align=True)
                            row.label(text = "    - " + bone_loc_text)
                            row = col.row(align=True)
                            row.label(text = "Selected Key: " + frame_current)
                            row = col.row(align=True)
                            row.label(text = "  Key:")
                            row = col.row(align=True)
                            row.label(text = "    - " + key_rot_text)
                            row = col.row(align=True)
                            row.label(text = "    - " + key_loc_text)
                            
                    anim_joint_priority_menu_enabled_icon = "menu_closed"
                    if anim.anim_joint_priority_menu_enabled == True:
                        anim_joint_priority_menu_enabled_icon = "menu_opened"

                    col = box.column(align = True)
                    row = col.row(align=True)

                    row.prop(
                        anim,
                        "anim_joint_priority_menu_enabled",
                        text = "Joint Priority Options",
                        toggle = True,
                        icon_value = ico.custom_icons[anim_joint_priority_menu_enabled_icon].icon_id,
                        )
                    row = col.row(align=True)

                    if anim.anim_joint_priority_menu_enabled == True:
                        
                        col = box.column(align = True)
                        row = col.row(align=True)
                        row.operator(
                            "onigiri.anim_enable_joint_priority",
                            text = "Enable Override",
                            )
                        row.operator(
                            "onigiri.anim_disable_joint_priority",
                            text = "Disable Override",
                            )
                        col = box.column(align = True)

                        row = col.row(align=True)
                        row.label(
                            text = "Apply Joint Priority:",
                            )
                        row = col.row(align=True)
                        for p in range(-1, 7):
                            row.operator(
                                "onigiri.anim_apply_joint_priority",
                                text=str(p),
                                ).priority = p
                        row = col.row(align=True)
                        col = box.column(align = True)

                        row = col.row(align=True)
                        col = box.column(align = True)
                        row.label(
                            text = "Select bones by priority: " + str(anim.anim_selected_pose_bones),
                            )
                        row = col.row(align=True)
                        for p in range(-1, 7):
                            row.operator(
                                "onigiri.select_priority",
                                text=str(p),
                                ).priority = p

                        row = col.row(align=True)
                        row.prop(
                            anim,
                            "anim_joint_priority_view_enabled",
                            text = "View selected priorities",
                            toggle = True,
                            )
                        
                        if anim.anim_joint_priority_view_enabled == True:
                            if selected_pose_bones() != False:
                                for boneObj in bpy.context.selected_pose_bones:
                                    priority = boneObj.get('priority')
                                    if priority == None:
                                        priority = anim.anim_base_priority
                                    
                                    enabled = "No "
                                    if boneObj.get('priority_enabled') == 1:
                                        enabled = "Yes"
                                    row = col.row(align=True)
                                    row.label(
                                        text = "P: " + str(priority) + " E: " + enabled + " Name: " + boneObj.name
                                        )

                    col = box.column(align = True)
                    row = col.row(align=True)
                    anim_interpolation_menu_enabled_icon = "menu_closed"
                    if anim.anim_interpolation_menu_enabled == True:
                        anim_interpolation_menu_enabled_icon = "menu_opened"

                    row.prop(
                        context.scene.bb_anim,
                        "anim_interpolation_menu_enabled",
                        text = "Interpolation Options",
                        icon_value = ico.custom_icons[anim_interpolation_menu_enabled_icon].icon_id,
                        )

                    if anim.anim_interpolation_menu_enabled == True:
                        
                        row = col.row(align=True)
                        box.label(
                            text = "Interpolation Method:",
                            )
                        col = box.column(align = True)
                        row = col.row(align=True)

                        row.prop(
                            context.scene.bb_anim,
                            "anim_interpolate_bone",
                            text = "Entire Bone / Curve",
                            icon_value = ico.custom_icons["bone"].icon_id,
                            )
                        row = col.row(align=True)
         
                        row.operator(
                            "onigiri.set_interpolation",
                            text = "Bezier",
                            icon="IPO_BEZIER"
                            ).mode = "BEZIER"
                        row.operator(
                            "onigiri.set_interpolation",
                            text = "Linear",
                            icon="IPO_LINEAR"
                            ).mode = "LINEAR"
                        row.operator(
                            "onigiri.set_interpolation",
                            text = "Constant",
                            icon="IPO_CONSTANT"
                            ).mode = "CONSTANT"
                        
                        row = col.row(align=True)
                        for interp in extra_interpolation_types:
                            row.operator(
                                "onigiri.set_interpolation",
                                text = " ",
                                icon=extra_interpolation_types[interp]
                                ).mode = interp
                    
                    anim_expression_menu_enabled_icon = "menu_closed"
                    if anim.anim_expression_menu_enabled == True:
                        anim_expression_menu_enabled_icon = "menu_opened"

                    col = box.column(align = True)
                    row = col.row(align=True)
                    row.prop(
                        context.scene.bb_anim,
                        "anim_expression_menu_enabled",
                        text = "Expression Options",
                        icon_value = ico.custom_icons[anim_expression_menu_enabled_icon].icon_id,
                        )

                    if anim.anim_expression_menu_enabled == True:
                        row = col.row(align=True)
                        box.prop(
                            anim,
                            "anim_hand_pose_enabled",
                            text = "Use an internal hand pose",
                            toggle = True,
                            icon_value = ico.custom_icons["hand_love"].icon_id
                            )
                        if anim.anim_hand_pose_enabled:
                            box.prop_menu_enum(
                                anim,
                                "anim_hand_pose",
                                )

                        col = box.column(align = True)
                        row = col.row(align=True)
                        anim_emote_menu_enabled_icon = "menu_closed"
                        if anim.anim_emote_menu_enabled == True:
                            anim_emote_menu_enabled_icon = "menu_opened"
                        row.prop(
                            anim,
                            "anim_emote_menu_enabled",
                            text = "Emote List",
                            icon_value = ico.custom_icons[anim_emote_menu_enabled_icon].icon_id
                            )
                        if anim.anim_emote_menu_enabled == True:
                            col = box.column(align = True)
                            row = col.row(align=True)

                            row.label(
                                text = "- Emote list coded by Candy"
                                )
                            row = col.row(align=True)
                            row.label(
                                text = "- Emote Name: " + anim.anim_emote_name,
                                )
                        
                            col = box.column(align = True)
                            row = col.row(align=True)
                            row.operator(
                                "onigiri.add_emote",
                                text="Clear",
                                icon_value = ico.custom_icons["x_red"].icon_id
                                ).emote = ""
                            col = box.column(align = True)
                            row = col.row(align=True)

                            for emote in gestures.emote:
                                if emote == anim.anim_emote_name:
                                    chosen_icon = "check_green"
                                else:
                                    chosen_icon = "blank"
                                p = gestures.emote[emote].get('priority')
                                if p != None:
                                    p = str(p)
                                l = gestures.emote[emote].get('looped')
                                if l == True:
                                    l = "yes"
                                elif l == False:
                                    l = "no"
                                else:
                                    l = "unknown"
                                row = col.row(align=True)
                                row.operator(
                                    "onigiri.add_emote",
                                    text=emote + " - Looped: " + l + " / Priority: " + p,
                                    icon_value = ico.custom_icons[chosen_icon].icon_id
                                    ).emote = emote

                        if anim.anim_show_actions == True:
                            col = box.column(align = True)
                            row = col.row(align=True)
                            row.label(
                                text = "- Enable items to export -",
                                )
                            for actionObj in bpy.data.actions:
                                row = col.row(align=True)
                                row.prop(
                                    anim,
                                    "anim_action_selected",
                                    text = "",
                                )
                                row.label(
                                    text = actionObj.name,
                                )

        row = self.layout.row(align=True)
        if bpy.context.scene.onigiri.bvh_menu_enabled == False:
            menu_state = "menu_closed"
        else:
            menu_state = "menu_opened"

        row.prop(
            context.scene.onigiri,
            "bvh_menu_enabled",
            text="BVH Export Features",
            toggle = True,
            icon_value = ico.custom_icons[menu_state].icon_id
            )

        if bpy.context.scene.onigiri.bvh_menu_enabled == True:
            bb = bpy.context.scene.onigiri
            bba = bpy.context.scene.bb_anim_props
            bb_anim = bpy.context.scene.bb_anim

            if bb.bvh_to_sl == True:
                bvh_to_sl_icon = "check_green"
            else:
                bvh_to_sl_icon = "check_black"

            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                context.scene.onigiri,
                "bvh_to_sl",
                toggle=True,
                text="Use BVH standard names",
                icon_value = ico.custom_icons[bvh_to_sl_icon].icon_id
                )

            row = col.row(align=True)
            row.separator()
            row = col.row(align=True)
            
            row.alert = bba.export_sl_bvh_alert
            row.operator(
                "onigiri.export_bvh_sl",
                
                text=bba.export_sl_bvh_label,
                icon_value = ico.custom_icons["running_guy"].icon_id
                )
            row = col.row(align=True)

        extended_animation_options_icon = "menu_closed"
        if bb.extended_animation_options == True:
            extended_animation_options_icon = "menu_opened"

        row = self.layout.row(align=True)
        row.prop(
            bb,
            "extended_animation_options",
            text = "Extended Options",
            toggle = True,
            icon_value = ico.custom_icons[extended_animation_options_icon].icon_id
            )

        if bb.extended_animation_options == True:

            if bb.export_onigiri_disabled == True:
                export_onigiri_disabled_icon = "check_red"
            else:
                export_onigiri_disabled_icon = "check_black"

            if bb.export_sl_limitations_check_disabled == True:
                export_sl_limitations_check_disabled_icon = "check_red"
            else:
                export_onigiri_disabled_icon = "check_black"

            if bb.export_volume_motion == True:
                export_volume_motion_icon = "check_green"
            else:
                export_volume_motion_icon = "check_black"

            if bb.bake_animation == True:
                bake_animation_icon = "check_yellow"
            else:
                bake_animation_icon = "check_black"

            if bba.disable_location_offsets == True:
                disable_location_offsets_icon = "check_red"
            else:
                disable_location_offsets_icon = "check_black"

            if bb.export_translations == True:
                export_translations_icon = "check_red"
            else:
                export_translations_icon = "check_black"

            layout = self.layout
            box = layout.box()
            col = box.column(align = False)

            row = col.row(align = False)
            row.prop(
                context.scene.onigiri,
                "export_onigiri_disabled",
                text="Disable Onigiri only check",
                icon_value = ico.custom_icons[export_onigiri_disabled_icon].icon_id
                )
            row = col.row(align = False)
            row.prop(
                context.scene.onigiri,
                "export_sl_limitations_check_disabled",
                text="Disable SL / OS limitations check",
                icon_value = ico.custom_icons[export_onigiri_disabled_icon].icon_id
                )

            row = col.row(align = False)
            row.prop(
                context.scene.onigiri,
                "export_volume_motion",
                text="Export with Volume Motion",
                icon_value = ico.custom_icons[export_volume_motion_icon].icon_id
                )
            row = col.row(align = True)
            row.prop(
                context.scene.bb_anim_props,
                "disable_location_offsets",
                toggle = True,
                text="Export with Disabled Location Motion",
                icon_value = ico.custom_icons[disable_location_offsets_icon].icon_id
                )
            row.prop(
                context.scene.bb_anim_props,
                "disable_pelvis_location_animation",
                toggle = True,
                text="",
                icon_value = ico.custom_icons["anchor"].icon_id
                )

            row = col.row(align = True)
            row.alert = bb_anim.bake_animation_alert
            row = col.row(align = True)
            row.operator(
                "onigiri.teflon",
                
                text = bb_anim.bake_animation_label,
                icon_value = ico.custom_icons["bake"].icon_id
                )
            row.scale_x = 0.3
            row.prop(
                bb_anim,
                "bake_frame_step",
                text = "",
                )
        
        bb_deform = bpy.context.window_manager.bb_deform
        row = self.layout.row(align=True)
        deformer_menu_enabled_icon = "menu_closed"
        if bb_deform.deformer_menu_enabled == True:
            deformer_menu_enabled_icon = "menu_opened"
        row.prop(
            context.window_manager.bb_deform,
            "deformer_menu_enabled",
            text = "Deformer",
            icon_value = ico.custom_icons[deformer_menu_enabled_icon].icon_id,
            )
        if bb_deform.deformer_menu_enabled == True:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align = True)
            row.operator(
                "onigiri.create_deformer",
                text="Create Deformer",
                )
            
            row.operator(
                "onigiri.create_deformer_mapped",
                text="Create Mapped Deformer",
                )
            row = col.row(align = True)
            row.prop(
                context.window_manager.bb_deform,
                "deformer_transform_location",
                text = "Deform Bone Positions",
                toggle = True
                )
            row.prop(
                context.window_manager.bb_deform,
                "deformer_transform_rotation",
                text = "Deform Bone Rotations",
                toggle = True
                )
            
            if 1 == 0:
                row = col.row(align = True)
                row.prop(
                    context.window_manager.bb_deform,
                    "deformer_default",
                    text = "Start with a default rig",
                    icon_value = ico.custom_icons["default"].icon_id,
                    )

            row = col.row(align = True)
            row.prop(
                context.window_manager.bb_deform,
                "deformer_acquire_animation_details",
                text = "Acquire Deformer Details",
                icon_value = ico.custom_icons["undeform"].icon_id
                )

        if context.scene.bb_anim_props.scale_animation_menu == True:
            scale_animation_menu_icon = "menu_opened"
        else:
            scale_animation_menu_icon = "menu_closed"
        row = self.layout.row(align=True)
        row.prop(
            context.scene.bb_anim_props,
            "scale_animation_menu",
            text = "Resize Animation ",
            icon_value = ico.custom_icons[scale_animation_menu_icon].icon_id
            )
        if context.scene.bb_anim_props.scale_animation_menu == True:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align = True)

            row = col.row(align = True)
            row.separator()
            row.label(
                text = "Scale Animation:"
            )
            row.label(
                text = "Total Frames: " + str(context.scene.bb_anim_props.scale_total_frames),
            )
            row = col.row(align = True)
            row.prop(
                context.scene.bb_anim_props,
                "scale_first_frame",
                text = "First"
                )
            row.prop(
                context.scene.bb_anim_props,
                "scale_last_frame",
                text = "Last"
                )
            row = col.row(align = True)
            row.operator(
                "onigiri.scale_animation",
                text="Scale Active Animation",
                icon_value = ico.custom_icons["scale_animation"].icon_id
                )
        
        bba = bpy.context.scene.bb_anim_props

        if bba.reference_pose_menu_enabled == True:
            reference_pose_menu_enabled_icon = "menu_opened"
        else:
            reference_pose_menu_enabled_icon = "menu_closed"

        row = self.layout.row(align=True)
        row.prop(
            context.scene.bb_anim_props,
            "reference_pose_menu_enabled",
            text = "Reference Pose Features",
            icon_value = ico.custom_icons[reference_pose_menu_enabled_icon].icon_id,
            )

        if bba.reference_pose_menu_enabled == True:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            if 1 == 0:
                row = col.row(align=True)
                row.operator(
                    "onigiri.pose_library_load",
                    text="Load Pose Lib",
                    icon_value = ico.custom_icons["load"].icon_id,
                    )
                row.operator(
                    "onigiri.pose_library_save",
                    text="Save Pose Lib",
                    icon_value = ico.custom_icons["save"].icon_id,
                    )
                row.operator(
                    "onigiri.pose_library_merge",
                    text="Merge Pose Lib",
                    icon_value = ico.custom_icons["merge"].icon_id,
                    )
                row = col.row(align=True)
                row.prop(
                    context.scene.bb_anim_props,
                    "lock_source_armature",
                    text = "Lock Source",
                    icon_value = ico.custom_icons["dot_blue"].icon_id,
                    )
                row.prop(
                    context.scene.bb_anim_props,
                    "lock_target_armature",
                    text = "Lock Target",
                    icon_value = ico.custom_icons["dot_red"].icon_id,
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.load_reference_map",
                    text="Load Template",
                    icon_value = ico.custom_icons["load"].icon_id,
                    )
                row = col.row(align=True)
                row.prop(
                    context.scene.bb_anim_props,
                    "match_pose_selected",
                    text = "Selected Only",
                    icon_value = ico.custom_icons["selection"].icon_id,
                    )
                row.prop(
                    context.scene.bb_anim_props,
                    "match_root_bones",
                    text = "Root Bones",
                    icon_value = ico.custom_icons["anchor"].icon_id,
                    )
                row.operator(
                    "onigiri.match_pose_reset",
                    text = "Reset",
                    icon_value = ico.custom_icons["reset"].icon_id,
                    )

                row = col.row(align=True)
                row.operator(
                    "onigiri.match_pose",
                    text = "Match Pose to Source",
                    icon_value = ico.custom_icons["sync"].icon_id,
                    )
                row.scale_x = 0.2
                row.prop(
                    context.scene.bb_anim_props,
                    "match_x_axis",
                    text = "X",
                    toggle=True,
                    )
                row.prop(
                    context.scene.bb_anim_props,
                    "match_y_axis",
                    text = "Y",
                    toggle=True,
                    )
                row.prop(
                    context.scene.bb_anim_props,
                    "match_z_axis",
                    text = "Z",
                    toggle=True,
                    )

            row = col.row(align=True)
            row.prop(
                context.scene.bb_anim_props,
                "pose_clear_location",
                text = "Clear Location",
                icon_value = ico.custom_icons["location"].icon_id,
                )
            row.prop(
                context.scene.bb_anim_props,
                "pose_clear_location_root",
                text = "Clear Root Location",
                icon_value = ico.custom_icons["center"].icon_id,
                )
            row = col.row(align=True)
            row.prop(
                context.scene.bb_anim_props,
                "reference_from_pose",
                text = "Reference from pose",
                icon_value = ico.custom_icons["arrow_left_green"].icon_id,
                )
            row.operator(
                "onigiri.restore_reference_pose",
                text="Restore reference pose",
                icon_value = ico.custom_icons["reset"].icon_id,
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.create_reference_pose",
                text="Create reference pose",
                )

        anim_misc_menu_enabled_icon = "menu_closed"
        if bb_anim.anim_misc_menu_enabled == True:
            anim_misc_menu_enabled_icon = "menu_opened"

        row = self.layout.row(align=True)
        row.prop(
            context.scene.bb_anim,
            "anim_misc_menu_enabled",
            text = "Misc Options",
            icon_value = ico.custom_icons[anim_misc_menu_enabled_icon].icon_id,
            )

        if bb_anim.anim_misc_menu_enabled == True:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.remove_animation_keys",
                text="Remove animation from selected bones",
                icon_value = ico.custom_icons["remove_keys"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                context.scene.onigiri,
                "blank",
                text = "Interpolation Methods",
                icon_value = ico.custom_icons["blank"].icon_id,
                )
            row = col.row(align=True)

            row.prop(
                context.scene.bb_anim,
                "anim_interpolate_bone",
                text = "Entire Bone / Curve",
                icon_value = ico.custom_icons["bone"].icon_id,
                )
            row = col.row(align=True)

            row.operator(
                "onigiri.set_interpolation",
                text = "Bezier",
                icon="IPO_BEZIER"
                ).mode = "BEZIER"
            row.operator(
                "onigiri.set_interpolation",
                text = "Linear",
                icon="IPO_LINEAR"
                ).mode = "LINEAR"
            row.operator(
                "onigiri.set_interpolation",
                text = "Constant",
                icon="IPO_CONSTANT"
                ).mode = "CONSTANT"
            
            row = col.row(align=True)
            for interp in extra_interpolation_types:
                row.operator(
                    "onigiri.set_interpolation",
                    text = " ",
                    icon=extra_interpolation_types[interp]
                    ).mode = interp

        ccl = bpy.context.window_manager.cc_libs
        row = self.layout.row(align=True)
        row.prop(
            ccl,
            "pose_enable_library",
            toggle = True,
            text="Enable Posing Library",
            icon_value = ico.custom_icons["pose_library"].icon_id
            )
        if ccl.pose_enable_library == True:

            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)

            row = col.row(align=True)
            row.operator(
                "bb_converter.load_pose_library",
                text = "Load Lib",
                icon_value = ico.custom_icons["load"].icon_id
                )
            row.operator(
                "bb_converter.save_pose_library",
                text = "Save Lib",
                icon_value = ico.custom_icons["save"].icon_id
                )
            row.operator(
                "bb_converter.reset_pose_library",
                text = "Reset Lib",
                icon_value = ico.custom_icons["reset"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "bb_converter.merge_pose_library",
                text = "Merge pose library",
                icon_value = ico.custom_icons["merge"].icon_id
                )
            row.operator(
                "bb_converter.merge_ccm_pose",
                text = "Merge BBM pose",
                icon_value = ico.custom_icons["merge"].icon_id
                )
            row = col.row(align=True)
            row.operator(
                "bb_converter.add_pose",
                text = "Add pose",
                icon_value = ico.custom_icons["add"].icon_id
                )
            row.prop(
                ccl,
                "pose_name",
                text="",
                )
            row = col.row(align=True)
            row.prop(
                ccl,
                "pose_apply_to_selected",
                text="Apply to selected bones only",
                icon_value = ico.custom_icons["selection"].icon_id
                )
            
            row = col.row(align=True)
            row.operator(
                "bb_converter.set_key",
                text = "Rotation",
                ).key_type = "rotation"
            row.operator(
                "bb_converter.set_key",
                text = "Location",
                ).key_type = "location"
            row.operator(
                "bb_converter.set_key",
                text = "Scale",
                ).key_type = "scale"
            row.operator(
                "bb_converter.set_key",
                text = "INS",
                ).key_type = "move"

            row = col.row(align=True)
            row.operator(
                "onigiri.onemap_pose",
                text = "Store Pose",
                ).action = "add"
            row.operator(
                "onigiri.onemap_pose",
                text = "Remove Pose",
                ).action = "del"

            pose_rename_map_text = " "
            pose_rename_map_icon = "dot_black"
            pose_pose_map_text = " "
            pose_pose_map_icon = "dot_black"
            selected = bpy.context.selected_objects
            if len(selected) == 1:
                if selected[0].type == 'ARMATURE':
                    if selected[0].get('bb_onemap_rename') != None:
                        if len(selected[0]['bb_onemap_rename']) > 0:
                            pose_rename_map_text = "Conversion Map Present"
                            pose_rename_map_icon = "dot_red"
                    if selected[0].get('bb_onemap_pose') != None:
                        if len(selected[0]['bb_onemap_pose']) > 0:
                            pose_pose_map_text = "Pose Map Present"
                            pose_pose_map_icon = "dot_red"

            row = col.row(align=True)
            row.prop(
                ccl,
                "pose_blank",
                text=pose_rename_map_text,
                icon_value = ico.custom_icons[pose_rename_map_icon].icon_id
                )
            row.prop(
                ccl,
                "pose_blank",
                text=pose_pose_map_text,
                icon_value = ico.custom_icons[pose_pose_map_icon].icon_id
                )

            if len(ccl['poses_stored']) > 0:
                col = box.column(align = True)
            
            poses_stored = ccl.get('poses_stored', {}).to_dict()
            for pose in poses_stored:
            
                row = col.row(align=True)
                row.operator(
                    "bb_converter.apply_pose",
                    text = "",
                    icon_value = ico.custom_icons["apply_pose"].icon_id
                    ).pose = pose
 
                row.operator(
                    "bb_converter.edit_pose",
                    text = "",
                    icon_value = ico.custom_icons["edit"].icon_id
                    ).pose = pose

                if ccl.pose_edit_trigger == 1:
                    
                    if pose == ccl.pose_edit_name_backup:
                        row.prop(
                            ccl,
                            "pose_edit_name",
                            text = "",
                            )
                    else:
                        row.label(
                            text = pose,
                            )
                
                else:
                    row.label(
                        text = pose,
                        )
                
                if ccl['poses_stored'][pose].get('pose_prefix') != None:
                    if ccl['poses_stored'][pose]['pose_prefix'] != "":
                        row.operator(
                            "bb_converter.remove_pose_prefix",
                            text = "",
                            icon_value = ico.custom_icons["prefix"].icon_id
                            ).pose = pose
                row.operator(
                    "bb_converter.delete_pose",
                    text = "",
                    icon_value = ico.custom_icons["x"].icon_id
                    ).pose = pose

        bb_autokey = bpy.context.scene.bb_autokey
        bb = bpy.context.scene.onigiri

        autokey_menu_enabled_icon = "menu_closed"
        if bb_autokey.autokey_menu_enabled == True:
            autokey_menu_enabled_icon = "menu_opened"
        row = self.layout.row(align=True)
        row.prop(
            bb_autokey,
            "autokey_menu_enabled",
            text = "Auto Key",
            icon_value = ico.custom_icons[autokey_menu_enabled_icon].icon_id,
            )
        if bb_autokey.autokey_menu_enabled == True:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align = True)
            row.operator(
                "onigiri.auto_key_reset",
                text="",
                icon_value = ico.custom_icons["x_black"].icon_id
                )
            row.operator(
                "onigiri.auto_key",
                text="Auto Key",
                ).action = "key"

            row.prop(
                bb_autokey,
                "autokey_steps_disabled",
                text = "",
                icon_value = ico.custom_icons["x_red"].icon_id
                )
            row.prop(
                bb_autokey,
                "autokey_steps",
                text = "Steps:",
                )
            row = col.row(align = True)
            row.operator(
                "onigiri.auto_key_insert",
                text="Insert Hold Rotation",
                icon_value = ico.custom_icons["insert"].icon_id
                ).action = "hold_rot"
            row.operator(
                "onigiri.auto_key_insert",
                text="Insert Hold Location",
                icon_value = ico.custom_icons["insert"].icon_id
                ).action = "hold_loc"

            row = col.row(align = True)
            row.operator(
                "onigiri.auto_key_bake_stored",
                text= "Bake Stored Keys",
                icon_value = ico.custom_icons["bake"].icon_id
                )
            row.operator(
                "onigiri.auto_key_bake_range",
                text= "Bake Range",
                icon_value = ico.custom_icons["bake"].icon_id
                )
            row = col.row(align = True)
            row.prop(
                bb_autokey,
                "autokey_bake_rotation_disabled",
                text= "Rotation Baking",
                icon_value = ico.custom_icons["x_black"].icon_id
                )
            row.prop(
                bb_autokey,
                "autokey_bake_location_disabled",
                text= "Location Baking",
                icon_value = ico.custom_icons["x_black"].icon_id
                )

            row = col.row(align = True)
            row.operator(
                "onigiri.auto_key",
                text= "Acquire",
                icon_value = ico.custom_icons["sync"].icon_id
                ).action = "acquire"
            row.operator(
                "onigiri.auto_key_isolate",
                text= "Isolate",
                icon_value = ico.custom_icons["isolate"].icon_id
                )

            row = col.row(align = True)

            row.operator(
                "onigiri.auto_key_store",
                text= "Store Action",
                icon_value = ico.custom_icons["store"].icon_id
                )

            if bb_autokey.autokey_bake_progress == "":
                row.prop(
                    bb_autokey,
                    "autokey_bake_progress_show",
                    text = "Show Bake Progress",
                    icon_value = ico.custom_icons["progress"].icon_id
                    )
            else:
                row.prop(
                    bb_autokey,
                    "autokey_bake_progress_show",
                    text= "Baking, please wait [" + bb_autokey.autokey_bake_progress + "]",
                    icon_value = ico.custom_icons["progress"].icon_id
                    )

            row = col.row(align = True)
            row.prop(
                bb_autokey,
                "autokey_bake_start",
                text = "Bake Start",
                )
            row.prop(
                bb_autokey,
                "autokey_bake_end",
                text = "Bake End",
                )

            row = col.row(align = True)
            row.prop(
                bb_autokey,
                "autokey_tol_rot",
                text = "Rot Tol:",
                )
            row.prop(
                bb_autokey,
                "autokey_tol_loc",
                text = "Loc Tol:",
                )
            row = col.row(align = True)
            row.operator(
                "onigiri.auto_key_reference",
                text="Record As Reference",
                icon_value = ico.custom_icons["record"].icon_id
                ).action = "save"
            row.operator(
                "onigiri.auto_key_reference",
                text="Restore To Reference",
                icon_value = ico.custom_icons["reset"].icon_id
                ).action = "restore"

            row = col.row(align = True)
            row.operator(
                "onigiri.auto_key",
                text="Copy Pose",
                icon_value = ico.custom_icons["copy"].icon_id
                ).action = "copy"
 
            row.prop(
                bb,
                "blank",
                text = "",
                icon_value = ico.custom_icons["blank"].icon_id
                )

            row.operator(
                "onigiri.auto_key_paste_pose",
                text="Paste Pose",
                icon_value = ico.custom_icons["paste"].icon_id
                ).action = "paste"
            row.prop(
                bb_autokey,
                "autokey_paste_to_selected",

                icon_only = True,
                icon_value = ico.custom_icons["selection"].icon_id
                )

            row = col.row(align = True)
            row.operator(
                "onigiri.auto_key_paste_pose",
                text="Clear Stored Pose",
                icon_value = ico.custom_icons["reset"].icon_id
                ).action = "clear"

        layout = self.layout
        row = self.layout.row(align=True)
        
        bb_alib = bpy.context.scene.bb_alib

        alib_motion_processing_menu_enabled_icon = "menu_closed"
        if bb_alib.alib_motion_processing_menu_enabled == True:
            alib_motion_processing_menu_enabled_icon = "menu_opened"

        row.prop(
            bb_alib,
            "alib_motion_processing_menu_enabled",
            text = "Motion Processing",
            icon_value = ico.custom_icons[alib_motion_processing_menu_enabled_icon].icon_id
            )

        if bb_alib.alib_motion_processing_menu_enabled == True:

            box = layout.box()
            col = box.column(align = True)
            row = col.row(align = True)

            alib_anim_menu_enabled_icon = "menu_closed"
            if bb_alib.alib_anim_menu_enabled == True:
                alib_anim_menu_enabled_icon = "menu_opened"

            row.prop(
                bb_alib,
                "alib_anim_menu_enabled",
                text = "Animations",
                icon_value = ico.custom_icons[alib_anim_menu_enabled_icon].icon_id
                )

            if bb_alib.alib_anim_menu_enabled == True:
            
                row = col.row(align = True)
                row.operator(
                    "onigiri.animation_library_save",
                    text="Save Lib",
                    icon_value = ico.custom_icons["save"].icon_id
                    )
                row.operator(
                    "onigiri.animation_library_load",
                    text="Load Lib",
                    icon_value = ico.custom_icons["load"].icon_id
                    )
                row.operator(
                    "onigiri.animation_library_merge",
                    text="Merge Lib",
                    icon_value = ico.custom_icons["merge"].icon_id
                    )
                row = col.row(align = True)

                row.operator(
                    "onigiri.animation_library_add",
                    text="Add Animation",
                    icon_value = ico.custom_icons["add"].icon_id
                    )
                row.prop(
                    bb_alib,
                    "alib_anim_name",
                    text = "",
                    )
                row.operator(
                    "onigiri.animation_library",
                    text="",
                    icon_value = ico.custom_icons["reset"].icon_id
                    ).action = "reset"
                if len( bb_alib.get('motion', {}) ) > 0:
                    for bb_motion in bb_alib['motion']:
                        row = col.row(align = True)
                        row.operator(
                            "onigiri.animation_library_apply",
                            text="",
                            icon_value = ico.custom_icons["running_guy"].icon_id
                            ).name = bb_motion
                        row.operator(
                            "onigiri.animation_library_rename",
                            text="",
                            icon_value = ico.custom_icons["edit"].icon_id
                            ).name = bb_motion

                        if bb_motion == bb_alib.alib_anim_name_new:
                            row.prop(
                                bb_alib,
                                "alib_anim_name_new",
                                text = "",
                                )
                        else:
                            row.operator(
                                "onigiri.animation_library_rename",
                                text= bb_motion,
                                ).name = bb_motion

                        row.operator(
                            "onigiri.animation_library_delete",
                            text="",
                            icon_value = ico.custom_icons["x_red"].icon_id
                            ).name = bb_motion

                row = col.row(align = True)
                row.prop(
                    bb,
                    "blank",
                    toggle = True,
                    text = " ",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )

                row = col.row(align = True)
            
            alib_action_menu_enabled_icon = "menu_closed"
            if bb_alib.alib_action_menu_enabled == True:
                alib_action_menu_enabled_icon = "menu_opened"

            row = col.row(align = True)
            row.prop(
                bb_alib,
                "alib_action_menu_enabled",
                text = "Actions",
                
                icon_value = ico.custom_icons[alib_action_menu_enabled_icon].icon_id
                )

            if bb_alib.alib_action_menu_enabled == True:
                
                col = box.column(align = True)
                row = col.row(align=True)
                anim = bpy.context.scene.bb_anim
                row.prop(
                    anim,
                    "anim_details",
                    text = "Embed Anim Details",
                    toggle = True,
                    icon_value = ico.custom_icons["code"].icon_id
                    )
                row = col.row(align=True)
                if anim.anim_details == True:
                    row.prop(
                        anim,
                        "anim_details_time",
                        text = "T",
                        toggle = True,
                        )
                    row.prop(
                        anim,
                        "anim_details_fps",
                        text = "F",
                        toggle = True,
                        )
                    row.prop(
                        anim,
                        "anim_details_loop_enabled",
                        text = "L",
                        toggle = True,
                        )
                    row.prop(
                        anim,
                        "anim_details_loop_in",
                        text = "I",
                        toggle = True,
                        )
                    row.prop(
                        anim,
                        "anim_details_loop_out",
                        text = "O",
                        toggle = True,
                        )

                    row.prop(
                        anim,
                        "anim_details_ease_in",
                        text = "E",
                        toggle = True,
                        )
                    row.prop(
                        anim,
                        "anim_details_ease_out",
                        text = "Z",
                        toggle = True,
                        )
                    row.prop(
                        anim,
                        "anim_details_priority",
                        text = "P",
                        toggle = True,
                        )

                    col = box.column(align = True)

                fake_count = 0
                for actionObj in bpy.data.actions:
                    if actionObj.use_fake_user == True:
                        fake_count += 1
                row.operator(
                    "onigiri.alib_action_fake_user",
                    text = "Enable Fake User [" + str(fake_count) + "]",
                    icon_value = ico.custom_icons["blank"].icon_id
                    ).action = True
                row.operator(
                    "onigiri.alib_action_fake_user",
                    text = "Disable Fake User",
                    icon_value = ico.custom_icons["blank"].icon_id
                    ).action = False

                row = col.row(align=True)

                row = col.row(align = True)
                row.operator(
                    "onigiri.alib_action_name",
                    text = "Generate Name",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_alib,
                    "alib_action_name",
                    toggle = True,
                    text = "",
                    
                    )

                row = col.row(align = True)
                row.prop(
                    bb_alib,
                    "alib_action_export_retargeted_animation",
                    toggle = True,
                    text = "Export Retargeted",
                    icon_value = ico.custom_icons["follow"].icon_id
                    )
                row.prop(
                    bb_alib,
                    "alib_action_export_mapped_animation",
                    toggle = True,
                    text = "Export Mapped",
                    icon_value = ico.custom_icons["map_bones"].icon_id
                    )

                row = col.row(align = True)
                row.prop(
                    bb_alib,
                    "alib_action_use_source_keys",
                    toggle = True,
                    text = "Use Keys Only",
                    icon_value = ico.custom_icons["key_blue"].icon_id
                    )
                row = col.row(align = True)
                row.prop(
                    bb_alib,
                    "alib_action_use_source_keys_rotation",
                    toggle = True,
                    text = "Rotation",
                    icon_value = ico.custom_icons["rotation_blue"].icon_id
                    )
                row.prop(
                    bb_alib,
                    "alib_action_use_source_keys_location",
                    toggle = True,
                    text = "Location",
                    icon_value = ico.custom_icons["location_blue"].icon_id
                    )

                row = col.row(align = True)
                row.operator(
                    "onigiri.alib_action_flag",
                    text = "",
                    icon_value = ico.custom_icons["flag_none"].icon_id
                    ).action = "none"
                row.operator(
                    "onigiri.alib_action_flag",
                    text = "",
                    icon_value = ico.custom_icons["flag_all"].icon_id
                    ).action = "all"

                alib_ranges_all_enabled_icon = "range"
                alib_loops_all_enabled_icon = "loop"
                if bb_alib.alib_ranges_all_enabled == True:
                    alib_ranges_all_enabled_icon = "range_enabled"
                if bb_alib.alib_loops_all_enabled == True:
                    alib_loops_all_enabled_icon = "loop_enabled"

                if 1 == 0:
                    row.operator(
                        "onigiri.alib_action_range_all",
                        text = "",
                        icon_value = ico.custom_icons[alib_ranges_all_enabled_icon].icon_id
                        )
                    row.operator(
                        "onigiri.alib_action_loop_all",
                        text = "",
                        icon_value = ico.custom_icons[alib_loops_all_enabled_icon].icon_id
                        )

                row.prop(
                    bb_alib,
                    "alib_ranges_all_enabled",
                    toggle = True,
                    text = "",
                    icon_value = ico.custom_icons[alib_ranges_all_enabled_icon].icon_id
                    )
                row.prop(
                    bb_alib,
                    "alib_loops_all_enabled",
                    toggle = True,
                    text = "",
                    icon_value = ico.custom_icons[alib_loops_all_enabled_icon].icon_id
                    )

                alib_ease_all_enabled_icon = "ease"
                if bb_alib.alib_ease_all_enabled == True:
                    alib_ease_all_enabled_icon = "ease_enabled"
                row.prop(
                    bb_alib,
                    "alib_ease_all_enabled",
                    toggle = True,
                    text = "",
                    icon_value = ico.custom_icons[alib_ease_all_enabled_icon].icon_id
                    )

                if 1 == 0:
                    row.prop(
                        bb_alib,
                        "alib_action_use_selected_rig",
                        toggle = True,
                        text = "Use selected rig",
                        
                        )
                    row.operator(
                        "onigiri.alib_action_convert",
                        text = "",
                        icon_value = ico.custom_icons["avastar_to_bb"].icon_id
                        )
                    row.prop(
                        bb_alib,
                        "alib_action_rotation_fix",
                        toggle = True,
                        text = "",
                        icon_value = ico.custom_icons["rotate"].icon_id
                        )
                
                row.prop(
                    bb,
                    "blank",
                    toggle = True,
                    text = " ",

                    )

                row.prop(
                    bb_alib,
                    "alib_action_overwrite",
                    toggle = True,
                    text = "",
                    icon_value = ico.custom_icons["edit_red"].icon_id
                    )

                row.operator(
                    "onigiri.alib_action_export",
                    text = "",
                    icon_value = ico.custom_icons["save_dark"].icon_id
                    )

                row = col.row(align = True)

                alib_actions = [a for a in bpy.data.actions]
                for actionObj in alib_actions:

                    row = col.row(align = True)
                    row.operator(
                        "onigiri.alib_action_apply",
                        text = "",
                        icon_value = ico.custom_icons["running_guy"].icon_id
                        ).name = actionObj.name
                    action_flag_icon = "flag"
                    if bb_alib.get('actions') != None:
                        if actionObj.name in bb_alib['actions']:
                            if bb_alib['actions'][actionObj.name]['flagged'] == True:
                                action_flag_icon = "flag_on"
                    row.operator(
                        "onigiri.alib_action_flag",
                        text = "",
                        icon_value = ico.custom_icons[action_flag_icon].icon_id
                        ).name = actionObj.name

                    alib_action_range_icon = "range"
                    alib_action_loop_icon = "loop"
                    action_range = actionObj.get('frame_range', False)
                    action_loop = actionObj.get('loop_range', False)
                    if action_range == True:
                        alib_action_range_icon = "range_enabled"
                    if action_loop == True:
                        alib_action_loop_icon = "loop_enabled"

                    row.operator(
                        "onigiri.alib_action_range",
                        text = "",
                        icon_value = ico.custom_icons[alib_action_range_icon].icon_id
                        ).action = actionObj.name
                    row.operator(
                        "onigiri.alib_action_loop",
                        text = "",
                        icon_value = ico.custom_icons[alib_action_loop_icon].icon_id
                        ).action = actionObj.name

                    alib_action_ease_icon = "ease"
                    action_ease = actionObj.get('ease', False)
                    if action_ease == True:
                        alib_action_ease_icon = "ease_enabled"
                    row.operator(
                        "onigiri.alib_action_ease",
                        text = "",
                        icon_value = ico.custom_icons[alib_action_ease_icon].icon_id
                        ).action = actionObj.name

                    if bb_alib.alib_action_rename_new == actionObj.name:
                        row.prop(
                            bb_alib,
                            "alib_action_rename_new",
                            )
                    else:
                        row.operator(
                            "onigiri.alib_action_rename",
                            text = actionObj.name,
                            ).name = actionObj.name

                    row.operator(
                        "onigiri.alib_action_rename",
                        text = "",
                        icon_value = ico.custom_icons["edit"].icon_id
                        ).name = actionObj.name

                    row.operator(
                        "onigiri.alib_action_delete",
                        text = "",
                        icon_value = ico.custom_icons["x_red"].icon_id
                        ).name = actionObj.name

                row = col.row(align = True)
                
                if len(bpy.data.actions) == 0:
                    row.prop(
                        bb,
                        "blank",
                        toggle = True,
                        text = "No actions available",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                else:
                    
                    alib_action_active_text = " "
                    alib_action_active_icon = "star_black"
                    if len(bpy.context.selected_objects) == 1:
                        o = bpy.context.selected_objects[0]
                        
                        if 1 == 1:
                            if o.animation_data != None:
                                if o.animation_data.action != None:
                                    alib_action_active_text = o.animation_data.action.name
                                    alib_action_active_icon = "star_green"

                    row.prop(
                        bb,
                        "blank",
                        toggle = True,
                        text = "",
                        icon_value = ico.custom_icons[alib_action_active_icon].icon_id
                        )
                    row.operator(
                        "onigiri.alib_action_copy",
                        text = alib_action_active_text,
                        ).name = actionObj.name
                    row.prop(
                        bb,
                        "blank",
                        toggle = True,
                        text = "",
                        icon_value = ico.custom_icons[alib_action_active_icon].icon_id
                        )

                bb_anim = bpy.context.scene.bb_anim
                alib_ranges_menu_enabled_icon = "menu_closed"
                if bb_alib.alib_ranges_menu_enabled == True:
                    alib_ranges_menu_enabled_icon = "menu_opened"
                row = col.row(align = True)
                row.prop(
                    bb_alib,
                    "alib_ranges_menu_enabled",
                    text = "Frame and Loop Ranges",
                    toggle = True,
                    icon_value = ico.custom_icons[alib_ranges_menu_enabled_icon].icon_id
                    )
                if bb_alib.alib_ranges_menu_enabled == True:
                    
                    col = box.column(align = True)
                    row = col.row(align = True)
                    row.operator(
                        "onigiri.action_fill_add",
                        text = "Auto Fill",
                        icon_value = ico.custom_icons["fill"].icon_id
                        )
                    row.operator(
                        "onigiri.action_fill_del",
                        text = "Empty",
                        icon_value = ico.custom_icons["empty"].icon_id
                        )
                    row = col.row(align = True)
                    row.prop(
                        bb_alib,
                        "action_fill_fps",
                        toggle = True,
                        text = "FPS",
                        )
                    row.prop(
                        bb_alib,
                        "action_fill_time",
                        toggle = True,
                        text = "time",
                        )
                    row = col.row(align = True)
                    row.prop(
                        bb_alib,
                        "action_fill_ease_in",
                        toggle = True,
                        text = "Ease In",
                        )
                    row.prop(
                        bb_alib,
                        "action_fill_ease_out",
                        toggle = True,
                        text = "Ease Out",
                        )
                    
                    col = box.column(align = True)
                    row = col.row(align = True)
                    row.operator(
                        "onigiri.action_fill_script",
                        text = "Export Animesh Script (LSL)",
                        icon_value = ico.custom_icons["script"].icon_id
                        ).action = "animesh"
                    row.operator(
                        "onigiri.action_fill_script",
                        text = "Export Avatar Script (LSL)",
                        icon_value = ico.custom_icons["script"].icon_id
                        ).action = "avatar"
                    
                    row = col.row(align = True)
                    row.prop(
                        bb_alib,
                        "action_script_debug",
                        toggle = True,
                        text = "debug",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row.prop(
                        bb_alib,
                        "action_script_owner",
                        toggle = True,
                        text = "owner",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row.prop(
                        bb_alib,
                        "action_script_loop",
                        toggle = True,
                        text = "loop",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row.prop(
                        bb_alib,
                        "action_script_touch",
                        toggle = True,
                        text = "Touch",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row.prop(
                        bb_alib,
                        "action_script_listen",
                        toggle = True,
                        text = "Listen",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    col = box.column(align = True)
                    row = col.row(align = True)
                    row.prop(
                        bb_alib,
                        "blank",
                        toggle = True,
                        text = "Channel Number",
                        )
                    row.prop(
                        bb_alib,
                        "blank",
                        toggle = True,
                        text = "Start Command",
                        )
                    row.prop(
                        bb_alib,
                        "blank",
                        toggle = True,
                        text = "Stop Command",
                        )
                    row = col.row(align = True)
                    row.prop(
                        bb_alib,
                        "action_script_channel",
                        toggle = True,
                        text = "",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row.prop(
                        bb_alib,
                        "action_script_start",
                        toggle = True,
                        text = "",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row.prop(
                        bb_alib,
                        "action_script_stop",
                        toggle = True,
                        text = "",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )

                    col = box.column(align = True)
                    row = col.split(factor=0.4, align=True)
                    row.prop(
                        bb,
                        "blank",
                        toggle = True,
                        text = "Action",
                        )

                    row.prop(
                        bb,
                        "blank",
                        toggle = True,
                        text = "Time",
                        )
                    row.prop(
                        bb,
                        "blank",
                        toggle = True,
                        text = "Frame Start",
                        )
                    row.prop(
                        bb,
                        "blank",
                        toggle = True,
                        text = "Frame End",
                        )
                    row.prop(
                        bb,
                        "blank",
                        toggle = True,
                        text = "Loop Start",
                        )
                    row.prop(
                        bb,
                        "blank",
                        toggle = True,
                        text = "Loop End",
                        )
                    row.prop(
                        bb,
                        "blank",
                        toggle = True,
                        text = "Priority",
                        )
                    row.prop(
                        bb,
                        "blank",
                        toggle = True,
                        text = "Ease In",
                        )
                    row.prop(
                        bb,
                        "blank",
                        toggle = True,
                        text = "Ease Out",
                        )

                    bb_frame_start = bb.animation_start_frame
                    bb_frame_end = bb.animation_end_frame
                    bb_loop_start = bb_anim.anim_loop_in_frame
                    bb_loop_end = bb_anim.anim_loop_out_frame
                    bb_priority = bb_anim.anim_base_priority
                    bb_ease_in = bb_anim.anim_ease_in_duration
                    bb_ease_out = bb_anim.anim_ease_out_duration

                    alib_actions = [a for a in bpy.data.actions]
                    for actionObj in alib_actions:

                        action_frame_start = actionObj.get('frame_start', bb_frame_start)
                        action_frame_end = actionObj.get('frame_end', bb_frame_end)
                        action_loop_start = actionObj.get('loop_start', bb_loop_start)
                        action_loop_end = actionObj.get('loop_end', bb_loop_end)
                        action_priority = actionObj.get('priority', bb_priority)
                        action_ease_in = actionObj.get('ease_in', bb_ease_in)
                        action_ease_out = actionObj.get('ease_out', bb_ease_out)

                        row = col.split(factor=0.4, align=True)
                        
                        total_time = abs(action_frame_start - action_frame_end) / bb_alib.action_fill_fps
                        total_time_text = str(round(total_time, 2))

                        if bb_alib.alib_action_range_set_name == actionObj.name:
                            alib_action_range_set_icon = "running_guy_enabled"
                        elif actionObj.name in bb_alib.get('fill_actions', ""):
                            alib_action_range_set_icon = "split"
                        elif total_time > 60:
                            alib_action_range_set_icon = "dot_red"
                        else:
                            alib_action_range_set_icon = "running_guy"
                        row.operator(
                            "onigiri.alib_action_range_set",
                            text = actionObj.name,
                            icon_value = ico.custom_icons[alib_action_range_set_icon].icon_id
                            ).action = actionObj.name
                        if bb_alib.alib_action_range_set_name == actionObj.name:
                            row.prop(
                                bb,
                                "blank",
                                text = total_time_text,
                                toggle = True
                                )
                            row.prop(
                                bb_alib,
                                "alib_action_frame_start",
                                text = ""
                                )
                            row.prop(
                                bb_alib,
                                "alib_action_frame_end",
                                text = ""
                                )
                            row.prop(
                                bb_alib,
                                "alib_action_loop_start",
                                text = ""
                                )
                            row.prop(
                                bb_alib,
                                "alib_action_loop_end",
                                text = ""
                                )
                            row.prop(
                                bb_alib,
                                "alib_action_priority",
                                text = ""
                                )
                            row.prop(
                                bb_alib,
                                "alib_action_ease_in",
                                text = ""
                                )
                            row.prop(
                                bb_alib,
                                "alib_action_ease_out",
                                text = ""
                                )

                        else:
                            
                            row.prop(
                                bb,
                                "blank",
                                text = total_time_text,
                                toggle = True
                                )
                            
                            row.operator(
                                "onigiri.alib_action_range_set",
                                text = str(action_frame_start),
                                ).action = actionObj.name
                            
                            row.operator(
                                "onigiri.alib_action_range_set",
                                text = str(action_frame_end),
                                ).action = actionObj.name
                            
                            row.operator(
                                "onigiri.alib_action_range_set",
                                text = str(action_loop_start),
                                ).action = actionObj.name
                            
                            row.operator(
                                "onigiri.alib_action_range_set",
                                text = str(action_loop_end),
                                ).action = actionObj.name
                            
                            row.operator(
                                "onigiri.alib_action_range_set",
                                text = str(action_priority),
                                ).action = actionObj.name

                            row.operator(
                                "onigiri.alib_action_range_set",
                                text = str(action_ease_in),
                                ).action = actionObj.name
                            row.operator(
                                "onigiri.alib_action_range_set",
                                text = str(action_ease_out),
                                ).action = actionObj.name

            bb_pose = bpy.context.scene.bb_pose
            pose_library_menu_enabled_icon = "menu_closed"
            if bb_pose.pose_library_menu_enabled == True:
                pose_library_menu_enabled_icon = "menu_opened"
            row = col.row(align = True)
            row.prop(
                bb_pose,
                "pose_library_menu_enabled",
                text = "Poses",
                icon_value = ico.custom_icons[pose_library_menu_enabled_icon].icon_id
                )
            if bb_pose.pose_library_menu_enabled == True:
                row = col.row(align = True)
                row.operator(
                    "onigiri.pose_library_load",
                    text = "Load Pose Lib",
                    icon_value = ico.custom_icons["load"].icon_id
                    )
                row.operator(
                    "onigiri.pose_library_save",
                    text = "Save Pose Lib",
                    icon_value = ico.custom_icons["save"].icon_id
                    )
                row = col.row(align = True)
                row.operator(
                    "onigiri.pose_library_merge",
                    text = "Merge Pose Lib",
                    icon_value = ico.custom_icons["merge"].icon_id
                    )
                row.operator(
                    "onigiri.pose_library_reset",
                    text = "Reset Library",
                    icon_value = ico.custom_icons["reset"].icon_id
                    )

                row = col.row(align = True)
                row.operator(
                    "onigiri.pose_library_flag",
                    text = "",
                    icon_value = ico.custom_icons["flag_none"].icon_id
                    ).action = "none"
                row.operator(
                    "onigiri.pose_library_flag",
                    text = "",
                    icon_value = ico.custom_icons["flag_all"].icon_id
                    ).action = "all"

                row.operator(
                    "onigiri.pose_library_add",
                    text = "",
                    icon_value = ico.custom_icons["add"].icon_id
                    )

                row.operator(
                    "onigiri.pose_library_hash",
                    text = "Generate Name",
                    )

                row.prop(
                    bb_pose,
                    "pose_library_name",
                    toggle = True,
                    text = "",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_pose,
                    "pose_library_overwrite",
                    toggle = True,
                    text = "",
                    icon_value = ico.custom_icons["edit_red"].icon_id
                    )

                row.operator(
                    "onigiri.pose_library_export",
                    text = "",
                    icon_value = ico.custom_icons["save_dark"].icon_id
                    )

                bb_pose_list = bb_pose.get('poses', [])
                for bb_pose_name in bb_pose_list:
                    row = col.row(align = True)
                    row.operator(
                        "onigiri.pose_library_apply",
                        text = "",
                        icon_value = ico.custom_icons["running_guy"].icon_id
                        ).name = bb_pose_name

                    pose_flag_icon = "flag"
                    if bb_pose['poses'][bb_pose_name].get('flagged'):
                        pose_flag_icon = "flag_on"
                    row.operator(
                        "onigiri.pose_library_flag",
                        text = "",
                        icon_value = ico.custom_icons[pose_flag_icon].icon_id
                        ).name = bb_pose_name
                    if bb_pose['poses'][bb_pose_name].get('prefix') == None:

                        row.operator(
                            "onigiri.pose_library_apply_to_selected",
                            text = "",
                            icon_value = ico.custom_icons["selection"].icon_id
                            ).name = bb_pose_name

                    else:
                        row.operator(
                            "onigiri.pose_library_prefix",
                            text = "",
                            icon_value = ico.custom_icons["prefix"].icon_id
                            ).name = bb_pose_name

                    if bb_pose.pose_library_rename_new == bb_pose_name:
                        row.prop(
                            bb_pose,
                            "pose_library_rename_new",
                            )
                    else:
                        row.operator(
                            "onigiri.pose_library_rename",
                            text = bb_pose_name,
                            ).name = bb_pose_name

                    row.operator(
                        "onigiri.pose_library_rename",
                        text = "",
                        icon_value = ico.custom_icons["edit"].icon_id
                        ).name = bb_pose_name

                    row.operator(
                        "onigiri.pose_library_delete",
                        text = "",
                        icon_value = ico.custom_icons["x_red"].icon_id
                        ).name = bb_pose_name

                row = col.row(align = True)
                row.prop(
                    bb,
                    "blank",
                    toggle = True,
                    text = "Last Loaded: " + bb_pose.pose_library_last_loaded,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
            
            bb_mixer = bpy.context.window_manager.bb_mixer
            bb = bpy.context.scene.onigiri

            mixer_menu_enabled_icon = "menu_closed"
            if bb_mixer.mixer_menu_enabled == True:
                mixer_menu_enabled_icon = "menu_opened"
            row = col.row(align = True)
            row.prop(
                bb_mixer,
                "mixer_menu_enabled",
                text = "Motion Mixer",
                icon_value = ico.custom_icons[mixer_menu_enabled_icon].icon_id
                )
            if bb_mixer.mixer_menu_enabled == True:
                row = col.row(align = True)

                if bb_mixer.mixer_target_locked == True:
                    row.prop(
                        bb_mixer,
                        "mixer_target_locked",
                        text = "Target Locked:",
                        icon_value = ico.custom_icons["target"].icon_id
                        )
                else:
                    row.operator(
                        "onigiri.mixer_lock_target",
                        text = "Lock Target:",
                        icon_value = ico.custom_icons["target"].icon_id
                        )

                mixer_target_name = " "
                targetObj = bb_mixer.get('target')

                if targetObj != None:
                    if targetObj.name not in bpy.context.scene.objects:
                        
                        bb_mixer.mixer_target_locked = False
                    else:
                        mixer_target_name = targetObj.name

                if bb_mixer.mixer_target_locked == True:
                    row.prop(
                        bb,
                        "blank",
                        text = mixer_target_name,
                        toggle = True,
                        icon_value = ico.custom_icons["dot_yellow"].icon_id
                        )
                else:
                    row.prop(
                        bb_mixer,
                        "mixer_target_name",
                        )

                if bb_mixer.mixer_target_locked == True:
                    row = col.row(align = True)
                    row.operator(
                        "onigiri.mixer_add_source",
                        text = "Add Source",
                        icon_value = ico.custom_icons["add"].icon_id
                        )

                    if bb_mixer.mixer_ready == True:
                        row.prop(
                            bb_mixer,
                            "mixer_ready",
                            text = "Click to suspend",
                            toggle = True,
                            icon_value = ico.custom_icons["time"].icon_id
                            )
                        row = col.row(align = True)
                        row.prop(
                            bb_mixer,
                            "mixer_transform_info",
                            text = "",
                            toggle = True,
                            icon_value = ico.custom_icons["alert"].icon_id
                            )
                        row.prop(
                            bb_mixer,
                            "mixer_location",
                            text = "Location",
                            toggle = True,
                            icon_value = ico.custom_icons["location"].icon_id
                            )
                        row.prop(
                            bb_mixer,
                            "mixer_rotation",
                            text = "Rotation",
                            toggle = True,
                            icon_value = ico.custom_icons["rotation"].icon_id
                            )
                        row.prop(
                            bb_mixer,
                            "mixer_scale",
                            text = "Scale",
                            toggle = True,
                            icon_value = ico.custom_icons["scale"].icon_id
                            )

                        row = col.row(align = True)
                        row.operator(
                            "onigiri.mixer_add_bones",
                            text = "Add Bones",
                            icon_value = ico.custom_icons["add"].icon_id
                            )
                        row.operator(
                            "onigiri.mixer_remove_bones",
                            text = "Remove Bones",
                            icon_value = ico.custom_icons["subtract"].icon_id
                            )

                    else:
                        row.operator(
                            "onigiri.mixer_ready",
                            text = "Click To Start Picking",
                            icon_value = ico.custom_icons["thumb_up"].icon_id
                            )

                    row = col.row(align = True)
                    row.prop(
                        bb,
                        "blank",
                        text = "Mix Mode",
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row = col.row(align = True)
                    row.operator(
                        "onigiri.mixer_mode",
                        text = "Repl",
                        ).action = "REPLACE"
                    row.operator(
                        "onigiri.mixer_mode",
                        text = "Add",
                        ).action = "ADD"
                    row.operator(
                        "onigiri.mixer_mode",
                        text = "Before",
                        ).action = "BEFORE"
                    row.operator(
                        "onigiri.mixer_mode",
                        text = "After",
                        ).action = "AFTER"
                    row.operator(
                        "onigiri.mixer_mode",
                        text = "Offset",
                        ).action = "OFFSET"

                    row = col.row(align = True)
                    row.prop(
                        bb,
                        "blank",
                        text = "Target Space",
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row.prop(
                        bb,
                        "blank",
                        text = "Owner Space",
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    
                    row = col.row(align = True)
                    mixer_space = row.operator(
                        "onigiri.mixer_space",
                        text = "World",
                        )
                    mixer_space.action = "target_space"
                    mixer_space.space = "WORLD"

                    mixer_space = row.operator(
                        "onigiri.mixer_space",
                        text = "World",
                        )
                    mixer_space.action = "owner_space"
                    mixer_space.space = "WORLD"
                    
                    row = col.row(align = True)
                    mixer_space = row.operator(
                        "onigiri.mixer_space",
                        text = "Pose",
                        )
                    mixer_space.action = "target_space"
                    mixer_space.space = "POSE"

                    mixer_space = row.operator(
                        "onigiri.mixer_space",
                        text = "Pose",
                        )
                    mixer_space.action = "owner_space"
                    mixer_space.space = "POSE"
                    
                    row = col.row(align = True)
                    mixer_space = row.operator(
                        "onigiri.mixer_space",
                        text = "Parent",
                        )
                    mixer_space.action = "target_space"
                    mixer_space.space = "LOCAL_WITH_PARENT"

                    mixer_space = row.operator(
                        "onigiri.mixer_space",
                        text = "Parent",
                        )
                    mixer_space.action = "owner_space"
                    mixer_space.space = "LOCAL_WITH_PARENT"
                    
                    row = col.row(align = True)
                    mixer_space = row.operator(
                        "onigiri.mixer_space",
                        text = "Local",
                        )
                    mixer_space.action = "target_space"
                    mixer_space.space = "LOCAL"

                    mixer_space = row.operator(
                        "onigiri.mixer_space",
                        text = "Local",
                        )
                    mixer_space.action = "owner_space"
                    mixer_space.space = "LOCAL"

                    row = col.row(align = True)
                    row.prop(
                        bb,
                        "blank",
                        text = "Target Parent Inheritance",
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    
                    row = col.row(align = True)
                    mixer_inherit = row.operator(
                        "onigiri.mixer_inherit",
                        text = "Rotation Enable",
                        )
                    mixer_inherit.transform = "rotation"
                    mixer_inherit.state = "True"
                    mixer_inherit = row.operator(
                        "onigiri.mixer_inherit",
                        text = "Rotation Disable",
                        )
                    mixer_inherit.transform = "rotation"
                    mixer_inherit.state = "False"
                    
                    row = col.row(align = True)
                    mixer_inherit = row.operator(
                        "onigiri.mixer_inherit",
                        text = "Location Enable",
                        )
                    mixer_inherit.transform = "location"
                    mixer_inherit.state = "True"
                    mixer_inherit = row.operator(
                        "onigiri.mixer_inherit",
                        text = "Location Disable",
                        )
                    mixer_inherit.transform = "location"
                    mixer_inherit.state = "False"

                    sources = bb_mixer.get('sources', [])
                    if len(sources) > 0:
                        row = col.row(align = True)
                        row.prop(
                            bb,
                            "blank",
                            text = "Animation Sources",
                            toggle = True,
                            icon_value = ico.custom_icons["blank"].icon_id
                            )
                    
                    for sourceObj in sources:
                        source = sourceObj.name

                        row = col.row(align = True)
                        if source == bb_mixer.mixer_anchor_name:
                            row.prop(
                                bb_mixer,
                                "mixer_anchor",
                                text = "",
                                toggle = True,
                                icon_value = ico.custom_icons["anchor"].icon_id,
                                )
                        else:
                            row.operator(
                                "onigiri.mixer_set_anchor",
                                text = "",
                                icon_value = ico.custom_icons["anchor"].icon_id
                                ).name = source

                        if bb_mixer.mixer_active_rig_name == sourceObj.name:
                            row.prop(
                                bb_mixer,
                                "mixer_active_rig",
                                text = source,
                                toggle = True,
                                icon_value = ico.custom_icons["dot_blue"].icon_id
                                )
                            
                            row.operator(
                                "onigiri.mixer_remove_source",
                                text = "",
                                icon_value = ico.custom_icons["x_black"].icon_id
                                ).name = source

                            for bone in bb_mixer['maps']['sources'].get(source, []):
                                row = col.row(align = True)
                                row.prop(
                                    bb,
                                    "blank",
                                    text = "",
                                    toggle = True,
                                    icon_value = ico.custom_icons["bone_black"].icon_id
                                    )

                                row.prop(
                                    bb,
                                    "blank",
                                    text = bone,
                                    toggle = True,

                                    )
                                
                                mixer_location_influence = int(globals.bb_mixer['constraints'][bone]['location'].influence)
                                mixer_location_icon = "location"
                                if mixer_location_influence:
                                    mixer_location_icon = "location_enabled"
                                mixer_location_properties = row.operator(
                                        "onigiri.mixer_set_location",
                                        text = "",
                                        icon_value = ico.custom_icons[mixer_location_icon].icon_id
                                        )
                                mixer_location_properties.name = bone
                                mixer_location_properties.influence = not mixer_location_influence
                                
                                mixer_rotation_influence = int(globals.bb_mixer['constraints'][bone]['rotation'].influence)
                                mixer_rotation_icon = "rotation"
                                if mixer_rotation_influence:
                                    mixer_rotation_icon = "rotation_enabled"
                                mixer_rotation_properties = row.operator(
                                        "onigiri.mixer_set_rotation",
                                        text = "",
                                        icon_value = ico.custom_icons[mixer_rotation_icon].icon_id
                                        )
                                mixer_rotation_properties.name = bone
                                mixer_rotation_properties.influence = not mixer_rotation_influence
                                
                                mixer_scale_influence = int(globals.bb_mixer['constraints'][bone]['scale'].influence)
                                mixer_scale_icon = "scale"
                                if mixer_scale_influence:
                                    mixer_scale_icon = "scale_enabled"
                                mixer_scale_properties = row.operator(
                                        "onigiri.mixer_set_scale",
                                        text = "",
                                        icon_value = ico.custom_icons[mixer_scale_icon].icon_id
                                        )
                                mixer_scale_properties.name = bone
                                mixer_scale_properties.influence = not mixer_scale_influence
                                
                                row.operator(
                                    "onigiri.mixer_remove_bones",
                                    text = "",
                                    icon_value = ico.custom_icons["x_red"].icon_id
                                    ).name = bone

                        else:
                            row.operator(
                                "onigiri.mixer_active_rig_name",
                                text = sourceObj.name,
                                icon_value = ico.custom_icons["dot_red"].icon_id
                                ).name = source

                            row.operator(
                                "onigiri.mixer_remove_source",
                                text = "",
                                icon_value = ico.custom_icons["x_black"].icon_id
                                ).name = source

            bb_splice = bpy.context.scene.bb_splice

            if splice.props['startup'] == True:
                row.prop(
                    bb_splice,
                    "splice_blank",
                    text = "",
                    icon_value = ico.custom_icons["camera_on"].icon_id
                    )
                
                bb_splice.property_unset("splice_menu_enabled")
                bb_splice.property_unset("splice_target_locked")
                splice.props['startup'] = False

            splice_menu_enabled_icon = "menu_closed"
            if bb_splice.splice_menu_enabled == True:
                splice_menu_enabled_icon = "menu_opened"

            row = col.row(align = True)
            row.prop(
                bb_splice,
                "splice_menu_enabled",
                text = "Motion Splicer",
                icon_value = ico.custom_icons[splice_menu_enabled_icon].icon_id
                )
            if bb_splice.splice_menu_enabled == True:
                row = col.row(align = True)
                row.prop(
                    bb_splice,
                    "splice_blank",
                    text = "Message: " + bb_splice.splice_message,
                    toggle = True,
                    icon_value = ico.custom_icons["alert"].icon_id
                    )
                row = col.row(align = True)
                row.prop(
                    bb_splice,
                    "splice_disable_onigiri_check",
                    text = "Enable this for NON SL rigs",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row = col.row(align = True)

                target_locked_text = "Lock Target"
                if bb_splice.splice_target_locked == True:
                    target_locked_text = "Target Locked"
                row = col.row(align = True)
                row.prop(
                    bb_splice,
                    "splice_target_locked",
                    text = target_locked_text,
                    icon_value = ico.custom_icons["target"].icon_id
                    )
                row.operator(
                    "onigiri.splice_reset",
                    text = "",
                    icon_value = ico.custom_icons["reset"].icon_id
                    )

                if bb_splice.splice_target_locked == True:
                    row = col.row(align = True)
                    row.prop(
                        bb_splice,
                        "splice_motion",
                        text = "Capture Motion",
                        icon_value = ico.custom_icons["fix_pose"].icon_id
                        )
                    row.prop(
                        bb_splice,
                        "splice_keys",
                        text = "Capture Keys",
                        icon_value = ico.custom_icons["key_black"].icon_id
                        )

                    gap_insert_text = "Gap Append Mode - Enabled"
                    if bb_splice.splice_gap_insert == True:
                        gap_insert_text = "Gap Insert Mode - Enabled"
                    row = col.row(align = True)
                    row.prop(
                        bb_splice,
                        "splice_gap_insert",
                        text = gap_insert_text,
                        icon_value = ico.custom_icons["insert"].icon_id
                        )
                    row = col.row(align = True)
                    row.prop(
                        bb_splice,
                        "splice_gap_start",
                        text = "Gap Start",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row = col.row(align = True)
                    
                    row.prop(
                        bb_splice,
                        "splice_gap_end",
                        text = "Gap End",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )

                    row = col.row(align = True)
                    row.operator(
                        "onigiri.splice_sync",
                        text = "",
                        icon_value = ico.custom_icons["range"].icon_id
                        )
                    row.prop(
                        bb_splice,
                        "splice_spread_enabled",
                        text = "Adjust start / end capture",
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )

                    row = col.row(align = True)
                    row.enabled = bb_splice.splice_spread_enabled
                    row.prop(
                        bb_splice,
                        "splice_spread_start",
                        text = "Capture Start",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row = col.row(align = True)
                    row.enabled = bb_splice.splice_spread_enabled
                    row.prop(
                        bb_splice,
                        "splice_spread_end",
                        text = "Capture End",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )

                    row = col.row(align = True)
                    splice_capture_icon = "camera"
                    splice_capture_text = "Capture Segment"
                    if splice.props['camera'] == True:
                        splice_capture_icon = "camera_on" 
                        splice_capture_text = "Capturing..."
                    row.operator(
                        "onigiri.splice_capture",
                        text = splice_capture_text,
                        icon_value = ico.custom_icons[splice_capture_icon].icon_id
                        )
                    col = box.column(align = True)
                    row = col.row(align=True)
                    row.prop(
                        bb_splice,
                        "splice_blank",
                        text = "Target name: " + bb_splice.splice_target_name,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )

                    target_frame_start = 0
                    target_frame_end = 0
                    if bb_splice.splice_target_name in bpy.data.objects:
                        tarmObj = bpy.data.objects[bb_splice.splice_target_name]
                        
                        if tarmObj.animation_data != None:
                            if tarmObj.animation_data.action != None:
                                target_frame_start, target_frame_end = tarmObj.animation_data.action.frame_range
                    row = col.row(align=True)
                    row.prop(
                        bb_splice,
                        "splice_blank",
                        text = "Frame Range: [ " + str(target_frame_start) + " <--> " + str(target_frame_end) + " ]",
                        icon_value = ico.custom_icons["blank"].icon_id
                        )

class OnigiriPanelRigTools(bpy.types.Panel):
    """This is rig tools"""
    bl_idname = "OBJECT_PT_bento_buddy_rig_tools"
    bl_label = "Rig Tools"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        obj = bpy.data.objects
        selected = bpy.context.selected_objects

        bbm = bpy.context.window_manager.bb_misc
        bb_misc = bbm

        brp = bpy.context.window_manager.bb_rigprops
        bb_mesh = bpy.context.scene.bb_mesh

        layout = self.layout
        box = layout.box()

        brp.bone_prefix_label = rigutils.get_bone_prefix()
        box.label(
            text = "Bone Prefix: " + brp.bone_prefix_label
            )

        box.operator(
            "onigiri.change_rig_prefix",
            text="Change / Remove (bone prefix)",
            )
        box.prop(
            brp,
            "bone_prefix_name",
            text = "",
            )
        
        if 1 == 0:
            layout = self.layout
            box = layout.box()
            box.label(
                text = "Convert Rig Class To:"
                )
            col = box.column(align = True)
            row = col.row(align=True)

            selected_objects = len(bpy.context.selected_objects)
            has_onigiri = False
            if selected_objects == 1:
                o = bpy.context.selected_objects[0]
                has_onigiri = o.get('onigiri', False)
            if has_onigiri == False:
                    
                    row.operator(
                        "onigiri.show_rig_config",
                        text="Default Rig",
                        )
                    row.operator(
                        "onigiri.show_rig_config",
                        text="Neutral Rig",
                        )
                    row = col.row(align=True)
                    row.operator(
                        "onigiri.show_rig_config",
                        text="Pivot Rig",
                        )
                    row.operator(
                        "onigiri.show_rig_config",
                        text="POS Rig",
                        )
                    row = col.row(align=True)

            else:
                rig_class = o.get('rig_class')
                
                if rig_class == "default" and bbm.rig_class_to_default == False:
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_default = True
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_neutral = False
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_pos = False
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_pivot = False
                if rig_class == "neutral" and bbm.rig_class_to_neutral == False:
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_neutral = True
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_default = False
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_pos = False
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_pivot = False
                if rig_class == "pivot" and bbm.rig_class_to_pivot == False:
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_pivot = True
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_default = False
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_neutral = False
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_pos = False
                if rig_class == "pos" and bbm.rig_class_to_pos == False:
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_pos = True
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_default = False
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_neutral = False
                        bb_settings['terminate'] = True
                        bbm.rig_class_to_pivot = False

                row.prop(
                    bbm,
                    "rig_class_to_default",
                    toggle=True,
                    text = "Default Rig"
                    )
                row.prop(
                    bbm,
                    "rig_class_to_neutral",
                    toggle=True,
                    text = "Neutral Rig"
                    )
                row = col.row(align=True)
                row.prop(
                    bbm,
                    "rig_class_to_pivot",
                    toggle=True,
                    text = "Pivot Rig"
                    )
                row.prop(
                    bbm,
                    "rig_class_to_pos",
                    toggle=True,
                    text = "POS Rig"
                    )

            row = col.row(align=True)
            row.operator(
                "onigiri.force_rig_to_class",
                text="Force To Default",
                icon_value = ico.custom_icons["hammer"].icon_id
                ).rig_class="default"
            row.operator(
                "onigiri.force_rig_to_class",
                text="Force To Neutral",
                icon_value = ico.custom_icons["hammer"].icon_id
                ).rig_class="neutral"

        layout = self.layout
        box = layout.box()
        box.label(
            text = "View / Select bone types:"
            )
        col = box.column(align = True)

        is_qualified = False
        
        if bpy.context.active_object != None:
            o = bpy.context.active_object
            has_onigiri = o.get('onigiri')
            if has_onigiri != None:
                if o.type == 'ARMATURE':
                    is_qualified = True
        
        if 1 == 1:
            
            MOOFEEDOODLEPOODLEMAKOODLE = bbm.poll_enable_bones
            row = col.row(align=True)
            select_base_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            select_base_bones.action="select"
            select_base_bones.group="base"
            deselect_base_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )
            deselect_base_bones.action="deselect"
            deselect_base_bones.group="base"
            row.prop(
                bbm,
                "enable_base_bones",
                toggle=True,
                text = "Base"
                )
            select_hand_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            select_hand_bones.action="select"
            select_hand_bones.group="hand"
            deselect_hand_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )
            deselect_hand_bones.action="deselect"
            deselect_hand_bones.group="hand"
            row.prop(
                bbm,
                "enable_hand_bones",
                toggle=True,
                text = "Hand"
                )

            row = col.row(align=True)
            select_face_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            select_face_bones.action="select"
            select_face_bones.group="face"
            deselect_face_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )
            deselect_face_bones.action="deselect"
            deselect_face_bones.group="face"
            row.prop(
                bbm,
                "enable_face_bones",
                toggle=True,
                text = "Face"
                )
            select_tail_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            select_tail_bones.action="select"
            select_tail_bones.group="tail"
            deselect_tail_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )
            deselect_tail_bones.action="deselect"
            deselect_tail_bones.group="tail"
            row.prop(
                bbm,
                "enable_tail_bones",
                toggle=True,
                text = "Tail"
                )
            row = col.row(align=True)
            select_wing_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            select_wing_bones.action="select"
            select_wing_bones.group="wing"
            deselect_wing_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )
            deselect_wing_bones.action="deselect"
            deselect_wing_bones.group="wing"
            row.prop(
                bbm,
                "enable_wing_bones",
                toggle=True,
                text = "Wing"
                )
            select_hind_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            select_hind_bones.action="select"
            select_hind_bones.group="hind"
            deselect_hind_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )
            deselect_hind_bones.action="deselect"
            deselect_hind_bones.group="hind"
            row.prop(
                bbm,
                "enable_hind_bones",
                toggle=True,
                text = "Hind"
                )
            row = col.row(align=True)
            select_spine_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            select_spine_bones.action="select"
            select_spine_bones.group="spine"
            deselect_spine_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )
            deselect_spine_bones.action="deselect"
            deselect_spine_bones.group="spine"
            row.prop(
                bbm,
                "enable_spine_bones",
                toggle=True,
                text = "Spine"
                )
            select_volume_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            select_volume_bones.action="select"
            select_volume_bones.group="volume"
            deselect_volume_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )
            deselect_volume_bones.action="deselect"
            deselect_volume_bones.group="volume"
            row.prop(
                bbm,
                "enable_volume_bones",
                toggle=True,
                text = "Volume"
                )
            row = col.row(align=True)
            select_attach_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            select_attach_bones.action="select"
            select_attach_bones.group="attach"
            deselect_attach_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )
            deselect_attach_bones.action="deselect"
            deselect_attach_bones.group="attach"
            row.prop(
                bbm,
                "enable_attach_bones",
                toggle=True,
                text = "Attach (1)"
                )
            
            select_attach_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            select_attach_bones.action="select"
            select_attach_bones.group="attach"
            deselect_attach_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )
            deselect_attach_bones.action="deselect"
            deselect_attach_bones.group="attach"
            row.prop(
                bbm,
                "enable_attach2_bones",
                toggle=True,
                text = "Attach (2)"
                )

            row = col.row(align=True)
            select_unknown_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_green"].icon_id
                )
            select_unknown_bones.action="select"
            select_unknown_bones.group="unknown"
            deselect_unknown_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["dot_red"].icon_id
                )
            deselect_unknown_bones.action="deselect"
            deselect_unknown_bones.group="unknown"
            row.prop(
                bbm,
                "blank",
                text="Unknown",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bbm,
                "blank",
                text="",
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
            invert_selected_bones = row.operator(
                "onigiri.select_bones",
                text="",
                icon_value = ico.custom_icons["loop"].icon_id
                )
            invert_selected_bones.group="invert"
            invert_selected_bones = row.operator(
                "onigiri.select_bones",
                text="Invert Selection",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            invert_selected_bones.group="invert"

            row = col.row(align=True)
            row.operator(
                "onigiri.rigs_match_edit_to_view",
                text="Match edit to view",
                )

        box = layout.box()
        box.label(
            text = "Hide / Show bones:"
            )
        col = box.column(align = True)
        row = col.row(align=True)
        row.operator(
            "onigiri.rigs_view_bones",
            text="Hide Selected",
            ).action = "hide"
        row.operator(
            "onigiri.rigs_view_bones",
            text="Show All",
            ).action = "show"
        
        layout = self.layout
        box = layout.box()

        col = box.column(align = True)

        col.separator()

        row = col.row(align=True)
        row.label(
            text = "Rig Converter:"
            )
        
        if 1 == 0:
            row = col.row(align=True)
            row.prop(
                bbm,
                "use_old_rig",
                text="Convert to old rig (non Bento)",
                toggle = True,
                icon_value = ico.custom_icons["bone"].icon_id
                )

        row = col.row(align=True)
        row.operator(
            "onigiri.convert_from_avastar",
            text="Convert from Avastar",
            icon_value = ico.custom_icons["avastar_to_bb"].icon_id
            )
        
        if 1 == 0:
            row = col.row(align=True)
            row.operator(
                "onigiri.convert_avastar_rig",
                text="Convert Avastar rig to BB",
                icon_value = ico.custom_icons["avastar_to_bb"].icon_id
                )
            row.prop(
                bbm,
                "existing_bones_only",
                text="",
                toggle = True,
                icon_value = ico.custom_icons["x_black"].icon_id
                )

        if 1 == 0:
            row.prop(
                bbm,
                "convert_with_animation",
                text="",
                toggle = True,
                icon_value = ico.custom_icons["animation"].icon_id
                )

        col = box.column(align = True)
        row = col.row(align=True)
        row.operator(
            "onigiri.convert_to_full_rig",
            text="Convert incomplete rig to full Rig",
            icon_value = ico.custom_icons["sliders"].icon_id
            )
        row.prop(
            bbm,
            "rig_rotate",
            text="",
            toggle = True,
            icon_value = ico.custom_icons["rotate"].icon_id
            )

        row = col.row(align=True)
        row.prop(
            bbm,
            "rig_resize",
            text="Resize",
            toggle = True,
            icon_value = ico.custom_icons["blank"].icon_id
            )
        row.prop(
            bbm,
            "rig_connect",
            text="Connect",
            toggle = True,
            icon_value = ico.custom_icons["blank"].icon_id
            )
        row.prop(
            bbm,
            "rig_strip",
            text="Strip",
            toggle = True,
            icon_value = ico.custom_icons["blank"].icon_id
            )
        row = col.row(align=True)
        row.prop(
            bbm,
            "rig_align",
            text="Align",
            toggle = True,
            icon_value = ico.custom_icons["blank"].icon_id
            )
        row.prop(
            bbm,
            "rig_fix",
            text="Fix",
            toggle = True,
            icon_value = ico.custom_icons["blank"].icon_id
            )
        row.prop(
            bbm,
            "rig_match",
            text="Match",
            toggle = True,
            icon_value = ico.custom_icons["blank"].icon_id
            )

        col = box.column(align = True)
        row = col.row(align=True)
        row.prop(
            bbm,
            "overwrite_rig_data_backup",
            text="",
            toggle = True,
            icon_value = ico.custom_icons["store"].icon_id
            )
        row.operator(
            "onigiri.manage_rig_data",
            text="Store Rig Data",
            ).action = "store"
        row.operator(
            "onigiri.manage_rig_data",
            text="Restore Rig Data",
            icon_value = ico.custom_icons["reset"].icon_id
            ).action = "restore"
        row.operator(
            "onigiri.remove_rig_data",
            text="",
            icon_value = ico.custom_icons["x_red"].icon_id
            )
        row = col.row(align=True)
        row.operator(
            "onigiri.alter_volume_bone_scale",
            text="Apply SL Volume Scale",
            icon_value = ico.custom_icons["hammer"].icon_id
            ).action = "apply"
        row.operator(
            "onigiri.alter_volume_bone_scale",
            text="Restore Volume Scale",
            icon_value = ico.custom_icons["reset"].icon_id
            ).action = "restore"

        if 1 == 0:
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)
            row.label(
                text = "Change rig class flag only: (obsolete)"
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.fix_rig_flags",
                text="Class Flag to Neutral",
                ).rig_class = "neutral"
            row.operator(
                "onigiri.fix_rig_flags",
                text="Class Flag to Default",
                ).rig_class = "default"
            row = col.row(align=True)
            row.operator(
                "onigiri.fix_rig_flags",
                text="Class Flag to Pivot",
                ).rig_class = "pivot"
            row.operator(
                "onigiri.fix_rig_flags",
                text="Class Flag to POS",
                ).rig_class = "pos"

        layout = self.layout
        box = layout.box()
        col = box.column(align = True)
        row = col.row(align=True)

        row.label(
            text = "Bone View Options:",
            )

        row = col.row(align=True)
        row.operator(
            "onigiri.access_all_bones",
            text="Make all bones accessible",
            icon_value = ico.custom_icons["eye"].icon_id
            )

        row = col.row(align=True)
        row.operator(
            "onigiri.remove_bone_shapes",
            text="Remove bone shapes",
            icon_value = ico.custom_icons["bone_bent"].icon_id
            )
        row = col.row(align=True)
        row.prop(
            bbm,
            "select_bone_shape",
            text="Add Bone Shape",
            toggle = True,
            icon_value = ico.custom_icons["bone"].icon_id
            )

        row = col.row(align=True)
        row.operator(
            "onigiri.move_tail_to_head",
            text="Move tail to head",
            icon_value = ico.custom_icons["tail_to_head"].icon_id
            )
        
        if 1 == 0:
            row = col.row(align=True)
            row.operator(
                "onigiri.safe_connect",
                text="Safely Connect Bones",
                icon_value = ico.custom_icons["bone_fixed"].icon_id
                )

        row = col.row(align=True)
        row.operator(
            "onigiri.magnify_bones",
            text="Magnifiy Bones * 1",
            icon_value = ico.custom_icons["magnify"].icon_id
            )
        row.scale_x = 0.2

        row.operator(
            "onigiri.magnify_bones",
            text="2",
            ).mag = 2
        row.operator(
            "onigiri.magnify_bones",
            text="3",
            ).mag = 3
        row.operator(
            "onigiri.magnify_bones",
            text="4",
            ).mag = 4
        row.operator(
            "onigiri.magnify_bones",
            text="5",
            ).mag = 5

        row = col.row(align=True)
        row.operator(
            "onigiri.restore_bones",
            text="Restore Bones",
            icon_value = ico.custom_icons["restore_bone"].icon_id
            )
        
        layout = self.layout
        box = layout.box()
        col = box.column(align = True)
        row = col.row(align=True)
        row.label(
            text = "Misc:"
            )
        row = col.row(align=True)
        row.operator(
            "onigiri.clean_controllers",
            text="Remove Unusable Controllers",
            icon_value = ico.custom_icons["cut"].icon_id
            )
        
        row = col.row(align=True)
        row.operator(
            "onigiri.fix_deformable",
            text="Fix Deformable Bones",
            icon_value = ico.custom_icons["bone_bent"].icon_id
            )
        row = col.row(align=True)
        row.operator(
            "onigiri.fix_hierarchy",
            text="Fix Hierarchy",
            icon_value = ico.custom_icons["integrity_check"].icon_id
            )
        row = col.row(align=True)
        row.operator(
            "onigiri.fix_bone_roll",
            text="Fix Bone Roll",
            icon_value = ico.custom_icons["roll"].icon_id
            )
        row = col.row(align=True)
        row.operator(
            "onigiri.fix_armature_mesh_links",
            text="Fix Armature / Mesh Links",
            icon_value = ico.custom_icons["broken_link"].icon_id
            )
        row = col.row(align=True)
        row.prop(
            context.scene.bb_anim_props,
            "rebind_keep_animation",
            text = "",
            icon_value = ico.custom_icons["sync"].icon_id
            )
        row.operator(
            "onigiri.sync_mesh_to_armature",
            text="Rebind associated mesh",
            
            )
        
        row = col.row(align=True)
        row.operator(
            "onigiri.remove_constraints_operator",
            text="Remove constraints",
            icon_value = ico.custom_icons["remove_constraints"].icon_id
            )
        
        bbp = bpy.context.scene.bb_arm_props
        
        row = col.row(align=True)

        use_connect_text = "Unlock Bones"
        use_connect_action = "unlock"
        use_connect_icon = "unknown"
        selected = bpy.context.selected_objects
        if len(selected) == 1:
            if selected[0].get('bb_bones_locked') == True:
                use_connect_text = "Unlock Bones"
                use_connect_action = "unlock"
                use_connect_icon = "key_green"
            elif selected[0].get('bb_bones_locked') == False:
                use_connect_text = "Lock Bones"
                use_connect_action = "lock"
                use_connect_icon = "key_red"

        row.operator(
            "onigiri.rigs_use_connect",
            text=use_connect_text,
            icon_value = ico.custom_icons[use_connect_icon].icon_id
            ).action = use_connect_action

        row = col.row(align=True)
        row.operator(
            "onigiri.fix_sl_alias_bones",
            text="Fix SL BVH Rig",
            icon_value = ico.custom_icons["glue"].icon_id
            )

        row = col.row(align=True)
        row.operator(
            "onigiri.fix_rig_orientation",
            text="Fix Rig Orientation (SL)",
            icon_value = ico.custom_icons["orientation"].icon_id
            )

        row = col.row(align=True)
        row.operator(
            "onigiri.rotate_toggle",
            text="Transform Toggle",
            icon_value = ico.custom_icons["transform"].icon_id
            )

        row = col.row(align=True)
        row.operator(
            "onigiri.remove_control_rig",
            text="Remove the control rig",
            icon_value = ico.custom_icons["control"].icon_id
            )

        col.separator()
        row = col.row(align=True)
        row.operator(
            "onigiri.rotate_rig",
            text="Rotate Rig",
            icon_value = ico.custom_icons["rotate"].icon_id
            )
        row = col.row(align=True)
        row.prop(
            context.scene.bb_anim_props,
            "x_rotate_value",
            text = "X:"
            )
        row.prop(
            context.scene.bb_anim_props,
            "y_rotate_value",
            text = "Y:"
            )
        row.prop(
            context.scene.bb_anim_props,
            "z_rotate_value",
            text = "Z:"
            )

        col.separator()
        row = col.row(align=True)

        row.operator(
            "onigiri.rotation_mode",
            text="Set rotation mode",
            icon_value = ico.custom_icons["angle"].icon_id
            )
        row = col.row(align=True)
        row.prop_menu_enum(
            context.scene.bb_anim_props,
            "rotation_mode",
            text="Rotation Mode: " + context.scene.bb_anim_props.rotation_mode,
            )

        bb = bpy.context.scene.onigiri
        bb_rig = bpy.context.window_manager.bb_rig
        layout = self.layout
        box = layout.box()
        col = box.column(align = True)
        row = col.row(align=True)

        row.label(
            text = "Pose Bone Transforms:"
            )
        row = col.row(align=True)

        row.prop(
            bb_rig,
            "lock_selected",
            text = "Lock Selected",
            toggle = True,
            icon_value = ico.custom_icons["lock_black"].icon_id
            )

        if bb_rig.lock_engaged == True:
            obj = bpy.data.objects
            
            if bb_rig.rig_selected == "" or bb_rig.bone_selected == "":
                bb_rig.lock_selected = False
            
            else:
                if bb_rig.rig_selected not in obj:
                    bb_rig.lock_selected = False
                else:
                    if bb_rig.bone_selected not in obj[bb_rig.rig_selected].data.bones:
                        bb_rig.lock_selected = False

        else:
            bb_rig.rig_selected = ""
            bb_rig.bone_selected = ""
            if bpy.context.object and bpy.context.object.type == 'ARMATURE':
                if context.mode == 'POSE' and len(bpy.context.selected_pose_bones) == 1:
                    bone = bpy.context.selected_pose_bones[0].name
                    bb_rig.rig_selected = bpy.context.object.name
                    bb_rig.bone_selected = bone

        if bb_rig.rig_selected != "":
            if bb_rig.bone_selected != "":
                armObj = bpy.data.objects[bb_rig.rig_selected]
                dBone = armObj.data.bones[bb_rig.bone_selected]
                mat = dBone.matrix_local.copy()
                deg = pill.to_deg(mat)
                deg = [round(a,4) for a in deg]
                loc = mat.to_translation()
                loc = [round(a,4) for a in loc]
                sca = [round(s,4) for s in armObj.pose.bones[bb_rig.bone_selected].scale]
                row = col.row(align=True)

                row.prop(
                    bb,
                    "blank",
                    text = "Rig: " + bb_rig.rig_selected,
                    toggle = True,
                    icon_value = ico.custom_icons["running_guy"].icon_id
                    )
                row = col.row(align=True)
                row.prop(
                    bb,
                    "blank",
                    text = "Bone: " + bb_rig.bone_selected,
                    toggle = True,
                    icon_value = ico.custom_icons["bone_black"].icon_id
                    )
                row = col.row(align=True)

                row.prop(
                    bb,
                    "blank",
                    text = "ROT: " + str(deg),
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row = col.row(align=True)
                row.prop(
                    bb,
                    "blank",
                    text = "LOC: " + str(loc),
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )

                if dBone.parent:
                    matl = dBone.parent.matrix_local.inverted() @ mat
                    matg = mat @ dBone.parent.matrix_local.inverted()
                    degl = pill.to_deg(matl)
                    degl = [round(a,4) for a in degl]
                    locl = matl.to_translation()
                    locl = [round(a,4) for a in locl]
                    degg = pill.to_deg(matg)
                    degg = [round(a,4) for a in degg]
                    locg = matl.to_translation()
                    locg = [round(a,4) for a in locg]
                    row = col.row(align=True)

                    row.prop(
                        bb,
                        "blank",
                        text = "ROT Local: " + str(degl),
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row = col.row(align=True)
                    row.prop(
                        bb,
                        "blank",
                        text = "LOC Local: " + str(locl),
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row = col.row(align=True)
                    row.prop(
                        bb,
                        "blank",
                        text = "ROT Global: " + str(degg),
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row = col.row(align=True)
                    row.prop(
                        bb,
                        "blank",
                        text = "LOC Global: " + str(locg),
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                    row = col.row(align=True)
                    row.prop(
                        bb,
                        "blank",
                        text = "Scale: " + str(sca),
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
        
class OnigiriHeadProperties(bpy.types.PropertyGroup):

    def update_bento_head_lock(self, context):
        if bb_settings['terminate'] == True:
            bb_settings['terminate'] = False
            return
        
            print("Terminating")
            return
        bbh = bpy.context.window_manager.bb_head
        obj = bpy.data.objects
        selected = bpy.context.selected_objects

        if bbh.bento_head_lock == True:
            
            if len(selected) == 0:
                print("nothing selected")
                bbh.bento_head_message = "I need a mesh object"
                bbh.bento_head_terminate = True
                bbh.bento_head_lock = False
                return
            
            if len(selected) > 1:
                bbh.bento_head_message = "Select only 1 object"
                bbh.bento_head_terminate = True
                bbh.bento_head_lock = False
                return
            meshObj = selected[0]
            
            if meshObj.type != 'MESH':
                print("object must be a mesh")
                bbh.bento_head_message = "Must be a mesh object"
                bbh.bento_head_terminate = True
                bbh.bento_head_lock = False
                return
            
            old_mode = bpy.context.mode
            bpy.ops.object.mode_set(mode='EDIT')
            if len(meshObj.data.vertices) != bb_settings['mh_vcount']:
                bpy.ops.object.mode_set(mode=old_mode)
                print("Vertex count does not match MH")
                bbh.bento_head_message = "Vertex count is wrong"
                bbh.bento_head_terminate = True
                bbh.bento_head_lock = False
                return
            
            print("Bento head locked")

            bbh.bento_head_mesh_name = meshObj.name
            bbh.bento_head_enabled = True
            
            bpy.context.tool_settings.mesh_select_mode = (False, True, False) 
            bpy.ops.mesh.select_all(action='DESELECT')
            meshObj.update_from_editmode()
            edge_index = bb_settings['mh_edges'][bbh.bento_head_length]
            
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.data.objects[bbh.bento_head_mesh_name].data.edges[edge_index].select = True
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.loop_multi_select(ring=False)
            meshObj.update_from_editmode()

        else:
            bbh.bento_head_mesh_name = ""
            bbh.bento_head_enabled = False
        return

    def update_bento_head_length(self, context):
        obj = bpy.data.objects
        bbh = bpy.context.window_manager.bb_head
        
        bpy.ops.mesh.select_all(action='DESELECT')
        
        bpy.ops.object.mode_set(mode='OBJECT')
        edge_index = bb_settings['mh_edges'][bbh.bento_head_length]
        obj[bbh.bento_head_mesh_name].data.edges[edge_index].select = True
        
        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.mesh.loop_multi_select(ring=False)
        obj[bbh.bento_head_mesh_name].update_from_editmode()
        return

    bento_head_enabled : bpy.props.BoolProperty(
        description =            "Enable the head tools, this will put the mesh into edit mode so that you can see "            "what your selection is.  The tools below will give you the ability to slice at certain places.",
        default = False,
        )
    bento_head_lock : bpy.props.BoolProperty(
        description =            "Select a Makehuman standard mesh and click this button to start.",
        default = False,
        update = update_bento_head_lock
        )
    bento_head_message : bpy.props.StringProperty(
        default = "[watch here for messages]",
        )
    
    bento_head_fix_seam : bpy.props.BoolProperty(
        description =            "After the cut there will be a seam between the body and the head, if you choose to keep the body.  "            "This button will apply a data transfer modifier to correct the (normals) and apply it.  Unfortunately Blender "            "will keep reminding you that they are separate objects by visibly displaying a line between them.  In SL, however, "            "this partition is reduced dramatically and, with an applied texture, very difficult to see.",
        default = True,
        )
    bento_head_keep_body : bpy.props.BoolProperty(
        description =            "The Bento head is detached from the body and the body is removed.  If you want to keep the body for futher work you can "            "enable this option.  The default is to keep it since it's a bit more congruent visually and, if you are going to use the "            "Makehuman body as well, then you will want to keep this enabled.",
        default = True,
        )
    bento_head_keep_original : bpy.props.BoolProperty(
        description =            "The process makes copies of the original mesh, in order to create the separate parts, head and body.  It leaves the "            "original untouched.  If you want the original body to be removed then enable this feature.",
        default = True,
        )

    bento_head_mesh_name : bpy.props.StringProperty(
        description = "The name of the mesh you're working on will show here",
        default = "",
        )
    bento_head_length : bpy.props.IntProperty(
        min = 0,
        max = 5,
        default = 2,
        update = update_bento_head_length
        )

    bento_head_tools_enabled : bpy.props.BoolProperty(
        description = "--internal - triggers tools",
        default=False
        )

    def update_object_outline(self, context):
        bbh = bpy.context.window_manager.bb_head
        if bbh.bento_head_object_outline == True:
            bpy.context.space_data.shading.show_object_outline = True
        else:
            bpy.context.space_data.shading.show_object_outline = False

    bento_head_object_outline : bpy.props.BoolProperty(
        description =            "If you're using the (fix seam) feature you may not realize that it's working because of a "            "Blender feature that draws an outline around every object.  This button allows you to toggle that on and off.",
        default=True,
        update = update_object_outline
        )

class OnigiriHeadOperator(bpy.types.Operator):
    """Generate a Bento Head from your Makehuman"""

    bl_idname = "onigiri.bento_head"
    bl_label = "Bento Head"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) > 1:
            return False
        
        if bpy.context.mode != 'EDIT_MESH':
            return False

        return True

    def execute(self, context):
        obj = bpy.data.objects
        bbh = bpy.context.window_manager.bb_head
        meshObj = bpy.context.selected_objects[0]

        bpy.ops.object.mode_set(mode='OBJECT')

        error = apply_transform_chain(meshObj.name)
        if error == False:
            print("some error occurred when attempting to find an armature", meshObj.name)
            return {'FINISHED'}

        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')

        meshObj.select_set(True)

        bpy.context.view_layer.objects.active = meshObj

        bpy.ops.object.mode_set(mode='EDIT')
        bpy.context.tool_settings.mesh_select_mode = (False, True, False) 

        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.mesh.edge_split()
        
        bpy.ops.mesh.select_all(action='DESELECT')
        bpy.ops.object.mode_set(mode='OBJECT')

        mesh_name = meshObj.name
        bpy.ops.object.duplicate()
        o = bpy.context.selected_objects[0]
        o.name = mesh_name + "_head"
        mesh_head_name = o.name 

        selected = bpy.context.selected_objects
        print("selected:", selected)

        if bbh.bento_head_fix_seam == True:

            bpy.context.object.data.use_auto_smooth = True
            
            bpy.ops.mesh.customdata_custom_splitnormals_add()
            
            bpy.ops.object.modifier_add(type='DATA_TRANSFER')
            
            for m in obj[mesh_head_name].modifiers:
                if m.type == 'DATA_TRANSFER':
                    dt_name = m.name
                    break
            
            obj[mesh_head_name].modifiers[dt_name].object = obj[mesh_name]
            
            bpy.context.object.modifiers[dt_name].use_loop_data = True
            bpy.context.object.modifiers[dt_name].data_types_loops = {'CUSTOM_NORMAL'}

            bpy.ops.object.modifier_apply(modifier=dt_name)

        bpy.ops.object.duplicate()
        o = bpy.context.selected_objects[0]
        o.name = mesh_name + "_body"
        mesh_body_name = o.name

        bpy.context.tool_settings.mesh_select_mode = (False, False, True)

        bpy.data.objects[mesh_body_name].data.polygons[0].select = True
        
        bpy.ops.object.mode_set(mode='EDIT')

        bpy.ops.mesh.select_linked()
        polys_1 = get_selected_polygons()
        invert_polygon_selection()
        polys_2 = get_selected_polygons()

        bpy.ops.mesh.select_all(action='DESELECT')
        bpy.ops.object.mode_set(mode='OBJECT')

        if polys_1 < polys_2:
            head_polys = polys_1
            body_polys = polys_2
        else:
            head_polys = polys_2
            body_polys = polys_1

        obj[mesh_body_name].data.polygons[head_polys[0]].select = True
        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.mesh.select_linked()
        
        bpy.ops.mesh.delete(type='VERT')

        bpy.ops.object.mode_set(mode='OBJECT')
        obj[mesh_body_name].select_set(False)
        obj[mesh_head_name].select_set(True)
        obj[mesh_head_name].data.polygons[body_polys[0]].select = True
        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.mesh.select_linked()
        bpy.ops.mesh.delete(type='VERT')
        bpy.ops.object.mode_set(mode='OBJECT')
        obj[mesh_head_name].select_set(False)

        bbh.bento_head_lock = False
        bbh.bento_head_tools_enabled = True

        obj[mesh_name]['mh_mesh_part'] = "base"
        obj[mesh_body_name]['mh_mesh_part'] = "body"
        obj[mesh_head_name]['mh_mesh_part'] = "head"

        arm = get_mesh_armature(mesh=mesh_head_name)
        obj[arm]['bento_head'] = True

        if bbh.bento_head_keep_original == False:
            obj[mesh_name].select_set(True)
            bpy.ops.object.delete()

        if bbh.bento_head_keep_body == False:
            obj[mesh_body_name].select_set(True)
            bpy.ops.object.delete()

        return {'FINISHED'}

class OnigiriHeadPanel(bpy.types.Panel):
    """Bento Heads"""
    bl_idname = "OBJECT_PT_bento_buddy_head"
    bl_label = "Bento Head Tool"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        ccp = bpy.context.window_manager.cc_props
        bbm = bpy.context.window_manager.bb_misc
        brp = bpy.context.window_manager.bb_rigprops
        bbh = bpy.context.window_manager.bb_head

        row = self.layout.row(align=True)
        row.prop(
            bbh,
            "bento_head_lock",
            text="Lock Mesh",
            icon_value = ico.custom_icons["head"].icon_id
            )
        row.prop(
            bbh,
            "bento_head_mesh_name",
            text="",
            icon_value = ico.custom_icons["info"].icon_id
            )

        row = self.layout.row(align=True)

        row.label(
            text = bbh.bento_head_message
            )
        row = self.layout.row(align=True)

        if bbh.bento_head_enabled == True:
            row.label(
                text = "Cut Length:",
                )
            row.scale_x = 0.4
            row.prop(
                bbh,
                "bento_head_length",
                text="",
                )
            row = self.layout.row(align=True)
            row.prop(
                bbh,
                "bento_head_fix_seam",
                text="Fix Seam",
                toggle = True
                )
            row.prop(
                bbh,
                "bento_head_keep_body",
                text="Keep Body",
                toggle = True
                )
            row = self.layout.row(align=True)
            row.prop(
                bbh,
                "bento_head_keep_original",
                text="Keep Original",
                toggle = True
                )

            row = self.layout.row(align=True)
            row.operator(
                "onigiri.bento_head",
                text="Generate Bento Head",
    
                )
    
        if bbh.bento_head_tools_enabled == True:
            row = self.layout.row(align=True)
            row.prop(
                bbh,
                "bento_head_object_outline",
                text="Object Outline",
                toggle = True
                )

class OnigiriTestOperatorEnable(bpy.types.Operator):
    bl_idname = "test.enable"
    bl_label = "Test Operator Enabler"

    def execute(self, context):
        bpy.utils.register_class(OnigiriTestPanel)

        return {'FINISHED'}

class OnigiriTestOperator(bpy.types.Operator):
    """For testing"""
    
    bl_idname = "test.test"
    bl_label = "Test Operator"

    action : bpy.props.StringProperty(default="")

    @classmethod
    def poll(cls, context):
        pass
        return True

    def execute(self, context):

        if self.action == "scale_sl":
            if bpy.context.object.type != 'ARMATURE':
                print("Not an armature")
                return {'FINISHED'}
            bpy.ops.object.mode_set(mode='POSE')
            print("Applying SL bone scale to vbones")
            for boneObj in bpy.context.object.pose.bones:
                bone = boneObj.name
                if bone in volumes.vol_joints:
                    boneObj.scale = volumes.vol_joints[bone]['scale']
            bpy.context.view_layer.update()
            bpy.ops.object.mode_set(mode='OBJECT')
            return {'FINISHED'}
        
        elif self.action == "scale_reset":
            if bpy.context.object.type != 'ARMATURE':
                print("Not an armature")
                return {'FINISHED'}
            bpy.ops.object.mode_set(mode='POSE')
            print("Resetting bone scale to 1 for vbones")
            for boneObj in bpy.context.object.pose.bones:
                bone = boneObj.name
                if bone in volumes.vol_joints:
                    boneObj.scale = 1.0, 1.0, 1.0
            bpy.context.view_layer.update()
            bpy.ops.object.mode_set(mode='OBJECT')
            return {'FINISHED'}
        elif self.action == "generic":
            print("Generic Test O.o")
            filename = script_dir + "/test_file.py"
            try:
                exec(compile(open(filename, 'r', encoding='UTF8').read(), filename, 'exec'))
            except Exception as e:
                txt = traceback.format_exc()
                print(txt)
            return {'FINISHED'}
        elif self.action == "quats_to_euler":
            from . import action_quats_to_euler as xyzzy
            xyzzy.convert_quaternion_to_euler(bpy.context.object.animation_data.action, bpy.context.object, 'XYZ')

        elif self.action == "unhide_bones":
            selected = bpy.context.selected_objects
            if len(selected) == 1:
                armObj = selected[0]
                if armObj.type == 'ARMATURE':
                    for boneObj in armObj.data.bones:
                        boneObj.hide = False
        elif self.action == "avastar_data":
            filename = script_dir + "/test_ava_file.py"
            try:
                exec(compile(open(filename, 'r', encoding='UTF8').read(), filename, 'exec'))
            except Exception as e:
                txt = traceback.format_exc()
                print(txt)
            return {'FINISHED'}

        else:
            print("unknown action")
        return {'FINISHED'}

class OnigiriServerProperties(bpy.types.PropertyGroup):

    daemon: bpy.props.BoolProperty(
        name = "Dictionary of Daemons",
        description =            "-- internal, sounds like a magical spell O.o",
        default = False,
        )

class OnigiriTestProperties(bpy.types.PropertyGroup):

    test_panel_enabled : bpy.props.BoolProperty(
        name = "test property bool",
        description =            "Description of test property bool",
        default = False,
        )
    test_property_string : bpy.props.StringProperty(
        name = "test property string",
        description = "Description of test property string",
        default = "",
        )
    edge_number : bpy.props.IntProperty(default=0)

class OnigiriTestPanel(bpy.types.Panel):
    """Test"""

    bl_idname = "OBJECT_PT_bento_buddy_test"
    bl_label = "Test Panel"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):

        ccp = bpy.context.window_manager.cc_props
        bbm = bpy.context.window_manager.bb_misc
        brp = bpy.context.window_manager.bb_rigprops
        bbt = bpy.context.window_manager.bb_test

        row = self.layout.row(align=True)
        row.operator(
            "test.test",
            text="Scale vbones",
            icon_value = ico.custom_icons["experiment"].icon_id,
            ).action = "scale_sl"
        row = self.layout.row(align=True)
        row.operator(
            "test.test",
            text="Restore vbones",
            icon_value = ico.custom_icons["experiment"].icon_id,
            ).action = "scale_reset"
        row = self.layout.row(align=True)
        row.operator(
            "test.test",
            text="Extract Ava Data",
            icon_value = ico.custom_icons["experiment"].icon_id,
            ).action = "avastar_data"
        row = self.layout.row(align=True)
        row.operator(
            "test.test",
            text="Action - quats to euler",
            icon_value = ico.custom_icons["experiment"].icon_id,
            ).action = "quats_to_euler"
        row = self.layout.row(align=True)
        row.operator(
            "test.test",
            text="Rig - unhide bones",
            icon_value = ico.custom_icons["experiment"].icon_id,
            ).action = "unhide_bones"

        row = self.layout.row(align=True)
        row.operator(
            "test.test",
            text="Generic Test",
            icon_value = ico.custom_icons["experiment"].icon_id,
            ).action = "generic"

        if bpy.context.object and bpy.context.object.type == 'ARMATURE':
            if context.mode == 'POSE' and len(bpy.context.selected_pose_bones) == 1:
                layout = self.layout
                box = layout.box()
                col = box.column(align = True)
                row = col.row(align=True)
                bone = bpy.context.selected_pose_bones[0].name
                armObj = bpy.context.object
                dBone = armObj.data.bones[bone]
                mat = dBone.matrix_local.copy()
                deg = pill.to_deg(mat)
                deg = [round(a,4) for a in deg]
                loc = mat.to_translation()
                loc = [round(a,4) for a in loc]
                row = col.row(align=True)
                row.label(
                    text = "ROT: " + str(deg)
                )
                row = col.row(align=True)
                row.label(
                    text = "LOC: " + str(loc)
                )
                if dBone.parent:
                    matl = dBone.parent.matrix_local.inverted() @ mat
                    matg = mat @ dBone.parent.matrix_local.inverted()
                    degl = pill.to_deg(matl)
                    degl = [round(a,4) for a in degl]
                    locl = matl.to_translation()
                    locl = [round(a,4) for a in locl]
                    degg = pill.to_deg(matg)
                    degg = [round(a,4) for a in degg]
                    locg = matl.to_translation()
                    locg = [round(a,4) for a in locg]
                    row = col.row(align=True)
                    row.label(
                        text = "ROTL: " + str(degl)
                    )
                    row = col.row(align=True)
                    row.label(
                        text = "LOCL: " + str(locl)
                    )
                    row = col.row(align=True)
                    row.label(
                        text = "ROTG: " + str(degg)
                    )
                    row = col.row(align=True)
                    row.label(
                        text = "LOCG: " + str(locg)
                    )

class OnigiriShapeShifterPanel(bpy.types.Panel):
    """Mesh Tools"""
    bl_idname = "OBJECT_PT_bento_buddy_shape_shifter"
    bl_label = "Shape Shifter"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        ss = bpy.context.scene.bb_shifter
        layout = self.layout

        row = self.layout.row(align=True)
        shifter_morph_menu_enabled_icon = "menu_closed"
        if ss.shifter_morph_menu_enabled == True:
            shifter_morph_menu_enabled_icon = "menu_opened"
        row.prop(
            ss,
            "shifter_morph_menu_enabled",
            text="Morph Character Rig",
            toggle = True,
            icon_value = ico.custom_icons[shifter_morph_menu_enabled_icon].icon_id
            )
        if ss.shifter_morph_menu_enabled == True:
            
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)

            if ss.shifter_morph_source_locked == True:
                row.prop(
                    ss,
                    "shifter_morph_source_locked",
                    toggle = True,
                    text="Choose Source First",
                    )
                row.label(
                    text = ss.shifter_morph_source_name,
                    )
            else:
                row.operator(
                    "onigiri.shifter_morph",
                    text="Choose Source First",
                    icon_value = ico.custom_icons["dot_blue"].icon_id
                    ).action = "source"

                row.prop(
                    ss,
                    "shifter_morph_source_name",
                    text="",
                    )

            row = col.row(align=True)
            if ss.shifter_morph_target_locked == True:
                row.prop(
                    ss,
                    "shifter_morph_target_locked",
                    toggle = True,
                    text="Choose Targets",
                    )
                row.label(
                    text = ss.shifter_morph_target_name,
                    )

            else:
                
                row.enabled = False
                if ss.get('template_map') == None:
                    row.enabled = True

                row.operator(
                    "onigiri.shifter_morph",
                    text="Choose Targets",
                    icon_value = ico.custom_icons["dot_red"].icon_id
                    ).action = "target"
                row.prop(
                    ss,
                    "shifter_morph_target_name",
                    text="",
                    )

            row = col.row(align=True)

            row.operator(
                "onigiri.shifter_load",
                text="Load Template",
                icon_value = ico.custom_icons["load"].icon_id
                )

            row.prop(
                ss,
                "shifter_morph_match",
                text="Match Map",
                toggle = True,
                icon_value = ico.custom_icons["match"].icon_id
                )

            row = col.row(align=True)
            row.operator(
                "onigiri.shifter_morph",
                text="Reset",
                icon_value = ico.custom_icons["reset"].icon_id
                ).action = "reset"

            targets_waiting = ss.get('targets_waiting', [])
            for tarm in targets_waiting:
                row = col.row(align=True)
                row.operator(
                    "onigiri.shifter_target",
                    text=tarm,
                    icon_value = ico.custom_icons["dot_red"].icon_id
                    ).name = tarm

            col = box.column(align = True)
            row = col.row(align=True)
            shifter_morph_icon = "shape_shifter"
            if ss.shifter_morph_source_locked == True and ss.shifter_morph_target_locked == True:
                shifter_morph_icon = "shape_shifter_navy"
            row.operator(
                "onigiri.shifter_morph",
                text="Morph Rigs",
                icon_value = ico.custom_icons[shifter_morph_icon].icon_id
                ).action = "morph"
            row = col.row(align=True)
            row.prop(
                ss,
                "shifter_morph_location",
                text="Location",
                toggle = True,
                )
            row.prop(
                ss,
                "shifter_morph_rotation",
                text="Rotation",
                toggle = True,
                )
            row.prop(
                ss,
                "shifter_morph_scale",
                text="Scale",
                toggle = True,
                )

            row = col.row(align=True)
            row.prop(
                ss,
                "shifter_morph_start",
                text="Start Frame",
                )
            row.prop(
                ss,
                "shifter_morph_range",
                text="Frame Range",
                )
            row = col.row(align=True)

            shifter_morph_reverse_row_enabled = True
            shifter_morph_reverse_icon = "peak_black"

            peak_message = "Ready!"
            
            if ss.shifter_morph_range < 3:
                shifter_morph_reverse_row_enabled = False
                shifter_morph_reverse_icon = "peak_red"
                peak_message = "reverse disabled, 3+ frames required"

            else:
                
                morph_end_frame = ss.shifter_morph_start + ss.shifter_morph_range - 1

                if ss.shifter_morph_peak > morph_end_frame - 1:
                    shifter_morph_reverse_icon = "peak_yellow"
                    peak_message = "peak is too high"
                
                if ss.shifter_morph_peak < ss.shifter_morph_start + 1:
                    shifter_morph_reverse_icon = "peak_white"
                    peak_message = "peak is too low"

            row = col.row(align=True)
            row.enabled = shifter_morph_reverse_row_enabled
            row.prop(
                ss,
                "shifter_morph_reverse",
                text="Reverse",
                toggle = True,
                icon_value = ico.custom_icons[shifter_morph_reverse_icon].icon_id
                )
            row.prop(
                ss,
                "shifter_morph_peak",
                text="Peak Frame",
                )

            row = col.row(align=True)
            row.label(text="Peak Message: " + peak_message)

        row = self.layout.row(align=True)
        shifter_freeform_menu_enabled_icon = "menu_closed"
        if ss.shifter_freeform_menu_enabled == True:
            shifter_freeform_menu_enabled_icon = "menu_opened"
        row.prop(
            ss,
            "shifter_freeform_menu_enabled",
            text="Free-form Morph Pose",
            toggle = True,
            icon_value = ico.custom_icons[shifter_freeform_menu_enabled_icon].icon_id
            )
        if ss.shifter_freeform_menu_enabled == True:
            
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)

            row = col.row(align=True)
            row.operator(
                "onigiri.shifter_pose_rig",
                text="Pose Rig",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                ss,
                "shifter_pose_to_current",
                text="Current",
                toggle = True
                )
            row.prop(
                ss,
                "shifter_pose_to_start",
                text="Start",
                toggle = True
                )
            row.prop(
                ss,
                "shifter_pose_to_range",
                text="Range",
                toggle = True
                )
            row = col.row(align=True)
            row.label(
                text = "Location",
                )
            row = col.row(align=True)
            row.prop(
                ss,
                "shifter_pose_to_location_x",
                text="X",
                )
            row.prop(
                ss,
                "shifter_pose_to_location_y",
                text="Y",
                )
            row.prop(
                ss,
                "shifter_pose_to_location_z",
                text="Z",
                )
            row = col.row(align=True)
            row.label(
                text = "Rotation",
                )
            row = col.row(align=True)
            row.prop(
                ss,
                "shifter_pose_to_rotation_x",
                text="X",
                )
            row.prop(
                ss,
                "shifter_pose_to_rotation_y",
                text="Y",
                )
            row.prop(
                ss,
                "shifter_pose_to_rotation_z",
                text="Z",
                )
            row = col.row(align=True)
            row.label(
                text = "Scale",
                )
            row = col.row(align=True)
            row.prop(
                ss,
                "shifter_pose_to_scale_x",
                text="X",
                )
            row.prop(
                ss,
                "shifter_pose_to_scale_y",
                text="Y",
                )
            row.prop(
                ss,
                "shifter_pose_to_scale_z",
                text="Z",
                )

        bb_shifter = bpy.context.scene.bb_shifter
        row = self.layout.row(align=True)
        shifter_build_menu_enabled_icon = "menu_closed"
        if bb_shifter.shifter_build_menu_enabled == True:
            shifter_build_menu_enabled_icon = "menu_opened"
        row.prop(
            bb_shifter,
            "shifter_build_menu_enabled",
            text="Build-A-Rig",
            toggle = True,
            icon_value = ico.custom_icons[shifter_build_menu_enabled_icon].icon_id
            )
        if bb_shifter.shifter_build_menu_enabled == True:
            
            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.shifter_freeze_rig",
                text="Make bone bag",
                icon_value = ico.custom_icons["freeze"].icon_id
                )
            row = col.row(align=True)

            frozen_bone = "" 
            if bpy.context.mode == 'POSE':
                if len(bpy.context.selected_pose_bones) == 1:
                    frozen_bone = bpy.context.selected_pose_bones[0].name

            if bb_shifter.shifter_build_link == True:
                if bpy.context.mode == 'POSE':
                    row.prop(
                        bb_shifter,
                        "shifter_build_link",
                        text="Select parent and click",
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )
                
                else:
                    row.enabled = False
                    row.prop(
                        bb_shifter,
                        "shifter_blank",
                        text="Select parent and click",
                        toggle = True,
                        icon_value = ico.custom_icons["blank"].icon_id
                        )

            else:
                row.operator(
                    "onigiri.shifter_build_link",
                    text="Link Bones",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )

            row.operator(
                "onigiri.shifter_build_unlink",
                text="Unlink Bones",
                icon_value = ico.custom_icons["blank"].icon_id
                )

            row = col.row(align=True)
            row.operator(
                "onigiri.shifter_build_connect",
                text="Connect",
                icon_value = ico.custom_icons["blank"].icon_id
                ).use_connect = "yes"
            row.operator(
                "onigiri.shifter_build_connect",
                text="Disconnect",
                icon_value = ico.custom_icons["blank"].icon_id
                ).use_connect = "no"
            row = col.row(align=True)
            row.operator(
                "onigiri.shifter_build_snap",
                text="Snap selected to parent",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row = col.row(align=True)

            row.operator(
                "onigiri.shifter_build_select",
                text="Select Parents",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "parents"
            row.operator(
                "onigiri.shifter_build_select",
                text="Select Children",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "children"

            if len(shifter.props['frozen_bones']) == 0:
                shifter_build_bone = " "
            elif len(shifter.props['frozen_bones']) == 1:
                shifter_build_bone = shifter.props['frozen_bones'][0]
            elif len(shifter.props['frozen_bones']) > 1:
                shifter_build_bone = str(len(shifter.props['frozen_bones']))
            row = col.row(align=True)
            row.prop(
                bb_shifter,
                "shifter_blank",
                text=shifter_build_bone,
                toggle = True,
                icon_value = ico.custom_icons["blank"].icon_id
                )
        
        if 1 == 0:
            bb_latch = bpy.context.window_manager.bb_latch
            row = self.layout.row(align=True)
            latch_menu_enabled_icon = "menu_closed"
            if bb_latch.latch_menu_enabled == True:
                latch_menu_enabled_icon = "menu_opened"
            row.prop(
                bb_latch,
                "latch_menu_enabled",
                text="Latch Rigs (chain)",
                toggle = True,
                icon_value = ico.custom_icons[latch_menu_enabled_icon].icon_id
                )
            if bb_latch.latch_menu_enabled == True:
                layout = self.layout
                box = layout.box()
                col = box.column(align = True)
                row = col.row(align=True)

                col = box.column(align = True)
                row = col.row(align=True)

                row.operator(
                    "onigiri.snap_load_map",
                    text="Load Map",
                    icon_value = ico.custom_icons["load"].icon_id
                    )
                row.operator(
                    "onigiri.snap_clean",
                    text="Remove Map",
                    icon_value = ico.custom_icons["reset"].icon_id
                    )

                row = col.row(align=True)
                bb_latch_rename_text = " "
                bb_latch_rename_icon = "blank"
                o = bpy.context.active_object
                if o != None:
                    if o.type == 'ARMATURE':
                        bb_latch_rename = o.get('bb_onemap_rename')
                        if bb_latch_rename != None:
                            bb_latch_rename_text = "Rig contains a map"
                            bb_latch_rename_icon = "bone_black_red"
                row.prop(
                    bb_latch,
                    "latch_blank",
                    text=bb_latch_rename_text,
                    toggle = True,
                    icon_value = ico.custom_icons[bb_latch_rename_icon].icon_id
                    )
                
                row = col.row(align=True)
                latch_actor_engaged = bb_latch.latch_actor_poll
                latch_director_engaged = bb_latch.latch_director_poll
                if latch_actor_engaged == True:
                    row.prop(
                        bb_latch,
                        "latch_actor",
                        text = "Latch Actor",
                        icon_value = ico.custom_icons["dot_blue"].icon_id
                        )
                else:
                    row.operator(
                        "onigiri.latch_actor",
                        text="Latch Actor",
                        icon_value = ico.custom_icons["dot_blue"].icon_id
                        )
                if latch_director_engaged == True:
                    row.prop(
                        bb_latch,
                        "latch_director",
                        text = "Latch Director",
                        icon_value = ico.custom_icons["dot_red"].icon_id
                        )
                else:
                    row.operator(
                        "onigiri.latch_director",
                        text="Latch Director",
                        icon_value = ico.custom_icons["dot_red"].icon_id
                        )

                row = col.row(align=True)
                row.operator(
                    "onigiri.latch_snap",
                    text="Latch Snap",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.operator(
                    "onigiri.latch_connect",
                    text="Latch Connect",
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.latch_restore",
                    text="Latch Restore",
                    icon_value = ico.custom_icons["reset"].icon_id
                    )
                
        if 1 == 1:
            bb_sim = bpy.context.window_manager.bb_sim
            row = self.layout.row(align=True)
            sim_menu_enabled_icon = "menu_closed"
            if bb_sim.sim_menu_enabled == True:
                sim_menu_enabled_icon = "menu_opened"
            row.prop(
                bb_sim,
                "sim_menu_enabled",
                text="Simulation",
                toggle = True,
                icon_value = ico.custom_icons[sim_menu_enabled_icon].icon_id
                )
            if bb_sim.sim_menu_enabled == True:
                layout = self.layout
                box = layout.box()
                col = box.column(align = True)
                row = col.row(align=True)

                row.prop(
                    bb_sim,
                    "sim_blank",
                    text="Controllers and Animation",
                    toggle = True,
                    
                    )
                row = col.row(align=True)

                row.operator(
                    "onigiri.sim_stretch_add",
                    text="Add Stretch",
                    icon_value = ico.custom_icons["range"].icon_id
                    )
                row.operator(
                    "onigiri.sim_stretch_remove",
                    text="Remove Stretch",
                    icon_value = ico.custom_icons["x_black"].icon_id
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.sim_curl_add",
                    text="Add Curl",
                    icon_value = ico.custom_icons["rotate"].icon_id
                    )
                row.operator(
                    "onigiri.sim_curl_remove",
                    text="Remove Curl",
                    icon_value = ico.custom_icons["x_black"].icon_id
                    )

                row = col.row(align=True)
                row.prop(
                    bb_sim,
                    "sim_anchor",
                    text="Include Anchor",
                    toggle = True,
                    icon_value = ico.custom_icons["anchor"].icon_id
                    )
                row.prop(
                    bb_sim,
                    "sim_deformable",
                    text="Deformable Only",
                    toggle = True,
                    icon_value = ico.custom_icons["bone_bent"].icon_id
                    )

                col = box.column(align = True)
                row = col.row(align=True)

                row.operator(
                    "onigiri.sim_key",
                    text="Set Key",
                    icon_value = ico.custom_icons["key_black"].icon_id
                    )
                row = col.row(align=True)
                row.prop(
                    bb_sim,
                    "sim_key_rotation",
                    text="Rotation",
                    toggle = True,
                    icon_value = ico.custom_icons["rotate"].icon_id
                    )
                row.prop(
                    bb_sim,
                    "sim_key_location",
                    text="Location",
                    toggle = True,
                    icon_value = ico.custom_icons["location"].icon_id
                    )
                row.prop(
                    bb_sim,
                    "sim_key_scale",
                    text="Scale",
                    toggle = True,
                    icon_value = ico.custom_icons["scale"].icon_id
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.sim_ik",
                    text="Set IK",
                    icon_value = ico.custom_icons["ik"].icon_id
                    )
                sim_controller_text = sim.props['controller']
                sim_controller_icon = "locked_black"
                if sim.props['controller'] == "":
                    sim_controller_text = "Lock IK+"
                    sim_controller_icon = "unlocked_black"
                row.prop(
                    bb_sim,
                    "sim_controller",
                    text = sim_controller_text,
                    toggle = True,
                    icon_value = ico.custom_icons[sim_controller_icon].icon_id
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.sim_ik_nuke",
                    text="Nuke IK",
                    icon_value = ico.custom_icons["nuke"].icon_id
                    )
                
                row.prop(
                    bb_sim,
                    "sim_controller_length",
                    text = "IK Chain Length",
                    )

                box = layout.box()
                col = box.column(align = True)
                row = col.row(align=True)

                row.prop(
                    bb_sim,
                    "sim_inverse_motion_info",
                    text="Inverse Motion",
                    toggle = True,
                    icon_value = ico.custom_icons["inverse_motion"].icon_id
                    )
                col = box.column(align = True)
                row = col.row(align=True)

                row.prop(
                    bb_sim,
                    "sim_blank",
                    text="Automatic",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row = col.row(align=True)

                sim_motion_row_enabled = False
                if sim.props['bmesh'] == "":
                    sim_motion_row_enabled = True

                row.enabled = sim_motion_row_enabled
                row.prop(
                    bb_sim,
                    "sim_motion_dynamic",
                    text="Dynamics",
                    toggle = True,
                    icon_value = ico.custom_icons["dynamic"].icon_id
                    )
                row.prop(
                    bb_sim,
                    "sim_motion_object",
                    text="Objects",
                    toggle = True,
                    icon_value = ico.custom_icons["object"].icon_id
                    )
                row = col.row(align=True)
                if bb_sim.sim_motion_dynamic == True:
                    row.operator(
                        "onigiri.sim_action_dynamic",
                        text="Action!",
                        icon_value = ico.custom_icons["action"].icon_id
                        )
                else:
                    row.operator(
                        "onigiri.sim_action_object",
                        text="Action!",
                        icon_value = ico.custom_icons["action"].icon_id
                        )
                
                row.prop(
                    bb_sim,
                    "sim_marker_size",
                    text="Size:",
                    )

                row = col.row(align=True)
                sim_rigid_copy_enabled = False
                if bb_sim.sim_motion_object == True:
                    sim_rigid_copy_enabled = True
                row.operator(
                    "onigiri.sim_copy_rigid",
                    text="Copy Rigid",
                    icon_value = ico.custom_icons["freeze"].icon_id
                    )
                row.operator(
                    "onigiri.sim_remove_all",
                    text="Remove Sim",
                    icon_value = ico.custom_icons["x_red"].icon_id
                    )

                row = col.row(align=True)
                row.operator(
                    "onigiri.sim_add_bone",
                    text="Add Bones",
                    icon_value = ico.custom_icons["add"].icon_id
                    )
                sim_edit_bones_icon = "edit"
                if bpy.context.mode == 'EDIT_ARMATURE':
                    sim_edit_bones_icon = "edit_red"
                row.operator(
                    "onigiri.sim_edit_bones",
                    text="Edit Bones",
                    icon_value = ico.custom_icons[sim_edit_bones_icon].icon_id
                    )

                row = col.row(align=True)
                sim_path_text = "Enable Path"
                sim_path_icon = "dot_red"
                sim_path_enabled = bb_sim.sim_motion_dynamic
                if bb_sim.sim_path == True:
                    sim_path_text = "Disble Path"
                    sim_path_icon = "dot_green"
                row.enabled = sim_path_enabled
                row.prop(
                    bb_sim,
                    "sim_path",
                    text=sim_path_text,
                    icon_value = ico.custom_icons[sim_path_icon].icon_id
                    )

                row = col.row(align=True)
                row.enabled = bb_sim.sim_path
                row.prop(
                    bb_sim,
                    "sim_path_radius",
                    text="Radius:",
                    )
                row.prop(
                    bb_sim,
                    "sim_path_count",
                    text="Count:",
                    )
                row = col.row(align=True)
                row.enabled = bb_sim.sim_path
                row.prop(
                    bb_sim,
                    "sim_path_limit",
                    text="Limit:",
                    )
                row.prop(
                    bb_sim,
                    "sim_path_extend",
                    text="Extend",
                    icon_value = ico.custom_icons["more"].icon_id
                    )
                row = col.row(align=True)
                row.prop(
                    bb_sim,
                    "sim_path_parent",
                    text="Parent",
                    icon_value = ico.custom_icons["link"].icon_id
                    )

                col = box.column(align = True)
                row = col.row(align=True)

                row.prop(
                    bb_sim,
                    "sim_blank",
                    text="Manual",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )

                sim_custom_bones_icon = "bone_black"
                sim_custom_mesh_icon = "object_black"
                if sim.props.get('custom_bones') != None:
                    sim_custom_bones_icon = "bone_red"
                if sim.props.get('custom_mesh') != None:
                    sim_custom_mesh_icon = "object_red"

                row = col.row(align=True)
                row.operator(
                    "onigiri.sim_custom_bones",
                    text="Select Bones",
                    icon_value = ico.custom_icons[sim_custom_bones_icon].icon_id
                    )
                row.operator(
                    "onigiri.sim_custom_mesh",
                    text="Select Mesh",
                    icon_value = ico.custom_icons[sim_custom_mesh_icon].icon_id
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.sim_custom_action",
                    text="Action!",
                    icon_value = ico.custom_icons["action"].icon_id
                    )
                row.operator(
                    "onigiri.sim_custom_detach",
                    text="Detach Parent",
                    icon_value = ico.custom_icons["detach"].icon_id
                    )
                row.operator(
                    "onigiri.sim_custom_attach",
                    text="Retach Parent",
                    icon_value = ico.custom_icons["sync"].icon_id
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.sim_custom_constraints",
                    text="Disa. Constr.",
                    icon_value = ico.custom_icons["x_black"].icon_id
                    ).action = "disable"
                row.operator(
                    "onigiri.sim_custom_constraints",
                    text="Ena. Constr.",
                    icon_value = ico.custom_icons["x_green"].icon_id
                    ).action = "enable"
                row.operator(
                    "onigiri.sim_custom_constraints",
                    text="Rem. Constr.",
                    icon_value = ico.custom_icons["x_red"].icon_id
                    ).action="remove"

                row = col.row(align=True)
                row.prop(
                    bb_sim,
                    "sim_custom_preserve",
                    text="Preserve",
                    icon_value = ico.custom_icons["dot_blue"].icon_id
                    )
                row.prop(
                    bb_sim,
                    "sim_custom_radius",
                    text="Radius",
                    icon_value = ico.custom_icons["dot_blue"].icon_id
                    )
                row = col.row(align=True)
                row.prop(
                    bb_sim,
                    "sim_custom_disable_armatures",
                    text="Disable Arm Mods",
                    icon_value = ico.custom_icons["dot_blue"].icon_id
                    )
                row.prop(
                    bb_sim,
                    "sim_custom_influence",
                    text="Influence",
                    icon_value = ico.custom_icons["dot_blue"].icon_id
                    )
                row = col.row(align=True)

                sim_transforms_row_enabled = False
                if sim.props.get('custom_mesh') != None and sim.props.get('custom_rig') != None:
                    sim_transforms_row_enabled = True
                if 1 == 1:
                    row = col.row(align=True)
                    row.enabled = sim_transforms_row_enabled
                    row.prop(
                        bb_sim,
                        "sim_custom_location",
                        text="Location",
                        icon_value = ico.custom_icons["dot_green"].icon_id
                        )
                    row.prop(
                        bb_sim,
                        "sim_custom_rotation",
                        text="Rotation",
                        icon_value = ico.custom_icons["dot_yellow"].icon_id
                        )
                    row.prop(
                        bb_sim,
                        "sim_custom_scale",
                        text="Scale",
                        icon_value = ico.custom_icons["dot_red"].icon_id
                        )
                
                col = box.column(align = True)
                row = col.row(align=True)
                row.operator(
                    "onigiri.sim_reset",
                    text="Reset",
                    icon_value = ico.custom_icons["reset"].icon_id
                    )
                row.operator(
                    "onigiri.sim_done",
                    text="Done!",
                    icon_value = ico.custom_icons["thumb_up"].icon_id
                    )
                if 1 == 0:
                    sim_skin_enabled_icon = "paint_disabled"
                    if bb_sim.sim_skin_enabled == True:
                        sim_skin_enabled_icon = "paint_enabled"
                    row.prop(
                        bb_sim,
                        "sim_skin_enabled",
                        text="",
                        toggle = True,
                        icon_value = ico.custom_icons[sim_skin_enabled_icon].icon_id
                        )

                if 1 == 1:
                    col = box.column(align = True)
                    row = col.row(align=True)
                    row.operator(
                        "onigiri.sim_bake",
                        text="Bake Sim",
                        icon_value = ico.custom_icons["bake"].icon_id
                        )
                    row.operator(
                        "onigiri.sim_join",
                        text="Join Objects",
                        icon_value = ico.custom_icons["sync"].icon_id
                        )
                    row.operator(
                        "onigiri.sim_parent",
                        text="Parent Objects",
                        icon_value = ico.custom_icons["merge"].icon_id
                        )

        if 1 == 1:
            bb_puppet = bpy.context.window_manager.bb_puppet
            row = self.layout.row(align=True)
            puppet_menu_enabled_icon = "menu_closed"
            if bb_puppet.puppet_menu_enabled == True:
                puppet_menu_enabled_icon = "menu_opened"
            row.prop(
                bb_puppet,
                "puppet_menu_enabled",
                text="Puppeteer",
                toggle = True,
                icon_value = ico.custom_icons[puppet_menu_enabled_icon].icon_id
                )
            if bb_puppet.puppet_menu_enabled == True:
                layout = self.layout
                box = layout.box()
                col = box.column(align = True)
                row = col.row(align=True)

                row.prop(
                    bb_puppet,
                    "puppet_help",
                    text="Puppeteer Help (open webpage)",
                    toggle = True,
                    icon_value = ico.custom_icons["puppet"].icon_id
                    )
                col = box.column(align = True)
                row = col.row(align=True)
                row.operator(
                    "onigiri.puppet_compose",
                    text="Compose Rigs",
                    icon_value = ico.custom_icons["freeze"].icon_id
                    )
                row.operator(
                    "onigiri.puppet_decompose",
                    text="Decompose Rigs",
                    icon_value = ico.custom_icons["thaw"].icon_id
                    )

                col = box.column(align = True)
                row = col.row(align=True)
                row.prop(
                    bb_puppet,
                    "puppet_merge_animations",
                    text="Merge Animations",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row.prop(
                    bb_puppet,
                    "puppet_apply_transforms",
                    text="Apply Transforms",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )
                row = col.row(align=True)
                row.prop(
                    bb_puppet,
                    "puppet_rebind",
                    text="Rebind",
                    toggle = True,
                    icon_value = ico.custom_icons["blank"].icon_id
                    )

                row = col.row(align=True)
                puppet_recover_text = " "
                puppet_recover_icon = "blank"
                selected = bpy.context.selected_objects
                if len(selected) == 1:
                    if selected[0].type == 'ARMATURE':
                        if selected[0].get('bb_puppet_recover') != None:
                            puppet_recover_text = "Contains a recovery map"
                            puppet_recover_icon = "bone_black_red"
                row.prop(
                    bb_puppet,
                    "puppet_blank",
                    text=puppet_recover_text,
                    toggle = True,
                    icon_value = ico.custom_icons[puppet_recover_icon].icon_id
                    )

                col = box.column(align = True)
                row = col.row(align=True)
                row.operator(
                    "onigiri.puppet_master",
                    text="Pick Master",
                    icon_value = ico.custom_icons["master"].icon_id
                    )
                row.operator(
                    "onigiri.puppet_minions",
                    text="Pick Minions",
                    icon_value = ico.custom_icons["puppet"].icon_id
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.puppet_reset",
                    text="Reset Stage",
                    icon_value = ico.custom_icons["reset"].icon_id
                    )
                row = col.row(align=True)
                puppet_master_text = ""
                puppet_thumb_icon = "thumb_down"
                puppetObj = puppet.props['master']
                if puppetObj != None:
                    
                    if utils.is_valid(puppetObj):
                        puppet_master_text = puppetObj.name
                        puppet_thumb_icon = "thumb_up"
                row.prop(
                    bb_puppet,
                    "puppet_blank",
                    text="Master: " + puppet_master_text,
                    toggle = True,
                    icon_value = ico.custom_icons[puppet_thumb_icon].icon_id
                    )

class OnigiriPuppetProperties(bpy.types.PropertyGroup):
    def update_puppet_blank(self, context):
        self["puppet_blank"] = False
    puppet_blank : bpy.props.BoolProperty(
        default = False,
        update = update_puppet_blank
        )
    puppet_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Puppeteer allows you to combine rigs in order to use a single Second Life skeleton to animate them, potentially"            "saving you land impact and allowing you to fake multiple worn Animesh using a single rig.  Often we're not using all "            "of the bones in the SL skeleton for a single character and if there are enough left over, with a compatible hierarchy "            "they can be used to generate another character, maybe even a full duplicate."            "\n\n"            "This is a preparatory feature I added for use in conjunction with (Reactor) but it works independently and replaces the old "            "multiple rig target retargeter and the old mapped mesh export.  Note that the new mapped mesh exporter is found under "            "(Mesh Export) and this is NOT the old one, the old one is under (Character Tools - Character Mapper / Retargeter) which "            "will become obsolete along with its companion tool (Template Workshop), shortly after this tool emerges.",
        default = False
        )
    def puppet_help(self, context):
        self["puppet_help"] = False
        bpy.ops.wm.url_open(url=puppet.props['help'])
    puppet_help : bpy.props.BoolProperty(
        name = "",
        description =            "Puppeteer Info - Clicking this will open a web page:"            "\n\n"            "This is a mapping preparation tool.  It does not support reskin maps!  Convert your characters before using this."            "Puppeteer allows you to map multiple target character rigs together so that a single Second Life rig can be used "            "to control them all at the same time.  The (Compose) button will combine selected rigs together so that they can "            "be mapped as one, for easier mapping.  The (Decompose) tool will take this composed rig and distribute the resulting "            "map between the original rigs.  The original rigs are not altered, they are copied and joined then hidden.  You must "            "have a compatible map on them, which means they will not collide, or NO maps at all.  This is the final tool that "            "replaces the (Template Workshop) used in conjunction with the new retargeter.",
        default = False,
        update = puppet_help
        )

    def update_puppet_master_enabled(self, context):
        if self.puppet_enabled == False:
            puppet.props["master"] = None
        self["puppet_master_enabled"] = True
    puppet_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "This indicates that you've chosen a Master for your puppet crew.  Disable this "            "to unregister.",
        default = True,
        update = update_puppet_master_enabled
        )
    puppet_merge_animations : bpy.props.BoolProperty(
        name = "",
        description =            "With this enabled the animations will be combined along with the combined rigs, allowing "            "them to be used in this matter as a finished product or just for better reference in the mapper",
        default = True,
        )
    puppet_apply_transforms : bpy.props.BoolProperty(
        name = "",
        description =            "This can ruin your animation so it's an option if you're not merging the animations themselves",
        default = False,
        )
    puppet_rebind : bpy.props.BoolProperty(
        name = "",
        description =            "Rebind the mesh during the merge process.  This is a destructive process but the original data "            "is preserved for recovery so (Decompose Rigs) should not show any deformations even with repeated "            "cycles",
        default = False,
        )

class OnigiriPuppetCompose(bpy.types.Operator):
    """Select 2 or more entities, you can choose all of your character parts or just rigs.
The rigs will be registered, copied and joined together for use with the mappers.
The originals will be hidden until you (Decompose)"""

    bl_idname = "onigiri.puppet_compose"
    bl_label = "Compose"

    @classmethod
    def poll(cls, context):
        
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            return False
        qualified = []
        for o in selected:
            if o.type == 'ARMATURE':
                qualified.append(o)
        for o in qualified:
            
            if o.get('bb_puppet_recover') != None:
                return False
        return True

    def execute(self, context):
        bb_puppet = bpy.context.window_manager.bb_puppet

        selected = bpy.context.selected_objects

        armatures = []
        for o in selected:
            if o.type == 'ARMATURE':
                if o.get('bb_puppet_composed') != None:
                    print("Composed puppet found", o.name, "skipping")
                else:
                    armatures.append(o)

        if len(armatures) == 0:
            print("No qualified rigs to compose")
            popup("No selected rigs qualified for composition", "Bad selection", "ERROR")
            return {'FINISHED'}

        if len(armatures) == 1:
            print("There's only 1 qualified rig in the selection, there's nothing to do")
            print("Use this rig as the master map template.")
            popup("There's a single qualified rig, composition is not required", "Nothing to do", "INFO")
            return {'FINISHED'}

        mesh = []
        for armObj in armatures:
            
            mesh_list = rigutils.get_associated_mesh(armObj, report=True)
            if mesh_list != False:
                mesh.extend(mesh_list)
            else:
                print("There was a problem with the mesh associated with", armObj.name)

        print("mesh found:", mesh)

        map_test = set()
        bad_bones = set()
        
        composed_map = {}
        for armObj in armatures:
            rename_map = armObj.get('bb_onemap_rename')
            if rename_map == None:
                continue
            for anchor in rename_map:
                
                if anchor not in armObj.data.bones:
                    continue
                tbone = rename_map[anchor]
                if tbone in map_test:
                    
                    if anchor in armObj.data.bones:
                        bad_bones.add(tbone)
                    else:
                        print("Colliding anchor to target identified in source is missing, skipping:", anchor)
                else:
                    map_test.add(tbone)
                    composed_map[tbone] = {armObj.name : anchor }

        if len(bad_bones) > 0:
            print("Your rigs contain maps where the target bone collides with another, this is incompatible.")
            print("Either remove the duplicate references using a mapper or remove 1 or more maps from the rigs.")
            print("Below are a list of bones that collided.")
            for bone in bad_bones:
                print(" *", bone)
            popup("Map name collision, see System Console", "Error", "ERROR")
            return {'FINISHED'}

        for bone in composed_map:
            (arm, sbone), = composed_map[bone].items()
            for armObj in armatures:
                if sbone not in armObj.data.bones:
                    print("Missing bone", sbone, "in rig", armObj.name)

        names = set()
        recovery_map = {}
        for o in armatures:
            o['bb_puppet_name'] = o.name
            for boneObj in o.data.bones:
                name = utils.get_safe_name(names=names, max=20)
                if name == False:
                    print("Max collisions exceeded when gathering recovery names")
                    popup("Fatal internal error, report this!  See system console for details.", "Error", "ERROR")
                    return {'FINISHED'}
                new_name = "-" + boneObj.name + "-" + name
                
                if len(new_name) > 64:
                    
                    print("New bone name exceeds max length, using base hash instead", new_name, name)
                    new_name = name
                names.add(new_name)
                recovery_map[new_name] = {o.name : boneObj.name} 
        
        del names

        for o in selected:
            o.select_set(False)
        for o in armatures:
            o.select_set(True)
        for o in mesh:
            o.select_set(True)

        print("Duplicating rigs")
        utils.activate(o)
        bpy.ops.object.duplicate()

        for o in armatures:
            o.hide_viewport = True
        for o in mesh:
            o.hide_viewport = True

        new_rigs = []
        new_mesh = []
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                o['location'] = o.location
                o['matrix_world'] = o.matrix_world.copy()
                new_rigs.append(o)
            if o.type == 'MESH':
                o['location'] = o.location
                o['matrix_world'] = o.matrix_world.copy()
                new_mesh.append(o)

        if 1 == 1:
            print("Apply locations to rigs...")
            for armObj in new_rigs:
                utils.apply_transforms(object=armObj, rotation=False, location=True, scale=False)

        old_to_new = {}
        for o in new_rigs:
            new_name = o.name
            old_name = o['bb_puppet_name']
            old_to_new[old_name] = new_name
        obj = bpy.data.objects
        for new_bone in recovery_map:
            
            (old_rig, old_bone), = recovery_map[new_bone].items()
            
            new_name = old_to_new[old_rig]
            obj[new_name].data.bones[old_bone].name = new_bone

        for o in new_rigs:
            
            start_frame, end_frame = animutils.get_frame_range(o)
            break
        lowest = start_frame
        for o in new_rigs:
            start_frame, end_frame = animutils.get_frame_range(o)
            if start_frame < lowest:
                lowest = start_frame
        bpy.context.scene.frame_set(lowest)

        if bb_puppet.puppet_rebind == True:
            for armObj in new_rigs:
                
                print("Rebinding associated mesh for rig", armObj)
                rigutils.rebind(armObj, keep_animation=True, report=True)

        for o in bpy.context.selected_objects:
            o.select_set(False)

        print("Freezing mesh")
        for meshObj in new_mesh:
            meshObj.select_set(True)
            utils.activate(meshObj)

        if bb_puppet.puppet_apply_transforms == True:
            bpy.ops.object.parent_clear(type='CLEAR_KEEP_TRANSFORM')
            print("Apply transforms to mesh")
            bpy.ops.object.transform_apply()

        for o in bpy.context.selected_objects:
            o.select_set(False)
        for o in new_rigs:
            o.select_set(True)
        utils.activate(o)

        if bb_puppet.puppet_apply_transforms == True:
            print("Apply transforms to armatures")
            bpy.ops.object.transform_apply()

        actionable = []
        
        for o in new_rigs:
            if rigutils.has_action(o) == True:
                actionable.append(o.animation_data.action.name)
        
        bpy.ops.object.join()
        masObj = bpy.context.object

        if bb_puppet.puppet_merge_animations == True:
            print("Merging animations...")
            
            actionObj = animutils.merge_actions(actions=actionable, armature=masObj)
            print("...done!")
        
        if 1 == 1:
            for a in actionable:
                action = bpy.data.actions[a]
                bpy.data.actions.remove(action)

        masObj.animation_data.action = actionObj
        
        masObj['bb_puppet_action'] = actionObj.name
        
        for meshObj in new_mesh:
            meshObj.parent = masObj
            
            for modObj in meshObj.modifiers:
                if modObj.type == 'ARMATURE':
                    modObj.object = masObj

        rig_ref = {}
        for new_bone in recovery_map:
            (arm, old_bone), = recovery_map[new_bone].items()
            if arm not in rig_ref:
                rig_ref[arm] = {}
            
            if 'old_bones' not in rig_ref[arm]:
                rig_ref[arm]['old_bones'] = {}
            
            rig_ref[arm]['old_bones'][old_bone] = new_bone
            
        rename_map = {}
        for mbone in composed_map:
            (arm, old_bone), = composed_map[mbone].items()
            new_bone = rig_ref[arm]['old_bones'][old_bone] 
            rename_map[new_bone] = mbone
        masObj['bb_onemap_rename'] = rename_map

        new_objects = []
        for o in armatures:
            new_objects.append(o)
        for o in mesh:
            new_objects.append(o)
        masObj['bb_puppet_mesh'] = new_mesh
        masObj['bb_puppet_minions'] = new_objects
        masObj['bb_puppet_recover'] = recovery_map

        print("No constraint requirement for this setup")
        if 1 == 0:
            for new_bone in recovery_map:
                (old_rig, old_bone), = recovery_map[new_bone].items()
                oldRig = obj[old_rig]
                utils.activate(oldRig)
                oldBone = oldRig.pose.bones[old_bone]
                oldRig.data.bones.active = oldBone.bone
                bc = oldBone.constraints
                conObj = bc.new('COPY_TRANSFORMS')
                conObj.target = masObj
                conObj.subtarget = new_bone
                conObj.target_space = 'WORLD'
                conObj.owner_space = 'WORLD'
                conObj.influence = 1
                conObj.name = "BB " + conObj.name
                oldBone['cname'] = conObj.name

        if 1 == 1:

            if 1 == 1:
                for o in masObj.children:
                    print("child of masObj:", o.name)
                    
                    o.parent = None

            if len(new_mesh) > 0:
                state = utils.get_state()
                for o in new_mesh:
                    o.select_set(True)
                    utils.activate(o)

                bpy.ops.object.join()
                meshObj = bpy.context.object
                
                utils.set_state(state)
                meshObj.parent = masObj
                meshObj.matrix_parent_inverse = masObj.matrix_world.inverted()

        masObj.name = "MAP_RIG"
        
        utils.activate(masObj)

        return {'FINISHED'}

class OnigiriPuppetDecompose(bpy.types.Operator):
    """Select your composed rig and click this.  It will be examined and the map will be parsed
into your original rigs so that they can be used separately, or as one unit depending with the
tool being used"""

    bl_idname = "onigiri.puppet_decompose"
    bl_label = "Decompose"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return False
        if selected[0].get('bb_puppet_recover') == None:
            return False
        return True

    def execute(self, context):
        bb_puppet = bpy.context.window_manager.bb_puppet
        armObj = bpy.context.selected_objects[0]

        if armObj.get('bb_onemap_rename') == None:
            print("No rename map, I can't use this for anything")
            popup("No rename map available", "Error", "ERROR")
            return {'FINISHED'}
        if armObj.get('bb_puppet_minions') == None:
            print("No minions to process")
            popup("No minions, is this a Puppet Master?", "Error", "ERROR")
            return {'FINISHED'}

        merged_action = armObj.get('bb_puppet_action')

        rename_map = armObj['bb_onemap_rename'].to_dict()
        minions = armObj['bb_puppet_minions']
        recover_map = armObj['bb_puppet_recover'].to_dict()

        new_mins = []
        
        for minObj in minions:
            if utils.is_valid(minObj) == False:
                print("A minion that was stored for decomposition has become invalid", minObj)
            else:
                new_mins.append(minObj)
        if len(new_mins) == 0:
            print("There were no minions that survived the transition")
            popup("There were no minions", "Error", "ERROR")
            return {'FINISHED'}

        for minObj in new_mins:
            minObj.hide_viewport = False
            minObj.hide_set(False)

        min_match = False
        for minObj in new_mins:
            if minObj.type == 'ARMATURE':
                min_match = True
                break
        if min_match == False:
            print("The puppet master in your original minions collections is wrong for this rig", "Error", "ERROR")
            popup("The Puppet Master does not match your minions", "Error", "ERROR")
            return {'FINISHED'}

        print("All objects validated, re-map stage")

        new_ref = set([o.name for o in new_mins])
        for anchor in recover_map:
            (tarm, old_bone), = recover_map[anchor].items()
            if tarm not in new_ref:
                print("Missing rig reference from recover map to saved minions, this is probably a programming bug")
                popup("Fatal error matching saved minions", "Error", "ERROR")
                return {'FINISHED'}
        rig_ref = {}
        for anchor in recover_map:
            (tarm, old_bone), = recover_map[anchor].items()
            if tarm not in rig_ref:
                rig_ref[tarm] = {}
            rig_ref[tarm][anchor] = old_bone
        
        print("Maps validated, decomposing...")
        arm_maps = {}
        for anchor in rename_map:
            if anchor in recover_map:
                (tarm, old_bone), = recover_map[anchor].items()
                if tarm not in arm_maps:
                    arm_maps[tarm] = {}
                arm_maps[tarm][old_bone] = rename_map[anchor]
        
        for arm in arm_maps:
            bpy.data.objects[arm]['bb_onemap_rename'] = arm_maps[arm]

        for meshObj in armObj['bb_puppet_mesh']:
            if utils.is_valid(meshObj):
                meshObj.hide_viewport = False
                meshObj.hide_set(False)
                meshObj.select_set(True)
        
        utils.activate(armObj)
        bpy.ops.object.delete()

        for o in new_mins:
            o.pop('bb_puppet_name', "")
            o.select_set(True)
            if o.type == 'ARMATURE':
                utils.activate(o) 

        if merged_action != None:
            if merged_action in bpy.data.actions:
                actionObj = bpy.data.actions[merged_action]
                bpy.data.actions.remove(actionObj)

        return {'FINISHED'}

class OnigiriPuppetMaster(bpy.types.Operator):
    """Register the Master rig.  This is the base rig that all others are combined with.  It's expected
that you want to keep the names of the bones in this rig in tact while the other rigs` bone names will
change.  The existing maps will be used if present and animations are preserved"""

    bl_idname = "onigiri.puppet_master"
    bl_label = "Choose the anchor rig"

    @classmethod
    def poll(cls, context):
        
        if puppet.props['master'] != None:
            return False
        
        armObj = rigutils.is_armature()
        if armObj == False:
            return False
        
        if armObj.get('bb_puppet_master') or armObj.get('bb_puppet_minions'):
            return False
        return True

    def execute(self, context):
        bb_puppet = bpy.context.window_manager.bb_puppet
        
        anchorObj = bpy.context.selected_objects[0]
        puppet.props['master'] = anchorObj

        print("Recorded Anchor", anchorObj.name)

        return {'FINISHED'}

class OnigiriPuppetMinions(bpy.types.Operator):
    """Mark the selected rigs as minions controlled using the Master rig"""

    bl_idname = "onigiri.puppet_minions"
    bl_label = "Register Minions"

    @classmethod
    
    def poll(cls, context):
        
        if puppet.props['master'] == None:
            return False
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            return False
        for o in selected:
            
            if o != puppet.props['master']:
                if o.type == 'ARMATURE':
                    return True
        return False

    def execute(self, context):
        bb_puppet = bpy.context.window_manager.bb_puppet

        masterRig = puppet.props['master']
        
        if utils.is_valid(masterRig) == False:
            print("The master rig seems to have been removed or is just not in the scene or invalid for some other reason.")
            popup("Invalid Master, try setting it again.", "Error", "ERROR")
            puppet.props['master'] = None
            return {'FINISHED'}

        puppet.props['master'] = None

        rigs = []
        for o in bpy.context.selected_objects:
            if o.type == 'ARMATURE':
                
                if o != masterRig:
                    rigs.append(o)
                    o['bb_puppet_master'] = masterRig

        masterRig['bb_puppet_minions'] = rigs

        print("Recorded minions", [o.name for o in rigs])

        return {'FINISHED'}

class OnigiriPuppetReset(bpy.types.Operator):
    """Select any one of the rigs in your set and click this to reset your stage"""

    bl_idname = "onigiri.puppet_reset"
    bl_label = "Reset Stage"

    def execute(self, context):
        bb_puppet = bpy.context.window_manager.bb_puppet
        if len(bpy.context.selected_objects) != 0:
            armObj = bpy.context.selected_objects[0]
            masRig = puppet.get_master(armObj, report=True)
            if masRig == False:
                print("This rig doesn't have a link to your puppet master but the master may have been recorded so that will be cleaned.")
                masRig = armObj
            
            minions = masRig.get('bb_puppet_minions', [])
            for minRig in minions:
                if utils.is_valid(minRig):
                    minRig.pop('bb_puppet_master', "")
            masRig.pop('bb_puppet_minions', "")

        puppet.props['master'] = None

        print("Puppet Master stage reset.")

        return {'FINISHED'}

class OnigiriReactorPanel(bpy.types.Panel):
    """Reactor is a powerful but quick solution to some complicated and common tasks that cannot
normally be implemented in Second Life but we give you the magic that makes it possible.
This is similar to the Simulator but for a more refined purpose"""

    bl_idname = "OBJECT_PT_bento_buddy_reactor"
    bl_label = "Reactor"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        bb_reactor = bpy.context.window_manager.bb_reactor
        bb_ragdoll = bpy.context.window_manager.bb_ragdoll
        layout = self.layout
        row = self.layout.row(align=True)

        if 1 == 0:
            reactor_menu_enabled_icon = "menu_closed"
            if bb_reactor.reactor_menu_enabled == True:
                reactor_menu_enabled_icon = "menu_opened"
            row.prop(
                bb_reactor,
                "reactor_menu_enabled",
                text="Reactor",
                toggle = True,
                icon_value = ico.custom_icons[reactor_menu_enabled_icon].icon_id
                )
            if bb_reactor.reactor_menu_enabled == True:
                layout = self.layout
                box = layout.box()
                col = box.column(align = True)
                row = col.row(align=True)

                row.label(text="Reactor:")
                row.prop(
                    bb_reactor,
                    "reactor_help",
                    text="Reactor",
                    toggle = True,
                    icon_value = ico.custom_icons["info"].icon_id
                    )

        ragdoll_menu_enabled_icon = "menu_closed"
        if bb_ragdoll.ragdoll_menu_enabled == True:
            ragdoll_menu_enabled_icon = "menu_opened"

        row.prop(
            bb_ragdoll,
            "ragdoll_menu_enabled",
            text="Ragdoll",
            toggle = True,
            icon_value = ico.custom_icons[ragdoll_menu_enabled_icon].icon_id
            )
        if bb_ragdoll.ragdoll_menu_enabled == True:
            layout = self.layout
            box = layout.box()

            col = box.column(align = True)
            row = col.row(align=True)

            row.operator(
                "onigiri.ragdoll_load",
                text="Load",
                icon_value = ico.custom_icons["load"].icon_id
                )
            row.operator(
                "onigiri.ragdoll_save",
                text="Save",
                icon_value = ico.custom_icons["save"].icon_id
                )

            row = col.row(align=True)
            row.prop(
                bb_ragdoll,
                "ragdoll_blank",
                text="Location",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bb_ragdoll,
                "ragdoll_location",
                text="",
                )
            col = box.column(align = True)
            row = col.row(align=True)
            ragdoll_mesh_name = "Lock Mesh"
            if ragdoll.props['mesh'] != None:
                ragdoll_mesh_name = ragdoll.props['mesh']
            else:
                ragdoll_mesh_name = "Lock Mesh"
            row.prop(
                bb_ragdoll,
                "ragdoll_use_mesh",
                toggle = True,
                text=ragdoll_mesh_name,
                icon_value = ico.custom_icons["blank"].icon_id
                )

            if ragdoll.props['pool'] == None:
                ragdoll_pool_text = "Use Pool"
            else:
                ragdoll_pool_text = "Pool Count: " + str(len(ragdoll.props['pool']))
            row.prop(
                bb_ragdoll,
                "ragdoll_use_pool",
                toggle = True,
                text="Use Pool",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bb_ragdoll,
                "ragdoll_use_existing",
                toggle = True,
                text="Use Existing",
                icon_value = ico.custom_icons["blank"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_ragdoll,
                "ragdoll_disable_collisions",
                toggle = True,
                text="Disable Collisions",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bb_ragdoll,
                "ragdoll_anchor",
                toggle = True,
                text="Anchor Selected",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row = col.row(align=True)
            row.prop(
                bb_ragdoll,
                "ragdoll_use_breaking",
                toggle = True,
                text="Use Breaking",
                icon_value = ico.custom_icons["blank"].icon_id
                )
            row.prop(
                bb_ragdoll,
                "ragdoll_breaking_threshold",
                text="Threshold",
                )
            row = col.row(align=True)
            row.prop(
                bb_ragdoll,
                "ragdoll_show_constraints",
                toggle = True,
                text="Show Constraints",
                icon_value = ico.custom_icons["blank"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                bb_ragdoll,
                "ragdoll_type",
                text="",
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.ragdoll_action",
                text="Action",
                icon_value = ico.custom_icons["action"].icon_id
                )
            row.operator(
                "onigiri.ragdoll_reset",
                text="Reset Stage",
                icon_value = ico.custom_icons["reset"].icon_id
                )
            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.ragdoll_bake",
                text="Bake Animation",
                icon_value = ico.custom_icons["bake"].icon_id
                )
            row.operator(
                "onigiri.ragdoll_join",
                text="Join Directors",
                icon_value = ico.custom_icons["sync"].icon_id
                )
            col = box.column(align = True)
            row = col.row(align=True)

            row.operator(
                "onigiri.ragdoll_copy_rigid",
                text="Copy Rigid",
                icon_value = ico.custom_icons["freeze"].icon_id
                )

class OnigiriReactorProperties(bpy.types.PropertyGroup):

    def update_reactor_blank(self, context):
        self["reactor_blank"] = False
    reactor_blank : bpy.props.BoolProperty(
        default = False,
        update = update_reactor_blank
        )
    def update_reactor_help(self, context):
        self["reactor_help"] = False
        bpy.ops.wm.url_open(url=reactor.props['help'])
    reactor_help : bpy.props.BoolProperty(
        name = "",
        description =            "Reactor is a server to server feature that bi-laterally controls your character in and out of Second Life.  "            "This character is built using prims in SL and then generated in Blender for a visual.  This visual can then be "            "constructed automatically into an Avatar or even Animesh completely.  Also note that using Blender is not "            "a requirement and the conversion feature can be automatically initiated from in-world.",
        default = False,
        update = update_reactor_help
        )

    def reactor_menu_enabled(self, context):
        if self.reactor_menu_enabled == True:
            print("Reactor engaged")
            reactor.props['poll_enabled'] = True
            reactor.props['poll_time'] = 0.2
            bpy.app.timers.register(reactor.poll, first_interval=1)
        else:
            print("Reactor disengaged")
            reactor.props['poll_enabled'] = False

    reactor_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "--stub",
        default = False,
        update=reactor_menu_enabled
        )

class OnigiriRagdollProperties(bpy.types.PropertyGroup):

    def update_ragdoll_blank(self, context):
        self["ragdoll_blank"] = False
    ragdoll_blank : bpy.props.BoolProperty(
        default = False,
        update = update_ragdoll_blank
        )

    def update_ragdoll_help(self, context):
        self["ragdoll_help"] = False
        bpy.ops.wm.url_open(url=reactor.props['help'])
    ragdoll_help : bpy.props.BoolProperty(
        name = "",
        description =            "help",
        default = False,
        update = update_ragdoll_help
        )

    ragdoll_location : bpy.props.FloatVectorProperty(
        name = "",
        description =            "Set this before loading your rig.  Your loaded rig will have an origin set to this location",
        subtype = 'XYZ',
        default = (0.0, 0.0, 0.0)
        )

    ragdoll_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "In this area you can enable properties on a rig that will cause it to (ragdoll).  This special setup "            "allows you to carry that same simulation, as an animation, into Second Life",
        default = False,
        )

    def update_ragdoll_use_mesh(self, context):
        
        if self.ragdoll_use_mesh == False:
            ragdoll.props["mesh"] = None
            print("Mesh unlocked")
            return
        
        self["ragdoll_use_pool"] = False
        self["ragdoll_use_existing"] = False
        ragdoll.props['pool'] = None

        selected = bpy.context.selected_objects
        if len(selected) == 0:
            self["ragdoll_use_mesh"] = False
            print("Nothing selected")
        if len(selected) != 1:
            self["ragdoll_use_mesh"] = False
            print("Choose only 1 object")
            return
        o = selected[0]
        if o.type != 'MESH':
            self["ragdoll_use_mesh"] = False
            print("I can only process mesh, this is not a mesh:", o.type)
            return
        ragdoll.props['mesh'] = o.name
        print("Recorded", o.name, "as the ragdoll physics mesh")
    ragdoll_use_mesh : bpy.props.BoolProperty(
        name = "",
        description =            "Select a mesh, possibly a primitive, for use with your ragdoll.  In object mode choose a suitable mesh "            "then click this button, it will be utilized when you run (Action).",
        default = False,
        update = update_ragdoll_use_mesh
        )
    def update_ragdoll_use_pool(self, context):
        
        if self.ragdoll_use_pool == False:
            ragdoll.props['pool'] = None
            print("Pool unlocked")
            return
        
        self.ragdoll_use_mesh == False
        self.ragdoll_use_pool == False
        ragdoll.props['pool'] = None
        self["ragdoll_use_existing"] = False
        self["ragdoll_use_mesh"] = False
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            self["ragdoll_use_pool"] = False
            print("Nothing selected")
        if len(selected) < 1:
            self["ragdoll_use_pool"] = False
            print("Choose 1 or more objects")
            return
        pool = []
        for o in selected:
            if o.type != 'MESH':
                print("Skipping", o.name, "since it is not a mesh")
                continue
            pool.append(o.name)
        if len(pool) == 0:
            self["ragdoll_use_pool"] = False
            print("None of the selected objects are qualified, no mesh")
            return
        ragdoll.props['pool'] = pool
        print("Recorded", str(len(pool)), "objects as the ragdoll physics mesh")
    ragdoll_use_pool : bpy.props.BoolProperty(
        name = "",
        description =            "Select a set of meshes, possibly a number of primitives, for use with your ragdoll.  In object mode "            "choose a suitable mesh set as your pool then click this button, they will be randomly utilized when "            "you run (Action).  Note that your selection will be duplicated as needed to fill the rig offered.",
        default = False,
        update = update_ragdoll_use_pool
        )

    def update_ragdoll_use_existing(self, context):
        if self.ragdoll_use_existing == True:
            self["ragdoll_use_mesh"] = False
            ragdoll.props['mesh'] = None
            self["ragdoll_use_pool"] = False
            ragdoll.props['pool'] = None

    ragdoll_use_existing : bpy.props.BoolProperty(
        name = "",
        description =            "This setting overrides (Lock Mesh) and utilizes the mesh that's already associated with your rig.  "            "There are some concerns about what you can do with this.  The first thing to consider is the mesh "            "density, since the ragdoll utilizes physics simulation, please be careful or you will have a bad day.  "            "The other consideration is when any single mesh contains more than one joint definition (vertex group), "            "these mesh cannot be utilized and will be excluded from processing.  If you need to deform your dense "            "mesh as a result of the simulated objects then bake the animation first, this will pull it out of sim "            "mode, then you can use the resulting animated bones directly, without the director objects included.  "            "To do that simply simulate (Action) then (Bake Animation).  You can then (Reset) or (Join) to preserve your "            "animation and remove the simulation objects.  Reset will remove objects that were generated as (chosen) or "            "leave them in place if they were already part of your set.  The (Join) feature will destroy your existing "            "set, however, so be careful if you engaged the ragdoll with that option enabled",
        default = False,
        update = update_ragdoll_use_existing
        )

    def update_ragdoll_type(self, context):
        armObj = ragdoll.get_actor()
        if armObj == False:
            return
        print("Got actor", armObj.name)
        empties = armObj.get('bb_ragdoll_empties')
        if empties == None:
            return
        for o in empties:
            if o.rigid_body_constraint != None:
                o.rigid_body_constraint.type = self.ragdoll_type
        print("Set ragdoll to", self.ragdoll_type)

    ragdoll_type_items = [
        ('POINT',"Point",'',0),
        ('FIXED',"Fixed",'',1),
        ('HINGE',"Hinge",'',2),
        ('SLIDER',"Slider",'',3),
        ('PISTON',"Piston",'',4),
        ('GENERIC',"Generic",'',5),
        ('GENERIC_SPRING',"Generic Spring",'',6),
        ('MOTOR',"Motor",'',7),
        ]
    ragdoll_type : bpy.props.EnumProperty(
        name = "Ragdoll Type",
        description = "This is the Rigid Body Constraint (Type), no all of these will be useful",
        items = ragdoll_type_items,
        update = update_ragdoll_type
        )

    def update_ragdoll_disable_collisions(self, context):
        armObj = ragdoll.get_actor()
        if armObj == False:
            return
        print("Got actor", armObj.name)
        empties = armObj.get('bb_ragdoll_empties')
        if empties == None:
            return
        for o in empties:
            if o.rigid_body_constraint != None:
                o.rigid_body_constraint.disable_collisions = self.ragdoll_disable_collisions
        print("disable collisions", self.ragdoll_disable_collisions)
    ragdoll_disable_collisions : bpy.props.BoolProperty(
        default = True,
        update = update_ragdoll_disable_collisions
        )
    def update_ragdoll_use_breaking(self, context):
        armObj = ragdoll.get_actor()
        if armObj == False:
            return
        print("Got actor", armObj.name)
        empties = armObj.get('bb_ragdoll_empties')
        if empties == None:
            return
        for o in empties:
            if o.rigid_body_constraint != None:
                o.rigid_body_constraint.use_breaking = self.ragdoll_use_breaking
        print("use breaking", self.ragdoll_use_breaking)
    ragdoll_use_breaking : bpy.props.BoolProperty(
        default = False,
        update = update_ragdoll_use_breaking
        )
    def update_ragdoll_breaking_threshold(self, context):
        armObj = ragdoll.get_actor()
        if armObj == False:
            return
        print("Got actor", armObj.name)
        empties = armObj.get('bb_ragdoll_empties')
        if empties == None:
            return
        for o in empties:
            if o.rigid_body_constraint != None:
                o.rigid_body_constraint.breaking_threshold = self.ragdoll_breaking_threshold
        print("breaking threshold", self.ragdoll_breaking_threshold)
    ragdoll_breaking_threshold : bpy.props.FloatProperty(
        min=0.0,
        max=1000.0,
        default=1.0,
        update = update_ragdoll_use_breaking
        )
    def update_ragdoll_anchor(self, context):
        armObj = ragdoll.get_actor()
        if armObj == False:
            print("No actor")
            self['ragdoll_anchor'] = False
            return
        print("Got actor", armObj.name)
        directors = armObj.get('bb_ragdoll_directors')
        if directors == None:
            print("No directors")
            self['ragdoll_anchor'] = False
            return
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            print("Nothing selected")
            self['ragdoll_anchor'] = False
            return
        rigid_type = 'ACTIVE'
        if self.ragdoll_anchor == True:
            rigid_type = 'PASSIVE'
        
        directors_set = set()
        for bone in directors.keys():
            d = directors[bone]
            directors_set.add(d)
        for o in selected:
            name = o.name
            if name in directors_set:
                o.rigid_body.type = rigid_type
        print("Rigid Type", rigid_type)
    ragdoll_anchor : bpy.props.BoolProperty(
        default = False,
        update = update_ragdoll_anchor
        )
    def update_ragdoll_show_constraints(self, context):
        armObj = ragdoll.get_actor()
        if armObj == False:
            print("No actor")
            self['ragdoll_show_constraints'] = False
            return
        print("Got actor", armObj.name)
        empties = armObj.get('bb_ragdoll_empties')
        if empties == None:
            print("No empties")
            self['ragdoll_show_constraints'] = False
            return
        state = not self.ragdoll_show_constraints
        for o in empties:
            o.hide_set(state)
        print("Constraints", self.ragdoll_show_constraints)
    ragdoll_show_constraints : bpy.props.BoolProperty(
        default = False,
        update = update_ragdoll_show_constraints
        )

class OnigiriRagdollLoad(bpy.types.Operator, ImportHelper):
    """Load a skeleton for use as a rag doll."""

    bl_idname = "onigiri.ragdoll_load"
    bl_label = "Load a Ragdoll preset"

    filter_glob : bpy.props.StringProperty(
        default='*.rig',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        load_path = script_dir + character_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def execute(self, context):

        file_path = self.properties.filepath
        path, name = os.path.split(self.properties.filepath)
        file_prefix = name.split(".")[0]
        ext = name.split(".")[-1]

        try:
            namespace = {}
            exec(open(file_path, 'r', encoding='UTF8').read(), namespace)
        except Exception as e:
            print(traceback.format_exc())
            return {'FINISHED'}
        rig = namespace.get('rig', {})
        if len(rig) == 0:
            print("No rig data, damaged file?")
            popup("No rig data, damaged file?", "Error", "ERROR")
            return {'FINISHED'}

        bb_reactor = bpy.context.window_manager.bb_ragdoll

        try:
            name = rig['name']
        except:
            print("Corrupt rig file, name missing")
            popup("Corrupt file", "Error", "ERROR")
            return {'FINISHED'}

        bb_ragdoll = bpy.context.window_manager.bb_ragdoll

        state = utils.get_state()

        arm_thing = bpy.data.armatures.new(name)
        armObj = bpy.data.objects.new(name, arm_thing)
        bpy.context.scene.collection.objects.link(armObj)
        bpy.context.view_layer.update()
        
        arm = armObj.name

        armObj.location = bb_ragdoll.ragdoll_location

        armObj.select_set(True)
        utils.activate(armObj)
        bpy.ops.object.mode_set(mode='EDIT')

        ragdoll_parents = {}
        for bone in rig['bones']:
            matrix = mathutils.Matrix(rig['bones'][bone]['matrix'])
            head = mathutils.Vector(rig['bones'][bone]['head'])
            tail = mathutils.Vector(rig['bones'][bone]['tail'])
            parent = rig['bones'][bone]['parent']
            ragdoll_parents[bone] = parent
            boneObj = armObj.data.edit_bones.new(bone)
            boneObj.head = head
            boneObj.tail = tail
            boneObj.matrix = matrix
        utils.update()

        for boneObj in armObj.data.edit_bones:
            parent = ragdoll_parents[boneObj.name]
            if parent != "":
                boneObj.parent = armObj.data.edit_bones[parent]

        bpy.ops.object.mode_set(mode='OBJECT')
        utils.update()

        print("Rig loaded!")

        return {'FINISHED'}

class OnigiriRagdollSave(bpy.types.Operator, ExportHelper):
    """Save a Ragdoll preset"""

    bl_idname = "onigiri.ragdoll_save"
    bl_label = "Ragdoll Save"

    filename_ext = ".rig"

    filter_glob : bpy.props.StringProperty(
        default='*.rig',
        options={'HIDDEN'}
        )

    def invoke(self, context, event):
        load_path = script_dir + character_path
        self.filepath = load_path
        wm = context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

    @classmethod
    def poll(cls, context):
        selection = bpy.context.selected_objects
        if len(selection) == 0:
            return False
        arms = 0
        for o in selection:
            if o.type == 'ARMATURE':
                arms += 1
        if arms != 1:
            return False

        return True

    def execute(self, context):

        def matrix_to_list(m, r=6):
            l = list(m)
            lt = list()
            for v in l:
                
                t = tuple([round(a, r) for a in v])
                lt.append(t)
            return lt
        def normalize_float(f, max=6):
            reduced = round(f, max)
            result = abs(reduced)
            if result <= 10** -max:
                result = reduced
            return result

        file_path = self.properties.filepath
        path, name = os.path.split(self.properties.filepath)
        file_prefix = name.split(".")[0]
        ext = name.split(".")[-1]

        bb_reactor = bpy.context.scene.bb_ragdoll

        selection = bpy.context.selected_objects
        for armObj in selection:
            if armObj.type == 'ARMATURE':
                break

        skeleton = {}
        skeleton['name'] = armObj.name
        skeleton['bones'] = {}
        for boneObj in armObj.data.bones:
            skeleton['bones'][boneObj.name] = {}
            skeleton['bones'][boneObj.name]['matrix'] = matrix_to_list( boneObj.matrix_local.copy() )
            skeleton['bones'][boneObj.name]['head'] = [round(f, 6) for f in boneObj.head_local.copy() ]
            skeleton['bones'][boneObj.name]['tail'] = [round(f, 6) for f in boneObj.tail_local.copy() ]
            parent = ""
            if boneObj.parent:
                parent = boneObj.parent.name
            skeleton['bones'][boneObj.name]['parent'] = parent

        output = "rig = " + str(skeleton)

        f = open(file_path, "w", encoding='UTF8')
        f.write(output)
        f.close()

        print("Rig saved!")

        return {'FINISHED'}

class OnigiriRagdollAction(bpy.types.Operator):
    """
Activate this set or skeleton as a ragdoll.
"""

    bl_idname = "onigiri.ragdoll_action"
    bl_label = "Ragdoll Action"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            return False
        return True

    def execute(self, context):
        
        selected = bpy.context.selected_objects
        arms = 0
        for o in selected:
            if o.type == 'ARMATURE':
                arms += 1
                armObj = o
        if arms == 0:
            print("No armatures selected")
            popup("Select an armature", "Error", "ERROR")
            return {'FINISHED'}
        if arms > 1:
            print("Too many armatures, but we may allow this later")
            popup("Too many armatures, see console", "Error", "ERROR")
            return {'FINISHED'}

        bb_ragdoll = bpy.context.window_manager.bb_ragdoll

        if 1 == 0:
            armObj = ragdoll.get_actor()
            if armObj == False:
                popup("No rig found", "Error", "ERROR")
                return {'FINISHED'}

        if armObj.get('bb_ragdoll_empties') != None:
            print("Ragdoll is already engaged, reset to start over")
            popup("Ragdoll is already engaged, use reset to start over", "Error", "ERROR")
            return {'FINISHED'}

        state = utils.get_state()

        ragdoll_parents = {}
        for boneObj in armObj.data.bones:
            bone = boneObj.name
            if boneObj.parent:
                parent = boneObj.parent.name
                ragdoll_parents[bone] = parent
            else:
                ragdoll_parents[bone] = ""

        armObj['bb_ragdoll_parents'] = ragdoll_parents
        txt = "I contain a dictionary of bone name to its parent, an empty string indicates no parent."
        armObj['bb_ragdoll_parents_info'] = txt

        mesh_source = None
        
        if bb_ragdoll.ragdoll_use_existing:
            print("Using rig mesh")
            mesh_source = "existing"
        if bb_ragdoll.ragdoll_use_mesh:
            print("use mesh was enabled")
            mesh_source = "mesh"
        if bb_ragdoll.ragdoll_use_pool:
            print("use pool was enabled")
            mesh_source = "pool"

        print("Calling function ragdoll::create_directors with", mesh_source)
        
        ragdoll.create_directors(armObj, source=mesh_source)
        armObj['bb_ragdoll_source'] = mesh_source
        print("Stored source type for later processing")
        
        if 1 == 0:
            bpy.ops.object.mode_set(mode = 'EDIT')
            for boneObj in armObj.data.edit_bones:
                if boneObj.parent:
                    boneObj['parent'] = boneObj.parent.name
                else:
                    boneObj['parent'] = ""
            boneObj.parent = None
            bpy.ops.object.mode_set(mode = 'OBJECT')

        bpy.ops.mesh.primitive_plane_add(size=10, enter_editmode=False, align='WORLD', location=(0, 0, 0))
        armObj['bb_ragdoll_floor'] = bpy.context.active_object

        directors = armObj['bb_ragdoll_directors']
        
        if bpy.context.scene.rigidbody_world == None:
            bpy.ops.rigidbody.world_add()
        for bone in directors.keys():
            name = directors[bone]
            dObj = bpy.data.objects[name]
            utils.activate(dObj)
            bpy.ops.rigidbody.object_add()

        floorObj = armObj['bb_ragdoll_floor']
        utils.activate(floorObj)
        bpy.ops.rigidbody.object_add()
        floorObj.rigid_body.type = 'PASSIVE'
        floorObj.rigid_body.use_margin = True
        floorObj.rigid_body.collision_margin = 0.1

        for o in bpy.context.selected_objects:
            o.select_set(False)

        empties = []
        world_mat = armObj.matrix_world
        for boneObj in armObj.pose.bones:
            dBone = boneObj.bone
            
            bone_mat = dBone.matrix_local.copy()
            o = bpy.data.objects.new( "empty", None )
            
            bpy.context.scene.collection.objects.link( o )
            
            o.empty_display_size = 0.1
            o.empty_display_type = 'PLAIN_AXES'
            o.matrix_world = bone_mat @ world_mat
            empties.append(o)
            utils.activate(o)

            if boneObj.parent:
                bpy.ops.rigidbody.constraint_add()
                o.rigid_body_constraint.type = bb_ragdoll.ragdoll_type
                o.rigid_body_constraint.disable_collisions = bb_ragdoll.ragdoll_disable_collisions
                o.rigid_body_constraint.use_breaking = bb_ragdoll.ragdoll_use_breaking
                o.rigid_body_constraint.breaking_threshold = bb_ragdoll.ragdoll_breaking_threshold

                cbone = boneObj.name
                pbone = boneObj.parent.name
                
                if pbone not in directors:
                    print("missing parent link in directors [", pbone, "], probably due to (pool) or (existing) limit reached", sep="")
                    continue
                pdir =directors[pbone]
                
                if cbone not in directors:
                    print("missing child link in directors [", cbone, "], probably due to (pool) or (existing) limit reached", sep="")
                    continue
                cdir = directors[cbone]
                
                bpy.context.object.rigid_body_constraint.object1 = bpy.data.objects[pdir]
                bpy.context.object.rigid_body_constraint.object2 = bpy.data.objects[cdir]

            o.select_set(False)

        armObj['bb_ragdoll_empties'] = empties

        for o in bpy.context.selected_objects:
            o.select_set(False)
        armObj.select_set(True)
        utils.activate(armObj)

        bpy.ops.object.mode_set(mode = 'EDIT')
        for boneObj in armObj.data.edit_bones:
            boneObj.parent = None
        bpy.ops.object.mode_set(mode = 'OBJECT')

        ragdoll.add_constraints(armObj)

        for o in empties:
            o.hide_set(True)

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriRagdollBake(bpy.types.Operator):
    """
    Bake the simulation to an armature animation
"""

    bl_idname = "onigiri.ragdoll_bake"
    bl_label = "Bake simulation"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            return False
        for o in selected:
            if o.get('bb_ragdoll_actor'):
                return True
            if o.get('bb_ragdoll_directors'):
                return True
        return False

    def execute(self, context):
        bb_ragdoll = bpy.context.window_manager.bb_ragdoll
        armObj = ragdoll.get_actor()
        if armObj == False:
            print("Can't find an actor")
            popup("Can't find an actor", "Error", "ERROR")
            return {'FINISHED'}

        state = utils.get_state()

        result = animutils.bake_motion(sarm=armObj, tarm=armObj)
        if result == False:
            print("There was an error baking the animation")
            popup("Animation couldn't bake", "Error", "ERROR")
            return {'FINISHED'}
        print("Animation baked")

        empties = armObj.get('bb_ragdoll_empties')
        if empties == None:
            print("No empties, I'll process other things anyway")
        else:
            
            for o in empties:
                o.hide_set(False)
            for o in empties:
                o.select_set(True)
            utils.activate(o)
        floorObj = armObj.get('bb_ragdoll_floor')
        if floorObj != None:
            floorObj.select_set(True)
        bpy.ops.object.delete()

        armObj.pop('bb_ragdoll_empties', "")
        armObj.pop('bb_ragdoll_floor', "")

        directors = armObj['bb_ragdoll_directors']
        if directors != None:
            
            if armObj.get('bb_ragdoll_mesh') != "existing":
                for bone in directors.keys():
                    name = directors[bone]
                    dObj = bpy.data.objects[name]
                    utils.activate(dObj)
                    try:
                        bpy.ops.rigidbody.object_remove()
                        print("removed rigid body from", dObj.name)
                    except:
                        print("skipping remove of rigid body from", dObj.name)

        for boneObj in armObj.pose.bones:
            cname = boneObj.bone.get('bb_ragdoll_constraint')
            if cname != None:
                for cObj in boneObj.constraints:
                    if cObj.name == cname:
                        boneObj.constraints.remove(cObj)
                del boneObj.bone['bb_ragdoll_constraint']

        armObj.pop('bb_ragdoll_mesh', "")

        for bone in directors.keys():
            dname = directors[bone]
            if dname in bpy.data.objects:
                print("enabling armature modifier to show in viewport for", dname)
                dObj = bpy.data.objects[dname]
                if dObj.type == 'MESH':
                    for modObj in dObj.modifiers:
                        if modObj.type == 'ARMATURE':
                            modObj.show_viewport = True
                
        print("Skipping parenting for now, add this back later")
        if 1 == 0:
            parents = armObj.get('bb_ragdoll_parents')
            if parents == None:
                print("bb_ragdoll_parents missing after bake")
            else:
                armObj.select_set(True)
                utils.activate(armObj)
                bpy.ops.object.mode_set(mode='EDIT')
                for boneObj in armObj.data.edit_bones:
                    bone = boneObj.name
                    parent = parents[bone]
                    if parent != "":
                        boneObj.parent = armObj.data.edit_bones[parent]
                bpy.ops.object.mode_set(mode='OBJECT')

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriRagdollJoin(bpy.types.Operator):
    """
This will remove the rigid dynamics from the objects (Directors) join them.  It's suggested that
you use (Bake Animation) prior to this"""

    bl_idname = "onigiri.ragdoll_join"
    bl_label = "Join mesh"

    @classmethod
    def poll(cls, context):
        selected = bpy.context.selected_objects
        if len(selected) == 0:
            return False
        return True

    def execute(self, context):
        bb_ragdoll = bpy.context.window_manager.bb_ragdoll
        armObj = ragdoll.get_actor()
        if armObj == False:
            print("Could not find actor")
            return {'FINISHED'}
        directors = armObj.get('bb_ragdoll_directors')
        if directors == None:
            print("No directors were found, can't join mesh")
            popup("Can't find directors", "Error" "ERROR")
            return {'FINISHED'}
        for o in bpy.context.selected_objects:
            o.select_set(False)

        for bone in directors.keys():
            dname = directors[bone]
            if dname not in bpy.data.objects:
                continue
            dObj = bpy.data.objects[dname]
            dObj.select_set(True)
            utils.activate(dObj)

        if len(bpy.context.selected_objects) != 0:
            bpy.ops.object.join()
            dObj.select_set(True)
            utils.activate(dObj)

        else:
            armObj.setlect_set(True)
            utils.activate(armObj)

        return {'FINISHED'}

class OnigiriRagdollRigidCopy(bpy.types.Operator):
    """The active object receives the rigid body properties when adjusted.  If you you have
mutliple objects selected, or you box select them after setting these properties, you
can use this button to copy those properties to the other objects"""

    bl_idname = "onigiri.ragdoll_copy_rigid"
    bl_label = "Copy Rigid"

    @classmethod
    def poll(cls, context):
        active = bpy.context.active_object
        if active == None:
            return False
        if active.type != 'MESH':
            return False
        return True

    def execute(self, context):
        
        try:
            bpy.ops.rigidbody.object_settings_copy()
            print("Sim rigid copied from active to selected")
        except:
            print("Rigid sim copy failed, make sure that the active object has rigid")
            popup("Rigid copy failed", "Error", "ERROR")

        return {'FINISHED'}

class OnigiriRagdollReset(bpy.types.Operator):
    """Reset Stage"""

    bl_idname = "onigiri.ragdoll_reset"
    bl_label = "Ragdoll Reset"

    @classmethod
    def poll(cls, context):
        bb_reactor = bpy.context.window_manager.bb_reactor

        return True

    def execute(self, context):
        
        armObj = ragdoll.get_actor()
        if armObj == False:
            print("There was no usable actor found.")
            popup("No actor found", "Error", "ERROR")
            return {'FINISHED'}

        empties = armObj.get('bb_ragdoll_empties')
        if empties == None:
            print("The ragdoll was not engaged so no reset needed")
            return {'FINISHED'}
        state = utils.get_state()

        for o in empties:
            o.hide_set(False)

        floorObj = armObj.get('bb_ragdoll_floor')
        if floorObj != None:
            floorObj.select_set(True)

        for o in empties:
            o.select_set(True)
        utils.activate(o)

        bpy.ops.object.delete()

        armObj.pop('bb_ragdoll_empties', "")
        armObj.pop('bb_ragdoll_floor', "")

        directors = armObj['bb_ragdoll_directors']
        for bone in directors.keys():
            name = directors[bone]
            dObj = bpy.data.objects[name]
            utils.activate(dObj)
            try:
                bpy.ops.rigidbody.object_remove()
                print("removed rigid body from", dObj.name)
            except:
                print("skipping remove of rigid body from", dObj.name)

        for boneObj in armObj.pose.bones:
            for cObj in boneObj.constraints:
                boneObj.constraints.remove(cObj)

        for o in bpy.context.selected_objects:
            o.select_set(False)
            utils.activate(None)

        if armObj.get('bb_ragdoll_source') != "existing":
            if len(directors) != 0:  
                for bone in directors.keys():
                    name = directors[bone]
                    if name in bpy.data.objects:
                        dObj = bpy.data.objects[name]
                        dObj.select_set(True)
                if len(bpy.context.selected_objects) > 0:
                    utils.activate(dObj)
                bpy.ops.object.delete()

        armObj.pop('bb_ragdoll_directors', "")
        
        armObj.select_set(True)
        utils.activate(armObj)

        parents = armObj['bb_ragdoll_parents']
        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in armObj.data.edit_bones:
            bone = boneObj.name
            parent = parents[bone]
            if parent != "":
                boneObj.parent = armObj.data.edit_bones[parent]
        bpy.ops.object.mode_set(mode='OBJECT')

        return {'FINISHED'}

class OnigiriSimProperties(bpy.types.PropertyGroup):

    def update_sim_blank(self, context):
        self["sim_blank"] = False
        self["sim_inverse_motion_info"] = False
    sim_blank : bpy.props.BoolProperty(
        default = False,
        update = update_sim_blank
        )
    sim_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "This segment uses cloth dynamics and simulation to animate bones so that you have an additional "            "property to add to your appeal on your character or if you just like your drapes to wiggle.",
        default = False
        )
    sim_anchor : bpy.props.BoolProperty(
        name = "",
        description =            "This options, when in default mode (False/Off), give expected function to the (Stretch) features.  It allows "            "this last qualified parent in the selected chain to be manipulated for the desired visual effect.  When this "            "is enabled your last qualified parent in the chain will have the stretch feature added to it as well, effectively "            "freezing that bone, and the parent to that will have to be manipulated to see the changes.  This is a convenience "            "option and that last parent is selected for you to manipulate after the constraints (Stretch) is placed so that you "            "can begin manipulating immediately.",
        default = False
        )
    sim_deformable : bpy.props.BoolProperty(
        name = "",
        description =            "This applies stretch to deformable bones only, it's not a bad idea to keep this enabled unless you have a "            "complex rig and controllers that will benifit from having non-deformable bones processed in the same manner.  "            "A non-deformable bone is one that is not expected to be exported with the rig or manipulate vertices via skin/weights",
        default = True
        )
    sim_key_location : bpy.props.BoolProperty(
        name = "",
        description =            "When setting a key include location data",
        default = True
        )
    sim_key_rotation : bpy.props.BoolProperty(
        name = "",
        description =            "When setting a key also include rotation data",
        default = True
        )
    sim_key_scale : bpy.props.BoolProperty(
        name = "",
        description =            "This type of animation (Scale) is not supported in SL but when it changes a child bone location this will be "            "observed and can be used in that way.  However, the view will not be the same as you see in SL, only the location "            "data will be preserved so your mesh will not change shape at all as you see in the viewport.",
        default = False
        )

    def update_sim_controller(self, context):
        if self.sim_controller == True:
            if bpy.context.mode == 'POSE':
                if len(bpy.context.selected_pose_bones) == 1:
                    sim.props['controller'] = bpy.context.selected_pose_bones[0].name
                else:
                    self["sim_controller"] = False
            else:
                self["sim_controller"] = False
        else:
            sim.props['controller'] = ""

    sim_controller : bpy.props.BoolProperty(
        name = "",
        description =            "This enables and disable the preferred controller.  This remembers the name of the selected pose bone when enabled.  "            "This bone can be any one in the rig but it's most useful if it's one that you're manipulating often, like one with "            "an IK constraint.  This option is referenced when you set key using this tool and set the controller as active and "            "after every key set so that you can continue manipulating your bone chain without having to find the controller again.",
        default = False,
        update = update_sim_controller
        )
    def update_sim_controller_length(self, context):
        selected = bpy.context.selected_objects
        if len(selected) != 1:
            return
        o = selected[0]
        if o.type != 'ARMATURE':
            return
        if o.data.bones.active == None:
            return
        for boneObj in o.pose.bones:
            for C in boneObj.constraints:
                if C.type == 'IK':
                    C.chain_count = self.sim_controller_length
    sim_controller_length : bpy.props.IntProperty(
        name = "",
        description =            "This is how many joints the IK controller affects, reduce the number if it moves too much of your avatar.",
        min = 1,
        default = 3,
        update = update_sim_controller_length,
        )
    def get_sim_controller_length_poll(self):
        chain = sim.ik_length()
        if chain != False:
            print("get ran ok:", chain)
            return chain
        return False
    sim_controller_length_poll : bpy.props.IntProperty(
        name = "",
        description =            "This is how many joints the IK controller affects, reduce the number if it moves too much of your avatar.",
        min = 1,
        default = 3,
        get = get_sim_controller_length_poll
        )

    sim_inverse_motion_info : bpy.props.BoolProperty(
        name = "",
        description =            "WARNING"            "\n\n"            "Transforms on your mesh will ruin your day.  Examine these before using this tool!"            "\n\n"            "Inverse Motion allows you to animate a rig using mesh instead of a rig animating, or deforming, mesh.  This is a "            "preparatory measure that is then reverted to do the expected, the animation then deforms the mesh.  In this way we "            "can translate a mesh simulation into an armature animation which can then be transfered into a system that does not "            "support this type of simulation, such as Second Life."
            "\n\n"            "There are two types of automatic simulation to make quick work of rigid and cloth type simulations, which are "            "Dynamic for cloth and Object for multiple simulated rigid body objects.  Dynamic can also work with a soft body."            "\n\n"            "There are two tool sets which can be used together but are designed to be used independently, the Automatic and the "            "Manual tool-sets.  The Automatic tool-set allows you build a rig along a path of a set of vertices and the Manual "            "section expects that you already have a rig.",
        update = update_sim_blank
        )

    def update_sim_motion_dynamic(self, context):
        if self.sim_motion_dynamic == True:
            self["sim_motion_object"] = False
        else:
            self["sim_motion_object"] = True
    def update_sim_motion_object(self, context):
        if self.sim_motion_object == True:
            self["sim_motion_dynamic"] = False
        else:
            self["sim_motion_dynamic"] = True
    sim_motion_dynamic : bpy.props.BoolProperty(
        name = "",
        description =            "This is the default because it's pretty neat.  You choose a mesh that's been simulated by cloth/wind, or some other "            "method, and you deposit markers in edit mode onto vertices.  These markers will move when the mesh does and translate "            "to an animated rig which you can then export for use with Second Life and your mesh.",
        default = True,
        update = update_sim_motion_dynamic
        )
    sim_motion_object : bpy.props.BoolProperty(
        name = "",
        description =            "Per Object Motion"            "\n\n"            "This type of inverse motion capture is for whole objects.  You can select multiple objects for use with motion "            "inheritance and they will drive a rig that this tool creates for you.  One bone per object will be assigned and "            "that bone will capture the location and rotation of the associated object.  Because of the single shot, multiple "            "object, complexity of this particular type of sim attachment, there is no reset.  You just chose your objects again "            "and use (Action) again, any stale data will be removed before attaching.  The Director contains a list of active "            "simulation objects and will attempt to clean those, each object contains a Director reference so one can find the other.",
        default = False,
        update = update_sim_motion_object
        )
    def update_sim_marker_size(self, context):
        if sim.props['marker_head'] == "":
            return
        if sim.props['marker_tail'] == "":
            return
        headObj = sim.props['marker_head']
        tailObj = sim.props['marker_tail']
        try:
            if headObj.name in bpy.context.scene.objects:
                headObj.dimensions.xyz = self.sim_marker_size, self.sim_marker_size, self.sim_marker_size
            else:
                print("Head marker missing on update")
        except:
            print("exception: no head marker")
            return
        try:
            if headObj.name in bpy.context.scene.objects:
                tailObj.dimensions.xyz = self.sim_marker_size, self.sim_marker_size, self.sim_marker_size
            else:
                print("Tail marker missing on update")
        except:
            print("exception: no tail marker")
            return

    sim_marker_size : bpy.props.FloatProperty(
        name = "",
        description =            "The tool places an object called a marker when you click on a vertex.  The size of this marker can be adjusted "            "using this property.",
        default = 0.05,
        update = update_sim_marker_size
        )

    sim_path : bpy.props.BoolProperty(
        name = "",
        description =            "Allows to build bones between a path of the selected vertices where the markers were placed.  Use this with the (count)"            "property to choose how many bones to generate long the path.",
        default = False,
        )
    sim_path_radius : bpy.props.FloatProperty(
        name = "",
        description =            "The (Path) type of bone placement requires a skinning process that is temporary.  Vertices control the bones, which is "            "the opposite of what is usually done, and this allows your simulation to be turned into an animated bone/rig.  But for "            "that to happened with the (Path) type of placement there are no distinct vertices defined for controllers and is why a "            "radius is required to calculate a weight distance in order to find those vertices.  This is an internal weight and does not "            "contribute to your skinning data, it's specifically for inverse influences.  If the radius is set to 0 then only a "            "single vertex will be used, the first one found that's closest to the bone head.",
        min = 0,
        default = 0,
        )
    sim_path_count : bpy.props.IntProperty(
        name = "",
        description =            "Use this with the (Enable Path) option.  This allows for more than one bone per marker set across your object. "            "The adherence method is different so the result may be as well and could be completely unusable for simulation.  "            "This placement can be useful for quick skinning and this same feature may be found in another area, if I've gotten to "            "it by now, where you can generate bones across a surface or inside a mesh along a path between two vertices.",
        min=2,
        default = 2,
        )
    sim_path_limit : bpy.props.FloatProperty(
        name = "",
        description =            "Are the bones touching?  To back off the tail from the next head put in a fractional percentage... 0.5 is 50 percent. "            "I can't allow 100 percent or the tail will meet up with the head and in Blender that's not a bone, it's a nothing.  "            "Blender will not allow that and the bone will vanish.  If your distance is very short then ever the fractional safety "            "maximum I'm putting on this may not be good enough.  This is not just a visual nicety, the end of a bone determines "            "weight influences so keep that in mind when performing neat tricks.",
        max = 0.95,
        default = 0.0,
        )

    sim_path_extend : bpy.props.BoolProperty(
        name = "",
        description =            "This extends your bone path by 1 segment, 1 bone length beyond your tail marker. The usefulness of this is apparent when "            "you are using the (limit) property, otherwise it's probably just a waste of bones.  When using the limit property your "            "bone tails will back off of the head a percentage indicated by the value, which can cause skin weight issues for the last "            "bone in the sequence depending on your goal.  This option helps prevent that by making sure there's an anchor for "            "weights where the last bone was indicated.",
        default = False,
        )
    sim_path_parent : bpy.props.BoolProperty(
        name = "",
        description =            "If you enabled (Path) then you're wanting mutliple bones to be generated.  This switch allows the chain to be parented, "            "which is usually not what you want for this tool since each bone is expected to translate freely while controled by the "            "associated vertices.  However, this can be very useful when genrating a quick rig using a meshs` topology or just a means "            "to create an IK system to manipulate the mesh in a more organic and controlled way",
        default = False,
        )

    sim_skin_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "Dynamic type simulations require an additional step before exporting for use with Second Life.  This extra step is the "            "typical skinning process (weights).  This button allows you to skip that step if you are testing your simulation.  Once "            "you click (Done) with this enabled then your simulation will no longer work as expected.  Clicking (Action) again should "            "recover from this but it's unlikely that your simulation will be identical afterwards.",
        default = False,
        )

    def stub(self, context):
        print("This is a stub thrown for loc/rot/sca, replace with individual updaters later")
    sim_custom_location : bpy.props.BoolProperty(
        name = "",
        description =            "Allow the bone to inherit the relative location of the associated vertex group",
        default = True,
        update = stub
        )
    sim_custom_rotation : bpy.props.BoolProperty(
        name = "",
        description =            "Allow the bone to inherit the relative rotation of the associated vertex group",
        default = True,
        update = stub
        )
    sim_custom_scale : bpy.props.BoolProperty(
        name = "",
        description =            "Allow the bone to inherit the relative scale of the associated vertex group",
        default = True,
        update = stub
        )
    sim_custom_radius : bpy.props.FloatProperty(
        name = "",
        description =            "This works similarly to the path radius but has nothing to do with the (Automatic) path feature of that tool.  This does "            "the same thing but with your existing material.  This is only used if (Preserve) is disabled, since this property is only "            "useful when creating vertex groups but not when preserving existing ones.",
        min = 0,
        default = 0,
        )

    sim_custom_influence : bpy.props.FloatProperty(
        name = "",
        description =            "This is the constraint influence.  Usually we work with a value of 1 but you have the option to adjust it for some other "            "interesting effects",
        min = 0,
        max = 1,
        default = 1,
        )

    sim_custom_preserve : bpy.props.BoolProperty(
        name = "",
        description =            "The sim tools default behavior is to create vertex groups to accomplish the task but this manual tool allows you to switch "            "this off.  If this is enabled then your existing vertex groups will be used as pin groups for the associated bones and the "            "armature modifier, if there is one, will be temporarily disabled in order to absorb the motion from the mesh without "            "recursive interference.  If this is disabled any bones you chose to include in your simulation will have their respective "            "vertex group information, of the chosen mesh, replaced with the version provided by the tool",
        default = False,
        )

    def sim_custom_disable_armatures(self, context):
        
        state = self.sim_custom_disable_armatures

        selected = bpy.context.selected_objects
        if len(selected) != 1:
            self["sim_custom_disable_armatures"] = not state
            return
        armObj = sim.get_actor(selected[0])
        if armObj == False:
            print("INIT: sim.get_actor returned False")
            self["sim_custom_disable_armatures"] = not state
            return
        dObj = sim.get_director(armObj)
        if dObj == False:
            print("INIT: sim.get_director returned False")
            self["sim_custom_disable_armatures"] = not state
            return
        
        if isinstance(dObj, list) == False:
            dObj = [dObj]
        for meshObj in dObj:
            for modObj in meshObj.modifiers:
                if modObj.type == 'ARMATURE':
                    modObj.show_viewport = state
                    modeObj.show_render = state

    sim_custom_disable_armatures : bpy.props.BoolProperty(
        name = "",
        description =            "Disable Armature Modifiers"            "\n\n"            "This is enabled by default because it is the expected behavior.  When your sim is processed with (Action) and you have any "            "existing armature modifiers associated with the chosen mesh then these modifiers are disabled by default, in order to get "            "an expected result.  However, with some very careful planning you can utilize existing modifiers and their associated vertex "            "groups to achieve an enhanced simulation, more finely controled by you and, in that case, turn this off to see the results",
        default = True,
        update = sim_custom_disable_armatures
        )

class OnigiriSimActionDynamic(bpy.types.Operator):
    """These tools attach bones to simulated mesh, cloth, dynamic objects, to give some of that
same motion to items, even avatars, in Second Life"""

    bl_idname = "onigiri.sim_action_dynamic"
    bl_label = "Enable Inverse Motion"

    @classmethod
    def poll(cls, context):
        bb_sim = bpy.context.window_manager.bb_sim
        if bb_sim.sim_motion_dynamic == True:
            if len(bpy.context.selected_objects) != 1:
                return False
            if bpy.context.selected_objects[0].type != 'MESH':
                return False
        elif bb_sim.sim_motion_object == True:
            if len(bpy.context.selected_objects) < 1:
                return False
        
        if sim.props['bmesh'] != "":
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        checkObj = bpy.context.selected_objects[0]
        actorObj = None
        directorObj = sim.get_director(checkObj)
        
        if directorObj != False:
            actorObj = directorObj['bb_sim_actor']
            
            print("Found existing actor, continuing work:", actorObj.name)
            
            if 1 == 1:
                result = sim.sync(actorObj)
                if result == False:
                    print("Bad actor, can't continue")
                    popup("Error in existing actor object, the object was cleaned up so try again")
                    for o in bpy.context.selected_objects:
                        o.select_set(False)
                    if utils.is_valid(actorObj):
                        actorObj.select_set(True)
                        utils.activate(actorObj)
                        bpy.ops.object.delete()
                        directorObj.select_set(True)
                        utils.activate(directorObj)
                    directorObj.pop('bb_sim_actor', "")
                    return {'FINISHED'}
        else:
            directorObj = checkObj

        print("--------------------------------------------------------------")
        print("passed area")
        print("--------------------------------------------------------------")

        if len(directorObj.data.vertices) == 0:
            print("This object has zero vertices so it is not a candidate for inverse simulation")
            popup("No vertices to work with", "Error", "ERROR")
            directorObj.pop('bb_sim_actor', "")
            return {'FINISHED'}

        if actorObj == None:
            print("Creating actor")
            
            armature = bpy.data.armatures.new('Actor')
            actorObj = bpy.data.objects.new('Actor', armature)
            
            bpy.context.scene.collection.objects.link(actorObj)
            bpy.context.view_layer.update()

            print("Actor generated at world origin!")

            actorObj.select_set(True)
            bpy.context.view_layer.objects.active = actorObj
            directorObj['bb_sim_actor'] = actorObj
            
            bpy.ops.object.mode_set(mode='EDIT')
            newBone = actorObj.data.edit_bones.new('ROOT')
            newBone.head = 0,0,0
            newBone.tail = 0,0,0.5
            bpy.ops.object.mode_set(mode='OBJECT')
            actorObj['bb_sim_director'] = directorObj
            bpy.context.view_layer.update()

        actorObj.select_set(False)
        directorObj.select_set(True)
        utils.activate(directorObj)

        sim.add_markers(testing=True)

        for f in directorObj.data.polygons:
            f.select = False
        for e in directorObj.data.edges:
            e.select = False
        for v in directorObj.data.vertices:
            v.select = False

        bpy.ops.object.mode_set(mode='OBJECT')
        bm = bmesh.new()
        bm.from_mesh(directorObj.data)
        vert_id = bm.verts.layers.int.new('id')
        bm.verts.ensure_lookup_table()
        for v in directorObj.data.vertices:
            bm.verts[v.index][vert_id] = v.index
        bm.to_mesh(directorObj.data)
        bm.free()

        bpy.ops.object.mode_set(mode='EDIT')

        bpy.ops.mesh.select_mode(type="VERT")

        bm = bmesh.from_edit_mesh( directorObj.data )
        bm.verts.ensure_lookup_table()

        sim.props['bmesh'] = bm

        context.window_manager.modal_handler_add(self)
        return {'RUNNING_MODAL'}

    def modal(self, context, event):
        
        if bpy.context.mode != 'EDIT_MESH':
            
            selected = bpy.context.selected_objects
            active = bpy.context.active_object
            for o in selected:
                o.select_set(False)
            utils.activate(None)

            headObj = sim.props['marker_head']
            tailObj = sim.props['marker_tail']
            if headObj != "":
                try:
                    if headObj.name in bpy.context.scene.objects:
                        headObj.select_set(True)
                        utils.activate(headObj)
                except:
                    print("Transient head marker is missing, that's ok")
            if tailObj != "":
                try:
                    if tailObj.name in bpy.context.scene.objects:
                        tailObj.select_set(True)
                        utils.activate(tailObj)
                except:
                    print("Transient tail marker is missing, that's ok")

            if len(bpy.context.selected_objects) > 0:
                utils.activate(bpy.context.selected_objects[0])
                bpy.ops.object.delete()

            sim.props['marker_head'] = ""
            sim.props['marker_tail'] = ""
            sim.props['marker_is_head'] = True

            bm = sim.props['bmesh']
            if bm != "":
                bm.free()
            sim.props['bmesh'] = ""
            
            sim.props['vertex_head'] = ""
            sim.props['vertex_tail'] = ""

            for o in selected:
                o.select_set(True)
            utils.activate(active)
            
            print("Sim disengaged!")

            return {'FINISHED'}

        sim.move_marker(testing=True)

        return {'PASS_THROUGH'}

class OnigiriSimCustomBones(bpy.types.Operator):
    """Select bones in pose mode that you want to associate with this custom sim.  Any bones that you
select will have their vertex groups removed from the mesh in the next step"""

    bl_idname = "onigiri.sim_custom_bones"
    bl_label = "Select Bones"

    @classmethod
    def poll(cls, context):
        
        if len(bpy.context.selected_objects) != 1:
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False

        rigs = set()
        for boneObj in bpy.context.selected_pose_bones:
            if boneObj.id_data not in rigs:
                rigs.add(boneObj.id_data)
        if len(rigs) > 1:
            return False

        if sim.props.get('custom_rig') != None:
            if bpy.context.selected_pose_bones[0].id_data != sim.props['custom_rig']:
                return False

        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        armObj = bpy.context.selected_objects[0]

        sim_bones = []
        for boneObj in bpy.context.selected_pose_bones:
            sim_bones.append(boneObj)

        sim.props['custom_bones'] = sim_bones
        sim.props['custom_rig'] = armObj

        bpy.ops.object.mode_set(mode="OBJECT")

        return {'FINISHED'}

class OnigiriSimCustomMesh(bpy.types.Operator):
    """Select Your mesh.  You can use multple mesh for this but it may give unusable results.
This converts your set into a sim.  This will remove all weight data and link bones to vertices
closest to the actor bone.  This cannot be reversed"""

    bl_idname = "onigiri.sim_custom_mesh"
    bl_label = "Select Mesh"

    @classmethod
    def poll(cls, context):
        
        if bpy.context.mode != 'OBJECT':
            return False
        
        if len(bpy.context.selected_objects) == 0:
            return False
        
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                return True
        
        return False

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim

        mesh = []
        for o in bpy.context.selected_objects:
            if o.type == 'MESH':
                mesh.append(o)
        sim.props['custom_mesh'] = mesh

        return {'FINISHED'}

class OnigiriSimCustomAction(bpy.types.Operator):
    """This converts your set into a sim.  This will remove all associated weight data and link
bones to vertices closest to the actor bone.  This cannot be reversed"""

    bl_idname = "onigiri.sim_custom_action"
    bl_label = "Custom Action!"

    @classmethod
    def poll(cls, context):
        
        bb_sim = bpy.context.window_manager.bb_sim
        if sim.props.get('custom_rig') == None:
            return False
        if sim.props.get('custom_mesh') == None:
            return False
        
        if bpy.context.mode != 'OBJECT':
            return False

        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim

        mesh = []
        for o in sim.props['custom_mesh']:
            if utils.is_valid(o):
                mesh.append(o)
        if len(mesh) == 0:
            print("INIT: None of your chosen mesh are viable any longer")
            popup("Mesh Error: none of your chosen mesh survived", "Error", "ERROR")
            sim.props['custom_mesh'] = None
            return {'FINISHED'}
        armObj = sim.props['custom_rig']

        armObj['bb_sim_manual'] = True

        if utils.is_valid(armObj) == False:
            print("INIT: Your armature object is no longer viable")
            popup("Armature Error: your chosen armature did not survive", "Error", "ERROR")
            sim.props['custom_rig'] = None
            return {'FINISHED'}
        bones = []
        for boneObj in sim.props['custom_bones']:
            if boneObj.name in armObj.data.bones:
                bones.append(boneObj)
        if len(bones) == 0:
            print("INIT: The selected bones did not surfive.")
            popup("Bone Error: your selected pose bones did not survive", "Error", "ERROR")
            sim.props['custom_bones'] = None
            return {'FINISHED'}

        state = utils.get_state()

        armObj.select_set(True)
        utils.activate(armObj)
        bpy.ops.object.mode_set(mode='POSE')

        armObj['bb_sim_directors'] = mesh
        
        for meshObj in mesh:
            meshObj['bb_sim_actor'] = armObj

        location = bb_sim.sim_custom_location
        rotation = bb_sim.sim_custom_rotation
        scale = bb_sim.sim_custom_scale
        radius = bb_sim.sim_custom_radius
        influence = bb_sim.sim_custom_influence
        preserve = bb_sim.sim_custom_preserve
        disable_armatures = bb_sim.sim_custom_disable_armatures

        for meshObj in mesh:

            dmw = meshObj.matrix_world.copy()
            size = len(meshObj.data.vertices)
            kd = mathutils.kdtree.KDTree(size)
            for v in meshObj.data.vertices:
                v_co = dmw @ v.co
                kd.insert(v_co, v.index)
            kd.balance()

            for boneObj in bones:
                bone = boneObj.name
                dBone = boneObj.bone
                hloc = dBone.head_local.copy()
                vertices = []
                if radius == 0:
                    loc, index, dist = kd.find(hloc)  
                    vertices.append(index)
                else:
                    for loc, index, dist in kd.find_range(hloc, radius):
                        vertices.append(index)

                if preserve == False:
                    if bone in meshObj.vertex_groups:
                        print("sanity check discovers bone already in groups, removing:", bone)
                        G = meshObj.vertex_groups[bone]
                        meshObj.vertex_groups.remove(G)
                    G = meshObj.vertex_groups.new( name = boneObj.name )
                    G.add(vertices, 1, 'REPLACE')

                armObj.data.bones.active = boneObj.bone 
                bc = boneObj.constraints

                conObj = bc.new('CHILD_OF')
                cname = conObj.name
                conObj.target = meshObj
                conObj.subtarget = boneObj.name
                conObj.influence = influence
                conObj.use_location_x = location
                conObj.use_location_y = location
                conObj.use_location_z = location
                conObj.use_rotation_x = rotation
                conObj.use_rotation_y = rotation
                conObj.use_rotation_z = rotation
                conObj.use_scale_x = scale
                conObj.use_scale_y = scale
                conObj.use_scale_z = scale

                context_py = bpy.context.copy()
                context_py["constraint"] = bc.active

                if 1 == 0:
                    new_state = utils.get_state()
                    aObj.select_set(True)
                    utils.activate(aObj)
                    bpy.ops.object.mode_set(mode='POSE')

                utils.set_inverse(context_py, cname)
                
                conObj.name = "BB Sim " + cname

                if sim.props['group_base'] not in armObj.pose.bone_groups:
                    bpy.ops.pose.group_add()
                armObj.pose.bone_groups.active.name = sim.props['group_base']
                armObj.pose.bone_groups.active.color_set = sim.props['theme_base']
                group_base = sim.props['group_base']
                boneObj.bone_group = armObj.pose.bone_groups[group_base]

        if disable_armatures == True:
            print("Disabling armature modifiers")
            mods = {}
            for meshObj in mesh:
                for modObj in meshObj.modifiers:
                    if modObj.type == 'ARMATURE':
                        mods[modObj.name] = {}
                        mods[modObj.name]['show_viewport'] = modObj.show_viewport
                        mods[modObj.name]['show_render'] = modObj.show_render
                        modObj.show_viewport = False
                        modObj.show_render = False

            if len(mods) > 0:
                meshObj['bb_sim_mods'] = mods

        print("parenting mesh to armature")
        for meshObj in mesh:
            meshObj.parent = armObj

        sim.props['custom_rig'] = None
        sim.props['custom_bones'] = None
        sim.props['custom_mesh'] = None

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriSimCustomDetach(bpy.types.Operator):
    """This detaches all recorded bones from their parents or detaches the currently selected
bones from their parents as a convenience.  This is usualy what you want when generating a
sim but sometimes special conditions dictate otherwise"""

    bl_idname = "onigiri.sim_custom_detach"
    bl_label = "Custom Detach!"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        armObj = bpy.context.selected_objects[0]
        if armObj.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        
        armObj = bpy.context.selected_objects[0]
        state = utils.get_state()
        armObj.select_set(True)
        utils.activate(armObj)
        
        for boneObj in armObj.pose.bones:
            if boneObj.parent:
                boneObj.bone['parent'] = boneObj.name
            else:
                boneObj.bone['parent'] = ""

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in armObj.data.edit_bones:
            boneObj.parent = None
            print("unparent", boneObj.name)

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriSimCustomAttach(bpy.types.Operator):
    """This re-attaches the bones that you detached using (Detach)"""

    bl_idname = "onigiri.sim_custom_attach"
    bl_label = "Custom Attach!"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        armObj = bpy.context.selected_objects[0]
        if armObj.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        
        armObj = bpy.context.selected_objects[0]
        state = utils.get_state()
        armObj.select_set(True)
        utils.activate(armObj)

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in armObj.data.edit_bones:
            bone = boneObj.name
            parent = armObj.data.bones[bone].pop('parent', "")
            if parent != "":
                boneObj.parent = armObj.data.edit_bones[parent]
                print("parent", boneObj.name, "to", parent)

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriSimCustomConstraints(bpy.types.Operator):
    """The button label says what it will do to constraints.  The chosen pose bones will be
examined first.  If this is not available the the selected armature will be used instead.  This
may be useful when packing on additional sims"""

    bl_idname = "onigiri.sim_custom_constraints"
    bl_label = "Constraints"

    action : bpy.props.StringProperty(default="disable")

    @classmethod
    def poll(cls, context):
        if sim.props.get('custom_rig') != None:
            armObj = sim.props['custom_rig']
            if utils.is_valid(armObj):
                return True
        selected = bpy.context.selected_objects
        if len(selected) == 1:
            if selected[0].type == 'ARMATURE':
                return True

        return False

    def execute(self, context):
        selected = bpy.context.selected_objects
        if sim.props.get('custom_rig') == None:
            if len(selected) == 0:
                popup("No armature available", "Error", "ERROR")
                return {'FINISHED'}
            if selected[0].type != 'ARMATURE':
                popup("Not an armature", "Error", "ERROR")
                return {'FINISHED'}
            armObj = selected[0]

        else:
            armObj = sim.props['custom_rig']

        if utils.is_valid(armObj) == False:
            popup("Armature is no longer valid", "Error", "ERROR")
            return {'FINISHED'}

        if self.action == "disable":
            for boneObj in armObj.pose.bones:
                for conObj in boneObj.constraints:
                    conObj.mute = True
        elif self.action == "enable":
            for boneObj in armObj.pose.bones:
                for conObj in boneObj.constraints:
                    conObj.mute = False
        elif self.action == "remove":
            for boneObj in armObj.pose.bones:
                for conObj in boneObj.constraints:
                    boneObj.constraints.remove(conObj)

        return {'FINISHED'}

class OnigiriSimActionObject(bpy.types.Operator):
    """Select 1 or more simulated objects and click (Action!).  This will attach a bone to each
object location and inherit the motion from them.  You can then export these as SL animations with
a mapped mesh to get a similar result in SL"""

    bl_idname = "onigiri.sim_action_object"
    bl_label = "Enable Inverse Motion"

    @classmethod
    def poll(cls, context):
        bb_sim = bpy.context.window_manager.bb_sim
        if bb_sim.sim_motion_object == True:
            if len(bpy.context.selected_objects) > 0:
                return True
        return False

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim

        selected = bpy.context.selected_objects
        mesh = []

        for o in selected:
            if o.type == 'MESH':
                mesh.append(o)

        actors = set()
        for o in selected:
            if o.type == 'MESH':
                a = o.get('bb_sim_actor')
                if a != None:
                    actors.add(a)
                o.pop('bb_sim_actor', "")
        
        directors = []
        for a in actors:
            ds = a.get('bb_sim_directors', [])
            directors.extend(ds)
        
        for d in directors:
            if utils.is_valid(d):
                d.pop('bb_sim_actor', "")
        
        delete = []
        for a in actors:
            if utils.is_valid(a):
                delete.append(a)
        for o in bpy.context.selected_objects:
            o.select_set(False)

        if len(delete) > 0:
            for o in delete:
                o.select_set(True)
                print("Will remove actor", o.name)
            
            utils.activate(delete[0])
            
            bpy.ops.object.delete()

        if len(mesh) == 0:
            print("There are no qualified mesh in the selection")
            popup("There are not qualified mesh in the selection", "Error", "ERROR")
            return {'FINISHED'}

        for o in mesh:
            o.select_set(True)
        utils.activate(mesh[0])
        directors = mesh
        print("Mesh reset and actors removed if there were any")

        print("Remaining directors for simulation:")
        for o in directors:
            print(" - ", o.name)

        print("Creating actor")
        
        armature = bpy.data.armatures.new('Actor')
        aObj = bpy.data.objects.new('Actor', armature)
        
        bpy.context.scene.collection.objects.link(aObj)
        bpy.context.view_layer.update()
        aObj.location = (0.0, 0.0, 0.0)
        aObj.select_set(True)
        bpy.context.view_layer.objects.active = aObj
        
        bpy.ops.object.mode_set(mode='EDIT')
        newBone = aObj.data.edit_bones.new('ROOT')
        newBone.head = 0,0,0
        newBone.tail = 0,0,0.5
        bpy.ops.object.mode_set(mode='OBJECT')
        aObj['bb_sim_directors'] = directors
        bpy.context.view_layer.update()

        print("Storing actors into the directors")
        for d in directors:
            d['bb_sim_actor'] = aObj

        distance = {}
        for dObj in directors:
            bpy.ops.object.mode_set(mode='EDIT')
            
            vertices = [v.index for v in dObj.data.vertices]
            
            bbox_corners = [dObj.matrix_world @ Vector(corner) for corner in dObj.bound_box]
            
            head = bbox_corners[0]
            tail = mathutils.Vector((0,0,0))
            
            longest = 0
            for v in bbox_corners:
                next_length = (v - head).length
                if next_length > longest:
                    tail = v
                    longest = next_length
            
            bname = "BB_SIM_BONE_" + utils.get_temp_name()
            if bname in aObj.data.bones:
                print("Bone name collision", bname)
            boneObj = aObj.data.edit_bones.new(bname)
            
            bone = boneObj.name
            boneObj.head = head
            boneObj.tail = tail
            G = dObj.vertex_groups.new( name = bone )
            G.add(vertices, 1, 'REPLACE')

            constraints = ['COPY_LOCATION', 'COPY_ROTATION']
            bpy.ops.object.mode_set(mode='OBJECT')
            boneObj = aObj.pose.bones[bone]
            aObj.data.bones.active = boneObj.bone 

            for C in boneObj.constraints:
                boneObj.constraints.remove(C)
            
            for constraint in constraints:
                bc = boneObj.constraints
                conObj = bc.new(constraint)
                cname = conObj.name
                conObj.name = "BB Sim " + cname
                conObj.target = dObj
                
                conObj.target_space = 'WORLD'
                conObj.owner_space = 'WORLD'
                conObj.influence = 1

        bpy.ops.object.mode_set(mode='OBJECT')

        for o in bpy.context.selected_objects:
            o.select_set(False)

        aObj.select_set(True)
        utils.activate(aObj)
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode='OBJECT')
        aObj.select_set(False)

        for o in directors:
            o.select_set(True)
        
        if len(directors) > 0:
            utils.activate(o)

        return {'FINISHED'}

class OnigiriSimDone(bpy.types.Operator):
    """A convenience, when you're done click this and go map your bones.  You can return here
to continue work using (Action) again.  You can finalize your work by using (Bake) """

    bl_idname = "onigiri.sim_done"
    bl_label = "Done"

    @classmethod
    def poll(cls, context):
        bb_sim = bpy.context.window_manager.bb_sim
        
        if bb_sim.sim_motion_object == True:
            return False
        if len(bpy.context.selected_objects) < 1:
            return False
        if bpy.context.selected_objects[0].type != 'MESH':
                return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        checkObj = bpy.context.selected_objects[0]

        state = utils.get_state()

        headObj = sim.props['marker_head']
        tailObj = sim.props['marker_tail']
        txt = ""
        if headObj != "":
            headObj.select_set(True)
            utils.activate(headObj)
        if tailObj != "":
            tailObj.select_set(True)
            utils.activate(tailObj)
        if len(bpy.context.selected_objects) > 0:
            bpy.ops.object.delete()

        dObj = sim.get_director(checkObj)
        if dObj == False:
            print("No director")
            popup("Not a valid set", "Error", "ERROR")
            return {'FINISHED'}

        sim.props['marker_head'] = ""
        sim.props['marker_tail'] = ""
        sim.props['marker_is_head'] = True
        bm = sim.props['bmesh']
        if bm != "":
            bm.free()
        sim.props['bmesh'] = ""
        
        sim.props['vertex_head'] = ""
        sim.props['vertex_tail'] = ""

        aObj = dObj['bb_sim_actor']
        if aObj.name not in bpy.context.scene.objects:
            print("actor was removed, this could be a bug")
            return {'FINISHED'}

        for o in bpy.context.selected_objects:
            o.select_set(False)

        if 1 == 0:
        
            dObj.select_set(True)
            aObj.select_set(True)
            utils.activate(aObj)
            bpy.ops.object.parent_set(type='ARMATURE_AUTO')
            for boneObj in aObj.pose.bones:
                for C in boneObj.constraints:
                    C.influence = 0

        dObj.select_set(True)
        utils.activate(dObj)

        if 1 == 0:
            
            bpy.context.scene.frame_set(1)

            bpy.ops.object.duplicate()
            mObj = bpy.context.object

        print("selected:", bpy.context.selected_objects[0].name)
        dObj['bb_sim_type'] = "dynamic"
        return {'FINISHED'}

class OnigiriLatchProperties(bpy.types.PropertyGroup):

    def update_latch_blank(self, context):
        self["latch_blank"] = False
    latch_blank : bpy.props.BoolProperty(
        name = "",
        description =            "blank",
        default = False,
        update = update_latch_blank
        )
    latch_menu_enabled : bpy.props.BoolProperty(
        name = "",
        description =            "These are rig controller and matching features for ease of use.  The process here is also useful for transferring "            "between chained rigs using multiple maps.  This is where you can snap one rig to another.",
        default = False,
        )

    def update_latch_actor(self, context):
        
        self["latch_actor"] = True
        bpy.ops.onigiri.latch_cleanup()

    def update_latch_director(self, context):
        
        print("Latch cleanup from director")
        self["latch_director"] = True
        bpy.ops.onigiri.latch_cleanup()

    latch_actor : bpy.props.BoolProperty(
        name = "",
        description =            "This rig appears to be an actor for the latch, remove it or use another",
        default = True,
        update = update_latch_actor
        )
    latch_director : bpy.props.BoolProperty(
        name = "",
        description =            "This rig appears to be an director for the latch, remove it or use another",
        default = True,
        update = update_latch_director
        )
    
    def get_latch_actor(self):
        active = bpy.context.active_object
        if active == None:
            return False
        
        if active.get('bb_latch_director') != None:
            return True
        
        if latch.props['latch_waiting'] != None:
            return True
        return False
    def get_latch_director(self):
        active = bpy.context.active_object
        if active == None:
            return False
        
        if active.get('bb_latch_actor') != None:
            return True
        
        if latch.props['latch_waiting'] == None:
            return False
        
        return False
    latch_actor_poll : bpy.props.BoolProperty(
        default = False,
        get = get_latch_actor
        )
    latch_director_poll : bpy.props.BoolProperty(
        default = False,
        get = get_latch_director
        )

class OnigiriLatchcleanup(bpy.types.Operator):
    """-internal"""
    bl_idname = "onigiri.latch_cleanup"
    bl_label = ""

    def execute(self, context):
        bb_latch = bpy.context.window_manager.bb_latch
        armObj = bpy.context.active_object

        print("Latch cleanup!")

        latch.props["latch_waiting"] = None

        inRig = latch.get_director(armObj)
        if inRig != False:
            print("Found director:", inRig.name)
            outRig = inRig.get('bb_latch_actor', "")
            if utils.is_valid(outRig):
                print("Found actor:", outRig.name)
                outRig.pop('bb_latch_director', "")
                outRig.pop('bb_latch_actor', "")
                
                for boneObj in outRig.pose.bones:
                    constraints = boneObj.get('bb_latch_constraints')
                    if constraints != None:
                        for cname in constraints:
                            conObj = boneObj.constraints.get(cname)
                            if conObj != None:
                                boneObj.constraints.remove(conObj)
                        boneObj.pop('bb_latch_constraints', "")
                inRig.pop('bb_latch_actor', "")

        else:
            
            for boneObj in armObj.pose.bones:
                constraints = boneObj.get('bb_latch_constraints')
                if constraints != None:
                    for cname in constraints:
                        conObj = boneObj.constraints.get('cname')
                        if conObj != None:
                            boneObj.constraints.remove(conObj)
            armObj.pop('bb_latch_actor', "")
            armObj.pop('bb_latch_director', "")

        return {'FINISHED'}

class OnigiriLatchActor(bpy.types.Operator):
    """Load a map onto this rig first, then click this to register it in order to attach it to
another rig useed for localized constraints to inherit translation data as well as location.
This may be needed to source your animation to your custom rig when retargeting"""

    bl_idname = "onigiri.latch_actor"
    bl_label = "Enable this actor for a latch"

    @classmethod
    def poll(cls, context):
        active = bpy.context.active_object
        if active == None: 
            return False
        if active.type != 'ARMATURE':
            return False
        
        if active.get('bb_latch_director') or active.get('bb_latch_actor'):
            return False
        return True

    def execute(self, context):
        bb_latch = bpy.context.window_manager.bb_latch
        armObj = bpy.context.active_object

        latch.props['latch_waiting'] = armObj

        state = utils.get_state()

        armObj.select_set(True)
        utils.activate(armObj)
        bpy.ops.object.mode_set(mode='OBJECT')

        armObj['bb_latch_data'] = armObj.data.copy()
        
        utils.make_single(armObj)

        bpy.ops.object.transform_apply(scale=True, rotation=True, location=False)

        utils.set_state(state)

        print("Locked actor", armObj.name)
        print("Your Actor is engaged, now choose a Director, IK, animated rig or some controller rig.")

        return {'FINISHED'}

class OnigiriLatchDirector(bpy.types.Operator):
    """Use this to attach the registered actor to this rig for this rig to act as a director/latch,
make sure you have a map on your actor, not THIS rig"""

    bl_idname = "onigiri.latch_director"
    bl_label = "Attach your actor to this director"

    @classmethod
    def poll(cls, context):
        active = bpy.context.active_object
        if active == None: 
            return False
        if active.type != 'ARMATURE':
            return False
        
        if active.get('bb_latch_director') or active.get('bb_latch_actor'):
            return False
        if latch.props['latch_waiting'] == None:
            return False
        
        return True

    def execute(self, context):
        bb_latch = bpy.context.window_manager.bb_latch
        inRig = bpy.context.active_object
        outRig = latch.props['latch_waiting']
        if outRig == None:
            print("weird issue with outrig for a latch, see where you forgot to reset it or to define it")
            popup("Bad Latch", "Error", "ERROR")
            return {'FINISHED'}

        if outRig == inRig:
            print("Actor and director are the same object")
            popup("The actor and director are the same object", "Error", "ERROR")
            return {'FINISHED'}

        rename_map = outRig.get('bb_onemap_rename')
        if rename_map == None:
            print("Your actor object/rig must have a map on it which you can generate using any of the mapper tools")
            popup("There's no map on the actor, use a map tool first", "Error", "ERROR")
            return {'FINISHED'}

        bad_bones = []
        good_bones = []
        for bone in rename_map:
            if bone not in outRig.data.bones:
                bad_bones.append(bone)
            else:
                good_bones.append(bone)
        if len(bad_bones):
            print("The following bones did not match your actor rig:")
            print(bad_bones)
        if len(good_bones) == 0:
            print("There were no mappable bones in the actor rig, wrong map?")
            popup("Incompatible map, see console", "Error", "ERROR")
            return {'FINISHED'}
        
        bad_bones = []
        good_bones = []
        for bone in rename_map:
            tbone = rename_map[bone]
            if tbone not in inRig.data.bones:
                bad_bones.append(tbone)
            else:
                good_bones.append(tbone)
        if len(bad_bones):
            print("The following bones did not match your latch rig:")
            print(bad_bones)
        if len(good_bones) == 0:
            print("There were no mappable bones in the latch rig, wrong map?")
            popup("Incompatible map, see console", "Error", "ERROR")
            return {'FINISHED'}

        latch.props['latch_waiting'] = None
        inRig['bb_latch_actor'] = outRig
        outRig['bb_latch_director'] = inRig

        inRig['bb_latch_data'] = inRig.data.copy()
        
        utils.make_single(inRig)

        for o in bpy.context.selected_objects:
            o.select_set(False)
        outRig.select_set(True)
        utils.activate(outRig)

        for boneObj in outRig.data.bones:
            boneObj['matrix_local'] = boneObj.matrix_local.copy()
            boneObj['head'] = boneObj.head_local.copy()
            boneObj['tail'] = boneObj.tail_local.copy()
            boneObj['roll'] = utils.get_bone_roll(boneObj.matrix_local.copy())
            boneObj['use_connect'] = boneObj.use_connect

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in outRig.data.edit_bones:
            boneObj.use_connect = False
        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.mode_set(mode='EDIT')
        for sbone in rename_map:
            tbone = rename_map[bone]
            if sbone in inRig.data.bones and tbone in outRig.data.bones:
                outRig.data.edit_bones[tbone].roll = utils.get_bone_roll(inRig.data.bones[sbone].matrix_local.copy())
        bpy.ops.object.mode_set(mode='OBJECT')

        latch.attach(inRig=inRig, outRig=outRig)

        outRig.select_set(True)
        utils.activate(outRig)

        print("Latch engaged on", outRig.name, "to", inRig.name)

        return {'FINISHED'}

class OnigiriLatchSnap(bpy.types.Operator):
    """Snap actor to director"""

    bl_idname = "onigiri.latch_snap"
    bl_label = "Snap actor to director"

    @classmethod
    def poll(cls, context):
        active = bpy.context.active_object
        if active == None: 
            return False
        if active.type != 'ARMATURE':
            return False
        
        if active.get('bb_latch_director') == None and active.get('bb_latch_actor') == None:
            return False
        return True

    def execute(self, context):
        bb_latch = bpy.context.window_manager.bb_latch
        armObj = bpy.context.active_object
        inRig = latch.get_director(armObj)
        if inRig == False:
            print("no director")
            popup("No Director", "Error", "ERROR")

        outRig = inRig['bb_latch_actor']
        rename_map = outRig['bb_onemap_rename']

        state = utils.get_state()

        for boneObj in outRig.pose.bones:
            constraints = boneObj.pop('bb_latch_constraints', [])
            for c in constraints:
                conObj = boneObj.constraints.get('c')
                if conObj != None:
                    boneObj.constraints.remove(conObj)

        armObj.select_set(False)
        inRig.select_set(True)
        utils.activate(inRig)
        bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)

        inRig.select_set(False)
        outRig.select_set(True)
        utils.activate(outRig)
        bpy.ops.object.transform_apply(scale=True, rotation=True, location=True)

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in outRig.data.edit_bones:
            boneObj.use_connect = False

        for tbone in rename_map:
            sbone = rename_map[tbone]
            inrig_mw = inRig.matrix_world.copy()
            outrig_mw = outRig.matrix_world.copy()
            if tbone in outRig.data.bones and sbone in inRig.data.bones:
                outRig.data.edit_bones[tbone].head = inrig_mw @ outrig_mw.inverted() @ inRig.data.bones[sbone].head_local.copy()
                outRig.data.edit_bones[tbone].tail = inrig_mw @ outrig_mw.inverted() @ inRig.data.bones[sbone].tail_local.copy()
                
        bpy.ops.object.mode_set(mode='OBJECT')

        rigutils.match_bone_orientation(inRig=inRig, outRig=outRig, apply=True)

        outRig.select_set(True)
        utils.activate(outRig)

        return {'FINISHED'}

class OnigiriLatchConnect(bpy.types.Operator):
    """Connect tail bones to the head of the intended target bones, this gives you a better visual
and may clear up some issues with the Rigify goofyness"""

    bl_idname = "onigiri.latch_connect"
    bl_label = "Connect bones"

    @classmethod
    def poll(cls, context):
        active = bpy.context.active_object
        if active == None: 
            return False
        if active.type != 'ARMATURE':
            return False
        
        if active.get('bb_latch_director') == None and active.get('bb_latch_actor') == None:
            return False
        return True

    def execute(self, context):
        bb_latch = bpy.context.window_manager.bb_latch
        armObj = bpy.context.active_object
        inRig = latch.get_director(armObj)
        if inRig == False:
            print("no director")
            popup("No Director", "Error", "ERROR")

        outRig = inRig['bb_latch_actor']
        rename_map = outRig['bb_onemap_rename']

        state = utils.get_state()

        outRig.select_set(True)
        utils.activate(outRig)

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in outRig.data.edit_bones:
            if boneObj.name in rename_map:
                pBone = boneObj.parent
                if pBone:
                    if pBone.name in rename_map:
                        if len(pBone.children) == 1:
                            pBone.tail = boneObj.head.copy()
                            
        bpy.ops.object.mode_set(mode='OBJECT')

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriLatchRestore(bpy.types.Operator):
    """This will attempt to restore your rigs to before you latched them"""

    bl_idname = "onigiri.latch_restore"
    bl_label = "Restore"

    @classmethod
    def poll(cls, context):
        active = bpy.context.active_object
        if active == None: 
            return False
        if active.type != 'ARMATURE':
            return False
        return True

    def execute(self, context):
        bb_latch = bpy.context.window_manager.bb_latch
        armObj = bpy.context.active_object
        inRig = latch.get_director(armObj)
        if inRig == False:
            print("no director")
        else:
            outRig = inRig['bb_latch_actor']
            data = outRig.get('bb_latch_data')
            if data != None:
                outRig.data = data
                outRig.pop('bb_latch_data')
            data = inRig.get('bb_latch_data')
            if data != None:
                inRig.data = data
                inRig.pop('bb_latch_data')
        if armObj != None:
            data = armObj.get('bb_latch_data')
            if data != None:
                armObj.data = data
                armObj.pop('bb_latch_data')

        utils.purge_orphans()

        print("Reset finished")

        return {'FINISHED'}

class OnigiriLatchFreeze(bpy.types.Operator):
    """Freeze the actor where it is"""

    bl_idname = "onigiri.latch_freeze"
    bl_label = "Freeze the Actor rig"

    @classmethod
    def poll(cls, context):
        active = bpy.context.active_object
        if active == None: 
            return False
        if active.type != 'ARMATURE':
            return False
        
        if active.get('bb_latch_director') == None or active.get('bb_latch_actor') == None:
            return False
        if active.get('bb_onemap_rename') == None:
            return False
        return True

    def execute(self, context):
        bb_latch = bpy.context.window_manager.bb_latch
        inRig = bpy.context.active_object
        if inRig == False:
            print("no director")
            popup("No Director", "Error", "ERROR")

        outRig = inRig['bb_latch_actor']
        
        rename_map = inRig.get('bb_onemap_rename')
        if rename_map == None:
            print("No map")
            popup("No map", "Error", "ERROR")
            return {'FINISHED'}
        
        bpy.ops.onigiri.latch_cleanup()

        print("would have frozen")

        return {'FINISHED'}

class OnigiriSelectBones(bpy.types.Operator):
    """Select/Deselect bones of type"""

    bl_idname = "onigiri.select_bones"
    bl_label = "Select/Deselect Bones"

    action : bpy.props.StringProperty(default="select")
    group : bpy.props.StringProperty(default="base")

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'EDIT_ARMATURE' and bpy.context.mode != 'POSE':
            return False
        return True

    def execute(self, context):
        armObj = bpy.context.selected_objects[0]
        utils.activate(armObj)

        action = self.action
        group = self.group

        if action == "select":
            state = True
        elif action == "deselect":
            state = False
        mode = bpy.context.mode
        if mode == 'EDIT_ARMATURE':
            boneType = armObj.data.edit_bones
        elif mode == 'POSE':
            boneType = armObj.data.bones
        if group == "invert":
            for boneObj in boneType:
                state = boneObj.select
                boneObj.select = not state
            return {'FINISHED'}
        if group == "unknown":
            for boneObj in boneType:
                if boneObj.name not in skel.avatar_skeleton:
                    boneObj.select = state
            return {'FINISHED'}
        
        for bone in skel.avatar_skeleton:
            if bone in bone_groups.bones[group]:
                boneType[bone].select = state

        return {'FINISHED'}

class OnigiriSimBake(bpy.types.Operator):
    """Bake the simulation into armature animation.  This will add the simulation to your rig
as an animation and detach your set from the sim tools.  Make sure your timeline range is set
appropriately for start and end"""

    bl_idname = "onigiri.sim_bake"
    bl_label = "Bake Animation"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        director = o.get('bb_sim_director')
        directors = o.get('bb_sim_directors')
        actor = o.get('bb_sim_actor')
        if director == None and directors == None and actor == None:
            return False
        if sim.props['marker_head'] != "":
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        checkObj = bpy.context.selected_objects[0]

        dObj = sim.get_director(checkObj)
        if dObj == False:
            print("This doesn't appear to be a sim set")
            popup("This doesn't appear to be part of a sim set", "Error", "ERROR")
            return {'FINISHED'}
        if isinstance(dObj, list):
            print("Appears to be an Object sim")
            directors = dObj
        else:
            print("Appears to be a Dynamic sim")
            directors = [dObj]

        aObj = directors[0]['bb_sim_actor']

        if utils.is_valid(aObj):

            result = animutils.bake_motion(sarm=aObj, tarm=aObj)
            if result == True:
                print("Baking finished!")
                
                for boneObj in aObj.pose.bones:
                    for C in boneObj.constraints:
                        if C.name.startswith('BB Sim'):
                            boneObj.constraints.remove(C)

                aObj.select_set(False)
                for o in directors:
                    if utils.is_valid(o):
                        o.select_set(True)
                    else:
                        try:
                            print("Skipping invalid object", o)
                        except:
                            print("Non existent object cannot be referenced")
                
                utils.activate(o)

                print("-------------------------------------------")
                print("selected:", bpy.context.selected_objects)
                print("mode:", bpy.context.mode)
                print("-------------------------------------------")
                try:
                    bpy.ops.rigidbody.objects_remove()
                except:
                    print("Not a rigid body, maybe cloth?")

                print("Attempting to remove cloth or softbody sim")
                
                for o in directors:
                    for modObj in o.modifiers:
                        if modObj.type == 'CLOTH' or modObj.type == 'SOFT_BODY':
                            o.modifiers.remove(modObj)

                for o in directors:
                    m = o.modifiers.new(name='Armature', type='ARMATURE')
                    m.object = aObj
                    m.use_vertex_groups = True
                    
            else:
                print("Baking seemed to have failed")
                
        else:
            print("The actor is invalid, this shouldn't happen")
            popup("Bad Actor, this shouldn't happen", "Error", "ERROR")
            return {'FINISHED'}

        for o in directors:
            o['bb_sim_type'] = "object"

        print("Freezing sim, reset will no longer apply to this set")

        bb_sim = bpy.context.window_manager.bb_sim
        checkObj = bpy.context.selected_objects[0]

        state = utils.get_state()

        headObj = sim.props['marker_head']
        tailObj = sim.props['marker_tail']
        if headObj != "":
            try:
                if headObj.name in bpy.context.scene.objects:
                    headObj.select_set(True)
                    utils.activate(headObj)
            except:
                print("Head removed already")
        if tailObj != "":
            try:
                if tailObj.name in bpy.context.scene.objects:
                    tailObj.select_set(True)
                    utils.activate(tailObj)
            except:
                print("Tail removed already")

        sim.props['marker_nead'] = ""
        sim.props['marker_tail'] = ""

        if 1 == 0:
            dObj = sim.get_director(checkObj)
            if dObj == False:
                print("No director link for", checkObj.name)
                
                print("Cleaning up mesh just in case")
                checkObj.pop('bb_sim_director', "")
                checkObj.pop('bb_sim_actor', "")

            else:
                if isinstance(dObj, list):
                    print("Got multiple directors")
                    director_objects = dObj
                else:
                    print("Got single director")
                    director_objects = [dObj] 

                for dObj in director_objects:
                    aObj = dObj.get('bb_sim_actor')
                    dObj.pop('bb_sim_actor', "")

        bm = sim.props['bmesh']
        if bm != "":
            bm.free()
        sim.props['bmesh'] = ""
        sim.props['vertex_head'] = ""
        sim.props['vertex_tail'] = ""

        armObj = sim.get_actor(checkObj)
        if armObj == False:
            print("No custom actor available, no problem")
        else:
            sim.props.pop('custom_rig', "")
            sim.props.pop('custom_bones', "")
            sim.props.pop('custom_mesh', "")
            mesh = armObj.pop('custom_mesh', [])
            for meshObj in mesh:
                meshObj.pop('sim_custom_mods', [])
                meshObj.pop('sim_custom_actor', "")
        
        return {'FINISHED'}

class OnigiriSimJoin(bpy.types.Operator):
    """Combine your sim objects for cleaner uploads.  You should bake your animation first or
export it retargeted in the Character Tools / Retarget Motion then Animation / Export Animation.
Baking preserves your animation and allows you to examine and adjust it before export"""

    bl_idname = "onigiri.sim_join"
    bl_label = "Join the sim objects"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        director = o.get('bb_sim_director')
        directors = o.get('bb_sim_directors')
        actor = o.get('bb_sim_actor')
        if director == None and directors == None and actor == None:
            return False
        if sim.props['marker_head'] != "":
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        checkObj = bpy.context.selected_objects[0]

        dObj = sim.get_director(checkObj)
        if dObj == False:
            print("This doesn't appear to be a sim set")
            popup("This doesn't appear to be part of a sim set", "Error", "ERROR")
            return {'FINISHED'}
        if isinstance(dObj, list):
            print("Appears to be an Object sim")
            directors = dObj
        else:
            print("Appears to be a Dynamic sim")
            directors = [dObj]

        aObj = directors[0]['bb_sim_actor']
        if utils.is_valid(aObj):
            
            for boneObj in aObj.pose.bones:
                for C in boneObj.constraints:
                    if C.name.startswith('BB Sim'):
                        boneObj.constraints.remove(C)
        else:
            print("The actor is invalid, this shouldn't happen")
            popup("Bad Actor, this shouldn't happen", "Error", "ERROR")
            return {'FINISHED'}

        del_kludge = []
        for o in directors:
            if utils.is_valid(o):
                o.select_set(True)
                
                o.parent = None
                
                del_kludge.append(o.name) 

            else:
                try:
                    print("Skipping invalid object", o)
                except:
                    print("Non existent object cannot be referenced")

        utils.activate(o)
        bpy.ops.object.join()
        
        bpy.context.active_object.parent = aObj

        for name in del_kludge:
            if name == bpy.context.active_object.name:
                print("Dereference kludge skips joined object", name)
                continue
            print("Peforming dereference klude for object", name)
            bpy.data.objects.remove(bpy.data.objects[name], do_unlink=True)

        return {'FINISHED'}

class OnigiriSimParent(bpy.types.Operator):
    """The (Join) operator will parent the resulting object to the armature but you can do that
here, in order to keep them separated.  This can be useful, and is the expected state that a mesh
is in when associated with a rig, but not always necessary"""

    bl_idname = "onigiri.sim_parent"
    bl_label = "Parent the objects"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        director = o.get('bb_sim_director')
        directors = o.get('bb_sim_directors')
        actor = o.get('bb_sim_actor')
        if director == None and directors == None and actor == None:
            return False
        if sim.props['marker_head'] != "":
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        checkObj = bpy.context.selected_objects[0]

        dObj = sim.get_director(checkObj)
        if dObj == False:
            print("This doesn't appear to be a sim set")
            popup("This doesn't appear to be part of a sim set", "Error", "ERROR")
            return {'FINISHED'}
        if isinstance(dObj, list):
            print("Appears to be an Object sim")
            directors = dObj
        else:
            print("Appears to be a Dynamic sim")
            directors = [dObj]

        aObj = directors[0]['bb_sim_actor']
        if utils.is_valid(aObj):
            
            for boneObj in aObj.pose.bones:
                for C in boneObj.constraints:
                    if C.name.startswith('BB Sim'):
                        boneObj.constraints.remove(C)
                
        else:
            print("The actor is invalid, this shouldn't happen")
            popup("Bad Actor, this shouldn't happen", "Error", "ERROR")
            return {'FINISHED'}

        for o in bpy.context.selected_objects:
            o.select_set(False)

        valid = []
        for o in directors:
            if utils.is_valid(o):
                valid.append(o)
            else:
                try:
                    print("Skipping invalid object when parenting", o)
                except:
                    print("Non existent object cannot be referenced when parenting")

        if len(valid) == 0:
            print("None of the director objecs were valid")
        else:
            for o in valid:
                o.parent = aObj
                o.select_set(True)
            utils.activate(o)

        return {'FINISHED'}

class OnigiriSimAddBone(bpy.types.Operator):
    """Add a bone using the markers, red is head and blue is tail so click until you have
the arrangement you like before using this."""

    bl_idname = "onigiri.sim_add_bone"
    bl_label = "Add Bone"

    @classmethod
    def poll(cls, context):
        bb_sim = bpy.context.window_manager.bb_sim
        
        if bb_sim.sim_motion_object == True:
            return False
        if len(bpy.context.selected_objects) < 1:
            return False
        if bpy.context.selected_objects[0].type != 'MESH':
                return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        checkObj = bpy.context.selected_objects[0]

        if sim.props['vertex_head'] == "" or sim.props['vertex_tail'] == "":
            print("The simulation is not ready yet, please choose your start and end vertices")
            popup("The sim is not prepared yet, choose your markers", "Info", "INFO")
            return {'FINISHED'}

        headObj = sim.props['marker_head']
        tailObj = sim.props['marker_tail']
        txt = ""
        if headObj == "":
            txt = "Fatal error, head data missing\n"
        if tailObj == "":
            txt += "Fatal error, tail data missing\n"
        if txt != "":
            popup("Some data was missing so I can't continue, see console", "Error", "ERROR")
            return {'FINISHED'}

        head_loc = headObj.location.copy()
        tail_loc = tailObj.location.copy()

        head_vertex = sim.props['vertex_head'].index
        tail_vertex = sim.props['vertex_tail'].index

        state = utils.get_state()

        headObj.select_set(True)
        tailObj.select_set(True)
        utils.activate(tailObj)
        bpy.ops.object.delete()

        headObj = None
        tailObj = None

        sim.props['marker_head'] = ""
        sim.props['marker_tail'] = ""
        sim.props['marker_is_head'] = True
        sim.props['vertex_head'] = ""
        sim.props['vertex_tail'] = ""
        
        bm = sim.props['bmesh']
        if bm != "":
            bm.free()
        sim.props['bmesh'] = ""

        dObj = sim.get_director(checkObj)
        if dObj == False:
            print("No simulation object was in the set")
            popup("Missing simulation object so no actor either", "Error", "ERROR")
            return {'FINISHED'}
        aObj = dObj['bb_sim_actor']
        if aObj.name not in bpy.context.scene.objects:
            print("actor was removed", "Error", "ERROR")
            return {'FINISHED'}

        if bb_sim.sim_path == True:
            
            dObj.select_set(True)
            utils.activate(dObj)
            
            for f in dObj.data.polygons:
                f.select = False
            
            for e in dObj.data.edges:
                e.select = False
            
            for v in dObj.data.vertices:
                v.select = False

            pathObj = meshutils.freeze(
                object=dObj, copy=True)
            pathObj.name = "SIM_PATH_" + utils.get_temp_name()

            pathObj.data.vertices[head_vertex].select = True
            pathObj.data.vertices[tail_vertex].select = True

            bpy.ops.object.mode_set(mode='EDIT')
            
            alternate = False
            try:
                bpy.ops.mesh.vert_connect_path()
            except:
                print("Couldn't cut path, using a straight through method")
                
                alt_head_loc = pathObj.data.vertices[head_vertex].co.copy()
                alt_tail_loc = pathObj.data.vertices[tail_vertex].co.copy()
                alt_mw = pathObj.matrix_world.copy()
                alt_location = pathObj.location.copy()

                bpy.ops.object.mode_set(mode='OBJECT')
                bpy.ops.object.delete()
                alternate = True

            if alternate == True:
                popup("A surface path could not be determined, using a straight path instead", "Error", "ERROR")
                bpy.ops.mesh.primitive_plane_add(size=2, enter_editmode=False, align='WORLD', location=(0, 0, 0))
                pathObj = bpy.context.object
                pathObj.name = "SIM_PATH_ALT_" + utils.get_temp_name()

                for f in pathObj.data.polygons:
                    f.select = False
                
                for e in pathObj.data.edges:
                    e.select = False
                
                for v in pathObj.data.vertices:
                    v.select = False

                v1 = pathObj.data.vertices[0]
                v2 = pathObj.data.vertices[1]
                v1.select = True
                v2.select = True

                v1.co = head_loc
                v2.co = tail_loc

                v1.co = alt_head_loc
                v2.co = alt_tail_loc

                head_vertex = v1.index
                tail_vertex = v2.index

                bpy.ops.object.mode_set(mode='EDIT')
                bpy.ops.mesh.vert_connect_path()

            bpy.ops.mesh.select_mode(type='VERT')
            bpy.ops.mesh.select_all(action='INVERT')
            bpy.ops.mesh.delete(type='VERT')
            
            bpy.ops.object.mode_set(mode='OBJECT')

            bpy.ops.object.mode_set(mode='EDIT')
            bm = bmesh.from_edit_mesh( pathObj.data )
            bm.verts.ensure_lookup_table()

            if alternate == True:
                hid = head_vertex

            else:
                vert_id = bm.verts.layers.int.get('id')

                if vert_id == None:
                    print("Lost the vertex properties!")
                    popup("Fatal internal error, your setup is not stable after this error", "Error", "ERROR")
                    return {'FINISHED'}
                for v in bm.verts:
                    if bm.verts[v.index][vert_id] == head_vertex:
                        hid = v.index
                        print("Found head vertex in remaining mesh hid, head_vertex:", hid, head_vertex)

            path_length = 0
            for e in bm.edges:
                path_length += e.calc_length()
            bm.free()

            bpy.ops.object.mode_set(mode='OBJECT')

            edges = {}
            verts = {}
            for e in pathObj.data.edges:
                edges[e.index] = {}
                for v in e.vertices:
                    edges[e.index][v] = pathObj.data.vertices[v].co
            for e in edges:
                for v in edges[e]:
                    if v not in verts:
                        verts[v] = {}
                    verts[v][e] = ""
            
            for v in verts:
                if len(verts[v]) == 1:
                    print("vert:", v)
                    print(" - edges:", verts[v])
                    if v == hid:
                        start_vertex = v
                        start_edge = [ e for e in verts[v] ][0]
                        print("start_vertex / start_edge:", start_vertex, "/", start_edge)
                    else:
                        end_vertex = v
                        end_edge = [ e for e in verts[v] ][0]
                        print("end_vertex / end_edge:", end_vertex, "/", end_edge)

            last_vertex = start_vertex
            
            bpy.ops.object.duplicate()
            curveObj = bpy.context.object
            curveObj.name = "SIM_CURVE_" + utils.get_temp_name()

            bpy.ops.object.convert(target='CURVE')
            bpy.ops.object.mode_set(mode='EDIT')
            p_zero = False
            for p in curveObj.data.splines[0].points:
                if p_zero == False:
                    p_zero = True
                    p.select = False
                else:
                    p.select = True
            
            bpy.ops.curve.delete(type='VERT')
            bpy.ops.object.mode_set(mode='OBJECT')

            co = [f for f in pathObj.data.vertices[start_vertex].co]
            curveObj.data.splines[0].points[0].co = (co + [0.0])

            def get_next_vertex(object, vertex, previous):
                for e in object.data.edges:
                    vertices = set([v for v in e.vertices])
                    if previous in vertices:
                        continue
                    if vertex in vertices:
                        if   vertex == e.vertices[0]:
                           return e.vertices[1]
                        elif vertex == e.vertices[1]:
                           return e.vertices[0]
                print("Fallthrough, no data found for vertex:", vertex)
                return None

            previous_vertex = None
            while True:
                
                v = get_next_vertex(pathObj, last_vertex, previous_vertex)
                if v == None: 
                    print(
                        "Internal vertex search error, pathObj.name:",
                        pathObj.name, "last_vertex:", last_vertex,
                        "previous_vertex:", previous_vertex)
                    popup("Fatal error when searching for vertices, see console", "Error", "ERROR")
                    return {'FINISHED'}
                previous_vertex = last_vertex
                last_vertex = v
                
                curveObj.data.splines[0].points.add(1)
                co = [f for f in pathObj.data.vertices[v].co]
                curveObj.data.splines[0].points[-1].co = (co + [0.0])

                if last_vertex == end_vertex:
                    print("break normal")
                    break

            locObj = sim.add_locator()

            print(" * locator to curve using matrix, keep an eye on this")
            
            locObj.matrix_world = curveObj.matrix_world.copy()

            modArray = locObj.modifiers.new("SIM Array", 'ARRAY')
            modArray.use_relative_offset = False
            modArray.use_constant_offset = True
            modArray.fit_type = 'FIXED_COUNT'
            
            modArray.count = bb_sim.sim_path_count + 1

            if bb_sim.sim_path_extend == True:
                displace = path_length / (bb_sim.sim_path_count - 1)
            else:
                displace = path_length / (bb_sim.sim_path_count)

            modArray.constant_offset_displace[0] = displace

            modCurve = locObj.modifiers.new("SIM Curve", 'CURVE')
            modCurve.object = curveObj
            modCurve.deform_axis = 'POS_X'

            bpy.ops.object.modifier_apply(modifier=modArray.name)
            bpy.ops.object.modifier_apply(modifier=modCurve.name)

            bpy.ops.mesh.separate(type='LOOSE')
            bpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='MEDIAN')
            bpy.ops.object.mode_set(mode='OBJECT')

            selected = bpy.context.selected_objects

            dmw = dObj.matrix_world.copy()
            size = len(dObj.data.vertices)
            kd = mathutils.kdtree.KDTree(size)
            for v in dObj.data.vertices:
                v_co = dmw @ v.co
                kd.insert(v_co, v.index)
            kd.balance()

            heads = {}
            for o in selected:
                heads[o.name] = o.location.copy()
            
            tails = {}
            for i in range(len(selected)):
                o = selected[i]
                if o == selected[-1]:
                    
                    heads.pop(o.name, "")
                    break
                next_o = selected[i+1]
                
                limit = bb_sim.sim_path_limit
                tloc = next_o.location.lerp(heads[o.name], limit)
                tails[o.name] = tloc

            pathObj.select_set(True)
            curveObj.select_set(True)
            utils.activate(curveObj)
            bpy.ops.object.delete()

            bone_chain = []
            for hname in heads:
                hloc =  heads[hname]
                tloc = tails[hname]

                vertices = []
                if bb_sim.sim_path_radius == 0:
                    loc, index, dist = kd.find(hloc)  
                    vertices.append(index)
                else:
                    for loc, index, dist in kd.find_range(hloc, bb_sim.sim_path_radius):
                        vertices.append(index)
                
                if hloc == tloc:
                    print("This bone will fail, the head and tail locations are the same")
                result = sim.build_bone(actor=aObj.name, director=dObj.name, head=hloc, tail=tloc, vertices=vertices)
                if result == False:
                    print("Bone builder failed")
                    return {'FINISHED'}
                
                bone_chain.append(result)

            del kd

            if bb_sim.sim_path_parent == True:
                
                print("Parenting requested, the armature has", len(aObj.data.bones), "bones in it, linking...")
                print("UPDATE: linking only this branch of", len(bone_chain), "bones")
                print("MODE:", bpy.context.mode)
                print("SELECTED:", [o.name for o in bpy.context.selected_objects])
                print("ACTIVE:", bpy.context.active_object)
                aObj.select_set(True)
                utils.activate(aObj)
                bpy.ops.object.mode_set(mode='EDIT')
                parent_chain = []

                for pBone in bone_chain:
                    boneObj = aObj.data.edit_bones[pBone.name]
                    parent_chain.append(boneObj)

                parent_chain.reverse()
                parent_length = len(parent_chain)
                count = 0
                for boneObj in parent_chain:
                    
                    if boneObj == parent_chain[-1]:
                        break
                    boneObj.parent = parent_chain[count+1]
                    count += 1
                bpy.ops.object.mode_set(mode='OBJECT')
                aObj.select_set(False)
                utils.activate(None)
                
                if 1 == 0:
                    for boneObj in aObj.data.bones:
                        boneObj.use_local_location = False
                        boneObj.use_inherit_rotation = False
                        boneObj.inherit_scale = 'NONE'
                
                aObj['bb_sim_parent'] = True

        else:
            dObj.select_set(True)
            utils.activate(dObj)
            
            for f in dObj.data.polygons:
                f.select = False
            
            for e in dObj.data.edges:
                e.select = False
            
            for v in dObj.data.vertices:
                v.select = False

            pathObj = meshutils.freeze(
                object=dObj, copy=True)
            pathObj.name = "SIM_PATH_" + utils.get_temp_name()
 
            head_loc = pathObj.data.vertices[head_vertex].co.copy()
            tail_loc = pathObj.data.vertices[tail_vertex].co.copy()

            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.delete()

            sim.build_bone(actor=aObj.name, director=dObj.name, head=head_loc, tail=tail_loc, vertices=[head_vertex])

        dObj.select_set(True)
        utils.activate(dObj)
        bpy.ops.onigiri.sim_action_dynamic()

        return {'FINISHED'}

class OnigiriSimEditBones(bpy.types.Operator):
    """This is a convenient button in case you want to move bones or remove, or otherwise just
edit the armature manually.  If you choose this you'll be in edit armature mode and you will
have to return to action mode manually if you need it"""

    bl_idname = "onigiri.sim_edit_bones"
    bl_label = "Edit Bones"

    @classmethod
    def poll(cls, context):
        bb_sim = bpy.context.window_manager.bb_sim
        
        if bb_sim.sim_motion_object == True:
            return False
        if len(bpy.context.selected_objects) < 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.get('bb_sim_actor') == None and o.get('bb_sim_director') == None:
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        checkObj = bpy.context.selected_objects[0]

        if bpy.context.mode == 'EDIT_ARMATURE':
            dObj = sim.get_director(checkObj)
            if dObj == False:
                print("No director, not the right EDIT_ARMATURE")
                return {'FINISHED'}
            bpy.ops.object.mode_set(mode='OBJECT')
            
            bpy.ops.object.mode_set(mode='OBJECT')
            checkObj.select_set(False)
            dObj.select_set(True)
            utils.activate(dObj)
            bpy.ops.onigiri.sim_action_dynamic()
            return {'FINISHED'}

        state = utils.get_state()

        headObj = sim.props['marker_head']
        tailObj = sim.props['marker_tail']
        txt = ""
        if headObj != "":
            headObj.select_set(True)
            utils.activate(headObj)
        if tailObj != "":
            tailObj.select_set(True)
            utils.activate(tailObj)
        if len(bpy.context.selected_objects) > 0:
            bpy.ops.object.delete()

        dObj = sim.get_director(checkObj)
        if dObj == False:
            print("No director")
            popup("Not a valid set", "Error", "ERROR")
            return {'FINISHED'}

        sim.props['marker_head'] = ""
        sim.props['marker_tail'] = ""
        sim.props['marker_is_head'] = True
        bm = sim.props['bmesh']
        if bm != "":
            bm.free()
        sim.props['bmesh'] = ""
        
        sim.props['vertex_head'] = ""
        sim.props['vertex_tail'] = ""

        aObj = dObj['bb_sim_actor']
        if aObj.name not in bpy.context.scene.objects:
            print("actor was removed", "Error", "ERROR")
            return {'FINISHED'}

        aObj.select_set(True)
        utils.activate(aObj)
        bpy.ops.object.mode_set(mode='EDIT')

        return {'FINISHED'}

class OnigiriSimRigidCopy(bpy.types.Operator):
    """The active object recieves the rigid body properties when adjusted.  If you you have
mutliple objects selected, or you box select them after setting these properties, you
can use this button to copy those properties to the other objects"""

    bl_idname = "onigiri.sim_copy_rigid"
    bl_label = "Copy rigid sim"

    @classmethod
    def poll(cls, context):
        bb_sim = bpy.context.window_manager.bb_sim
        if bb_sim.sim_motion_object == False:
            return False
        return True

    def execute(self, context):
        
        try:
            bpy.ops.rigidbody.object_settings_copy()
            print("Sim rigid copied from active to selected")
        except:
            print("Rigid sim copy failed, did you add a simulation, is here an active object selected?")
            popup("Rigid copy failed", "Error", "ERROR")

        return {'FINISHED'}

class OnigiriSimRemoveAll(bpy.types.Operator):
    """Remove the simulation from the selected objects.  This could bring the system out of sync but
it allows you this as a bulk action for convenience.  It should be ok to use but it will remove
all sim influences that Onigiri knows about"""

    bl_idname = "onigiri.sim_remove_all"
    bl_label = "Remove all sims"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) == 0:
            return False
        if bpy.context.mode != 'OBJECT':
            return False
        return True

    def execute(self, context):
        selected = bpy.context.selected_objects
        state = utils.get_state()
        for o in selected:
            o.select_set(True)
            utils.activate(o)
            try:
                bpy.ops.rigidbody.objects_remove()
            except:
                print("Not a rigid body, maybe cloth?")

            for modObj in o.modifiers:
                if modObj.type == 'CLOTH' or modObj.type == 'SOFT_BODY':
                    o.modifiers.remove(modObj)

            o.select_set(False)

        utils.set_state(state)

        return {'FINISHED'}

class OnigiriSimReset(bpy.types.Operator):
    """Reset the stage"""

    bl_idname = "onigiri.sim_reset"
    bl_label = "Sim Reset"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        checkObj = bpy.context.selected_objects[0]

        state = utils.get_state()

        headObj = sim.props['marker_head']
        tailObj = sim.props['marker_tail']
        if headObj != "":
            try:
                if headObj.name in bpy.context.scene.objects:
                    headObj.select_set(True)
                    utils.activate(headObj)
            except:
                print("Head removed already")
        if tailObj != "":
            try:
                if tailObj.name in bpy.context.scene.objects:
                    tailObj.select_set(True)
                    utils.activate(tailObj)
            except:
                print("Tail removed already")

        sim.props['marker_nead'] = ""
        sim.props['marker_tail'] = ""

        dObj = sim.get_director(checkObj)
        if dObj == False:
            print("No director link for", checkObj.name)
            
            print("Cleaning up mesh just in case")
            checkObj.pop('bb_sim_director', "")
            checkObj.pop('bb_sim_actor', "")

        else:
            if isinstance(dObj, list):
                print("Got multiple directors")
                director_objects = dObj
            else:
                print("Got single director")
                director_objects = [dObj] 

            for dObj in director_objects:
                aObj = dObj.get('bb_sim_actor')
                dObj.pop('bb_sim_actor', "")
                if aObj != None:
                    if utils.is_valid(aObj):
                        
                        if aObj.get('bb_sim_manual') != None:
                            aObj.select_set(False)
                            aObj.pop('bb_sim_manual', "")
                        else:
                            aObj.select_set(True)
                        dObj.select_set(False)

                        groups = set([g.name for g in dObj.vertex_groups])
                        for boneObj in aObj.data.bones:
                            bone = boneObj.name
                            if bone in groups:
                                G = dObj.vertex_groups[bone]
                                dObj.vertex_groups.remove(G)

        if len(bpy.context.selected_objects) > 0:
            utils.activate(bpy.context.selected_objects[0])
            bpy.ops.object.delete()

        bm = sim.props['bmesh']
        if bm != "":
            bm.free()
        sim.props['bmesh'] = ""
        sim.props['vertex_head'] = ""
        sim.props['vertex_tail'] = ""

        if dObj != False:
            for o in director_objects:
                o.select_set(True)
                utils.activate(director_objects[0])

        else:
            if checkObj.name in bpy.context.scene.objects:
                checkObj.select_set(True)
                utils.activate(checkObj)

        armObj = sim.get_actor(checkObj)
        if armObj == False:
            print("No custom actor available, no problem")
        else:
            sim.props.pop('custom_rig', "")
            sim.props.pop('custom_bones', "")
            sim.props.pop('custom_mesh', "")
            mesh = armObj.pop('custom_mesh', [])
            for meshObj in mesh:
                
                meshObj.parent = None
                if utils.is_valid(meshObj):
                    mods = meshObj.pop('sim_custom_mods', [])
                    if len(mods) > 0:
                        for m in mods:
                            if m in meshObj.modifiers:
                                meshObj.modifiers[m].show_viewport = mods[m]['show_viewport']
                                meshObj.modifiers[m].show_render = mods[m]['show_render']
        
        return {'FINISHED'}

class OnigiriSimStretchAdd(bpy.types.Operator):
    """
Apply stretch property from the selected bone up the chain to the just before the last selected
parent.  This last parent bone is left free for you to manipulate or you won't be able to manipulate
the bone for the effect.  To include this last parent use (Include Anchor)"""

    bl_idname = "onigiri.sim_stretch_add"
    bl_label = "Add stretch"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        armObj = bpy.context.selected_objects[0]

        selected_bones = bpy.context.selected_pose_bones
        bone_list = [b.name for b in selected_bones]
        bone_names = set(bone_list)

        for boneObj in selected_bones:
            cname = boneObj.get('bb_sim_stretch')
            if cname != None:
                for C in boneObj.constraints:
                    if C.name == cname:
                        boneObj.constraints.remove(C)

        bpy.ops.object.mode_set(mode='EDIT')
        for boneObj in armObj.data.edit_bones:
            boneObj.use_connect = False
        bpy.ops.object.mode_set(mode='POSE')

        anchor = None
        for boneObj in selected_bones:
            
            if boneObj.parent:
                parent = boneObj.parent.name
                
                if bb_sim.sim_deformable == True:
                    if boneObj.bone.use_deform == False:
                        continue
                
                if bb_sim.sim_anchor == False:
                    if parent not in bone_names:
                        
                        print("Found end:", parent)
                        anchor = boneObj.name
                        continue
                armObj.data.bones.active = boneObj.bone
                bc = boneObj.constraints
                conObj = bc.new('COPY_LOCATION')
                conObj.name = "LOC Stretch"
                cname = conObj.name 
                conObj.target = armObj
                conObj.subtarget = parent
                conObj.target_space = 'LOCAL'
                conObj.owner_space = 'LOCAL'
                conObj.influence = 1
                boneObj['bb_sim_stretch'] = cname

        if anchor != None:
            armObj.data.bones.active = armObj.data.bones[anchor]

        return {'FINISHED'}

class OnigiriSimStretchRemove(bpy.types.Operator):
    """This removes the stretch property from the selected bones"""

    bl_idname = "onigiri.sim_stretch_remove"
    bl_label = "Remove stretch"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        armObj = bpy.context.selected_objects[0]
        selected_bones = bpy.context.selected_pose_bones

        for boneObj in selected_bones:
            cname = boneObj.get('bb_sim_stretch')
            if cname != None:
                for C in boneObj.constraints:
                    if C.name == cname:
                        boneObj.constraints.remove(C)

        return {'FINISHED'}

class OnigiriSimCurlAdd(bpy.types.Operator):
    """Add a curl property the the selected bones.  This is useful for influencing child bones
like those of a finger, when bending a base the remaining parts of the figner will curl, rotate"""

    bl_idname = "onigiri.sim_curl_add"
    bl_label = "Add curl"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        armObj = bpy.context.selected_objects[0]

        selected_bones = bpy.context.selected_pose_bones
        bone_list = [b.name for b in selected_bones]
        bone_names = set(bone_list)

        for boneObj in selected_bones:
            cname = boneObj.get('bb_sim_curl')
            if cname != None:
                for C in boneObj.constraints:
                    if C.name == cname:
                        boneObj.constraints.remove(C)
        anchor = None
        for boneObj in selected_bones:
            
            if boneObj.parent:
                parent = boneObj.parent.name
                
                if bb_sim.sim_deformable == True:
                    if boneObj.bone.use_deform == False:
                        continue
                if bb_sim.sim_anchor == False:
                    if parent not in bone_names:
                        
                        anchor = boneObj.name
                        continue
                armObj.data.bones.active = boneObj.bone
                bc = boneObj.constraints
                conObj = bc.new('COPY_TRANSFORMS')
                conObj.name = "LOC Curl"
                cname = conObj.name 
                conObj.target = armObj
                conObj.subtarget = parent
                conObj.target_space = 'LOCAL'
                conObj.owner_space = 'LOCAL'
                conObj.mix_mode = 'AFTER'
                conObj.influence = 1
                boneObj['bb_sim_curl'] = cname

        if anchor != None:
            armObj.data.bones.active = armObj.data.bones[anchor]

        return {'FINISHED'}

class OnigiriSimCurlRemove(bpy.types.Operator):
    """This removes the stretch property from the selected bones"""

    bl_idname = "onigiri.sim_curl_remove"
    bl_label = "Remove curl"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        armObj = bpy.context.selected_objects[0]
        selected_bones = bpy.context.selected_pose_bones

        for boneObj in selected_bones:
            cname = boneObj.get('bb_sim_curl')
            if cname != None:
                for C in boneObj.constraints:
                    if C.name == cname:
                        boneObj.constraints.remove(C)

        return {'FINISHED'}

class OnigiriIK(bpy.types.Operator):
    """Set a simple IK controller on the selected pose bone.  Use the chain length property to
adjust influence of additional bones"""

    bl_idname = "onigiri.sim_ik"
    bl_label = "Set as IK"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) != 1:
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        armObj = bpy.context.selected_objects[0]
        cBone = bpy.context.selected_pose_bones[0]

        cname = cBone.get('bb_sim_controller')
        if cname != None:
            for C in cBone.constraints:
                if C.type == 'IK':
                    if C.name == cname:
                        cBone.constraints.remove(C)

        if 1 == 0:
            chain = 0
            boneObj = cBone
            while True:
                if boneObj.parent:
                    chain += 1
                    boneObj = boneObj.parent
                
                else:
                    if boneObj.bone.use_deform == True:
                        chain += 1
                    break

        armObj.data.bones.active = cBone.bone
        bc = cBone.constraints
        conObj = bc.new('IK')
        conObj.name = "BB IK Controller"
        cname = conObj.name 
        conObj.influence = 1
        cBone['bb_sim_controller'] = cname
        conObj.chain_count = bb_sim.sim_controller_length
        
        for boneObj in armObj.data.bones:
            boneObj.select = False

        cBone.bone.select = True
        armObj.data.bones.active = cBone.bone

        return {'FINISHED'}

class OnigiriIKNuke(bpy.types.Operator):
    """This will remove all of the IK controllers from the selected pose bones placed
by this tool, only this tool, all of your custom manually added controller, or
from other sources, will not be touched"""

    bl_idname = "onigiri.sim_ik_nuke"
    bl_label = "Set as IK"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        armObj = bpy.context.selected_objects[0]
        selected_bones = bpy.context.selected_pose_bones

        for boneObj in selected_bones:
            cname = boneObj.get('bb_sim_controller')
            if cname != None:
                for C in boneObj.constraints:
                    if C.type == 'IK':
                        if C.name == cname:
                            boneObj.constraints.remove(C)
                            del boneObj['bb_sim_controller']

        return {'FINISHED'}

class OnigiriSimKey(bpy.types.Operator):
    """Key the selected bones.  This is not a normal Blender key set.  Blender will not see the
transforms set by the controllers that you've used here (Stretch/Curl) but this key operator
will.  This is for advanced fine tuning motion"""

    bl_idname = "onigiri.sim_key"
    bl_label = "Key selected bones"

    @classmethod
    def poll(cls, context):
        if len(bpy.context.selected_objects) != 1:
            return False
        o = bpy.context.selected_objects[0]
        if o.type != 'ARMATURE':
            return False
        if bpy.context.mode != 'POSE':
            return False
        if len(bpy.context.selected_pose_bones) == 0:
            return False
        return True

    def execute(self, context):
        bb_sim = bpy.context.window_manager.bb_sim
        armObj = bpy.context.selected_objects[0]
        selected_bones = bpy.context.selected_pose_bones

        bpy.context.view_layer.update()

        frame_current = bpy.context.scene.frame_current

        if armObj.animation_data == None:
            armObj.animation_data_create()
        if armObj.animation_data.action == None:
            armObj.animation_data_create()

        for boneObj in selected_bones:

            mat = boneObj.matrix.copy()
            boneObj.matrix = mat
            pmat = boneObj.matrix_basis.copy()
            boneObj.matrix_basis = pmat

            if bb_sim.sim_key_rotation == True:
                rotation_mode = boneObj.rotation_mode
                if rotation_mode == 'QUATERNION':
                    rmode = 'rotation_quaternion'
                else:
                    rmode = 'rotation_euler'
                boneObj.keyframe_insert(data_path=rmode, frame=frame_current)
            if bb_sim.sim_key_location == True:
                boneObj.keyframe_insert(data_path='location', frame=frame_current)
            if bb_sim.sim_key_scale == True:
                boneObj.keyframe_insert(data_path='scale', frame=frame_current)

        if bb_sim.sim_controller == True:
            bone = sim.props['controller']
            if bone in armObj.data.bones:
                for boneObj in selected_bones:
                    boneObj.bone.select = False
                armObj.data.bones[bone].select = True

        return {'FINISHED'}

class OnigiriInfoPanel(bpy.types.Panel):
    """Onigiri Info"""
    bl_idname = "OBJECT_PT_bento_buddy_info"
    bl_label = "Onigiri Info"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        ccp = bpy.context.window_manager.cc_props
        bbm = bpy.context.window_manager.bb_misc
        brp = bpy.context.window_manager.bb_rigprops
        bbt = bpy.context.window_manager.bb_test

        row = self.layout.row(align=True)
        row.separator()
        row.label(
            text = "Blender Version: " + bpy.app.version_string
            )

        row = self.layout.row(align=True)
        row.separator()
        row.label(
            text = "Onigiri Version: " + str(bl_info['version'])
            )
        if len(bpy.context.selected_objects) == 1:
            if bpy.context.selected_objects[0].get('onigiri') != None:
                bb_rig_class = bpy.context.object.get('rig_class', "None")
                bb_rig_version = bpy.context.object.get('onigiri')
                if bb_rig_version == None:
                    bb_rig_version = ("Unknown")
                else:
                    bb_rig_version = tuple(bb_rig_version.to_list())
                
                row = self.layout.row(align=True)
                row.separator()
                row.label(
                    text = "Rig Class: " + bb_rig_class,
                    icon_value = ico.custom_icons["dot_white"].icon_id
                    )
                row = self.layout.row(align=True)
                row.separator()
                row.label(
                    text = "Rig Version: " + str(bb_rig_version),
                    icon_value = ico.custom_icons["dot_white"].icon_id
                    )

        row = self.layout.row(align=True)
        row.operator("wm.url_open", text="Onigiri Help System").url = "http://critters.xyz/help/onigiri"
        row = self.layout.row(align=True)
        row.operator("wm.url_open", text="Join Discord Server").url = "http://critters.xyz/discord"

class OnigiriPanelBind(bpy.types.Panel):
    """This is bind tools"""
    bl_idname = "OBJECT_PT_bento_buddy_bind"
    bl_label = "Bind Tools"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        bb = bpy.context.scene.onigiri 
        bbm = bpy.context.window_manager.bb_misc
        obj = bpy.data.objects
        selected = bpy.context.selected_objects
        
        layout = self.layout
        box = layout.box()

        col = box.column(align = True)
        row = col.row(align=True)

        row.prop(
            bbm,
            "enable_bind_data",
            toggle=True,
            text = "Show / Hide Bind Options",
            icon_value = ico.custom_icons["glue"].icon_id
            )

        if bbm.enable_bind_data == False:
            row = col.row(align=True)
            row.label(
                text="Manipulate Bind Info Data - !",
                )
            row = col.row(align=True)
            row.label(
                text="This tool is not usually useful,",
                )
            row = col.row(align=True)
            row.label(
                text="if you have bind data on your rig",
                )
            row = col.row(align=True)
            row.label(
                text="you may need to remove it before",
                )
            row = col.row(align=True)
            row.label(
                text="you export your mesh to SL or",
                )
            row = col.row(align=True)
            row.label(
                text="you may get deformities.",
                )
            row = col.row(align=True)
            row.label(
                text="This may no longer be useful but",
                )
            row = col.row(align=True)
            row.label(
                text="it cleans up the useless bind info",
                )
            row = col.row(align=True)

        if bbm.enable_bind_data == True:
            col = box.column(align = True)

            bind_data_loc_icon = "dot_red"
            bind_data_rot_icon = "dot_red"
            bind_data_scl_icon = "dot_red"
            bind_data_action_loc = "add"
            bind_data_action_rot = "add"
            bind_data_action_scl = "add"

            selected = bpy.context.selected_objects
            if len(selected) == 1:
                armObj = selected[0]
                if armObj.type == 'ARMATURE':
                    
                    if armObj.data.bones[0].get('restpose_loc_x') != None:
                        bind_data_action_loc = "del"
                        bind_data_loc_icon = "dot_green"
                    if armObj.data.bones[0].get('restpose_rot_x') != None:
                        bind_data_action_rot = "del"
                        bind_data_rot_icon = "dot_green"
                    if armObj.data.bones[0].get('restpose_scale_x') != None:
                        bind_data_action_scl = "del"
                        bind_data_scl_icon = "dot_green"
            row = col.row(align=True)
            row.prop(
                bb,
                "blank",
                toggle=True,
                text = "Bind Data add / del",
                )
            row = col.row(align=True)

            bind_data_loc = row.operator(
                "onigiri.bind_data",
                text="Location",
                icon_value = ico.custom_icons[bind_data_loc_icon].icon_id
                )
            bind_data_loc.action = bind_data_action_loc
            bind_data_loc.transform = "loc"

            bind_data_rot = row.operator(
                "onigiri.bind_data",
                text="Rotation",
                icon_value = ico.custom_icons[bind_data_rot_icon].icon_id
                )
            bind_data_rot.action = bind_data_action_rot
            bind_data_rot.transform = "rot"

            bind_data_scl = row.operator(
                "onigiri.bind_data",
                text="Scale",
                icon_value = ico.custom_icons[bind_data_scl_icon].icon_id
                )
            bind_data_scl.action = bind_data_action_scl
            bind_data_scl.transform = "scl"

            row = col.row(align=True)

            col = box.column(align = True)
            row = col.row(align=True)
            row.operator(
                "onigiri.bind_info",
                text="Set All To 0",
                ).action = "set_0"
            row.operator(
                "onigiri.bind_info",
                text="Set All To 1",
                ).action = "set_1"
            row = col.row(align=True)

            row.operator(
                "onigiri.bind_info",
                text="Scale PBones ",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "scale_vbones_pbones"
            row.operator(
                "onigiri.bind_info",
                text="Scale EBones ",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "scale_vbones_ebones"

            row = col.row(align=True)
            row.operator(
                "onigiri.bind_info",
                text="Save Bind Data",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "save_bind_data"
            row = col.row(align=True)
            row.operator(
                "onigiri.bind_info",
                text="Load Bind Data",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "load_bind_data"

            row = col.row(align=True)
            row.operator(
                "onigiri.bind_info",
                text="Remove Bind Info",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "remove"
            row = col.row(align=True)
            row.operator(
                "onigiri.bind_info",
                text="Remove Bind Matrix",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "remove_bind_matrix"
            row = col.row(align=True)
            row.operator(
                "onigiri.bind_info",
                text="Remove Rest Matrix",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "remove_rest_matrix"
            row = col.row(align=True)
            if bbm.get('bind_info') == None:
                bind_copy_buffer = "blank"
            else:
                bind_copy_buffer = "thumb_up"
            row.operator(
                "onigiri.bind_info",
                text="Copy Bind Info",
                icon_value = ico.custom_icons[bind_copy_buffer].icon_id
                ).action = "copy"
            row = col.row(align=True)
            row.operator(
                "onigiri.bind_info",
                text="Paste Bind Info",
                icon_value = ico.custom_icons["blank"].icon_id
                ).action = "paste"

class OnigiriPanelAdvanced(bpy.types.Panel):
    """This is rig tools"""
    bl_idname = "OBJECT_PT_bento_buddy_advanced"
    bl_label = "Advanced Tools"
    bl_space_type = "VIEW_3D"
    bl_category = "Onigiri"
    bl_region_type = "UI"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        obj = bpy.data.objects
        selected = bpy.context.selected_objects
        bbm = bpy.context.window_manager.bb_misc
        brp = bpy.context.window_manager.bb_rigprops
        anim_advanced = bpy.context.scene.bb_anim_advanced

        if 1 == 0:
            
            layout = self.layout
            row = layout.row(align=True)
            row.prop(
                anim_advanced,
                "disable_axis_conversion",
                text="Disable Axis Conversion",
                toggle = True,
                )

            row = layout.row(align=True)
            row.prop(
                anim_advanced,
                "disable_joint_offsets",
                text="Disable Joint Offsets",
                toggle = True,
                )
            
            ajd = bpy.context.window_manager.bb_joint_data
            if ajd.joint_data_enabled == True:
                menu_state = "menu_opened"
            else:
                menu_state = "menu_closed"

            layout = self.layout
            row = layout.row(align=True)
     
            if len(bpy.context.selected_objects) == 0:
                ajd.joint_data_enabled = False
            elif len(bpy.context.selected_objects) > 1:
                ajd.joint_data_enabled = False
            if len(bpy.context.selected_objects) == 1:
                if ajd.joint_data_enabled_override != True:
                    if bpy.context.selected_objects[0].get('onigiri') == None:
                        ajd.joint_data_enabled = False

            row.prop(
                ajd,
                "joint_data_enabled_override",
                text = "",
                toggle = True,
                icon_value = ico.custom_icons[menu_state].icon_id
                )
            row.prop(
                ajd,
                "joint_data_enabled",
                text = "Alter Joint Data",
                toggle = True,
    
                )

            if ajd.joint_data_enabled == True:

                box = layout.box()
                col = box.column(align = True)
                row = col.row(align=True)

                row.operator(
                    "onigiri.save_joint_data",
                    text= "Save Joint Data",
                    icon_value = ico.custom_icons['save'].icon_id
                    )
                row.operator(
                    "onigiri.load_joint_data",
                    text= "Load Joint Data",
                    icon_value = ico.custom_icons['load'].icon_id
                    )

                if selected_pose_bones() == 1:
                    selected_bone = bpy.context.selected_pose_bones[0].name
                    ad = axis_defs
                    idef = icon_defs
                    jd = joint_data
                    
                    for icon_axis in idef.icon_defs:
                        idef.icon_defs[icon_axis]['icon'] = idef.icon_choice_off
                    for icon_axis in jd.joint_data[selected_bone]:
                        if icon_axis.endswith("angle"):
                            x,y,z = jd.joint_data[selected_bone][icon_axis]
                            axis  = str(idef.ICON_AXIS[x])
                            axis += str(idef.ICON_AXIS[y])
                            axis += str(idef.ICON_AXIS[z])
                            icon_axis += '_' + axis
                            idef.icon_defs[icon_axis]['icon'] = idef.icon_choice_on
                            
                col = box.column(align = True)
                row = col.row(align=True)
                box.label(
                    text = "Location Axis Angle:",
                    )
                ad = axis_defs
                idef = icon_defs
                col = box.column(align = True)
                
                row = col.row(align=True)
                row.operator(
                    "onigiri.set_joint_data",
                    text = "XYZ",
                    icon_value = ico.custom_icons[idef.icon_defs['loc_axis_angle_xyz']['icon']].icon_id,
                    ).action = "loc_axis_angle_xyz"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "XZY",
                    icon_value = ico.custom_icons[idef.icon_defs['loc_axis_angle_xzy']['icon']].icon_id,
                    ).action = "loc_axis_angle_xzy"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "YZX",
                    icon_value = ico.custom_icons[idef.icon_defs['loc_axis_angle_yzx']['icon']].icon_id,
                    ).action = "loc_axis_angle_yzx"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "YXZ",
                    icon_value = ico.custom_icons[idef.icon_defs['loc_axis_angle_yxz']['icon']].icon_id,
                    ).action = "loc_axis_angle_yxz"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "ZXY",
                    icon_value = ico.custom_icons[idef.icon_defs['loc_axis_angle_zxy']['icon']].icon_id,
                    ).action = "loc_axis_angle_zxy"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "ZYX",
                    icon_value = ico.custom_icons[idef.icon_defs['loc_axis_angle_zyx']['icon']].icon_id,
                    ).action = "loc_axis_angle_zyx"
                row = col.row(align=True)
                row.prop(
                    ajd,
                    "loc_axis_inverted_x",
                    text = "Invert X",
                    toggle = True
                    )
                row.prop(
                    ajd,
                    "loc_axis_inverted_y",
                    text = "Invert Y",
                    toggle = True
                    )
                row.prop(
                    ajd,
                    "loc_axis_inverted_z",
                    text = "Invert Z",
                    toggle = True
                    )
                col = box.column(align = True)
                row = col.row(align=True)
                box.label(
                    text = "Location Offset Angle:",
                    )
                col = box.column(align = True)
                
                row = col.row(align=True)
                row.operator(
                    "onigiri.set_joint_data",
                    text = "XYZ",
                    icon_value = ico.custom_icons[idef.icon_defs['loc_offset_angle_xyz']['icon']].icon_id,
                    ).action = "loc_offset_angle_xyz"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "XZY",
                    icon_value = ico.custom_icons[idef.icon_defs['loc_offset_angle_xzy']['icon']].icon_id,
                    ).action = "loc_offset_angle_xzy"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "YZX",
                    icon_value = ico.custom_icons[idef.icon_defs['loc_offset_angle_yzx']['icon']].icon_id,
                    ).action = "loc_offset_angle_yzx"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "YXZ",
                    icon_value = ico.custom_icons[idef.icon_defs['loc_offset_angle_yxz']['icon']].icon_id,
                    ).action = "loc_offset_angle_yxz"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "ZXY",
                    icon_value = ico.custom_icons[idef.icon_defs['loc_offset_angle_zxy']['icon']].icon_id,
                    ).action = "loc_offset_angle_zxy"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "ZYX",
                    icon_value = ico.custom_icons[idef.icon_defs['loc_offset_angle_zyx']['icon']].icon_id,
                    ).action = "loc_offset_angle_zyx"
                row = col.row(align=True)
                row.prop(
                    ajd,
                    "loc_offset_inverted_x",
                    text = "Invert X",
                    toggle = True
                    )
                row.prop(
                    ajd,
                    "loc_offset_inverted_y",
                    text = "Invert Y",
                    toggle = True
                    )
                row.prop(
                    ajd,
                    "loc_offset_inverted_z",
                    text = "Invert Z",
                    toggle = True
                    )
                col = box.column(align = True)
                row = col.row(align=True)
                box.label(
                    text = "Rotation Axis Angle:",
                    )
                col = box.column(align = True)
                row = col.row(align=True)
                row.operator(
                    "onigiri.set_joint_data",
                    text = "XYZ",
                    icon_value = ico.custom_icons[idef.icon_defs['rot_axis_angle_xyz']['icon']].icon_id,
                    ).action = "rot_axis_angle_xyz"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "XZY",
                    icon_value = ico.custom_icons[idef.icon_defs['rot_axis_angle_xzy']['icon']].icon_id,
                    ).action = "rot_axis_angle_xzy"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "YZX",
                    icon_value = ico.custom_icons[idef.icon_defs['rot_axis_angle_yzx']['icon']].icon_id,
                    ).action = "rot_axis_angle_yzx"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "YXZ",
                    icon_value = ico.custom_icons[idef.icon_defs['rot_axis_angle_yxz']['icon']].icon_id,
                    ).action = "rot_axis_angle_yxz"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "ZXY",
                    icon_value = ico.custom_icons[idef.icon_defs['rot_axis_angle_zxy']['icon']].icon_id,
                    ).action = "rot_axis_angle_zxy"
                row.operator(
                    "onigiri.set_joint_data",
                    text = "ZYX",
                    icon_value = ico.custom_icons[idef.icon_defs['rot_axis_angle_zyx']['icon']].icon_id,
                    ).action = "rot_axis_angle_zyx"
                row = col.row(align=True)
                row.prop(
                    ajd,
                    "rot_axis_inverted_x",
                    text = "Invert X",
                    toggle = True
                    )
                row.prop(
                    ajd,
                    "rot_axis_inverted_y",
                    text = "Invert Y",
                    toggle = True
                    )
                row.prop(
                    ajd,
                    "rot_axis_inverted_z",
                    text = "Invert Z",
                    toggle = True
                    )

                jd = joint_data

                col = box.column(align = True)
                row = col.row(align=True)

                row.label(
                    text = "Use alternate bone data:",
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.copy_joint_data",
                    text = "Add",
                    ).action = "add"
                row.operator(
                    "onigiri.copy_joint_data",
                    text = "Remove",
                    ).action = "remove"
                row.operator(
                    "onigiri.copy_joint_data",
                    text = "Clear",
                    ).action = "clear"

                row.scale_x = 2.0
                row.prop(
                    ajd,
                    "copy_joint_data_name",
                    text = "",
                    toggle = True,
                    icon_value = ico.custom_icons[ajd.on_state].icon_id
                    )
                col = box.column(align = True)
                row = col.row(align=True)
                row.operator(
                    "onigiri.copy_joint_buffer",
                    text = "Copy Buffer",
                    )

                for bone in jd.copy_buffer:
                    col = box.column(align = True)
                    row = col.row(align=True)
                    row.operator(
                        "onigiri.paste_joint_buffer",
                        text = "Paste",
                        ).bone = bone
                    row.label(
                        text = "[ " + bone + " ]",
                        )
                    row.scale_y = 0.75
                    row.operator(
                        "onigiri.remove_joint_buffer",
                        text = "",
                        icon_value = ico.custom_icons["x"].icon_id
                        ).bone = bone

                col = box.column(align = True)
                row = col.row(align=True)

                row = col.row(align=True)
                row.prop(
                    ajd,
                    "joint_locked",
                    text = "Disable Editing (lock)",
                    toggle = True,
                    icon_value = ico.custom_icons["thumb_down"].icon_id
                    )

        layout = self.layout
        box = layout.box()
        box.label(
            text = "Select Difficult Bones:",
            )
        col = box.column(align = True)
        row = col.row(align=True)
        row.operator(
            "onigiri.select_bone",
            text="mPelvis",
            ).bone = "mPelvis"
        row.operator(
            "onigiri.select_bone",
            text="mSpine1",
            ).bone = "mSpine1"
        row.operator(
            "onigiri.select_bone",
            text="mSpine2",
            ).bone = "mSpine2"
        row = col.row(align=True)
        row.operator(
            "onigiri.select_bone",
            text="mTorso",
            ).bone = "mTorso"
        row.operator(
            "onigiri.select_bone",
            text="mSpine3",
            ).bone = "mSpine3"
        row.operator(
            "onigiri.select_bone",
            text="mSpine4",
            ).bone = "mSpine4"
        row = col.row(align=True)
        row.operator(
            "onigiri.select_bone",
            text="mChest",
            ).bone = "mChest"
        row.operator(
            "onigiri.select_bone",
            text="mCollarLeft",
            ).bone = "mCollarLeft"
        row.operator(
            "onigiri.select_bone",
            text="mCollarRight",
            ).bone = "mCollarRight"
        row = col.row(align=True)
        row.operator(
            "onigiri.select_bone",
            text="mEyeRight",
            ).bone = "mEyeRight"
        row.operator(
            "onigiri.select_bone",
            text="mEyeLeft",
            ).bone = "mEyeLEft"
        row = col.row(align=True)
        row.operator(
            "onigiri.select_bone",
            text="mFaceEyeAltRight",
            ).bone = "mFaceEyeAltRight"
        row.operator(
            "onigiri.select_bone",
            text="mFaceEyeAltLeft",
            ).bone = "mFaceEyeAltLeft"

        if 1 == 0:
            layout = self.layout
            box = layout.box()
            box.label(
                text = "Alter the bone orientation:",
                )
            if anim_advanced.matrix_converter_enabled == True:
                menu_state = "menu_opened"
            else:
                menu_state = "menu_closed"

            col = box.column(align = True)
            row = col.row(align=True)
            row.prop(
                anim_advanced,
                "matrix_converter_enabled",
                text = "Modify Animated Joint Orientation",
                toggle = True,
                icon_value = ico.custom_icons[menu_state].icon_id
                )
            if anim_advanced.matrix_converter_enabled == True:
                
                row = col.row(align=True)
                row.label(
                    text = "From Forward: " + anim_advanced.ac_from_forward_axis,
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="+X",
                    ).axis = "from_forward_pos_x"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="+Y",
                    ).axis = "from_forward_pos_y"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="+Z",
                    ).axis = "from_forward_pos_z"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="-X",
                    ).axis = "from_forward_neg_x"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="-Y",
                    ).axis = "from_forward_neg_y"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="-Z",
                    ).axis = "from_forward_neg_z"
                
                row = col.row(align=True)
                row.label(
                    text = "From Up: " + anim_advanced.ac_from_up_axis,
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="+X",
                    ).axis = "from_up_pos_x"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="+Y",
                    ).axis = "from_up_pos_y"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="+Z",
                    ).axis = "from_up_pos_z"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="-X",
                    ).axis = "from_up_neg_x"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="-Y",
                    ).axis = "from_up_neg_y"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="-Z",
                    ).axis = "from_up_neg_z"
                
                row = col.row(align=True)
                row.label(
                    text = "To Forward: " + anim_advanced.ac_to_forward_axis,
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="+X",
                    ).axis = "to_forward_pos_x"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="+Y",
                    ).axis = "to_forward_pos_y"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="+Z",
                    ).axis = "to_forward_pos_z"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="-X",
                    ).axis = "to_forward_neg_x"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="-Y",
                    ).axis = "to_forward_neg_y"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="-Z",
                    ).axis = "to_forward_neg_z"
                
                row = col.row(align=True)
                row.label(
                    text = "To Up: " + anim_advanced.ac_to_up_axis,
                    )
                row = col.row(align=True)
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="+X",
                    ).axis = "to_up_pos_x"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="+Y",
                    ).axis = "to_up_pos_y"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="+Z",
                    ).axis = "to_up_pos_z"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="-X",
                    ).axis = "to_up_neg_x"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="-Y",
                    ).axis = "to_up_neg_y"
                row.operator(
                    "onigiri.anim_convert_axis",
                    text="-Z",
                    ).axis = "to_up_neg_z"
        
        row = self.layout.row(align=True)
        row.operator(
            "onigiri.snap_nuke",
            text = "Nuke Influences",
            icon_value = ico.custom_icons["nuke"].icon_id
            )
        
        row = self.layout.row(align=True)
        row.operator(
            "onigiri.save_bone_matrices",
            text="Save Bone Matrices",
            )
        row = self.layout.row(align=True)
        row.operator(
            "onigiri.load_bone_orientation",
            text="Load Orientation To Armature",
            )
        row = self.layout.row(align=True)
        row.operator(
            "onigiri.match_bone_orientation",
            text="Match Bone Orientation",
            )
        row = self.layout.row(align=True)
        row.operator(
            "onigiri.reset_bone_roll",
            text="Reset Bone Roll",

            )

        row = self.layout.row(align=True)

        row.operator(
            "onigiri.refresh_blender",
            text="Refresh Blender File",
            icon_value = ico.custom_icons["reset"].icon_id
            )
        
        row = self.layout.row(align=True)
        
        bba = bpy.context.scene.bb_anim

        layout = self.layout

        if bba.bvh_menu_enabled == True:
            bvh_menu_enabled_icon = "menu_opened"
        else:
            bvh_menu_enabled_icon = "menu_closed"

        row.prop(
            bba,
            "bvh_menu_enabled",
            text = "BVH / XML Tools",
            toggle = True,
            icon_value = ico.custom_icons[bvh_menu_enabled_icon].icon_id
            )

        if bba.bvh_menu_enabled == True:
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)

            row.prop(
                bba,
                "bvh_type_sl_os",
                text = "BVH for SL / OS",
                toggle = True,
                )
            row.prop(
                bba,
                "bvh_type_other",
                text = "BVH for Other",
                toggle = True,
                )
            row = col.row(align=True)
            row.operator(
                "onigiri.rig_to_xml",
                text="Rig / Animation to XML",
                icon_value = ico.custom_icons["save"].icon_id
                )

            col = box.column(align = True)
            row = col.row(align=True)
            row.label(
                text = "Convert BVH to / from XML: " + bba.bvh_import_name,
                )

            row = col.row(align=True)
            row.operator(
                "onigiri.import_bvh",
                text="Open BVH or XML",
                icon_value = ico.custom_icons["load"].icon_id
                )

            row.operator(
                "onigiri.export_bvh_to_xml",
                text="Save BVH to XML",
                icon_value = ico.custom_icons["save"].icon_id
                )
            row.operator(
                "onigiri.export_bvh_to_bvh",
                text="Save XML To BVH",
                icon_value = ico.custom_icons["save"].icon_id
                )

        layout = self.layout
        row = self.layout.row(align=True)

        bb_misc = bpy.context.window_manager.bb_misc
        object_props_menu_enabled_icon = "menu_closed"
        if bb_misc.object_props_menu_enabled == True:
            object_props_menu_enabled_icon = "menu_opened"
        row.prop(
            bb_misc,
            "object_props_menu_enabled",
            text="Object Properties",
            toggle = True,
            icon_value = ico.custom_icons[object_props_menu_enabled_icon].icon_id
            )
        if bb_misc.object_props_menu_enabled == True:

            layout = self.layout
            box = layout.box()
            col = box.column(align = True)
            row = col.row(align=True)

            transfer_object_props_copy_buffer_icon = "blank"
            transfer_object_props_paste_buffer_icon = "blank"
            transfer_object_props_clear_buffer_icon = "blank"
            transfer_object_props_print_buffer_icon = "blank"
            if bb_misc.get('prop_buffer') != None:
                transfer_object_props_copy_buffer_icon = "dot_blue"
                transfer_object_props_paste_buffer_icon = "dot_green"
                transfer_object_props_clear_buffer_icon = "x_red"
                transfer_object_props_print_buffer_icon = "dot_white"
            show_object_props_icon = "menu_closed"
            if bb_misc.show_object_props == True:
                show_object_props_icon = "menu_opened"

            row = col.row(align=True)
            row.operator(
                "onigiri.transfer_object_props",
                text="Copy Object Props",
                icon_value = ico.custom_icons[transfer_object_props_copy_buffer_icon].icon_id
                ).action = "copy"
            row.operator(
                "onigiri.transfer_object_props",
                text="Paste Object Props",
                icon_value = ico.custom_icons[transfer_object_props_paste_buffer_icon].icon_id
                ).action = "paste"
            row = col.row(align=True)
            row.operator(
                "onigiri.transfer_object_props",
                text="Print Props Buffer",
                icon_value = ico.custom_icons[transfer_object_props_print_buffer_icon].icon_id
                ).action = "print"
            row.operator(
                "onigiri.transfer_object_props",
                text="Clear Props Buffer",
                icon_value = ico.custom_icons[transfer_object_props_clear_buffer_icon].icon_id
                ).action = "clear"
            row = col.row(align=True)
            row.prop(
                bb_misc,
                "show_object_props",
                text="Show Object Props",
                toggle = True,
                icon_value = ico.custom_icons[show_object_props_icon].icon_id
                )
            if bb_misc.show_object_props == True:
                if (len(bpy.context.selected_objects) == 1) and (bpy.context.object.type == 'MESH' or bpy.context.object.type == 'ARMATURE'):
                    o = bpy.context.object
                    col = box.column(align = True)
                    row = col.row(align=True)
                    row.label(text="- object props list - [" + o.name + "]", icon_value = ico.custom_icons["dot_yellow"].icon_id)
                    prop_str = ""
                    for op in o.keys():
                        prop_str = "Unknown Prop Type"
                        try:
                            holding = o[op].to_dict()
                            prop_str = str(holding)
                        except:
                            pass
                        try:
                            holding = o[op].to_list()
                            prop_str = str(holding)
                        except:
                            pass
                        if 'str' in str( type(o[op]) ):
                            prop_str = str(o[op])
                        if 'int' in str( type(o[op]) ):
                            prop_str = str(o[op])
                        row = col.row(align=True)
                        row.label(
                            text= op + " : " + prop_str
                            )
                    row = col.row(align=True)
                    row.label(text="- object props list ends -", icon_value = ico.custom_icons["dot_red"].icon_id)

                    show_bone_props = False
                    if o.type == 'ARMATURE':
                        if bpy.context.mode == 'POSE' or bpy.context.mode == 'EDIT_ARMATURE':
                            if bpy.context.selected_pose_bones != None:
                                if len(bpy.context.selected_pose_bones) == 1:
                                    boneObj = bpy.context.selected_pose_bones[0]
                                    show_bone_props = True
                            if o.data.edit_bones.active != None:
                                bone = o.data.edit_bones.active.name
                                boneObj = o.data.bones[bone]
                                show_bone_props = True
                    if show_bone_props == True:
                        col = box.column(align = True)
                        row = col.row(align=True)
                        row.label(text = "- bone props list - [" + boneObj.name + "]", icon_value = ico.custom_icons["dot_blue"].icon_id)
                        for op in boneObj.keys():
                            bone_prop_str = "unknown"
    
                            try:
                                bone_holding = boneObj[op].to_dict()
                                bone_prop_str = str(bone_holding)
                            except:
                                pass
                            try:
                                bone_holding = boneObj[op].to_list()
                                bone_prop_str = str(bone_holding)
                            except:
                                pass
                            if 'str' in str( type(boneObj[op]) ):
                                bone_prop_str = str(boneObj[op])
                            if 'int' in str( type(boneObj[op]) ):
                                bone_prop_str = str(boneObj[op])
                            if 'float' in str( type(boneObj[op]) ):
                                bone_prop_str = str(boneObj[op])

                            if bone_prop_str == "unknown":
                                try:
                                    m = mathutils.Matrix(boneObj[op])
                                    bone_prop_str = "matrix: use print to see it"
                                except:
                                    pass
                            row = col.row(align=True)
                            row.label(
                                text= op + " : " + bone_prop_str
                                )
                        row = col.row(align=True)
                        row.label(text="- bone props list ends -", icon_value = ico.custom_icons["dot_red"].icon_id)

                else:
                    row = col.row(align=True)
                    row.label(
                        text="[EMPTY]"
                        )
        
        row = self.layout.row(align=True)
        row.operator(
            "onigiri.onemap_rename_bones",
            text="Rename bones and maps",
            icon_value = ico.custom_icons["bone_black"].icon_id
            )
        
class OnigiriReloadMyImportantModules(bpy.types.Operator):
    """Makes a backup of __init__.py then overwrites it with itself in order to
trick Blender into reloading it.  The reloader module takes care of the other py
files that are listed in my custom modules list"""

    bl_idname = "onigiri.reload_my_important_modules"
    bl_label = "Flag for reload"

    def execute(self, context):
        if utils.flag_reloader():
            print("Call to flag_reloader succeeded")
        else:
            print("Call to flag_reloader failed")

        return {'FINISHED'}

classes = (

    OnigiriSlidersProperties,
    OnigiriSlidersApply,
    OnigiriSlidersResetAll,
    OnigiriSlidersResetSelected,
    OnigiriSlidersRestore,
    OnigiriSlidersStore,
    OnigiriSlidersClean,
    OnigiriSlidersShowAllBones,
    
    OnigiriCharacterConverterPanel,

    OnigiriCharacterConverterProperties,
    OnigiriCharacterConverterLoadMap,
    OnigiriCharacterConverter,
    
    CharacterConverterConvert,
    CharacterConverterConvertReset,
    CharacterConverterMergeCCMPose,
    CharacterConverterLoadPoseLib,
    CharacterConverterSavePoseLib,
    CharacterConverterResetPoseLib,
    CharacterConverterMergePoseLib,
    CharacterConverterApplyPose,
    CharacterConverterSetKey,
    CharacterConverterAddPose,
    CharacterConverterEditPose,
    CharacterConverterRemovePosePrefix,
    CharacterConverterDeletePose,
    CharacterConverterLibProperties,
    CharacterConverterProperties,

    CharacterConverterContainers,
    CharacterConverterSetRename,
    CharacterConverterSetReskin,
    CharacterConverterSetTarget,
    CharacterConverterLoadMap,
    CharacterConverterSaveMap,
    CharacterConverterResetMapper,
    CharacterConverterUnhideAnchorBranch,
    CharacterConverterHideAnchorBranch,
    CharacterConverterEditMap,
    CharacterConverterResetBone,
    CharacterConverterCheckRigs,
    CharacterConverterMap,
    CharacterConverterExport,
    OnigiriDevKitPresetLoad,
    OnigiriDevKitPresetSave,
    OnigiriDevKitPresetSaveDefaults,
    OnigiriDevKitResetAll,
    OnigiriDevKitResetCollada,
    OnigiriColladaExporter,
    OnigiriPanelMeshExport,
    OnigiriPanelMeshTools,
    OnigiriSkinningPanel,
    OnigiriPopup,
    OnigiriMessage,
    OnigiriRemoveConstraintsOperator,
    OnigiriRemoveControlRigOperator,
    OnigiriRestoreReferencePoseOperator,
    OnigiriLoadReferenceMap,
    OnigiriMatchPose,
    OnigiriMatchPoseReset,
    OnigiriCreateReferencePoseOperator,
    OnigiriFixFlags,
    OnigiriDevkitProperties,
    OnigiriMeshProperties,
    OnigiriProperties,
    OnigiriMiscProperties,
    OnigiriTargetProperties,
    OnigiriBoneProperties,
    OnigiriArmatureProperties,
    OnigiriRunProperties,
    OnigiriExpireProperties,
    OnigiriMapperLoad,
    OnigiriMapperReset,
    OnigiriMapperDetach,
    OnigiriMapperSaveTargets,
    OnigiriMapperRemoveRetargetLink,
    OnigiriMapperRemoveTarget,
    OnigiriMapperTarget,
    OnigiriMapperAuto,
    OnigiriMapperMatch,
    OnigiriMapperTemplate,
    OnigiriMapperRestore,
    OnigiriMapperAttachTEST,
    OnigiriMapperAttach,
    OnigiriMapperPackOptionsSave,
    OnigiriMapperPackOptionsLoad,
    OnigiriMapperPackOptionsReset,
    OnigiriMapperPackBones,
    OnigiriMapperCustomStabilizer,
    OnigiriMapperVisualStabilizer,
    OnigiriMapperExport,
    OnigiriForceRigToClass,
    OnigiriAttachProxyRig,

    OnigiriCreateDevkitRig,

    OnigiriCreateAnimationRig,
    OnigiriCreateOldRig,
    OnigiriCreateSLRig,
    OnigiriCreateSLPosRig,
    OnigiriCreateSLPivotRig,
    OnigiriCreateDefaultRig,
    OnigiriCreateNeutralRig,
    OnigiriCreateMaleRig,
    OnigiriCreateRig,
    OnigiriReferenceRig,

    OnigiriRigCreationPanel,

    OnigiriRigProps,
    OnigiriRigProperties,
    OnigiriAddRig,
    OnigiriMapperProps,
    OnigiriAnimeshCollectionProps,
    OnigiriAnimeshProps,
    OnigiriAnimeshGetCurrent,
    OnigiriAnimeshSetTarget,
    OnigiriAnimeshRemoveTarget,
    OnigiriAnimeshAddTarget,
    OnigiriAnimeshLoad,
    OnigiriAnimeshSave,
    OnigiriAnimeshStore,
    OnigiriAnimeshApply,
    OnigiriAnimeshRestore,
    OnigiriAnimeshReset,
    OnigiriAnimeshRemoveBone,
    OnigiriAnimeshRemoveSelectedBones,
    
    OnigiriCharacterPanel,

    OnigiriRetargetProps,
    OnigiriRetargetApply,
    OnigiriRetargetRestore,
    OnigiriRetargetRemoveMap,
    OnigiriRetargetSave,
    OnigiriRetargetLoad,
    OnigiriRetargetBake,

    OnigiriAnimationPanel,

    OnigiriPanelRigTools,

    OnigiriRigsMatchEditToView,
    OnigiriRigsViewBones,
    
    OnigiriJointDataProps,
    OnigiriSaveJointData,
    OnigiriLoadJointData,
    OnigiriSetJointData,
    OnigiriCopyJointData,
    OnigiriCopyJointBuffer,
    OnigiriPasteJointBuffer,
    OnigiriRemoveJointBuffer,
    OnigiriAnimPropertiesAdvanced,
    OnigiriAnimAxisConvert,
    OnigiriAnimProperties,
    OnigiriSetInterpolation,
    OnigiriAnimEnableJointPriority,
    OnigiriAnimDisableJointPriority,
    OnigiriAnimApplyJointPriority,
    OnigiriAnimSelectPriority,
    OnigiriAcquireAnimationDetails,
    OnigiriExportSLPose,
    OnigiriExportSLAnim,
    OnigiriBakeProxy,
    OnigiriExportSLAnimOld,
    OnigiriAddEmote,

    OnigiriHeadOperator,
    OnigiriHeadProperties,

    OnigiriHeadPanel,

    OnigiriSkinProperties,
    OnigiriTransferWeights,
    
    OnigiriPaintProperties,
    OnigiriPaintEnabled,
    OnigiriPaintBackFace,
    
    OnigiriTestOperatorEnable,
    OnigiriTestOperator,
    OnigiriTestProperties,
    
    OnigiriExportAnimationMapped,
    OnigiriDummyAnimation,
    OnigiriTeflon,
    OnigiriExportBVHSL,
    OnigiriExportRetargetedAnimation,
    OnigiriAnimKeepBoneTransforms,
    OnigiriAnimKeepKeyTransforms,
    OnigiriExportAnimation,
    OnigiriDeleteEmptyGroups,
    OnigiriMoveWeights,
    OnigiriConvertToFitmesh,
    OnigiriLimitWeights,
    OnigiriRemoveWeightsFromSelected,
    OnigiriRemoveSelectUnweighted,
    
    OnigiriSkinAttachmentBones,
    OnigiriSkinSmoothEnable,
    OnigiriSkinSmoothUpdate,
    OnigiriSkinSmoothManualUpdate,
    OnigiriSkinSmoothUndo,
    OnigiriNormalizeWeights,
    OnigiriRefreshWeights,
    
    OnigiriMeshSmoothNormals,
    OnigiriMeshFreeze,
    OnigiriMeshEdit,

    OnigiriMeshEditCollapseShape,
    
    OnigiriRemoveSkinSource,
    OnigiriSkinPoseLockSources,
    OnigiriSkinPoseLockTargets,
    OnigiriSkinPoseTransfer,
    OnigiriSkinPoseRestore,
    OnigiriSkinPoseClean,
    OnigiriSkinCorrectionSource,
    OnigiriSkinCorrectionSetup,
    OnigiriSkinCorrectionFinish,
    OnigiriSkinCorrection,
    OnigiriSkinPose,
    OnigiriSkinPoseExport,
    OnigiriSkinPoseImport,

    OnigiriCreateMeshDeformer,
    OnigiriCreateMeshFromBones,
    OnigiriMeshFromArmature,
    OnigiriMeshIntegrityCheck,
    OnigiriSplitMesh,
    OnigiriRefitDuplicate,
    OnigiriRefitReset,
    OnigiriFixArmatureMeshLinks,

    OnigiriChangeRigPrefix,
    OnigiriChangeBonePrefix,

    OnigiriLoadTemplates,
    OnigiriSaveTemplates,
    OnigiriResetTemplates,
    
    OnigiriLoadGenericTemplate,
    OnigiriSaveCCM,
    OnigiriSaveCTM,
    OnigiriCombineGenericTemplate,
    OnigiriSaveCombinedCCM,
    OnigiriSaveCombinedCTM,
    OnigiriResetCombinedTemplates,
    
    OnigiriEditTemplateProperties,
    OnigiriEditTemplatePickSource,
    OnigiriEditTemplatePickTarget,
    OnigiriEditTemplateNewCTM,
    OnigiriEditTemplateLoadFromTXT,
    OnigiriEditTemplateLoadFromCTM,
    
    OnigiriEditTemplateSaveFromCTM,

    OnigiriEditTemplateLoadFromCCM,
    OnigiriEditTemplateSaveFromCCM,

    OnigiriPanelTemplateEditor,

    OnigiriEditTemplateMoveTarget,
    OnigiriEditTemplateRemovePrefix,
    OnigiriEditTemplateRemoveTarget,
    OnigiriEditTemplateReset,
    OnigiriEditTemplateRemoveBone,
    OnigiriEditTemplateAddBone,
    OnigiriEditTemplateChangeRigName,
    OnigiriEditTemplateChangeSourceBone,
    OnigiriEditTemplateChangeTargetBone,
    OnigiriEditTemplateUndo,
    
    OnigiriOnemapProperties,
    OnigiriOneMapRemoveInputBone,
    OnigiriOneMapRemoveOutputBone,
    OnigiriOneMapReskin,
    OnigiriOneMapMove,
    OnigiriOneMapMesh,
    OnigiriOneMapBones,
    OnigiriOneMapReskinToParent,
    OnigiriOneMapBonesMap,
    OnigiriOnemapMapLoad,
    OnigiriOnemapMapSave,
    OnigiriOnemapMapApplyPose,
    OnigiriOnemapMapStorePose,
    OnigiriOnemapMapPose,
    OnigiriOnemapMapRemovePrefix,
    OnigiriOnemapMapRenameBones,
    OnigiriOnemapMapRemoveUnused,
    OnigiriOneMapViewReskin,
    OnigiriOneMapSelectReskinBone,
    OnigiriOneMapSelectOutputBone,
    OnigiriOneMapAction,
    OnigiriOneMapOutputPick,
    OnigiriOneMapRemoveMap,
    OnigiriOnemapReverse,
    OnigiriOneMapNukeSelected,
    OnigiriOneMapReset,
    
    OnigiriOnemapViewActorBones,
    OnigiriOnemapViewDirectorBones,
    
    OnigiriRigsUseConnect,
    OnigiriShowRigConfig,
    OnigiriConvertAvastarRig,
    OnigiriConvertFromAvastar,
    OnigiriConvertToFullRig,
    OnigiriRemoveRigData,
    OnigiriManageRigData,
    OnigiriAlterVolumeBoneScale,
    OnigiriTransferObjectProperties,
    OnigiriFixRigFlags,
    OnigiriFixSLAliasBones,
    OnigiriFixRigOrientation,
    OnigiriRotateRig,
    OnigiriRotateToggle,
    OnigiriBindData,
    OnigiriBindInformation,
    OnigiriCollapseToSL,
    OnigiriAccessAllBones,
    OnigiriRemoveBoneShapes,
    OnigiriMoveTailToHead,
    OnigiriSafeConnect,
    OnigiriMagnifyBones,
    OnigiriRestoreBones,
    OnigiriFixBoneOrientation,
    OnigiriSynchronizeMesh,
    OnigiriRotationMode,
    OnigiriAutoKey,
    OnigiriAutoKeyBakeStored,
    OnigiriAutoKeyBakeRange,
    OnigiriAutoKeyStore,
    OnigiriAutoKeyReference,
    OnigiriAutoKeyInsert,
    OnigiriAutoKeyReset,
    OnigiriAutoKeyIsolate,
    OnigiriAutoKeyPastePose,
    OnigiriRemoveKeys,
    OnigiriScaleAnimationOperator,
    OnigiriAnimationProperties,
    OnigiriExportAnimesh,

    OnigiriPanelBind,

    OnigiriPanelAdvanced,

    OnigiriSelectDifficultBones,
    OnigiriSaveBoneMatrices,
    OnigiriLoadBoneOrientation,
    OnigiriMatchBoneOrientation,
    OnigiriResetBoneRoll,
    OnigiriFixDeformableBones,
    OnigiriFixHierarchy,
    OnigiriFixBoneRoll,
    OnigiriRefreshBlenderFile,
    OnigiriCleanControllers,

    OnigiriRigToXML,
    OnigiriBVHImport,
    OnigiriBVHExportXML,
    OnigiriBVHExportBVH,
    
    OnigiriInfoPanel,
    
    views.OnigiriViewProperties,
    views.OnigiriViewOperator,
    views.OnigiriPanelView,
    
    OnigiriReloadMyImportantModules,
    
    OnigiriDeformerProperties,
    OnigiriCreateDeformer,

    OnigiriCreateDeformerMapped,

    OnigiriShapeShifterPanel,

    OnigiriShapeShifterProperties,
    OnigiriShapeShifterBuildAttach,
    OnigiriShapeShifterBuildLink,
    OnigiriShapeShifterBuildUnlink,
    OnigiriShapeShifterBuildSelect,
    OnigiriShapeShifterBuildSnap,
    OnigiriShapeShifterBuildConnect,
    OnigiriShapeShifterFreezeRig,
    OnigiriShapeShifterPoseRig,
    OnigiriShapeShifterMorph,
    OnigiriShapeShifterTransform,
    OnigiriShapeShifterTarget,
    OnigiriShapeShifterLoad,
    
    OnigiriAnimImportProperties,
    OnigiriAnimImport,
    
    OnigiriImportProperties,
    OnigiriColladaImporter,
    OnigiriDevkitImporter,
    OnigiriColladaDataRemove,
    OnigiriPanelImport,
    
    OnigiriPanelDevKitTools,
    OnigiriDevKitMasterSet,
    OnigiriDevKitCombine,
    OnigiriDevKitMasterClear,
    OnigiriDevKitReshape,
    
    OnigiriAnimEditProperties,
    OnigiriAnimLoad,
    OnigiriAnimSave,
    OnigiriAnimReset,
    OnigiriAnimUpdate,
    OnigiriAnimJointPriorityEdit,
    OnigiriAnimJointPriorityReset,
    
    OnigiriAutoKeyProperties,
    
    OnigiriAnimationLibraryProperties,
    OnigiriAnimationLibrarySave,
    OnigiriAnimationLibraryLoad,
    OnigiriAnimationLibraryMerge,
    OnigiriAnimationLibraryAdd,
    OnigiriAnimationLibraryDelete,
    OnigiriAnimationLibraryRename,
    OnigiriAnimationLibraryApply,
    OnigiriAnimationLibrary,
    
    OnigiriAnimationActionApply,
    OnigiriAnimationActionFlag,
    OnigiriAnimationActionRangeSet,
    OnigiriAnimationActionRangeAll,
    OnigiriAnimationActionLoopAll,
    OnigiriAnimationActionEase,
    OnigiriAnimationActionRange,
    OnigiriAnimationActionLoop,
    OnigiriAnimationActionDelete,
    OnigiriAnimationActionCopy,
    OnigiriAnimationActionFakeUser,
    OnigiriAnimationActionName,
    OnigiriAnimationActionRename,
    OnigiriAnimationActionConvert,
    OnigiriAnimationActionExport,
    
    OnigiriActionFillAdd,
    OnigiriActionFillDel,
    OnigiriActionFillScript,
    
    OnigiriPoseLibraryProperties,
    OnigiriPoseLibraryHash,
    OnigiriPoseLibrarySave,
    OnigiriPoseLibraryLoad,
    OnigiriPoseLibraryMerge,
    OnigiriPoseLibraryAdd,
    OnigiriPoseLibraryDelete,
    OnigiriPoseLibraryRename,
    OnigiriPoseLibraryReset,
    OnigiriPoseLibraryPrefix,
    OnigiriPoseLibraryFlag,
    OnigiriPoseLibraryExport,
    OnigiriPoseLibraryApply,
    OnigiriPoseLibraryApplyToSelected,
    
    OnigiriMotionMixerProperties,
    OnigiriMotionMixerLockTarget,
    OnigiriMotionMixerAddSource,
    OnigiriMotionMixerRemoveSource,
    OnigiriMotionMixerReady,
    OnigiriMotionMixerSetAnchor,
    OnigiriMotionMixerActiveRigName,
    OnigiriMotionMixerMode,
    OnigiriMotionMixerSpace,
    OnigiriMotionMixerInherit,
    OnigiriMotionMixerAddBones,
    OnigiriMotionMixerRemoveBones,
    OnigiriMotionMixerSetLocation,
    OnigiriMotionMixerSetRotation,
    OnigiriMotionMixerSetScale,
    
    OnigiriMotionSpliceProperties,
    OnigiriMotionSpliceSync,
    OnigiriMotionSpliceReset,
    OnigiriMotionSpliceCapture,
    
    OnigiriServerProperties,
    
    OnigiriShapeProperties,
    OnigiriShapeLoad,
    OnigiriShapeSave,
    OnigiriShapeReset,
    OnigiriShapeRemove,
    
    OnigiriControllerProperties,
    OnigiriControllerRetarget,
    OnigiriControllerShowBones,
    OnigiriControllerGlue,
    OnigiriControllerStabilize,
    OnigiriControllerPelvisTransform,
    OnigiriControllerMapReset,
    OnigiriControllerMapRemove,
    OnigiriControllerSet,
    OnigiriControllerAdd,
    OnigiriControllerRemove,
    OnigiriControllerTemplateLoad,
    
    OnigiriDynamicProperties,
    OnigiriDynamicLoad,
    OnigiriDynamicController,
    OnigiriDynamicAction,
    OnigiriDynamicCleanRig,
    OnigiriDynamicMapRemove,
    OnigiriDynamicReset,
    
    OnigiriSnapProperties,
    OnigiriSnapPrepare,
    OnigiriSnapAction,
    OnigiriSnapNuke,
    OnigiriSnapDestroy,
    OnigiriSnapClean,
    OnigiriSnapReset,
    OnigiriSnapMapAcquire,
    OnigiriSnapMapApply,
    OnigiriSnapMapLoad,
    OnigiriSnapMapSave,
    OnigiriSnapConvert,
    OnigiriSnapConvertUndo,
    OnigiriSnapExportMesh,
    OnigiriSnapMesh,
    OnigiriSnapViewActorBones,
    OnigiriSnapDeformDirectorBones,
    OnigiriSnapViewDirectorBones,
    OnigiriSnapViewMappedBones,
    OnigiriSnapMapCollect,
    OnigiriSnapMapDeposit,
    OnigiriSnapMapFill,
    OnigiriSnapSelectEndBones,
    OnigiriSnapDeselectNonEndBones,
    OnigiriSnapSelectVolumeBones,
    OnigiriSnapSelectAttachBones,
    OnigiriSnapSelectActorBone,
    OnigiriSnapSelectDirectorBone,
    OnigiriSnapMapAdd,
    OnigiriSnapMapRemove,
    OnigiriSnapMapRemoveSingle,
    OnigiriSnapMapUndo,
    
    OnigiriSimProperties,
    OnigiriSimActionDynamic,

    OnigiriSimCustomBones,
    OnigiriSimCustomMesh,
    OnigiriSimCustomAction,
    OnigiriSimCustomDetach,
    OnigiriSimCustomAttach,
    OnigiriSimCustomConstraints,

    OnigiriSimActionObject,
    OnigiriSimBake,
    OnigiriSimJoin,
    OnigiriSimParent,
    OnigiriSimAddBone,
    OnigiriSimEditBones,
    OnigiriSimDone,
    OnigiriSimRigidCopy,
    OnigiriSimRemoveAll,
    OnigiriSimReset,
    OnigiriSimStretchAdd,
    OnigiriSimStretchRemove,
    OnigiriSimCurlAdd,
    OnigiriSimCurlRemove,
    OnigiriIK,
    OnigiriIKNuke,
    OnigiriSimKey,
    
    OnigiriInheritProperties,
    OnigiriInheritAnimation,
    OnigiriInheritReset,
    OnigiriInheritReverseMap,
    
    OnigiriMotionProperties,
    OnigiriMotionRemoveObjectAnimation,
    OnigiriMotionApplyTransforms,
    OnigiriMotionRemoveTransforms,
    OnigiriMotionCycleRig,
    OnigiriMotionMapLoad,
    OnigiriMotionMapSave,
    OnigiriMotionMatchMap,
    OnigiriMotionMapClean,
    OnigiriMotionAction,
    OnigiriMotionAnchor,
    OnigiriMotionMesh,
    OnigiriMotionViewBones,
    OnigiriMotionHideTarget,
    OnigiriMotionMapSelect,
    OnigiriMotionMapAdd,
    OnigiriMotionMapRemove,
    OnigiriMotionLockSelected,
    OnigiriMotionLockRemove,
    OnigiriMotionReset,
    OnigiriMotionApplyScale,
    
    OnigiriLatchProperties,
    OnigiriLatchcleanup,
    OnigiriLatchActor,
    OnigiriLatchDirector,
    OnigiriLatchSnap,
    OnigiriLatchConnect,
    OnigiriLatchFreeze,
    OnigiriLatchRestore,
    
    OnigiriPuppetProperties,
    OnigiriPuppetCompose,
    OnigiriPuppetDecompose,
    OnigiriPuppetMaster,
    OnigiriPuppetMinions,
    OnigiriPuppetReset,
    
    OnigiriReactorPanel,
    
    OnigiriReactorProperties,
    
    OnigiriRagdollProperties,
    OnigiriRagdollLoad,
    OnigiriRagdollSave,
    OnigiriRagdollAction,
    OnigiriRagdollBake,
    OnigiriRagdollJoin,
    OnigiriRagdollReset,
    OnigiriRagdollRigidCopy,
    
    OnigiriAlignBonesProperties,
    OnigiriAlignBones,
    OnigiriAlignKeep,
    
    OnigiriSelectBones,
    
    OnigiriSplitAnimProperties,
    OnigiriSaveAnimationScript,
    
    OnigiriJointControlProperties,
    OnigiriBoneControlExportSet,
    OnigiriBoneControlExportClear,
    OnigiriBoneControlExportRemove,
    
)

def register():

    print("Onigiri: enabled")

    from bpy.utils import register_class
    for cls in classes:
        
        register_class(cls)

        globals.version = bl_info['version']

    bpy.types.Scene.bb_sliders = bpy.props.PointerProperty(type=OnigiriSlidersProperties)

    bpy.types.PoseBone.bb_sliders_location_x = bpy.props.FloatProperty(
        name="",
        description="Adjust X location of bone",
        min=-1.00,
        max=1.00,
        default=0.00,
        update=sliders.update_location_x,
        )
    bpy.types.PoseBone.bb_sliders_location_y = bpy.props.FloatProperty(
        name="",
        description="Adjust Y location of bone",
        min=-1.00,
        max=1.00,
        default=0.00,
        update=sliders.update_location_y,
        )
    bpy.types.PoseBone.bb_sliders_location_z = bpy.props.FloatProperty(
        name="",
        description="Adjust Z location of bone",
        min=-1.00,
        max=1.00,
        default=0.00,
        update=sliders.update_location_z,
        )

    bpy.types.PoseBone.bb_sliders_scale_x = bpy.props.FloatProperty(
        name="",
        description="Adjust X scale of bone",
        min=-0.99,
        max=1.00,
        default=0.00,
        update=sliders.update_scale_x,
        )
    bpy.types.PoseBone.bb_sliders_scale_y = bpy.props.FloatProperty(
        name="",
        description="Adjust Y scale of bone",
        min=-0.99,
        max=1.00,
        default=0.00,
        update=sliders.update_scale_y,
        )
    bpy.types.PoseBone.bb_sliders_scale_z = bpy.props.FloatProperty(
        name="",
        description="Adjust Z scale of bone",
        min=-0.99,
        max=1.00,
        default=0.00,
        update=sliders.update_scale_z,
        )

    bpy.types.PoseBone.bb_sliders_scale_x_lock = bpy.props.BoolProperty(
        name="",
        description="Lock this transform axis",
        default=True,
        
        )
    bpy.types.PoseBone.bb_sliders_scale_y_lock = bpy.props.BoolProperty(
        name="",
        description="Lock this transform axis",
        default=False,
        
        )
    bpy.types.PoseBone.bb_sliders_scale_z_lock = bpy.props.BoolProperty(
        name="",
        description="Lock this transform axis",
        default=True,
        
        )

    bpy.types.WindowManager.bb_cc = bpy.props.PointerProperty(type=OnigiriCharacterConverterProperties)
    
    bpy.types.Scene.bb_devkit = bpy.props.PointerProperty(type=OnigiriDevkitProperties)
    
    bpy.types.Scene.bb_mesh = bpy.props.PointerProperty(type=OnigiriMeshProperties)
    bpy.types.Scene.onigiri = bpy.props.PointerProperty(type=OnigiriProperties)
    bpy.types.Object.bb_bone_props = bpy.props.CollectionProperty(type=OnigiriBoneProperties)
    bpy.types.Object.bb_targets = bpy.props.CollectionProperty(type=OnigiriTargetProperties)
    bpy.types.Scene.bb_arm_props = bpy.props.PointerProperty(type=OnigiriArmatureProperties)
    bpy.types.Scene.bb_run = bpy.props.PointerProperty(type=OnigiriRunProperties)
    bpy.types.Scene.bb_anim_props = bpy.props.PointerProperty(type=OnigiriAnimationProperties)
    bpy.types.WindowManager.cc_props = bpy.props.PointerProperty(type=CharacterConverterProperties)
    bpy.types.WindowManager.cc_libs = bpy.props.PointerProperty(type=CharacterConverterLibProperties)

    bpy.types.WindowManager.bb_expire = bpy.props.PointerProperty(type=OnigiriExpireProperties)

    bpy.types.WindowManager.bb_misc = bpy.props.PointerProperty(type=OnigiriMiscProperties)

    bpy.types.WindowManager.cc_containers = bpy.props.CollectionProperty(type=CharacterConverterContainers)

    bpy.types.WindowManager.bb_retarget = bpy.props.PointerProperty(type=OnigiriRetargetProps)

    bpy.types.WindowManager.bb_animesh = bpy.props.PointerProperty(type=OnigiriAnimeshProps)

    bpy.types.WindowManager.bb_animesh_collection = bpy.props.CollectionProperty(type=OnigiriAnimeshCollectionProps)
 
    bpy.types.WindowManager.bb_mapper = bpy.props.PointerProperty(type=OnigiriMapperProps)

    bpy.types.WindowManager.bb_rigprops = bpy.props.PointerProperty(type=OnigiriRigProps)

    bpy.types.WindowManager.bb_rig = bpy.props.PointerProperty(type=OnigiriRigProperties)

    bpy.types.WindowManager.bb_head = bpy.props.PointerProperty(type=OnigiriHeadProperties)

    bpy.types.WindowManager.bb_skin = bpy.props.PointerProperty(type=OnigiriSkinProperties)

    bpy.types.Scene.bb_anim = bpy.props.PointerProperty(type=OnigiriAnimProperties)

    bpy.types.Scene.bb_anim_advanced = bpy.props.PointerProperty(type=OnigiriAnimPropertiesAdvanced)

    bpy.types.WindowManager.bb_joint_data = bpy.props.PointerProperty(type=OnigiriJointDataProps)
    
    bpy.types.WindowManager.bb_test = bpy.props.PointerProperty(type=OnigiriTestProperties)

    bpy.types.Scene.bone_source = bpy.props.StringProperty    (
        name = "",
        description = "Choose a rig for the bone source.  You can create one from the Rig Creation rollout or you can "            "even use an Avastar rig",
        default = "Onigiri"
    )
    bpy.types.Scene.onigiri_template = bpy.props.StringProperty    (
        name = "Custom Map",
        description =            "Enable the blue target then click the (Load Template) button to open a text file with your custom bone mapping.  "            "It should include 3 names per line. The SL bone, your skeleton and the target bone in your rig."            "There can be no spaces in the names that you use in the bones or the rigs.",
        default = ""
    )
    bpy.types.Scene.onigiri_custom_bone_list = bpy.props.StringProperty    (
        name = "Custom Bone Lists",
        description =            "This replaces the internal automatic bone mapping.  Often times the automatic mapping is enough to get you "            "started.  This options is provided in order to change the order of use from source bones to target bones.  "            "Internally there is an order of bone mapping that you are not exposed to but this allows you to control it.  "            "It also allows you to name problem bones in case you are having difficulty with 1 or more.  The bone name mPelvis "            "is already in this list, not because it is a problem bone but because you will want to key that bone yourself if "            "needed.  There is already a bones list text file in the presets folder that you can use as a base.  It is prepared "            "in the same way that the internal mapping is.  Onigiri will only use your Bone List file if you load it.",
        default = ""
    )

    bpy.types.WindowManager.bb_view = bpy.props.PointerProperty(type=views.OnigiriViewProperties)

    bpy.types.WindowManager.bb_edit_template = bpy.props.PointerProperty(type=OnigiriEditTemplateProperties)

    bpy.types.Scene.bb_onemap = bpy.props.PointerProperty(type=OnigiriOnemapProperties)

    bpy.types.WindowManager.bb_deform = bpy.props.PointerProperty(type=OnigiriDeformerProperties)

    bpy.types.Scene.bb_shifter = bpy.props.PointerProperty(type=OnigiriShapeShifterProperties)
    
    bpy.types.WindowManager.anim_import = bpy.props.PointerProperty(type=OnigiriAnimImportProperties)
    
    bpy.types.WindowManager.bb_server = bpy.props.PointerProperty(type=OnigiriServerProperties)
    
    bpy.types.Scene.bb_autokey = bpy.props.PointerProperty(type=OnigiriAutoKeyProperties)
    
    bpy.types.Scene.bb_alib = bpy.props.PointerProperty(type=OnigiriAnimationLibraryProperties)
    
    bpy.types.Scene.bb_pose = bpy.props.PointerProperty(type=OnigiriPoseLibraryProperties)
    
    bpy.types.WindowManager.bb_mixer = bpy.props.PointerProperty(type=OnigiriMotionMixerProperties)
    
    bpy.types.Scene.bb_splice = bpy.props.PointerProperty(type=OnigiriMotionSpliceProperties)
    
    bpy.types.Scene.bb_import = bpy.props.PointerProperty(type=OnigiriImportProperties)
    
    bpy.types.WindowManager.bb_anim_edit = bpy.props.PointerProperty(type=OnigiriAnimEditProperties)
    
    bpy.types.WindowManager.bb_shape = bpy.props.PointerProperty(type=OnigiriShapeProperties)
    
    bpy.types.Scene.bb_paint = bpy.props.PointerProperty(type=OnigiriPaintProperties)
    
    bpy.types.WindowManager.bb_controller = bpy.props.PointerProperty(type=OnigiriControllerProperties)
    
    bpy.types.WindowManager.bb_dynamic = bpy.props.PointerProperty(type=OnigiriDynamicProperties)
    
    bpy.types.WindowManager.bb_snap = bpy.props.PointerProperty(type=OnigiriSnapProperties)
    
    bpy.types.WindowManager.bb_sim = bpy.props.PointerProperty(type=OnigiriSimProperties)
    
    bpy.types.WindowManager.bb_inherit = bpy.props.PointerProperty(type=OnigiriInheritProperties)
    
    bpy.types.WindowManager.bb_motion = bpy.props.PointerProperty(type=OnigiriMotionProperties)
    
    bpy.types.WindowManager.bb_latch = bpy.props.PointerProperty(type=OnigiriLatchProperties)
    
    bpy.types.WindowManager.bb_puppet = bpy.props.PointerProperty(type=OnigiriPuppetProperties)
    
    bpy.types.WindowManager.bb_reactor = bpy.props.PointerProperty(type=OnigiriReactorProperties)
    
    bpy.types.WindowManager.bb_ragdoll = bpy.props.PointerProperty(type=OnigiriRagdollProperties)
    
    bpy.types.WindowManager.bb_align_bones = bpy.props.PointerProperty(type=OnigiriAlignBonesProperties)
    
    bpy.types.WindowManager.bb_split = bpy.props.PointerProperty(type=OnigiriSplitAnimProperties)
    
    bpy.types.WindowManager.bb_joints = bpy.props.PointerProperty(type=OnigiriJointControlProperties)
    
    ico.load_icons()

def unregister():

    print("Onigiri: cleanup")

    from bpy.utils import unregister_class
    for cls in reversed(classes):
        unregister_class(cls)
    
    ico.unload_icons()
    
    my_property_list = [
        bpy.types.WindowManager.bb_joints,
        bpy.types.WindowManager.bb_split,
        bpy.types.WindowManager.bb_ragdoll,
        bpy.types.Scene.bb_sliders,
        bpy.types.Scene.bb_devkit,
        bpy.types.WindowManager.bb_inherit,
        bpy.types.WindowManager.bb_motion,
        bpy.types.WindowManager.bb_sim,
        bpy.types.Scene.bb_autokey,
        bpy.types.WindowManager.bb_snap,
        bpy.types.WindowManager.bb_controller,
        bpy.types.WindowManager.bb_shape,
        bpy.types.Scene.bb_paint,
        bpy.types.WindowManager.bb_mixer,
        bpy.types.WindowManager.bb_edit_template,
        bpy.types.WindowManager.bb_view,
        bpy.types.Scene.onigiri_custom_bone_list,
        bpy.types.Scene.onigiri_template,
        bpy.types.Scene.bone_source,
        bpy.types.WindowManager.bb_test,
        bpy.types.WindowManager.bb_joint_data,
        bpy.types.Scene.bb_anim_advanced,
        bpy.types.WindowManager.bb_skin,
        bpy.types.WindowManager.bb_head,
        bpy.types.WindowManager.bb_rigprops,
        bpy.types.WindowManager.bb_mapper,
        bpy.types.WindowManager.bb_animesh_collection,
        bpy.types.WindowManager.bb_animesh,
        bpy.types.WindowManager.bb_retarget,
        bpy.types.WindowManager.cc_containers,
        bpy.types.WindowManager.bb_misc,
        bpy.types.WindowManager.bb_expire,
        bpy.types.WindowManager.cc_libs,
        bpy.types.WindowManager.cc_props,
        bpy.types.WindowManager.anim_import,
        bpy.types.Scene.bb_anim_props,
        bpy.types.Scene.bb_run,
        bpy.types.Scene.bb_arm_props,
        bpy.types.Object.bb_targets,
        bpy.types.Object.bb_bone_props,
        bpy.types.Scene.onigiri,
        bpy.types.Scene.bb_mesh,
        bpy.types.Scene.bb_shifter,
        bpy.types.WindowManager.bb_server,
        bpy.types.Scene.bb_autokey,
        bpy.types.Scene.bb_import,
        bpy.types.WindowManager.bb_cc,
        bpy.types.WindowManager.bb_latch,
        bpy.types.WindowManager.bb_puppet,
        bpy.types.WindowManager.bb_reactor,
        bpy.types.WindowManager.bb_align_bones,
        ]
    for p in my_property_list:
        del p

    if 1 == 1:
        handlers_list = [
            
            ]
        for h in reversed(handlers_list):
            try:
                bpy.app.handlers.depsgraph_update_post.remove(h)
            except:
                print("couldn't remove handler:", h)
        try:
            bpy.app.handlers.load_post.clear()
        except:
            print("pose.clear nothing to do")

if __name__ == "__main__":
    register()
